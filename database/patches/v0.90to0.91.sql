--
-- Copyright (c) 2021 Todd Kover
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


\pset pager
/*
Invoked:

	--suffix=v91
	--reinsert-dir=i
	--pre=pre
	--pre=../new/database/ddl/schema/pgsql/create_schema_support.sql
	--post=post
	--postschema=property_utils
	--first=layer3_interface_netblock
	--first=network_service
	--first=shared_netblock
	--last=jazzhands_legacy.property_upd
	--scan
	sw_package:software_artifact_name
	val_sw_package_type:val_software_artifact_type
	jazzhands_legacy.val_device_mgmt_ctrl_type
	jazzhands_legacy.property
	jazzhands_legacy.x509_certificate_upd
*/

\set ON_ERROR_STOP
SELECT schema_support.begin_maintenance(false);
select clock_timestamp(), now(), clock_timestamp() - now() AS len;


-- BEGIN Misc that does not apply to above

SELECT jazzhands_cache.refresh_jazzhands_legacy_device_support();


-- END Misc that does not apply to above


-- BEGIN Misc that does not apply to above
/*
 * Copyright (c) 2010-2021 Todd Kover, Matthew Ragan
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

\set ON_ERROR_STOP

/*
 * Copyright (c) 2010-2021 Matthew Ragan
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


--
-- $HeadURL$
-- $Id$
--


-- Create schema if it does not exist, do nothing otherwise.
DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'schema_support';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS schema_support;
		CREATE SCHEMA schema_support AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA schema_support IS 'part of jazzhands';

	END IF;
END;
$$;


-------------------------------------------------------------------
-- returns the Id tag for CM
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.id_tag()
RETURNS VARCHAR AS $$
BEGIN
    RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;
-- end of procedure id_tag
-------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence
    ( schema VARCHAR, table_name VARCHAR )
RETURNS VOID AS $$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		WITH s AS (
			SELECT	pg_get_serial_sequence(nspname||'.'||relname,
				a.attname) as seq, a.attname as column
			FROM	pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE	c.relname = table_name
			AND	n.nspname = schema
				AND	a.attnum > 0
				AND	NOT a.attisdropped
		) SELECT s.*, nextval(s.seq) as nv FROM s WHERE seq IS NOT NULL
	LOOP
		EXECUTE 'SELECT max('||quote_ident(_r.column)||')+1 FROM  '
			|| quote_ident(schema)||'.'||quote_ident(table_name)
			INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE 'ALTER SEQUENCE ' || _r.seq || ' RESTART WITH '
				|| m;
		END IF;
	END LOOP;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.reset_all_schema_table_sequences
    ( schema TEXT )
RETURNS INTEGER AS $$
DECLARE
	_r	RECORD;
	tally INTEGER;
BEGIN
	tally := 0;
	FOR _r IN

		SELECT n.nspname, c.relname, c.relkind
		FROM	pg_class c
				INNER JOIN pg_namespace n ON n.oid = c.relnamespace
		WHERE	n.nspname = schema
		AND		c.relkind = 'r'
	LOOP
		PERFORM schema_support.reset_table_sequence(_r.nspname::text, _r.relname::text);
		tally := tally + 1;
	END LOOP;
	RETURN tally;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_trigger
    ( aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR )
RETURNS VOID AS $$
BEGIN
    EXECUTE 'CREATE OR REPLACE FUNCTION ' || quote_ident(tbl_schema)
	|| '.' || quote_ident('perform_audit_' || table_name)
	|| $ZZ$() RETURNS TRIGGER AS $TQ$
	    DECLARE
		appuser VARCHAR;
	    BEGIN
		appuser := concat_ws('/', session_user,
			coalesce(
				current_setting('jazzhands.appuser', true),
				current_setting('request.header.x-remote-user', true)
			)
		);

		appuser = substr(appuser, 1, 255);

		IF TG_OP = 'DELETE' THEN
		    INSERT INTO $ZZ$ || quote_ident(aud_schema)
			|| '.' || quote_ident(table_name) || $ZZ$
		    VALUES ( OLD.*, 'DEL', now(),
			clock_timestamp(), txid_current(), appuser );
		    RETURN OLD;
		ELSIF TG_OP = 'UPDATE' THEN
			IF OLD != NEW THEN
				INSERT INTO $ZZ$ || quote_ident(aud_schema)
				|| '.' || quote_ident(table_name) || $ZZ$
				VALUES ( NEW.*, 'UPD', now(),
				clock_timestamp(), txid_current(), appuser );
			END IF;
			RETURN NEW;
		ELSIF TG_OP = 'INSERT' THEN
		    INSERT INTO $ZZ$ || quote_ident(aud_schema)
			|| '.' || quote_ident(table_name) || $ZZ$
		    VALUES ( NEW.*, 'INS', now(),
			clock_timestamp(), txid_current(), appuser );
		    RETURN NEW;
		END IF;
		RETURN NULL;
	    END;
	$TQ$ LANGUAGE plpgsql SECURITY DEFINER
    $ZZ$;

    EXECUTE format(
	'REVOKE ALL ON FUNCTION %s.%s() FROM public',
		quote_ident(tbl_schema),
		quote_ident('perform_audit_' || table_name)
	);

    EXECUTE 'DROP TRIGGER IF EXISTS ' || quote_ident('trigger_audit_'
	|| table_name) || ' ON ' || quote_ident(tbl_schema) || '.'
	|| quote_ident(table_name);

    EXECUTE 'CREATE TRIGGER ' || quote_ident('trigger_audit_' || table_name)
	|| ' AFTER INSERT OR UPDATE OR DELETE ON ' || quote_ident(tbl_schema)
	|| '.' || quote_ident(table_name) || ' FOR EACH ROW EXECUTE PROCEDURE '
	|| quote_ident(tbl_schema) || '.' || quote_ident('perform_audit_'
	|| table_name) || '()';
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_triggers
    ( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $$
DECLARE
    table_list RECORD;
BEGIN
    --
    -- select tables with audit tables
    --
    FOR table_list IN
	SELECT table_name::text FROM information_schema.tables
	WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
	AND table_name IN (
	    SELECT table_name FROM information_schema.tables
	    WHERE table_schema = aud_schema AND table_type = 'BASE TABLE'
	) ORDER BY table_name
    LOOP
	PERFORM schema_support.rebuild_audit_trigger
	    (aud_schema, tbl_schema, table_list.table_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table_finish(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	cols	text[];
	i	text;
	_t	text;
BEGIN
	_t := regexp_replace(rpad(quote_ident('__old__t' || table_name), 63), ' *$', '');
	--
	-- get columns - XXX NOTE:  Need to remove columns not in the new
	-- table...
	--
	SELECT	array_agg(quote_ident(a.attname) ORDER BY a.attnum)
	INTO	cols
	FROM	pg_catalog.pg_attribute a
	INNER JOIN pg_catalog.pg_class c on a.attrelid = c.oid
	INNER JOIN pg_catalog.pg_namespace n on n.oid = c.relnamespace
	LEFT JOIN pg_catalog.pg_description d
			on d.objoid = a.attrelid
			and d.objsubid = a.attnum
	WHERE   n.nspname = quote_ident(aud_schema)
	  AND	c.relname = _t
	  AND	a.attnum > 0
	  AND	NOT a.attisdropped
	;

	IF cols IS NULL THEN
		RAISE EXCEPTION 'Unable to get columns from "%.%"',
			quote_ident(aud_schema), _t;
	END IF;

	EXECUTE 'INSERT INTO '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' ( '
		|| array_to_string(cols, ',') || ' ) SELECT '
		|| array_to_string(cols, ',') || ' FROM '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name)
		|| ' ORDER BY '
		|| quote_ident('aud#seq');


	EXECUTE 'DROP TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name);

	--
	-- drop audit sequence, in case it was not dropped with table.
	--
	EXECUTE 'DROP SEQUENCE IF EXISTS '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- drop indexes found before that did not get dropped.
	--
	FOR i IN SELECT	c2.relname
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident('__old__' || table_name)
		  AND	contype is NULL
	LOOP
		EXECUTE 'DROP INDEX '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('_' || i);
	END LOOP;
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR,
	finish_rebuild BOOLEAN DEFAULT true
)
RETURNS VOID AS $FUNC$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__t' || table_name);


	--
	-- RENAME sequence
	--
	EXECUTE 'ALTER SEQUENCE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq')
		|| ' RENAME TO '
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- fix sequence primary key to have the correct next value
	--
	EXECUTE 'SELECT max("aud#seq") + 1 FROM	 '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('__old__t' || table_name) INTO seq;
	IF seq IS NOT NULL THEN
		EXECUTE 'ALTER SEQUENCE '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident(table_name || '_seq')
			|| ' RESTART WITH ' || seq;
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table_pkak_indexes(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	keys	RECORD;
	count	INTEGER;
	name	TEXT;
BEGIN
	COUNT := 0;
	-- one day, I will want to construct the list of columns by hand rather
	-- than use pg_get_constraintdef.  watch me...
	FOR keys IN
		SELECT con.conname, c2.relname as index_name,
			pg_catalog.pg_get_constraintdef(con.oid, true) as condef,
				regexp_replace(
			pg_catalog.pg_get_constraintdef(con.oid, true),
					'^.*(\([^\)]+\)).*$', '\1') as cols,
			con.condeferrable,
			con.condeferred
		FROM pg_catalog.pg_class c
			INNER JOIN pg_namespace n
				ON relnamespace = n.oid
			INNER JOIN pg_catalog.pg_index i
				ON c.oid = i.indrelid
			INNER JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			INNER JOIN pg_catalog.pg_constraint con ON
				(con.conrelid = i.indrelid
				AND con.conindid = i.indexrelid )
		WHERE c.relname =  table_name
		AND	 n.nspname = tbl_schema
		AND con.contype in ('p', 'u')
		ORDER BY CASE WHEN con.contype = 'p' THEN 0 ELSE 1 END, con.conname
	LOOP
		name := 'aud_' || quote_ident( table_name || '_' || keys.conname);
		IF char_length(name) > 63 THEN
			name := 'aud_' || count || quote_ident( table_name || '_' || keys.conname);
			COUNT := COUNT + 1;
		END IF;
		EXECUTE 'CREATE INDEX ' || name
			|| ' ON ' || quote_ident(aud_schema) || '.'
			|| quote_ident(table_name) || keys.cols;
	END LOOP;

END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table_other_indexes(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	_r	RECORD;
	sch	TEXT;
BEGIN
	-- one day, I will want to construct the list of columns by hand rather
	-- than use pg_get_constraintdef.  watch me...

	sch := quote_ident( aud_schema );
	FOR _r IN
		SELECT c2.relname, pg_get_indexdef(i.indexrelid) as def, con.contype
	FROM pg_catalog.pg_class c
	    INNER JOIN pg_namespace n
		ON relnamespace = n.oid
	    INNER JOIN pg_catalog.pg_index i
		ON c.oid = i.indrelid
	    INNER JOIN pg_catalog.pg_class c2
		ON i.indexrelid = c2.oid
	   LEFT JOIN pg_catalog.pg_constraint con ON
		(con.conrelid = i.indrelid
		AND con.conindid = i.indexrelid )
	WHERE c.relname =  table_name
	AND      n.nspname = tbl_schema
	AND	con.contype IS NULL

	LOOP
		_r.def := regexp_replace(_r.def, ' ON ', ' ON ' || sch || '.');
		EXECUTE _r.def;
	END LOOP;

END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
--
-- delete and recreate all but primary key and unique key indexes on audit
-- tables.   This is because foreign keys are not properly handled, but if
-- that support was added, it could be a thing.
--
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_indexes(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $$
DECLARE
	_r	RECORD;
	sch	TEXT;
	name_base	TEXT;
BEGIN
	FOR _r IN
		SELECT c2.relname, pg_get_indexdef(i.indexrelid) as def, con.contype
			FROM pg_catalog.pg_class c
				INNER JOIN pg_namespace n ON relnamespace = n.oid
				INNER JOIN pg_catalog.pg_index i ON c.oid = i.indrelid
				INNER JOIN pg_catalog.pg_class c2 ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_constraint con ON
				(con.conrelid = i.indrelid AND con.conindid = i.indexrelid )
			WHERE c.relname =  table_name
			AND	  n.nspname = aud_schema
			AND	(contype IS NULL OR contype NOT IN ('p','u'))
	LOOP
		EXECUTE format('DROP INDEX %s.%s',
		quote_ident(aud_schema), quote_ident(_r.relname));
	END LOOP;

	name_base := quote_ident( table_name );
	-- 17 is length of _aud#timestmp_idx
	-- md5 is just to make the name unique
	IF char_length(name_base) > 64 - 17 THEN
		-- using lpad as a truncate
		name_base := 'aud_' || lpad(md5(table_name), 10) || lpad(table_name, 64 - 19 - 10 );
	END IF;

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#timestamp_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#timestamp")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#realtime_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#realtime")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#txid_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#txid")';


	PERFORM schema_support.build_audit_table_pkak_indexes(
		aud_schema := aud_schema,
		tbl_schema := tbl_schema,
		table_name := table_name
	);
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.rebuild_all_audit_indexes
	( aud_schema varchar, tbl_schema varchar, beverbose boolean DEFAULT false )
RETURNS VOID AS $FUNC$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		IF beverbose THEN
			RAISE NOTICE '>> Processing ancillary indexes on %.%', aud_schema, table_list.table_name;
		END IF;
		PERFORM schema_support.rebuild_audit_indexes(
			aud_schema := aud_schema,
			tbl_schema := tbl_schema,
			table_name := table_list.table_name
		);
	END LOOP;
END;
$FUNC$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR,
	first_time boolean DEFAULT true
)
RETURNS VOID AS $FUNC$
DECLARE
	name_base	TEXT;
BEGIN
	BEGIN
	EXECUTE 'CREATE SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq');
	EXCEPTION WHEN duplicate_table THEN
		NULL;
	END;

	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| $$ ALTER COLUMN "aud#seq" SET NOT NULL, $$
		|| $$ ALTER COLUMN "aud#seq" SET DEFAULT nextval('$$
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name || '_seq')
		|| $$')$$;

	EXECUTE 'ALTER SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq') || ' OWNED BY '
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name)
		|| '.' || quote_ident('aud#seq');


	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident( table_name )
		|| ' ADD PRIMARY KEY ("aud#seq")';

	PERFORM schema_support.rebuild_audit_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.build_audit_tables
    ( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $FUNC$
DECLARE
     table_list RECORD;
BEGIN
    FOR table_list IN
	SELECT table_name::text FROM information_schema.tables
	WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
	AND NOT (
	    table_name IN (
		SELECT table_name FROM information_schema.tables
		WHERE table_schema = aud_schema
	    )
	)
	ORDER BY table_name
    LOOP
	PERFORM schema_support.build_audit_table
	    ( aud_schema, tbl_schema, table_list.table_name );
    END LOOP;

    PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

--
-- rebuilds all existing audit tables.  This is used when new columns are
-- added or there's some other reason to want to do it.
--
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_tables
	( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $FUNC$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		_tags := ARRAY[concat('rebuild_audit_tables_', aud_schema, '_', table_list.table_name)];
		PERFORM schema_support.save_dependent_objects_for_replay(
			schema := aud_schema::varchar,
			object := table_list.table_name::varchar,
			tags:= _tags);
		PERFORM schema_support.save_grants_for_replay(schema := aud_schema,
			object := table_list.table_name,
			tags := _tags);
		PERFORM schema_support.rebuild_audit_table
			( aud_schema, tbl_schema, table_list.table_name );
		PERFORM schema_support.replay_object_recreates(tags := _tags);
		PERFORM schema_support.replay_saved_grants(tags := _tags);
		END LOOP;

	PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
END;
$FUNC$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.trigger_ins_upd_generic_func()
RETURNS TRIGGER AS $$
DECLARE
    appuser VARCHAR;
BEGIN
	appuser := concat_ws('/', session_user,
		coalesce(
			current_setting('jazzhands.appuser', true),
			current_setting('request.header.x-remote-user', true)
		)
	);
    appuser = substr(appuser, 1, 255);

    IF TG_OP = 'INSERT' THEN
	NEW.data_ins_user = appuser;
	NEW.data_ins_date = 'now';
    END IF;

    IF TG_OP = 'UPDATE' AND OLD != NEW THEN
	NEW.data_upd_user = appuser;
	NEW.data_upd_date = 'now';

	IF OLD.data_ins_user != NEW.data_ins_user THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_USER" cannot be modified.';
	END IF;

	IF OLD.data_ins_date != NEW.data_ins_date THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_DATE" cannot be modified.';
	END IF;
    END IF;

    RETURN NEW;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_stamp_trigger
    (tbl_schema VARCHAR, table_name VARCHAR)
RETURNS VOID AS $$
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS '
	|| quote_ident('trig_userlog_' || table_name)
	|| ' ON ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name);

    EXECUTE 'CREATE TRIGGER '
	|| quote_ident('trig_userlog_' || table_name)
	|| ' BEFORE INSERT OR UPDATE ON '
	|| quote_ident(tbl_schema) || '.' || quote_ident(table_name)
	|| ' FOR EACH ROW EXECUTE PROCEDURE'
	|| ' schema_support.trigger_ins_upd_generic_func()';
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_stamp_triggers
    (tbl_schema VARCHAR)
RETURNS VOID AS $$
BEGIN
    DECLARE
	tab RECORD;
    BEGIN
	FOR tab IN
	    SELECT table_name::text FROM information_schema.tables
	    WHERE table_schema = tbl_schema AND table_type = 'BASE TABLE'
	    AND table_name NOT LIKE 'aud$%'
	LOOP
	    PERFORM schema_support.rebuild_stamp_trigger
		(tbl_schema, tab.table_name);
	END LOOP;
    END;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-------------------------------------------------------------------------------

-- MAINTENANCE SUPPORT FUNCTIONS

--
-- Check for ideal maintenance conditions.
-- Are we superuser? (argument turns this off if it is not necessary
-- Are we in a transaction?
--
-- Raise an exception now
--
CREATE OR REPLACE FUNCTION schema_support.begin_maintenance(
	shouldbesuper	BOOLEAN		DEFAULT true
)
RETURNS BOOLEAN AS $$
DECLARE
	issuper	boolean;
	_tally	integer;
BEGIN
	IF shouldbesuper THEN
		SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
		IF issuper IS false THEN
			PERFORM groname, rolname
			FROM (
				SELECT groname, unnest(grolist) AS oid
				FROM pg_group ) g
			JOIN pg_roles r USING (oid)
			WHERE groname = 'dba'
			AND rolname = current_user;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'User must be a super user or have the dba role';
			END IF;
		END IF;
	END IF;
	-- Not sure how reliable this is.
	-- http://www.postgresql.org/docs/9.3/static/monitoring-stats.html
	SELECT count(*)
	  INTO _tally
	  FROM	pg_stat_activity
	 WHERE	pid = pg_backend_pid()
	   AND	query_start = xact_start;
	IF _tally > 0 THEN
		RAISE EXCEPTION 'Must run maintenance in a transaction.';
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT query is the same
	--
	CREATE TEMPORARY TABLE __owner_before_stats (
		username					TEXT,
		before_views_count			INTEGER,
		before_func_count		INTEGER,
		before_key_count	INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_before_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Revokes superuser if its set on the current user
--
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(
	minnumdiff		INTEGER		DEFAULT 0,
	minpercent		INTEGER		DEFAULT 0,
	skipchecks		BOOLEAN		DEFAULT false
) RETURNS BOOLEAN AS $$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || _myrole;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in begin_maintenance (the INSERT query is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;

	DROP TABLE IF EXISTS __owner_before_stats;
	DROP TABLE IF EXISTS __owner_after_stats;
	RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Sets up temporary tables for replaying grants if it does not exist
--
-- This is called by other functions in this module.
--
CREATE OR REPLACE FUNCTION schema_support.prepare_for_grant_replay()
RETURNS VOID AS $$
DECLARE
	_tally integer;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__regrants'
	   AND	relpersistence = 't';

	IF _tally = 0 THEN
		CREATE TEMPORARY TABLE IF NOT EXISTS __regrants (id SERIAL, schema text, object text, newname text, regrant text, tags text[]);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Collect grants for relations and saves them for future replay (if objects
-- are dropped and recreated)
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_relations(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_schema		varchar;
	_object	varchar;
	_tabs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_fullgrant		varchar;
	_role		varchar;
	_myrole		TEXT;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;

	PERFORM schema_support.prepare_for_grant_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- Handle table wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			c.relacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || ' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	-- Handle column specific wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			a.attname as col,
			a.attacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
		ON a.attrelid = c.oid
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND a.attacl IS NOT NULL
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || '(' || _tabs.col || ')'
				' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Collect grants for functions and saves them for future replay (if objects
-- are dropped and recreated)
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_functions(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_schema		varchar;
	_object		varchar;
	_procs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_role		varchar;
	_fullgrant		varchar;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;
	PERFORM schema_support.prepare_for_grant_replay();
	FOR _procs IN SELECT  n.nspname as schema, p.proname,
			pg_get_function_identity_arguments(p.oid) as args,
			proacl as privs
		FROM    pg_catalog.pg_proc  p
				inner join pg_catalog.pg_namespace n on n.oid = p.pronamespace
		WHERE   n.nspname = _schema
		 AND    p.proname = _object
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _procs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := format(
				'GRANT %s on FUNCTION %s.%s TO %s%s',
				_perm.privilege_type, _schema,
				newname || '(' || _procs.args || ')',
				_role, _grant);
			-- RAISE DEBUG 'inserting % for %', _fullgrant, _perm;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );

			-- revoke stuff from public, too
			_fullgrant := format('REVOKE ALL ON FUNCTION %s.%s FROM public',
				_schema, newname || '(' || _procs.args || ')');
			-- RAISE DEBUG 'inserting % for %', _fullgrant, _perm;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- save grants for object regardless of if its a relation or function.
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
	PERFORM schema_support.save_grants_for_replay_relations(schema, object, newname, tags);
	PERFORM schema_support.save_grants_for_replay_functions(schema, object, newname, tags);
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- replay saved grants, drop temporary tables
--
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(
	beverbose	boolean DEFAULT false,
	schema		text DEFAULT NULL,
	tags		text[] DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Sets up temporary tables for replaying grants if it does not exist
--
-- This is called by other functions in this module.
--
CREATE OR REPLACE FUNCTION schema_support.prepare_for_object_replay()
RETURNS VOID AS $$
DECLARE
	_tally integer;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	IF _tally = 0 THEN
		CREATE TEMPORARY TABLE IF NOT EXISTS __recreate (id SERIAL, schema text, object text, owner text, type text, ddl text, idargs text, tags text[], path text[]);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Saves view definition for replay later.  This is to allow for dropping
-- dependent views and having a migration script recreate them.
--
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object) ||
					'.' || quote_ident(_c.colname) ||
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- NEED:  something to drop an object (view or function), save grants and deal with dependencies
-- probably want a restore everything function too
--

--
-- Saves relations dependent on an object for reply.
--
CREATE OR REPLACE FUNCTION schema_support.save_dependent_objects_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	doobjectdeps boolean DEFAULT false,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_myrole TEXT;
BEGIN
	RAISE DEBUG 'processing %.%', schema, object;
	path = path || concat(schema, '.', object);
	-- process stored procedures
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
			SELECT * FROM (
				-- functions that depend on relations
				SELECT  distinct np.nspname::text AS nspname,
					dependent.proname::text AS dep_object,
						n.nspname as base_namespace,
						dependee.typname as base_object
				FROM   pg_depend dep
					INNER join pg_type dependee on dependee.oid = dep.refobjid
					INNER join pg_namespace n on n.oid = dependee.typnamespace
					INNER join pg_proc dependent on dependent.oid = dep.objid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				UNION ALL
				-- relations that depend on functions
				-- note dependent and depndee are backwards

				SELECT  distinct n.nspname::text, dependee.relname::text,
					np.nspname, dependent.proname::text
				FROM   pg_depend dep
					INNER JOIN pg_rewrite ON dep.objid = pg_rewrite.oid
					INNER JOIN pg_class as dependee
						ON pg_rewrite.ev_class = dependee.oid
					INNER join pg_namespace n on n.oid = dependee.relnamespace
					INNER join pg_proc dependent on dependent.oid = dep.refobjid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				) x
	WHERE
			base_object = object
			AND base_namespace = schema
	LOOP
		-- RAISE NOTICE '1 dealing with  %.%', _r.nspname, _r.dep_object;
		PERFORM schema_support.save_constraint_for_replay(schema := _r.nspname, object := _r.dep_object, dropit := dropit, tags := tags, path := path);
		PERFORM schema_support.save_dependent_objects_for_replay(_r.nspname, _r.dep_object, dropit, doobjectdeps, tags, path);
		-- which of these to run depends on which side of the union above
		PERFORM schema_support.save_function_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
		PERFORM schema_support.save_view_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
	END LOOP;

	-- save any triggers on the view
	FOR _r in SELECT distinct n.nspname::text, dependee.relname::text, dependee.relkind
		FROM pg_depend
		JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
		JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
		JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
		JOIN pg_namespace n on n.oid = dependee.relnamespace
		JOIN pg_namespace sn on sn.oid = dependent.relnamespace
		JOIN pg_attribute ON pg_depend.refobjid = pg_attribute.attrelid
			AND pg_depend.refobjsubid = pg_attribute.attnum
		WHERE dependent.relname = object
		AND sn.nspname = schema
	LOOP
		IF _r.relkind = 'v' OR _r.relkind = 'm' THEN
			-- RAISE NOTICE '2 dealing with  %.%', _r.nspname, _r.relname;
			PERFORM * FROM save_dependent_objects_for_replay(_r.nspname, _r.relname, dropit, doobjectdeps, tags, path);
			PERFORM schema_support.save_view_for_replay(_r.nspname, _r.relname, dropit, tags, path);
		END IF;
	END LOOP;
	IF doobjectdeps THEN
		PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);
		PERFORM schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'table', tags := tags, path := path);
	END IF;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql
SECURITY INVOKER;

--
-- given schema.object, save all triggers for replay
--
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
		AND NOT tgisinternal
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;


--
-- given schema.object, look for all constraints to it outside of schema
--
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	newobject varchar DEFAULT NULL,
	newmap jsonb DEFAULT NULL,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
			pg_get_constraintdef(otherside.oid, true) AS def,
			otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
			myside.nspname as mynspname, myside.relname as myrelname,
			myside.cols as mycols, myside.conname as myconname
		FROM
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY confkey) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey,
					unnest(confkey) as confkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) otherside JOIN
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) myside ON myside.conrelid = otherside.confrelid
				AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY IMMEDIATE';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Saves view definition for replay later.  This is to allow for dropping
-- dependent functions and having a migration script recreate them.
--
-- Note this will drop and recreate all functions of the name.  This sh
--
CREATE OR REPLACE FUNCTION schema_support.save_function_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, owner,
			ddl, idargs, tags, path
		) VALUES (
			_r.nspname, _r.proname, 'function', _r.owner,
			_r.funcdef, _r.idargs, tags, path
		);
		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _r.nspname || '.' ||
				_r.proname || '(' || _r.idargs || ');';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- If tags is set, replays just the rows with those tags
-- If object/schema are set, further refines to replay objects
-- if path is set, include objects that have input path in path
-- with those names.
--
CREATE OR REPLACE FUNCTION schema_support.replay_object_recreates(
	beverbose	boolean DEFAULT false,
	tags		text[] DEFAULT NULL,
	schema		text DEFAULT NULL,
	object		text DEFAULT NULL,
	type		text DEFAULT NULL,
	path		text DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_tally	integer;
    _origsp TEXT;
	_myrole TEXT;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	SHOW search_path INTO _origsp;

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	IF _tally > 0 THEN
		FOR _r in SELECT * from __recreate ORDER BY id DESC FOR UPDATE
		LOOP
			IF tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			IF schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN NOT _r.schema = schema;
			END IF;
			IF type IS NOT NULL THEN
				CONTINUE WHEN _r.type IS NULL;
				CONTINUE WHEN NOT _r.type = type;
			END IF;
			IF object IS NOT NULL THEN
				CONTINUE WHEN _r.object IS NULL;
				IF object ~ '^!' THEN
					object = regexp_replace(object, '^!', '');
					CONTINUE WHEN _r.object = object;
				ELSE
					CONTINUE WHEN NOT _r.object = object;
				END IF;
			END IF;

			IF beverbose THEN
				RAISE NOTICE 'Recreate % %.%', _r.type, _r.schema, _r.object;
			END IF;
			EXECUTE _r.ddl;
			EXECUTE 'SET search_path = ' || _r.schema || ',jazzhands';
			IF _r.owner is not NULL THEN
				IF _r.type = 'view' OR _r.type = 'materialized view' THEN
					EXECUTE 'ALTER ' || _r.type || ' ' || _r.schema || '.' || _r.object ||
						' OWNER TO ' || _r.owner || ';';
				ELSIF _r.type = 'function' THEN
					EXECUTE 'ALTER FUNCTION ' || _r.schema || '.' || _r.object ||
						'(' || _r.idargs || ') OWNER TO ' || _r.owner || ';';
				ELSE
					RAISE EXCEPTION 'Unable to recreate object for % ', _r;
				END IF;
			END IF;
			DELETE from __recreate where id = _r.id;
		END LOOP;

		SELECT count(*) INTO _tally from __recreate;

		IF _tally > 0 THEN
			IF tags IS NULL AND schema IS NULL and object IS NULL THEN
				RAISE EXCEPTION '% objects still exist for recreating after a complete loop', _tally;
			END IF;
		ELSE
			DROP TABLE __recreate;
		END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_object_recreates did NOT have anything to regrant!';
		END IF;
	END IF;

	EXECUTE 'SET search_path = ' || _origsp;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

------------------------------------------------------------------------------
-- BEGIN functions to undo audit rows
--
-- schema_support.undo_audit_row is the function that does all the work here;
-- the rest just are support routines
------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.get_pk_columns(
	_schema		text,
	_table		text
) RETURNS text[] AS $$
DECLARE
	cols		text[];
	_r			RECORD;
BEGIN
	for _r IN SELECT a.attname
			FROM pg_class c
				INNER JOIN pg_namespace n on n.oid = c.relnamespace
				INNER JOIN pg_index i ON i.indrelid = c.oid
				INNER JOIN pg_attribute  a ON   a.attrelid = c.oid AND
								a.attnum = any(i.indkey)
			WHERE	c.relname = _table
			AND		n.nspname = _schema
			AND		indisprimary
	LOOP
		SELECT array_append(cols, _r.attname::text) INTO cols;
	END LOOP;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- given two relations, returns an array columns they have in common
--
-- runs the column names through quote_ident to ensure it is usable and
-- also will append ::text to adjust mismatches where one side or the other is
-- an enum to force both to text.
--
CREATE OR REPLACE FUNCTION schema_support.get_common_columns(
    _oldschema   TEXT,
    _table1      TEXT,
    _newschema   TEXT,
    _table2      TEXT
) RETURNS text[] AS $$
DECLARE
	_q			text;
    cols	text[];
BEGIN
    _q := 'WITH cols AS (
	SELECT  n.nspname as schema, c.relname as relation, a.attname as colname, t.typoutput as type,
		a.attnum
	    FROM    pg_catalog.pg_attribute a
		INNER JOIN pg_catalog.pg_class c
		    ON a.attrelid = c.oid
		INNER JOIN pg_catalog.pg_namespace n
		    ON c.relnamespace = n.oid
				INNER JOIN pg_catalog.pg_type t
					ON  t.oid = a.atttypid
	    WHERE   a.attnum > 0
	    AND   NOT a.attisdropped
	    ORDER BY a.attnum
       ) SELECT array_agg(colname ORDER BY attnum) as cols
	FROM ( SELECT CASE WHEN ( o.type::text ~ ''enum'' OR n.type::text ~ ''enum'')  AND o.type != n.type THEN concat(quote_ident(n.colname), ''::text'')
					ELSE quote_ident(n.colname)
					END  AS colname,
				o.attnum
			FROM cols  o
	    INNER JOIN cols n USING (colname)
		WHERE
			o.schema = $1
		and o.relation = $2
		and n.schema = $3
		and n.relation = $4
		) as prett
	';
	EXECUTE _q INTO cols USING _oldschema, _table1, _newschema, _table2;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.get_columns(
	_schema		text,
	_table		text
) RETURNS text[] AS $$
DECLARE
	cols		text[];
	_r			record;
BEGIN
	FOR _r IN SELECT  a.attname as colname,
	    pg_catalog.format_type(a.atttypid, a.atttypmod) as coltype,
	    a.attnotnull, a.attnum
	FROM    pg_catalog.pg_attribute a
				INNER JOIN pg_class c on a.attrelid = c.oid
				INNER JOIN pg_namespace n on n.oid = c.relnamespace
	WHERE   c.relname = _table
		  AND	n.nspname = _schema
	  AND   a.attnum > 0
	  AND   NOT a.attisdropped
		  AND	lower(a.attname) not like 'data_%'
	ORDER BY a.attnum
	LOOP
		SELECT array_append(cols, _r.colname::text) INTO cols;
	END LOOP;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.quote_ident_array(
	_input		text[]
) RETURNS text[] AS $$
DECLARE
	_rv		text[];
	x		text;
BEGIN
	FOREACH x IN ARRAY _input
	LOOP
		SELECT array_append(_rv, quote_ident(x)) INTO _rv;
	END LOOP;
	RETURN _rv;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-- Given a schema and table and (and and audit schema)
-- and some audit characteristics, undo the effects of the record
-- Note that this does not consider foreign keys, so the reply may fail
--
-- note also that the values are AND'd together, not OR'd
--
CREATE OR REPLACE FUNCTION schema_support.undo_audit_row(
	in_table		text,
	in_audit_schema	text DEFAULT 'audit',
	in_schema		text DEFAULT 'jazzhands',
	in_start_time	timestamp DEFAULT NULL,
	in_end_time		timestamp DEFAULT NULL,
	in_aud_user		text DEFAULT NULL,
	in_audit_ids	integer[] DEFAULT NULL,
	in_txids		bigint[] DEFAULT NULL
) RETURNS INTEGER AS $$
DECLARE
	tally	integer;
	pks		text[];
	cols	text[];
	q		text;
	val		text;
	x		text;
	_whcl	text;
	_eq		text;
	setstr	text;
	_r		record;
	_c		record;
	_br		record;
	_vals	text[];
BEGIN
	tally := 0;
	pks := schema_support.get_pk_columns(in_schema, in_table);
	cols := schema_support.get_columns(in_schema, in_table);
	q = '';
	IF in_start_time is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#timestamp') || ' >= ' || quote_literal(in_start_time);
	END IF;
	IF in_end_time is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#timestamp') || ' <= ' || quote_literal(in_end_time);
	END IF;
	IF in_aud_user is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#user') || ' = ' || quote_literal(in_aud_user);
	END IF;
	IF in_audit_ids is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#seq') || ' = ANY (in_audit_ids)';
	END IF;
	IF in_audit_ids is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#txid') || ' = ANY (in_txids)';
	END IF;

	-- Iterate over all the rows that need to be replayed
	q := 'SELECT * from ' || quote_ident(in_audit_schema) || '.' ||
			quote_ident(in_table) || ' ' || q || ' ORDER BY "aud#seq" desc';
	FOR _r IN EXECUTE q
	LOOP
		IF _r."aud#action" = 'DEL' THEN
			-- Build up a list of rows that need to be inserted
			_vals = NULL;
			FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
			LOOP
				IF _c.key !~ 'data|aud' THEN
					IF _c.value IS NULL THEN
						SELECT array_append(_vals, 'NULL') INTO _vals;
					ELSE
						SELECT array_append(_vals, quote_literal(_c.value)) INTO _vals;
					END IF;
				END IF;
			END LOOP;
			_eq := 'INSERT INTO ' || quote_ident(in_schema) || '.' ||
				quote_ident(in_table) || ' ( ' ||
				array_to_string(
					schema_support.quote_ident_array(cols), ',') ||
					') VALUES (' ||  array_to_string(_vals, ',', NULL) || ')';
		ELSIF _r."aud#action" in ('INS', 'UPD') THEN
			-- Build up a where clause for this table to get a unique row
			-- based on the primary key
			FOREACH x IN ARRAY pks
			LOOP
				_whcl := '';
				FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
				LOOP
					IF _c.key = x THEN
						IF _whcl != '' THEN
							_whcl := _whcl || ', ';
						END IF;
						IF _c.value IS NULL THEN
							_whcl = _whcl || quote_ident(_c.key) || ' = NULL ';
						ELSE
							_whcl = _whcl || quote_ident(_c.key) || ' =  ' ||
								quote_nullable(_c.value);
						END IF;
					END IF;
				END LOOP;
			END LOOP;

			IF _r."aud#action" = 'INS' THEN
				_eq := 'DELETE FROM ' || quote_ident(in_schema) || '.' ||
					quote_ident(in_table) || ' WHERE ' || _whcl;
			ELSIF _r."aud#action" = 'UPD' THEN
				-- figure out what rows have changed and do an update if
				-- they have.  NOTE:  This may result in no change being
				-- replayed if a row did not actually change
				setstr = '';
				FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
				LOOP
					--
					-- Iterate over all the columns and if they have changed,
					-- then build an update statement
					--
					IF _c.key !~ 'aud#|data_(ins|upd)_(user|date)' THEN
						EXECUTE 'SELECT ' || _c.key || ' FROM ' ||
							quote_ident(in_schema) || '.' ||
								quote_ident(in_table)  ||
							' WHERE ' || _whcl
							INTO val;
						IF ( _c.value IS NULL  AND val IS NOT NULL) OR
							( _c.value IS NOT NULL AND val IS NULL) OR
							(_c.value::text NOT SIMILAR TO val::text) THEN
							IF char_length(setstr) > 0 THEN
								setstr = setstr || ',
								';
							END IF;
							IF _c.value IS NOT  NULL THEN
								setstr = setstr || _c.key || ' = ' ||
									quote_nullable(_c.value) || ' ' ;
							ELSE
								setstr = setstr || _c.key || ' = ' ||
									' NULL ' ;
							END IF;
						END IF;
					END IF;
				END LOOP;
				IF char_length(setstr) > 0 THEN
					_eq := 'UPDATE ' || quote_ident(in_schema) || '.' ||
						quote_ident(in_table) ||
						' SET ' || setstr || ' WHERE ' || _whcl;
				END IF;
			END IF;
		END IF;
		IF _eq IS NOT NULL THEN
			tally := tally + 1;
			RAISE NOTICE '%', _eq;
			EXECUTE _eq;
		END IF;
	END LOOP;
	RETURN tally;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;
------------------------------------------------------------------------------
-- DONE functions to undo audit rows
------------------------------------------------------------------------------

------------------------------------------------------------------------------
-- START  schema_support.retrieve_functions
--
-- function that returns, and optionally drops all functions of a given
-- name in a schema, regardless of arguments.  The return array can be used
-- to operate on the objects if needed (enough to uniquely id the function)
--
--
CREATE OR REPLACE FUNCTION schema_support.retrieve_functions(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT false
) RETURNS TEXT[] AS $$
DECLARE
	_r		RECORD;
	_fn		TEXT;
	_cmd	TEXT;
	_rv		TEXT[];
	_myrole TEXT;
BEGIN
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		_fn = _r.nspname || '.' || _r.proname || '(' || _r.idargs || ')';
		_rv = _rv || _fn;

		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _fn || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
	RETURN _rv;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-- DONE  schema_support.retrieve_functions
------------------------------------------------------------------------------


----------------------------------------------------------------------------
--
-- returns true if all common colloms match between two simple relations
-- (define as containing common column that can be auto-converted to text)
--
-- returns false if not.  RAISE NOTICE all problems
--
-- Can raise an exception if desired.
--
-- Usage:
-- SELECT schema_support.relation_diff(
--	schema				- schema name of both objects
--	old_rel				- old relation name
--	new_rel				- new relation name
--	key_relation		- relation to extract pks from
--							- if not set, then defaults to old_rel
--							- will eventually be set to the one that's a table
--	prikeys				- which keys should be considered pks.  can be grabbed
--							based on key_relation; this one always wins
--	raise_exception		- raise an exception on mismatch


CREATE OR REPLACE FUNCTION schema_support.relation_diff(
	schema			text,
	old_rel			text,
	new_rel		text,
	key_relation	text DEFAULT NULL,
	prikeys			text[] DEFAULT NULL,
	raise_exception boolean DEFAULT true
) returns boolean AS
$$
DECLARE
	_r		RECORD;
	_t1		integer;
	_t2		integer;
	_cnt	integer;
	_cols	TEXT[];
	_pkcol	TEXT[];
	_q		TEXT;
	_f		TEXT;
	_c		RECORD;
	_w		TEXT[];
	_ctl		TEXT[];
	_rv	boolean;
	_oj		jsonb;
	_nj		jsonb;
	_oldschema	TEXT;
	_newschema	TEXT;
    _tmpschema	TEXT;
BEGIN
	SELECT nspname
		INTO _tmpschema
		FROM pg_namespace
		WHERE oid = pg_my_temp_schema();

	--
	-- validate that both old and new tables exist.  This has support for
	-- temporary tabels on either end, which kind of ignore schema.
	--
	IF old_rel ~ '\.' THEN
		_oldschema := regexp_replace(old_rel, '\..*$', '');
		old_rel := regexp_replace(old_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, old_rel;
		IF _t1 = 1 THEN
			_oldschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, old_rel;
			IF _t1 = 1 THEN
				_oldschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, old_rel;
			END IF;
		END IF;
	END IF;
	IF new_rel ~ '\.' THEN
		_newschema := regexp_replace(new_rel, '\..*$', '');
		new_rel := regexp_replace(new_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, new_rel;
		IF _t1 = 1 THEN
			_newschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, new_rel;
			IF _t1 = 1 THEN
				_newschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, new_rel;
			END IF;
		END IF;
	END IF;

	--
	-- at this point, the proper schemas have been figured out.
	--

	RAISE NOTICE '% % % %', _oldschema, old_rel, _newschema, new_rel;

	-- do a simple row count
	EXECUTE format('SELECT count(*) FROM %s.%s', _oldschema, old_rel) INTO _t1;
	EXECUTE format('SELECT count(*) FROM %s.%s', _newschema, new_rel) INTO _t2;

	_rv := true;

	IF _t1 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, old_rel;
		_rv := false;
	END IF;
	IF _t2 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, new_rel;
		_rv := false;
	END IF;

	IF prikeys IS NULL THEN
		-- read into prikeys the primary key for the table
		IF key_relation IS NULL THEN
			key_relation := old_rel;
		END IF;
		prikeys := schema_support.get_pk_columns(_oldschema, key_relation);
	END IF;

	-- read into _cols the column list in common between old_rel and new_rel
	_cols := schema_support.get_common_columns(_oldschema, old_rel, _newschema, new_rel);

	_ctl := NULL;
	FOREACH _f IN ARRAY prikeys
	LOOP
		SELECT array_append(_ctl, quote_ident(_f) ) INTO _ctl;
	END LOOP;
	_pkcol := _ctl;

	--
	-- Number of rows mismatch.  Show the missing rows based on the
	-- primary key.
	--
	IF _t1 != _t2 THEN
		RAISE NOTICE 'table % has % rows; table % has % rows (%)', old_rel, _t1, new_rel, _t2, _t1 - _t2;
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InOld/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InNew/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	IF NOT _rv THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Relations do not match';
		END IF;
		RETURN false;
	END IF;

	-- At this point, the same number of rows appear in both, so need to
	-- figure out rows that are different between them.

	-- SELECT row_to_json(o) as old, row_to_json(n) as new
	-- FROM ( SELECT cols FROM old WHERE prikeys in Vv ) old,
	-- JOIN ( SELECT cols FROM new WHERE prikeys in Vv ) new
	-- USING (prikeys);
	-- WHERE (prikeys) IN
	-- ( SELECT  prikeys FROM (
	--		( SELECT cols FROM old EXCEPT ( SELECT cols FROM new ) )
	-- ))

	_q := ' SELECT row_to_json(old) as old, row_to_json(new) as new FROM ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel) || ' ) old ' ||
		' JOIN ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' ) new ' ||
		' USING ( ' ||  array_to_string(_pkcol,',') ||
		' ) WHERE (' || array_to_string(_pkcol,',') || ' ) IN (' ||
		'SELECT ' || array_to_string(_pkcol,',')  || ' FROM ( ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel) ||
			' EXCEPT ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' )) ' ||
		' ) subq) ORDER BY ' || array_to_string(_pkcol,',')
	;

	_t1 := 0;
	FOR _r IN EXECUTE _q
	LOOP
		_t1 := _t1 + 1;
		FOR _f IN SELECT json_object_keys(_r.new)
		LOOP
			IF _f = ANY ( prikeys ) OR _r.old->>_f IS DISTINCT FROM _r.new->>_f
			THEN
				IF _oj IS NULL THEN
					_oj := jsonb_build_object(_f, _r.old->>_f);
					_nj := jsonb_build_object(_f, _r.new->>_f);
				ELSE
					_oj := _oj || jsonb_build_object(_f, _r.old->>_f);
					_nj := _nj || jsonb_build_object(_f, _r.new->>_f);
				END IF;
			END IF;
		END LOOP;
		RAISE NOTICE 'mismatched row:';
		RAISE NOTICE 'OLD: %', _oj;
		RAISE NOTICE 'NEW: %', _nj;
		_rv := false;
	END LOOP;


	IF NOT _rv AND raise_exception THEN
		RAISE EXCEPTION 'Relations do not match (% rows)', _t1;
	ELSE
		RAISE NOTICE '% rows mismatch', _t1;
	END IF;
	return _rv;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------------
-- BEGIN materialized view refresh automation support
----------------------------------------------------------------------------
--
-- These functions are used to better automate refreshing of materialized
-- views.  They are meant to be called by the schema owners and not by
-- mere mortals, which may mean writing wrapper functions
--
-- schema_support.relation_last_changed(table,schema,debug) can be used to
--	tell the last time a table, view or materialized view was updated
--	based on audit tables.  For views and materialized views, it will
--	recursively rifle through dependent tables to find the answer. Note
--	that if a dependency does not have an audit table (such as another
--	materialized view or caching/log table), the functions will just
--	assume they are current.
--
--	Also note that the recursive check is not terribly smart, so if
--	dependant tables had data changed that was not in the object that
--	called it, it will still trigger yes even if the view didn't really
--	change.
--
-- mv_last_updated()/set_mv_last_updated() are largely used internally.
--
-- schema_support.refresh_mv_if_needed(table,schema,debug) is used to
--	refresh a materialized view if tables internal to schema_support
--	reflect that it has not refreshed since the dependant objects were
--	refreshed.  There appears to be no place in the system catalog to
--	tell when a materialized view was last changed, so if the internal
--	tables are out of date, a refresh could happen.
--
--	Note that calls to this in different transactions will block, thus
--	if two things go to rebuild, they will happen serially.  In that
--	case, if there are no changes in a blocking transaction, the code
--	is arranged such that it will return immediately and not try to
--	rebuild the materialized view, so this should result in less churn.

--
-- refiles through internal tables to figure out when an mv or similar was
-- updated; runs as DEFINER to hide objects.
--
CREATE OR REPLACE FUNCTION schema_support.mv_last_updated (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	rv	timestamp;
BEGIN
	IF debug THEN
		RAISE NOTICE 'schema_support.mv_last_updated(): selecting for update...';
	END IF;

	SELECT	refresh
	INTO	rv
	FROM	schema_support.mv_refresh r
	WHERE	r.schema = mv_last_updated.schema
	AND	r.view = relation
	FOR UPDATE;

	IF debug THEN
		RAISE NOTICE 'schema_support.mv_last_updated(): returning %', rv;
	END IF;

	RETURN rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY DEFINER;

--
-- updates internal tables to set last update.
-- runs as DEFINER to hide objects.
--
CREATE OR REPLACE FUNCTION schema_support.set_mv_last_updated (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	whence timestamp DEFAULT now(),
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	rv	timestamp;
BEGIN
	INSERT INTO schema_support.mv_refresh AS r (
		schema, view, refresh
	) VALUES (
		set_mv_last_updated.schema, relation, whence
	) ON CONFLICT ON CONSTRAINT mv_refresh_pkey DO UPDATE
		SET		refresh = whence
		WHERE	r.schema = set_mv_last_updated.schema
		AND		r.view = relation
	;

	RETURN rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY DEFINER;

--
-- figures out the last time an object changed based on the audit tables
-- for the object.  This assumes that the schema -> audit mapping is found
-- in schema_support.schema_audit_map, otherwise raises an exception.
--
CREATE OR REPLACE FUNCTION schema_support.relation_last_changed (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands_legacy',
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	audsch	text;
	rk	char;
	rv	timestamp;
	ts	timestamp;
	obj	text;
	objaud text;
	objkind text;
	objschema text;
BEGIN
	SELECT	audit_schema
	INTO	audsch
	FROM	schema_support.schema_audit_map m
	WHERE	m.schema = relation_last_changed.schema;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Schema % not configured for this', schema;
	END IF;

	SELECT	relkind
	INTO	rk
	FROM	pg_catalog.pg_class c
		JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE	n.nspname = relation_last_changed.schema
	AND	c.relname = relation_last_changed.relation;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'No such object %.%', schema, relation;
	END IF;

	IF rk = 'r' THEN
		EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
			FROM '||quote_ident(audsch)||'.'|| quote_ident(relation)
		INTO rv;
		IF rv IS NULL THEN
			EXECUTE '
				SELECT	max("aud#timestamp")
				FROM	'||quote_ident(audsch)||'.'||quote_ident(relation)
			INTO rv;
		END IF;

		IF rv IS NULL THEN
			RETURN '-infinity'::timestamp;
		ELSE
			RETURN rv;
		END IF;
	END IF;

	IF rk = 'v' OR rk = 'm' THEN
		FOR obj,objaud,objkind, objschema IN WITH RECURSIVE recur AS (
		SELECT distinct rewrite.ev_class as root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		    JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE c.relname = relation
		AND n.nspname = relation_last_changed.schema
		AND d.refobjsubid > 0
	    UNION ALL
		SELECT recur.root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		JOIN recur ON recur.oid = rewrite.ev_class
		AND d.refobjsubid > 0
		AND c.relkind != 'm'
	    ), list AS ( select distinct m.audit_schema, c.relname, c.relkind, n.nspname as relschema, recur.*
		FROM pg_class c
		    JOIN recur on recur.oid = c.oid
		    JOIN pg_namespace n on c.relnamespace = n.oid
		    JOIN schema_support.schema_audit_map m
			ON m.schema = n.nspname
		WHERE relkind IN ('r', 'm')
		) SELECT relname, audit_schema, relkind, relschema from list
		LOOP
			-- if there is no audit table, assume its kept current.  This is
			-- likely some sort of cache table.  XXX - should probably be
			-- updated to use the materialized view update bits
			BEGIN
				IF objkind = 'r' THEN
					EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
						FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) ||'
						WHERE "aud#timestamp" > (
								SELECT max("aud#timestamp")
								FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) || '
							) - ''10 day''::interval'
						INTO ts;
					IF ts IS NULL THEN
						EXECUTE 'SELECT max("aud#timestamp")
							FROM '||quote_ident(objaud)||'.'|| quote_ident(obj)
							INTO ts;
					END IF;
				ELSIF objkind = 'm' THEN
					SELECT refresh INTO ts FROM schema_support.mv_refresh m WHERE m.schema = objschema
						AND m.view = obj;
				ELSE
					RAISE NOTICE 'Unknown object kind % for %.%', objkind, objaud, obj;
				END IF;
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): %.% -> %', objaud, obj, ts;
				END IF;
				IF rv IS NULL OR ts > rv THEN
					rv := ts;
				END IF;
			EXCEPTION WHEN undefined_table THEN
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): skipping %.%', schema, obj;
				END IF;
			END;
		END LOOP;
		RETURN rv;
	END IF;

	RAISE EXCEPTION 'Unable to process relkind %', rk;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.refresh_mv_if_needed (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	debug boolean DEFAULT false
) RETURNS void AS $$
DECLARE
	lastref	timestamp;
	lastdat	timestamp;
	whence	timestamp;
BEGIN
	SELECT coalesce(schema_support.mv_last_updated(relation, schema,debug),'-infinity') INTO lastref;
	SELECT coalesce(schema_support.relation_last_changed(relation, schema,debug),'-infinity') INTO lastdat;
	IF lastdat > lastref THEN
		IF debug THEN
			RAISE NOTICE 'schema_support.refresh_mv_if_needed(): refreshing %.%', schema, relation;
		END IF;
		EXECUTE 'REFRESH MATERIALIZED VIEW ' || quote_ident(schema)||'.'||quote_ident(relation);
		--  This can happen with long running transactions.
		whence := now();
		IF lastref > whence THEN
			whence := lastref;
		END IF;
		PERFORM schema_support.set_mv_last_updated(relation, schema, whence, debug);
	END IF;
	RETURN;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;


--
-- This migrates grants from one schema to another for setting up a shadow
-- schema for dealing with migrations.  It still needs to handle functions.
--
-- It also ignores sequences because those really need to move to IDENTITY
-- columns anyway. and sequences are really part of the shadow schema stuff.
--
CREATE OR REPLACE FUNCTION schema_support.migrate_grants (
	username	TEXT,
	direction	TEXT,
	old_schema	TEXT DEFAULT 'jazzhands_legacy',
	new_schema	TEXT DEFAULT 'jazzhands'
) RETURNS TEXT[] AS $$
DECLARE
	_rv	TEXT[];
	_r	RECORD;
	_q	TEXT;
BEGIN
	IF lower(direction) NOT IN ('grant','revoke') THEN
		RAISE EXCEPTION 'direction must be grant or revoke';
	END IF;

	FOR _r IN
		WITH x AS (
		SELECT *
			FROM (
		SELECT oid, schema, name,  typ,
			p->>'privilege_type' as privilege_type,
			col,
			r.usename as grantor, e.usename as grantee,
			r.usesysid as rid,  e.usesysid as eid,
			e.useconfig
		FROM (
			SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
				NULL::text as col,
			to_jsonb(pg_catalog.aclexplode(acl := c.relacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
		UNION ALL
		SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
			a.attname as col,
			to_jsonb(pg_catalog.aclexplode(a.attacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
				ON a.attrelid = c.oid
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
			AND a.attacl IS NOT NULL
		) x
		LEFT JOIN pg_user r ON r.usesysid = (p->>'grantor')::oid
		LEFT JOIN pg_user e ON e.usesysid = (p->>'grantee')::oid
		) i
		) select *
		FROM x
		WHERE ( schema = old_schema )
		AND grantee = username
		AND typ IN ('table', 'view', 'mview', 'foreign table')
		order by name, col
	LOOP
		IF _r.col IS NOT NULL THEN
			_q = concat(' (', _r.col, ') ');
		ELSE
			_q := NULL;
		END IF;
		IF lower(direction) = 'grant' THEN
			_q := concat('GRANT ', _r.privilege_type, _q, ' ON ', new_schema, '.', _r.name, ' TO ', _r.grantee);
		ELSIF lower(direction) = 'revoke' THEN
			_q := concat('REVOKE ', _r.privilege_type, _q, ' ON ', old_schema, '.', _r.name, ' FROM ', _r.grantee);
		END IF;


		_rv := array_append(_rv, _q);
		EXECUTE _q;
	END LOOP;
	RETURN _rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

----------------------------------------------------------------------------
--
-- schema versioning
--
----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.set_schema_version (
	version		TEXT,
	schema		TEXT
) RETURNS void AS $$
DECLARE
	in_version	ALIAS FOR version;
	in_schema	ALIAS FOR schema;
	_sp			TEXT;
BEGIN
	-- Make sure that the tracking table exists
	BEGIN
		PERFORM count(*)
		FROM schema_support.schema_version v
		WHERE v.schema = in_schema;
	EXCEPTION WHEN undefined_table THEN
		CREATE TABLE schema_support.schema_version (
			schema	TEXT,
			version	TEXT,
			CONSTRAINT schema_version_pkey PRIMARY KEY (schema)
		);
	END;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Unknown schema %', in_schema
			USING ERRCODE = 'invalid_schema_name';
	END IF;

	INSERT INTO schema_support.schema_version (
		schema, version
	) VALUES (
		in_schema, in_version
	) ON CONFLICT ON CONSTRAINT schema_version_pkey DO UPDATE
		SET version = in_version
		WHERE schema_version.schema = in_schema
	;
END;
$$
LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION schema_support.get_schema_version (
	schema			TEXT DEFAULT NULL,
	raise_exception	boolean DEFAULT true
) RETURNS TEXT AS $$
DECLARE
	in_schema	ALIAS FOR schema;
	chk_schema	TEXT;
	_sp			TEXT;
	s_version	TEXT;
BEGIN
	IF in_schema IS NOT NULL THEN
		chk_schema := in_schema;
	ELSE
		SHOW search_path INTO _sp;
		_sp := regexp_replace(_sp, ',.*$', '');
		PERFORM *
		FROM	pg_namespace
		WHERE	nspname = _sp;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'Unable to discern schema to check'
				USING ERRCODE = 'invalid_schema_name';
		END IF;
		chk_schema := _sp;
	END IF;

	BEGIN
		SELECT version
		INTO s_version
		FROM schema_support.schema_version
		WHERE schema_version.schema = chk_schema;
	EXCEPTION WHEN undefined_table THEN
		IF raise_exception THEN
			RAISE EXCEPTION '%', SQLERRM
				USING ERRCODE = SQLSTATE,
				HINT = 'Version has likely not been set';
		END IF;
	END;

	RETURN s_version;
END;
$$
LANGUAGE plpgsql SECURITY DEFINER;


CREATE OR REPLACE FUNCTION schema_support.check_schema_version (
	version			TEXT,
	schema			TEXT DEFAULT NULL,
	raise_exception	boolean DEFAULT true
) RETURNS boolean AS $$
DECLARE
	in_schema	ALIAS FOR schema;
	in_version	ALIAS FOR version;
	chk_schema	TEXT;
	s_version	TEXT;
	exist		INTEGER[];
	want		INTEGER[];
	i			INTEGER;
BEGIN
	s_version := schema_support.get_schema_version(
		schema := in_schema,
		raise_exception := raise_exception
	);

	IF s_version IS NULL  THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Could not find version'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = 'This should not happen';
		END IF;
		RETURN false;
	END IF;

	-- thx http://sqlfiddle.com/#!15/0d32c/2/0 via stackoverflow
	-- doesn't handle text labels super well, but patches welcome
	exist := regexp_split_to_array(regexp_replace(s_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];
	want := regexp_split_to_array(regexp_replace(in_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];

	--
	-- NOTE:  this does not (yet) handle software versions well, since it
	-- cosniders :, ., - to all be the same demiter, so they need the
	-- same number of elements.  Don't let the perfect be the enemy of the
	-- good, although I'm sure that sentiment will come back to bite me.
	--

	RETURN exist >= want;
END;
$$
LANGUAGE plpgsql
-- setting a search_path messes with the function, so do not.
SECURITY DEFINER;


--
-- This migrates grants from one schema to another for setting up a shadow
-- schema for dealing with migrations.  It still needs to handle functions.
--
-- It also ignores sequences because those really need to move to IDENTITY
-- columns anyway. and sequences are really part of the shadow schema stuff.
--

REVOKE USAGE ON SCHEMA schema_support FROM public;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA schema_support FROM public;

----------------------------------------------------------------------------
-- END materialized view support
----------------------------------------------------------------------------

/**************************************************************
 *  FUNCTIONS

schema_support.begin_maintenance

	- ensures you are running in a transaction
	- ensures you are a superuser (based on argument)

schema_support.end_maintenance
	- revokes superuser from running user (based on argument)


This:
	schema_support.migrate_grants is used to deal with setting up
	shadow schemas for migrations and removing/adding permissions as
	things are moving.

These will save an object for replay, including presering grants
automatically:

SELECT schema_support.save_function_for_replay('jazzhands', 'fncname');
	- saves all function of a given name

SELECT schema_support.save_view_for_replay('jazzhands',  'mytableorview');
	- saves a view includling triggers on the view, for replay

SELECT schema_support.save_constraint_for_replay('jazzhands', 'table');
	- saves constraints pointing to an object for replay

SELECT schema_support.save_trigger_for_replay('jazzhands', 'relation');
	- save triggers poinging to an object for replay

SELECT schema_support.save_dependent_objects_for_replay(schema, object)

This will take an option (relation[table/view] or procedure) and figure
out what depends on it, and save the ddl to recreate tehm.

NOTE:  This does not always handle constraints well. (bug, needs to be fixed)
Right now you may also need to call schema_support.save_constraint_for_replay.

NOTE:  All of the aforementioned tables take an optional boolean argument
at the end.  That argument defaults to true and indicates whether or not
the object shouldbe dropped after saveing grants and other info

==== GRANTS ===

This will save grants for later relay on a relation (view, table) or proc:

select schema_support.save_grants_for_replay('jazzhands', 'physical_port');
select schema_support.save_grants_for_replay('port_support',
	'do_l1_connection_update');

NOTE:  It saves the grants of stored procedures based on the arguments
passed in, so if you change those, you need to update the definitions in
__regrants (or __recreates)  before replying them.

NOTE:  These procedures end up losing who did the grants originally

THESE:

	SELECT schema_support.replay_object_recreates();
	SELECT schema_support.replay_saved_grants();

will replay object creations and grants on them respectively.  They should
be called in that order at the end of a maintenance script

THIS:
	schema_support.undo_audit_row()

will build and execute a statement to undo changes made in an audit table
against the current state.  It executes the queries in reverse order from
execution so in theory can undo every operation on a table if called without
restriction.  It does not cascade or otherwise do anything with foreign keys.


These setup triggers for the data_{ins,upd}_{user,date} columns on tables

select schema_support.rebuild_stamp_triggers();


Building and manipulating audit tables:

	schema_support.build_audit_table_pkak_indexes (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_table_other_indexes (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_table (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_tables (aud_schema, tbl_schema)

These are used to build various bits about audit tables.
schema_support.build_audit_tables() is just a wrapper that
loops through the list of tables in tbl_schema and runs
schema_support.build_audit_table().  Arguably, the system needs a method
to mark tables as exempt.

schema_support.build_audit_table() also calls table_pkak_indexes().  So
schema_support.build_audit_there is generally no reason to call that.

schema_support.build_audit_table_other_indexes() mirrors all the indexes on
the base table on the audit table and names them the same.  Note that the
rebuild commands DO NOT mirror these (yet).  This should arguably be
considered a bug...  It does not handle unique indexes well.

Rebuilding audit tables:

	schema_support.rebuild_audit_trigger(aud_schema, tbl_schema table_name)
	schema_support.rebuild_audit_table(aud_schema, tbl_schema, table_name)

	schema_support.rebuild_audit_tables(aud_schema, tbl_schema)
	schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);

These all work together but can be called individually.
schema_support.rebuild_audit_tables is generally the interface and will
iterate though every base table that has an audit table.
schema_support.rebuild_audit_tables() will also preserve grants and views
on top of the objects via functions in here, which the individual ones do not
do.  This should arguably be changed.

**************************************************************/


-- END Misc that does not apply to above
--
-- BEGIN: process_ancillary_schema(schema_support)
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'build_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'build_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.build_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, first_time boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	name_base	TEXT;
BEGIN
	BEGIN
	EXECUTE 'CREATE SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq');
	EXCEPTION WHEN duplicate_table THEN
		NULL;
	END;

	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| $$ ALTER COLUMN "aud#seq" SET NOT NULL, $$
		|| $$ ALTER COLUMN "aud#seq" SET DEFAULT nextval('$$
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name || '_seq')
		|| $$')$$;

	EXECUTE 'ALTER SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq') || ' OWNED BY '
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name)
		|| '.' || quote_ident('aud#seq');


	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident( table_name )
		|| ' ADD PRIMARY KEY ("aud#seq")';

	PERFORM schema_support.rebuild_audit_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('build_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc build_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'end_maintenance');
SELECT schema_support.save_grants_for_replay('schema_support', 'end_maintenance');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.end_maintenance ( integer,integer,boolean );
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(minnumdiff integer DEFAULT 0, minpercent integer DEFAULT 0, skipchecks boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || _myrole;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in begin_maintenance (the INSERT query is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;

	DROP TABLE IF EXISTS __owner_before_stats;
	DROP TABLE IF EXISTS __owner_after_stats;
	RETURN true;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('end_maintenance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc end_maintenance failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, finish_rebuild boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__t' || table_name);


	--
	-- RENAME sequence
	--
	EXECUTE 'ALTER SEQUENCE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq')
		|| ' RENAME TO '
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- fix sequence primary key to have the correct next value
	--
	EXECUTE 'SELECT max("aud#seq") + 1 FROM	 '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('__old__t' || table_name) INTO seq;
	IF seq IS NOT NULL THEN
		EXECUTE 'ALTER SEQUENCE '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident(table_name || '_seq')
			|| ' RESTART WITH ' || seq;
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table_finish');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table_finish');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table_finish ( character varying,character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table_finish(aud_schema character varying, tbl_schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	cols	text[];
	i	text;
	_t	text;
BEGIN
	_t := regexp_replace(rpad(quote_ident('__old__t' || table_name), 63), ' *$', '');
	--
	-- get columns - XXX NOTE:  Need to remove columns not in the new
	-- table...
	--
	SELECT	array_agg(quote_ident(a.attname) ORDER BY a.attnum)
	INTO	cols
	FROM	pg_catalog.pg_attribute a
	INNER JOIN pg_catalog.pg_class c on a.attrelid = c.oid
	INNER JOIN pg_catalog.pg_namespace n on n.oid = c.relnamespace
	LEFT JOIN pg_catalog.pg_description d
			on d.objoid = a.attrelid
			and d.objsubid = a.attnum
	WHERE   n.nspname = quote_ident(aud_schema)
	  AND	c.relname = _t
	  AND	a.attnum > 0
	  AND	NOT a.attisdropped
	;

	IF cols IS NULL THEN
		RAISE EXCEPTION 'Unable to get columns from "%.%"',
			quote_ident(aud_schema), _t;
	END IF;

	EXECUTE 'INSERT INTO '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' ( '
		|| array_to_string(cols, ',') || ' ) SELECT '
		|| array_to_string(cols, ',') || ' FROM '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name)
		|| ' ORDER BY '
		|| quote_ident('aud#seq');


	EXECUTE 'DROP TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name);

	--
	-- drop audit sequence, in case it was not dropped with table.
	--
	EXECUTE 'DROP SEQUENCE IF EXISTS '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- drop indexes found before that did not get dropped.
	--
	FOR i IN SELECT	c2.relname
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident('__old__' || table_name)
		  AND	contype is NULL
	LOOP
		EXECUTE 'DROP INDEX '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('_' || i);
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table_finish');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table_finish failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_tables');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_tables');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_tables ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_tables(aud_schema character varying, tbl_schema character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		_tags := ARRAY[concat('rebuild_audit_tables_', aud_schema, '_', table_list.table_name)];
		PERFORM schema_support.save_dependent_objects_for_replay(
			schema := aud_schema::varchar,
			object := table_list.table_name::varchar,
			tags:= _tags);
		PERFORM schema_support.save_grants_for_replay(schema := aud_schema,
			object := table_list.table_name,
			tags := _tags);
		PERFORM schema_support.rebuild_audit_table
			( aud_schema, tbl_schema, table_list.table_name );
		PERFORM schema_support.replay_object_recreates(tags := _tags);
		PERFORM schema_support.replay_saved_grants(tags := _tags);
		END LOOP;

	PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_tables');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_tables failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'relation_diff');
SELECT schema_support.save_grants_for_replay('schema_support', 'relation_diff');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.relation_diff ( text,text,text,text,text[],boolean );
CREATE OR REPLACE FUNCTION schema_support.relation_diff(schema text, old_rel text, new_rel text, key_relation text DEFAULT NULL::text, prikeys text[] DEFAULT NULL::text[], raise_exception boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_t1		integer;
	_t2		integer;
	_cnt	integer;
	_cols	TEXT[];
	_pkcol	TEXT[];
	_q		TEXT;
	_f		TEXT;
	_c		RECORD;
	_w		TEXT[];
	_ctl		TEXT[];
	_rv	boolean;
	_oj		jsonb;
	_nj		jsonb;
	_oldschema	TEXT;
	_newschema	TEXT;
    _tmpschema	TEXT;
BEGIN
	SELECT nspname
		INTO _tmpschema
		FROM pg_namespace
		WHERE oid = pg_my_temp_schema();

	--
	-- validate that both old and new tables exist.  This has support for
	-- temporary tabels on either end, which kind of ignore schema.
	--
	IF old_rel ~ '\.' THEN
		_oldschema := regexp_replace(old_rel, '\..*$', '');
		old_rel := regexp_replace(old_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, old_rel;
		IF _t1 = 1 THEN
			_oldschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, old_rel;
			IF _t1 = 1 THEN
				_oldschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, old_rel;
			END IF;
		END IF;
	END IF;
	IF new_rel ~ '\.' THEN
		_newschema := regexp_replace(new_rel, '\..*$', '');
		new_rel := regexp_replace(new_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, new_rel;
		IF _t1 = 1 THEN
			_newschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, new_rel;
			IF _t1 = 1 THEN
				_newschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, new_rel;
			END IF;
		END IF;
	END IF;

	--
	-- at this point, the proper schemas have been figured out.
	--

	RAISE NOTICE '% % % %', _oldschema, old_rel, _newschema, new_rel;

	-- do a simple row count
	EXECUTE format('SELECT count(*) FROM %s.%s', _oldschema, old_rel) INTO _t1;
	EXECUTE format('SELECT count(*) FROM %s.%s', _newschema, new_rel) INTO _t2;

	_rv := true;

	IF _t1 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, old_rel;
		_rv := false;
	END IF;
	IF _t2 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, new_rel;
		_rv := false;
	END IF;

	IF prikeys IS NULL THEN
		-- read into prikeys the primary key for the table
		IF key_relation IS NULL THEN
			key_relation := old_rel;
		END IF;
		prikeys := schema_support.get_pk_columns(_oldschema, key_relation);
	END IF;

	-- read into _cols the column list in common between old_rel and new_rel
	_cols := schema_support.get_common_columns(_oldschema, old_rel, _newschema, new_rel);

	_ctl := NULL;
	FOREACH _f IN ARRAY prikeys
	LOOP
		SELECT array_append(_ctl, quote_ident(_f) ) INTO _ctl;
	END LOOP;
	_pkcol := _ctl;

	--
	-- Number of rows mismatch.  Show the missing rows based on the
	-- primary key.
	--
	IF _t1 != _t2 THEN
		RAISE NOTICE 'table % has % rows; table % has % rows (%)', old_rel, _t1, new_rel, _t2, _t1 - _t2;
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InOld/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InNew/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	IF NOT _rv THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Relations do not match';
		END IF;
		RETURN false;
	END IF;

	-- At this point, the same number of rows appear in both, so need to
	-- figure out rows that are different between them.

	-- SELECT row_to_json(o) as old, row_to_json(n) as new
	-- FROM ( SELECT cols FROM old WHERE prikeys in Vv ) old,
	-- JOIN ( SELECT cols FROM new WHERE prikeys in Vv ) new
	-- USING (prikeys);
	-- WHERE (prikeys) IN
	-- ( SELECT  prikeys FROM (
	--		( SELECT cols FROM old EXCEPT ( SELECT cols FROM new ) )
	-- ))

	_q := ' SELECT row_to_json(old) as old, row_to_json(new) as new FROM ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel) || ' ) old ' ||
		' JOIN ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' ) new ' ||
		' USING ( ' ||  array_to_string(_pkcol,',') ||
		' ) WHERE (' || array_to_string(_pkcol,',') || ' ) IN (' ||
		'SELECT ' || array_to_string(_pkcol,',')  || ' FROM ( ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel) ||
			' EXCEPT ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' )) ' ||
		' ) subq) ORDER BY ' || array_to_string(_pkcol,',')
	;

	_t1 := 0;
	FOR _r IN EXECUTE _q
	LOOP
		_t1 := _t1 + 1;
		FOR _f IN SELECT json_object_keys(_r.new)
		LOOP
			IF _f = ANY ( prikeys ) OR _r.old->>_f IS DISTINCT FROM _r.new->>_f
			THEN
				IF _oj IS NULL THEN
					_oj := jsonb_build_object(_f, _r.old->>_f);
					_nj := jsonb_build_object(_f, _r.new->>_f);
				ELSE
					_oj := _oj || jsonb_build_object(_f, _r.old->>_f);
					_nj := _nj || jsonb_build_object(_f, _r.new->>_f);
				END IF;
			END IF;
		END LOOP;
		RAISE NOTICE 'mismatched row:';
		RAISE NOTICE 'OLD: %', _oj;
		RAISE NOTICE 'NEW: %', _nj;
		_rv := false;
	END LOOP;


	IF NOT _rv AND raise_exception THEN
		RAISE EXCEPTION 'Relations do not match (% rows)', _t1;
	ELSE
		RAISE NOTICE '% rows mismatch', _t1;
	END IF;
	return _rv;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('relation_diff');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc relation_diff failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'replay_saved_grants ( boolean,text,text )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.replay_saved_grants ( boolean,text,text );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'reset_table_sequence');
SELECT schema_support.save_grants_for_replay('schema_support', 'reset_table_sequence');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.reset_table_sequence ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence(schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		WITH s AS (
			SELECT	pg_get_serial_sequence(nspname||'.'||relname,
				a.attname) as seq, a.attname as column
			FROM	pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE	c.relname = table_name
			AND	n.nspname = schema
				AND	a.attnum > 0
				AND	NOT a.attisdropped
		) SELECT s.*, nextval(s.seq) as nv FROM s WHERE seq IS NOT NULL
	LOOP
		EXECUTE 'SELECT max('||quote_ident(_r.column)||')+1 FROM  '
			|| quote_ident(schema)||'.'||quote_ident(table_name)
			INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE 'ALTER SEQUENCE ' || _r.seq || ' RESTART WITH '
				|| m;
		END IF;
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('reset_table_sequence');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc reset_table_sequence failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_constraint_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_constraint_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_constraint_for_replay ( character varying,character varying,boolean,character varying,jsonb,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, newobject character varying DEFAULT NULL::character varying, newmap jsonb DEFAULT NULL::jsonb, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
			pg_get_constraintdef(otherside.oid, true) AS def,
			otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
			myside.nspname as mynspname, myside.relname as myrelname,
			myside.cols as mycols, myside.conname as myconname
		FROM
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY confkey) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey,
					unnest(confkey) as confkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) otherside JOIN
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) myside ON myside.conrelid = otherside.confrelid
				AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY IMMEDIATE';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_constraint_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_constraint_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_trigger_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_trigger_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_trigger_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
		AND NOT tgisinternal
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_trigger_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_trigger_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_view_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_view_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_view_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object) ||
					'.' || quote_ident(_c.colname) ||
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_view_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_view_for_replay failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.check_schema_version(version text, schema text DEFAULT NULL::text, raise_exception boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_schema	ALIAS FOR schema;
	in_version	ALIAS FOR version;
	chk_schema	TEXT;
	s_version	TEXT;
	exist		INTEGER[];
	want		INTEGER[];
	i			INTEGER;
BEGIN
	s_version := schema_support.get_schema_version(
		schema := in_schema,
		raise_exception := raise_exception
	);

	IF s_version IS NULL  THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Could not find version'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = 'This should not happen';
		END IF;
		RETURN false;
	END IF;

	-- thx http://sqlfiddle.com/#!15/0d32c/2/0 via stackoverflow
	-- doesn't handle text labels super well, but patches welcome
	exist := regexp_split_to_array(regexp_replace(s_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];
	want := regexp_split_to_array(regexp_replace(in_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];

	--
	-- NOTE:  this does not (yet) handle software versions well, since it
	-- cosniders :, ., - to all be the same demiter, so they need the
	-- same number of elements.  Don't let the perfect be the enemy of the
	-- good, although I'm sure that sentiment will come back to bite me.
	--

	RETURN exist >= want;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.get_schema_version(schema text DEFAULT NULL::text, raise_exception boolean DEFAULT true)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_schema	ALIAS FOR schema;
	chk_schema	TEXT;
	_sp			TEXT;
	s_version	TEXT;
BEGIN
	IF in_schema IS NOT NULL THEN
		chk_schema := in_schema;
	ELSE
		SHOW search_path INTO _sp;
		_sp := regexp_replace(_sp, ',.*$', '');
		PERFORM *
		FROM	pg_namespace
		WHERE	nspname = _sp;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'Unable to discern schema to check'
				USING ERRCODE = 'invalid_schema_name';
		END IF;
		chk_schema := _sp;
	END IF;

	BEGIN
		SELECT version
		INTO s_version
		FROM schema_support.schema_version
		WHERE schema_version.schema = chk_schema;
	EXCEPTION WHEN undefined_table THEN
		IF raise_exception THEN
			RAISE EXCEPTION '%', SQLERRM
				USING ERRCODE = SQLSTATE,
				HINT = 'Version has likely not been set';
		END IF;
	END;

	RETURN s_version;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.rebuild_all_audit_indexes(aud_schema character varying, tbl_schema character varying, beverbose boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		IF beverbose THEN
			RAISE NOTICE '>> Processing ancillary indexes on %.%', aud_schema, table_list.table_name;
		END IF;
		PERFORM schema_support.rebuild_audit_indexes(
			aud_schema := aud_schema,
			tbl_schema := tbl_schema,
			table_name := table_list.table_name
		);
	END LOOP;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_indexes(aud_schema character varying, tbl_schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r	RECORD;
	sch	TEXT;
	name_base	TEXT;
BEGIN
	FOR _r IN
		SELECT c2.relname, pg_get_indexdef(i.indexrelid) as def, con.contype
			FROM pg_catalog.pg_class c
				INNER JOIN pg_namespace n ON relnamespace = n.oid
				INNER JOIN pg_catalog.pg_index i ON c.oid = i.indrelid
				INNER JOIN pg_catalog.pg_class c2 ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_constraint con ON
				(con.conrelid = i.indrelid AND con.conindid = i.indexrelid )
			WHERE c.relname =  table_name
			AND	  n.nspname = aud_schema
			AND	(contype IS NULL OR contype NOT IN ('p','u'))
	LOOP
		EXECUTE format('DROP INDEX %s.%s',
		quote_ident(aud_schema), quote_ident(_r.relname));
	END LOOP;

	name_base := quote_ident( table_name );
	-- 17 is length of _aud#timestmp_idx
	-- md5 is just to make the name unique
	IF char_length(name_base) > 64 - 17 THEN
		-- using lpad as a truncate
		name_base := 'aud_' || lpad(md5(table_name), 10) || lpad(table_name, 64 - 19 - 10 );
	END IF;

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#timestamp_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#timestamp")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#realtime_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#realtime")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#txid_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#txid")';


	PERFORM schema_support.build_audit_table_pkak_indexes(
		aud_schema := aud_schema,
		tbl_schema := tbl_schema,
		table_name := table_name
	);
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(beverbose boolean DEFAULT false, schema text DEFAULT NULL::text, tags text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.set_schema_version(version text, schema text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_version	ALIAS FOR version;
	in_schema	ALIAS FOR schema;
	_sp			TEXT;
BEGIN
	-- Make sure that the tracking table exists
	BEGIN
		PERFORM count(*)
		FROM schema_support.schema_version v
		WHERE v.schema = in_schema;
	EXCEPTION WHEN undefined_table THEN
		CREATE TABLE schema_support.schema_version (
			schema	TEXT,
			version	TEXT,
			CONSTRAINT schema_version_pkey PRIMARY KEY (schema)
		);
	END;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Unknown schema %', in_schema
			USING ERRCODE = 'invalid_schema_name';
	END IF;

	INSERT INTO schema_support.schema_version (
		schema, version
	) VALUES (
		in_schema, in_version
	) ON CONFLICT ON CONSTRAINT schema_version_pkey DO UPDATE
		SET version = in_version
		WHERE schema_version.schema = in_schema
	;
END;
$function$
;

-- DONE: process_ancillary_schema(schema_support)
DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'component_manip';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS component_manip;
		CREATE SCHEMA component_manip AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA component_manip IS 'part of jazzhands';
	END IF;
END;
			$$;DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'dns_manip';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS dns_manip;
		CREATE SCHEMA dns_manip AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA dns_manip IS 'part of jazzhands';
	END IF;
END;
			$$;DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'versioning_utils';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS versioning_utils;
		CREATE SCHEMA versioning_utils AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA versioning_utils IS 'part of jazzhands';
	END IF;
END;
			$$;--
-- Process middle (non-trigger) schema jazzhands_cache
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
--
-- Process middle (non-trigger) schema account_collection_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_collection_manip', 'cleanup_account_collection_account');
SELECT schema_support.save_grants_for_replay('account_collection_manip', 'cleanup_account_collection_account');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_collection_manip.cleanup_account_collection_account ( interval );
CREATE OR REPLACE FUNCTION account_collection_manip.cleanup_account_collection_account(lifespan interval DEFAULT NULL::interval)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	rv	INTEGER;
BEGIN
	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_collection_cleanup_interval'
		AND		property_type = '_Defaults';
	END IF;

	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_cleanup_interval'
		AND		property_type = '_Defaults';
	END IF;

	IF lifespan IS NULL THEN
		lifespan := '1 year'::interval;
	END IF;

	--
	-- It is possible that this will fail if there are surprise foreign
	-- keys to the accounts.
	--
	EXECUTE '
		WITH x AS (
			SELECT account_collection_id, account_id
			FROM    account a
				JOIN account_collection_account aca USING (account_id)
				JOIN account_collection ac USING (account_collection_id)
				JOIN person_company pc USING (person_id, company_id)
			WHERE   pc.termination_date IS NOT NULL
			AND     pc.termination_date < now() - $1::interval
			AND	NOT a.is_enabled
			AND     account_collection_type != $2
			AND
				(account_collection_id, account_id)  NOT IN
					( SELECT unix_group_account_collection_id, account_id from
						account_unix_info)
			) DELETE FROM account_collection_account aca
			WHERE (account_collection_id, account_id) IN
				(SELECT account_collection_id, account_id FROM x)
		' USING lifespan, 'per-account';
	GET DIAGNOSTICS rv = ROW_COUNT;
	RETURN rv;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_collection_manip' AND type = 'function' AND object IN ('cleanup_account_collection_account');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc cleanup_account_collection_account failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_collection_manip', 'purge_inactive_account_collections');
SELECT schema_support.save_grants_for_replay('account_collection_manip', 'purge_inactive_account_collections');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_collection_manip.purge_inactive_account_collections ( interval,boolean );
CREATE OR REPLACE FUNCTION account_collection_manip.purge_inactive_account_collections(lifespan interval DEFAULT NULL::interval, raise_exception boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	_r	RECORD;
	i	INTEGER;
	rv	INTEGER;
BEGIN
	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_collection_purge_interval'
		AND		property_type = '_Defaults';
	END IF;

	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_cleanup_interval'
		AND		property_type = '_Defaults';
	END IF;
	IF lifespan IS NULL THEN
		lifespan := '1 year'::interval;
	END IF;

	--
	-- remove unused account collections
	--
	rv := 0;
	FOR _r IN
		SELECT ac.*
		FROM	account_collection ac
			JOIN val_account_collection_type act USING (account_collection_type)
		WHERE	now() -
			coalesce(ac.data_upd_date,ac.data_ins_date) > lifespan::interval
		AND	act.is_infrastructure_type = false
		AND	account_collection_id NOT IN
			(SELECT child_account_collection_id FROM account_collection_hier)
		AND	account_collection_id NOT IN
			(SELECT account_collection_id FROM account_collection_hier)
		AND	account_collection_id NOT IN
			(SELECT account_collection_id FROM account_collection_account)
		AND	account_collection_id NOT IN
			(SELECT account_collection_id FROM property
				WHERE account_collection_id IS NOT NULL)
		AND	account_collection_id NOT IN
			(SELECT property_value_account_collection_id FROM property
				WHERE property_value_account_collection_id IS NOT NULL)
	LOOP
		BEGIN
			DELETE FROM account_collection
				WHERE account_collection_id = _r.account_collection_id;
			GET DIAGNOSTICS i = ROW_COUNT;
			rv := rv + i;
		EXCEPTION WHEN foreign_key_violation THEN
			NULL;
		END;
	END LOOP;

	RETURN rv;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_collection_manip' AND type = 'function' AND object IN ('purge_inactive_account_collections');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc purge_inactive_account_collections failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_collection_manip', 'purge_inactive_department_properties');
SELECT schema_support.save_grants_for_replay('account_collection_manip', 'purge_inactive_department_properties');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_collection_manip.purge_inactive_department_properties ( character varying,character varying,interval,boolean );
CREATE OR REPLACE FUNCTION account_collection_manip.purge_inactive_department_properties(property_type character varying, property_name character varying DEFAULT NULL::character varying, lifespan interval DEFAULT NULL::interval, raise_exception boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r	RECORD;
	rv	INTEGER;
	i	INTEGER;
	_pn	TEXT;
	_pt TEXT;
BEGIN
	_pn := property_name;
	_pt := property_type;
	rv := 0;

	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_collection_purge_interval'
		AND		property_type = '_Defaults';
	END IF;

	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_cleanup_interval'
		AND		property_type = '_Defaults';
	END IF;
	IF lifespan IS NULL THEN
		lifespan := '1 year'::interval;
	END IF;

	--
	-- delete login assignment to linux machines for departments that are
	-- disabled and not in use
	--
	FOR _r IN SELECT	p.property_id
			FROM	account_collection ac
				JOIN department d USING (account_collection_id)
				JOIN property p USING (account_collection_id)
			WHERE 	d.is_active = false
			AND ((_pn IS NOT NULL AND _pn = p.property_name) OR _pn IS NULL )
			AND	p.property_type = _pt
			AND	account_collection_id NOT IN (
					SELECT child_account_collection_id
					FROM account_collection_hier
				)
			AND	account_collection_id NOT IN (
					SELECT account_collection_id
					FROM account_collection_account
				)
			AND account_collection_id NOT IN (
				SELECT account_collection_id
				FROM	account_collection ac
					JOIN department d USING (account_collection_id)
					JOIN (
						SELECT level, v.account_collection_id,
							ac.account_collection_id as child_account_collection_id,
							account_collection_name as name,
							account_collection_type as type
						FROM	v_account_collection_expanded 	 v
							JOIN account_collection ac ON v.root_account_collection_id = ac.account_collection_id
							JOIN department d ON ac.account_collection_id = d.account_collection_id
						WHERE	is_active = true
					) kid USING (account_collection_id)
				WHERE
					is_active = false
			)
	LOOP
		BEGIN
			DELETE FROM property
			WHERE property_id = _r.property_id;
			GET DIAGNOSTICS i = ROW_COUNT;
			rv := rv + i;
		EXCEPTION WHEN foreign_key_violation THEN
			NULL;
		END;
	END LOOP;


	--
	-- delete unix group overrides to linux machines for departments that are
	-- disabled and not in use
	--
	FOR _r IN SELECT	p.property_id
			FROM	account_collection ac
				JOIN department d USING (account_collection_id)
				JOIN property p ON p.property_value_account_collection_id =
					ac.account_collection_id
			WHERE 	d.is_active = false
			AND ((_pn IS NOT NULL AND _pn = p.property_name) OR _pn IS NULL )
			AND	p.property_type = _pt
			AND	p.property_value_account_collection_id NOT IN (
					SELECT child_account_collection_id
					FROM account_collection_hier
				)
			AND	p.property_value_account_collection_id NOT IN (
					SELECT account_collection_id
					FROM account_collection_account
						JOIN account a USING (account_id)
					WHERE a.is_enabled = true
				)
			AND p.property_value_account_collection_id NOT IN (
				SELECT account_collection_id
				FROM	account_collection ac
					JOIN department d USING (account_collection_id)
					JOIN (
						SELECT level, v.account_collection_id,
							ac.account_collection_id as child_account_collection_id,
							account_collection_name as name,
							account_collection_type as type
						FROM	v_account_collection_expanded 	 v
							JOIN account_collection ac ON v.root_account_collection_id = ac.account_collection_id
							JOIN department d ON ac.account_collection_id = d.account_collection_id
						WHERE	is_active = true
					) kid USING (account_collection_id)
				WHERE
					is_active = false
			)
	LOOP
		BEGIN
			DELETE FROM property
			WHERE property_id = _r.property_id;
			GET DIAGNOSTICS i = ROW_COUNT;
			rv := rv + i;
		EXCEPTION WHEN foreign_key_violation THEN
			NULL;
		END;
	END LOOP;

	RETURN rv;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_collection_manip' AND type = 'function' AND object IN ('purge_inactive_department_properties');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc purge_inactive_department_properties failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_collection_manip', 'purge_inactive_departments');
SELECT schema_support.save_grants_for_replay('account_collection_manip', 'purge_inactive_departments');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_collection_manip.purge_inactive_departments ( interval,boolean );
CREATE OR REPLACE FUNCTION account_collection_manip.purge_inactive_departments(lifespan interval DEFAULT NULL::interval, raise_exception boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	_r	RECORD;
	rv	INTEGER;
	i	INTEGER;
BEGIN
	rv := 0;
	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_collection_purge_interval'
		AND		property_type = '_Defaults';
	END IF;

	IF lifespan IS NULL THEN
		SELECT	property_value::interval
		INTO	lifespan
		FROM	property
		WHERE	property_name = 'account_cleanup_interval'
		AND		property_type = '_Defaults';
	END IF;
	IF lifespan IS NULL THEN
		lifespan := '1 year'::interval;
	END IF;

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'UnixLogin',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'MclassUnixProp',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'StabRole',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'Defaults',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'API',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'DeviceInventory',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	rv := rv + account_collection_manip.purge_inactive_department_properties(
		property_type := 'PhoneDirectoryAttributes',
		lifespan := lifespan,
		raise_exception := raise_exception
	);

	--
	-- remove child account collection membership
	--
	FOR _r IN SELECT	ac.*
			FROM	account_collection ac
				JOIN department d USING (account_collection_id)
			WHERE	d.is_active = false
			AND	account_collection_id IN (
				SELECT child_account_collection_id FROM account_collection_hier
			)
			AND account_collection_id NOT IN (
				SELECT account_collection_id
				FROM	account_collection ac
					JOIN department d USING (account_collection_id)
					JOIN (
						SELECT level, v.account_collection_id,
							ac.account_collection_id as child_account_collection_id,
							account_collection_name as name,
							account_collection_type as type
						FROM	v_account_collection_expanded 	 v
							JOIN account_collection ac ON v.root_account_collection_id = ac.account_collection_id
							JOIN department d ON ac.account_collection_id = d.account_collection_id
						WHERE	is_active = true
					) kid USING (account_collection_id)
				WHERE
					is_active = false
			)

	LOOP
		BEGIN
			DELETE FROM account_collection_hier
				WHERE child_account_collection_id = _r.account_collection_id;
			GET DIAGNOSTICS i = ROW_COUNT;
			rv := rv + i;
		EXCEPTION WHEN foreign_key_violation THEN
			NULL;
		END;
	END LOOP;

	RETURN rv;

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_collection_manip' AND type = 'function' AND object IN ('purge_inactive_departments');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc purge_inactive_departments failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process middle (non-trigger) schema account_password_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_password_manip', 'authenticate_account');
SELECT schema_support.save_grants_for_replay('account_password_manip', 'authenticate_account');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_password_manip.authenticate_account ( integer,text,text,text,boolean );
CREATE OR REPLACE FUNCTION account_password_manip.authenticate_account(account_id integer, password text, encode_method text DEFAULT 'aes-cbc/pad:pkcs'::text, label text DEFAULT 'default'::text, raiseexception boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	plainpw	TEXT;
	crypt	TEXT;
	method	TEXT;
	_tally	INTEGER;	
BEGIN
	--
	-- decode the password into plaintext
	--
	plainpw := obfuscation_utils.deobfuscate_text (encoded := password,
		type := encode_method,
		label := label);

	--
	-- go through all of this user's passwords  that the database is capable
	-- of decoding.  This list should probably be expanded.
	--
	_tally := 0;
	FOR crypt, method IN SELECT  a.password, a.password_type
		FROM	account_password a
		WHERE	a.account_id = authenticate_account.account_id
		AND		password_type IN ( 'cryptMD5', 'blowfish', 
					'xdes', 'postgresMD5')
	LOOP
		IF pgcrypto.crypt(plainpw, crypt) = crypt THEN
			RETURN true;
		END IF;
		_tally := _tally+ 1;
	END LOOP;
	IF raiseexception AND _tally = 0 THEN
		RAISE EXCEPTION 'User has no passwords set'
			USING ERRCODE = 'cardinality_violation';
	END IF;
	RETURN false;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_password_manip' AND type = 'function' AND object IN ('authenticate_account');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc authenticate_account failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('account_password_manip', 'set_account_passwords');
SELECT schema_support.save_grants_for_replay('account_password_manip', 'set_account_passwords');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS account_password_manip.set_account_passwords ( integer,text,text,timestamp without time zone,timestamp without time zone,jsonb,text,boolean,boolean );
CREATE OR REPLACE FUNCTION account_password_manip.set_account_passwords(account_id integer, password text, encode_method text DEFAULT 'pgp+base64'::text, change_time timestamp without time zone DEFAULT now(), expire_time timestamp without time zone DEFAULT NULL::timestamp without time zone, crypts jsonb DEFAULT '{}'::jsonb, label text DEFAULT 'default'::text, purge boolean DEFAULT true, racecatch boolean DEFAULT false)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	len			INTEGER;
	acid		account_collection.account_collection_id%TYPE;
	proplen		INTEGER;
	pwtype		TEXT;
	plainpw		TEXT;
	method		TEXT;
	value		TEXT;
	p_method	TEXT;
	p_value		TEXT;
	cols		TEXT[];
	vals		TEXT[];
	done		TEXT[];
	passed		TEXT[];
	upd			TEXT[];
	login		TEXT;
	curcrypt	TEXT[];
	_tally		INTEGER;
	_r			RECORD;
	foundac		BOOLEAN;
BEGIN
	--
	-- lock all the passwords for UPDATE.  Also keep track of all the recent
	--
	FOR _r IN SELECT ap.password, now()- ap.change_time <= '5 minutes'::interval AS recent
		FROM account_password ap 
		WHERE ap.account_id = set_account_passwords.account_id FOR UPDATE
	LOOP
		IF _r.recent THEN
			curcrypt := curcrypt || _r.password::text;
		END IF;
	END LOOP;


	--
	-- decode the password into plaintext
	--
	plainpw := obfuscation_utils.deobfuscate_text (encoded := password,
		type := encode_method,
		label := label);
	len := character_length(plainpw);

	IF racecatch AND curcrypt IS NOT NULL THEN
		FOREACH value IN ARRAY curcrypt LOOP
			IF pgcrypto.crypt(plainpw, value) = value THEN
				RETURN 1;
			END IF;
		END LOOP;
	END IF;
	value := NULL;

	-- figure out crypts that need to be added that we can handle
	--
	SELECT array_agg(KEY) INTO passed FROM jsonb_each_text(crypts);
	FOR pwtype IN SELECT property_value_password_type FROM property WHERE property_name = 'managedpwtype' AND property_type = 'Defaults'
	LOOP
		IF pwtype = SOME (passed) THEN
			CONTINUE;
		END IF;
		-- XXX - reallyneed to add SCRAM-SHA-256 for postgres. possibly 
		-- mysql and others since they're probably easy
		IF pwtype = 'cryptMD5' THEN
			crypts := jsonb_insert (crypts,
				ARRAY [ pwtype ],
				concat('"', pgcrypto.crypt(PASSWORD, pgcrypto.gen_salt('md5')), '"')::jsonb);
		ELSIF pwtype = 'blowfish' THEN
			crypts := jsonb_insert (crypts,
				ARRAY [ pwtype ],
				concat('"', pgcrypto.crypt(PASSWORD, pgcrypto.gen_salt('bf')), '"')::jsonb);
		ELSIF pwtype = 'xdes' THEN
			crypts := jsonb_insert (crypts,
				ARRAY [ pwtype ],
				concat('"', pgcrypto.crypt(PASSWORD, pgcrypto.gen_salt('xdes')), '"')::jsonb);
		ELSIF pwtype = 'postgresMD5' THEN
			SELECT	a.login INTO LOGIN
			FROM	account a
			WHERE	a.account_id = set_account_passwords.account_id;
			crypts := jsonb_insert (crypts,
				ARRAY [ pwtype ],
				concat('"md5', md5(concat(PASSWORD, LOGIN)), '"')::jsonb);
		ELSE
			RAISE EXCEPTION 'Unknown pwtype %', pwtype
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END LOOP;

	_tally := 0;
	FOR method, value IN SELECT * FROM jsonb_each_text(crypts)
		LOOP
			IF value IS NULL THEN
				DELETE FROM account_password ap WHERE password_type = method AND ap.account_id = set_account_passwords.account_id;
				CONTINUE;
			END IF;
			p_method := quote_nullable(method);
			p_value := quote_nullable(value);
			cols := ARRAY [ 'password_type', 'password', 'account_id' ];
			vals := ARRAY [ p_method, p_value, '$1' ];
			upd := ARRAY [ 'password_type = ' || p_method, 'password = ' || p_value ];

			IF change_time IS NOT NULL THEN
				cols := cols || quote_ident('change_time');
				vals := vals || quote_nullable(change_time);
				upd := upd || concat('change_time = ',
					 quote_nullable(change_time));

				--
				-- for any password changing, set the expire time so it 
				-- can fall back on default policy, even on NULL
				--
				cols := cols || quote_ident('expire_time');
				vals := vals || quote_nullable(expire_time);
				upd := upd || concat('expire_time = ',
					 quote_nullable(expire_time));
			END IF;
			--
			-- note that account_id is passed in as an argument
			--
			EXECUTE 'INSERT INTO account_password (' || 
					array_to_string(cols, ',') || ' ) VALUES ( ' || 
					array_to_string(vals, ',') || 
					') ON CONFLICT ON CONSTRAINT pk_accunt_password DO UPDATE SET ' || 
					array_to_string(upd, ',')
				USING account_id;
			done := done || method;
			_tally := _tally + 1;
		END LOOP;
	IF purge THEN
		DELETE FROM account_password
		WHERE account_password.account_id = set_account_passwords.account_id
			AND NOT password_type = ANY (done);
	END IF;

	--
	-- This is probably a hack that needs revisiting, ideally with the
	-- addition of a policy concept.  The logic is that an account is only
	-- in one of these.
	--
	foundac := false;
	FOR acid, proplen IN SELECT account_collection_id, property_value
		FROM property
		WHERE property_type = 'account-override'
		AND property_name = 'password_length'
		ORDER BY property_value::integer desc
	LOOP
		IF NOT foundac AND len >= proplen THEN
			--
			-- conflict means that they are already a part of this.
			--
			INSERT INTO account_collection_account (
				account_collection_id, account_id
			) VALUES (
				acid, set_account_passwords.account_id
			) ON CONFLICT ON CONSTRAINT pk_account_collection_user DO NOTHING;
			foundac := true;
		ELSE
			DELETE FROM account_collection_account ac 
				WHERE ac.account_collection_id = acid 
				AND ac.account_id = set_account_passwords.account_id;
		END IF;
	END LOOP;
	RETURN _tally;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'account_password_manip' AND type = 'function' AND object IN ('set_account_passwords');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_account_passwords failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
--
-- Process middle (non-trigger) schema approval_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
--
-- Process middle (non-trigger) schema audit
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Process middle (non-trigger) schema auto_ac_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process middle (non-trigger) schema backend_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
--
-- Process middle (non-trigger) schema company_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
--
-- Process middle (non-trigger) schema component_connection_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process middle (non-trigger) schema component_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('component_utils', 'migrate_component_template_slots');
SELECT schema_support.save_grants_for_replay('component_utils', 'migrate_component_template_slots');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS component_utils.migrate_component_template_slots ( integer );
CREATE OR REPLACE FUNCTION component_utils.migrate_component_template_slots(component_id integer)
 RETURNS SETOF jazzhands.slot
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	cid 	ALIAS FOR component_id;
BEGIN
	-- Ensure all of the new slots have appropriate names

	PERFORM component_utils.set_slot_names(
		slot_id_list := ARRAY(
				SELECT s.slot_id FROM slot s WHERE s.component_id = cid
			)
	);

	-- Move everything from the old slot to the new slot if the slot name
	-- and component functions match up, then delete the old slot

	RETURN QUERY
	WITH old_slot AS (
		SELECT
			s.slot_id,
			s.slot_name,
			s.slot_type_id,
			st.slot_function,
			ctst.component_type_slot_template_id
		FROM
			slot s JOIN 
			slot_type st USING (slot_type_id) JOIN
			component c USING (component_id) LEFT JOIN
			component_type_slot_template ctst USING (component_type_slot_template_id)
		WHERE
			s.component_id = cid AND
			ctst.component_type_id IS DISTINCT FROM c.component_type_id
	), new_slot AS (
		SELECT
			s.slot_id,
			s.slot_name,
			s.slot_type_id,
			st.slot_function
		FROM
			slot s JOIN 
			slot_type st USING (slot_type_id) JOIN
			component c USING (component_id) LEFT JOIN
			component_type_slot_template ctst USING (component_type_slot_template_id)
		WHERE
			s.component_id = cid AND
			ctst.component_type_id IS NOT DISTINCT FROM c.component_type_id
	), slot_map AS (
		SELECT
			o.slot_id AS old_slot_id,
			n.slot_id AS new_slot_id
		FROM
			old_slot o JOIN
			new_slot n ON (
				o.slot_name = n.slot_name AND o.slot_function = n.slot_function)
	), slot_1_upd AS (
		UPDATE
			inter_component_connection ic
		SET
			slot1_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot1_id = slot_map.old_slot_id
		RETURNING *
	), slot_2_upd AS (
		UPDATE
			inter_component_connection ic
		SET
			slot2_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot2_id = slot_map.old_slot_id
		RETURNING *
	), prop_upd AS (
		UPDATE
			component_property cp
		SET
			slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot_id = slot_map.old_slot_id
		RETURNING *
	), comp_upd AS (
		UPDATE
			component c
		SET
			parent_slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			parent_slot_id = slot_map.old_slot_id
		RETURNING *
	), l3i_upd AS (
		UPDATE
			layer3_interface l3i
		SET
			slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			l3i.slot_id = slot_map.old_slot_id
		RETURNING *
	), delete_migrated_slots AS (
		DELETE FROM
			slot
		WHERE
			slot_id IN (SELECT old_slot_id FROM slot_map)
		RETURNING *
	), delete_empty_slots AS (
		DELETE FROM
			slot s
		WHERE
			slot_id IN (
				SELECT os.slot_id FROM
					old_slot os LEFT JOIN
					component_property cp ON (os.slot_id = cp.slot_id) LEFT JOIN
					layer3_interface l3i ON (
						l3i.slot_id = os.slot_id OR
						l3i.slot_id = os.slot_id) LEFT JOIN
					inter_component_connection ic ON (
						slot1_id = os.slot_id OR
						slot2_id = os.slot_id) LEFT JOIN
					component c ON (c.parent_slot_id = os.slot_id)
				WHERE
					ic.inter_component_connection_id IS NULL AND
					c.component_id IS NULL AND
					l3i.layer3_interface_id IS NULL AND
					cp.component_property_id IS NULL AND
					os.component_type_slot_template_id IS NOT NULL
			)
	) SELECT s.* FROM slot s JOIN slot_map sm ON s.slot_id = sm.new_slot_id;

	RETURN;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'component_utils' AND type = 'function' AND object IN ('migrate_component_template_slots');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc migrate_component_template_slots failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process middle (non-trigger) schema device_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process middle (non-trigger) schema device_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
--
-- Process middle (non-trigger) schema dns_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_domain_from_cidr');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_domain_from_cidr');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_domain_from_cidr ( inet );
CREATE OR REPLACE FUNCTION dns_utils.add_domain_from_cidr(block inet)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ipaddr		text;
	ipnodes		text[];
	domain		text;
	domain_id	dns_domain.dns_domain_id%TYPE;
	j			text;
BEGIN
	RETURN dns_manip.add_domain_from_cidr(block);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_domain_from_cidr');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_domain_from_cidr failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_domains_from_netblock');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_domains_from_netblock');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_domains_from_netblock ( integer );
CREATE OR REPLACE FUNCTION dns_utils.add_domains_from_netblock(netblock_id integer)
 RETURNS TABLE(dns_domain_id integer, dns_domain_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN

	RETURN QUERY select *
	FROM jsonb_to_recordset(
                        dns_manip.add_domains_from_netblock ( netblock_id )
                ) AS x(dns_domain_id int, dns_domain_name text)
	;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_domains_from_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_domains_from_netblock failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_ns_records');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_ns_records');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_ns_records ( integer,boolean );
CREATE OR REPLACE FUNCTION dns_utils.add_ns_records(dns_domain_id integer, purge boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM dns_manip.add_ns_records(dns_domain_id, purge);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_ns_records');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_ns_records failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'find_dns_domain');
SELECT schema_support.save_grants_for_replay('dns_utils', 'find_dns_domain');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.find_dns_domain ( text );
CREATE OR REPLACE FUNCTION dns_utils.find_dns_domain(fqdn text)
 RETURNS TABLE(dns_name text, dns_domain_name text, dns_domain_id integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF fqdn !~ '^[^.][a-zA-Z0-9_.-]+[^.]$' THEN
		RAISE EXCEPTION '% is not a valid DNS name', fqdn;
	END IF;

	RETURN QUERY SELECT
		regexp_replace(fqdn, '.' || dd.dns_domain_name || '$', '')::text,
		dd.dns_domain_name::text,
		dd.dns_domain_id
	FROM
		dns_domain dd
	WHERE
		fqdn LIKE ('%.' || dd.dns_domain_name)
	ORDER BY
		length(dd.dns_domain_name) DESC
	LIMIT 1;

	RETURN;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('find_dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc find_dns_domain failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_utils', 'find_dns_domain_from_fqdn');
DROP FUNCTION IF EXISTS dns_utils.find_dns_domain_from_fqdn ( text );
CREATE OR REPLACE FUNCTION dns_utils.find_dns_domain_from_fqdn(fqdn text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	IF fqdn !~ '^[^.][a-zA-Z0-9_.-]+[^.]$' THEN
		RAISE EXCEPTION '% is not a valid DNS name', fqdn;
	END IF;

	SELECT
		regexp_replace(fqdn, '\.?' || dd.dns_domain_name || '$', '')::text
			as dns_name,
		dd.dns_domain_name::text,
		dd.dns_domain_id
	INTO _r
	FROM
		dns_domain dd
	WHERE fqdn LIKE ('%.' || dd.dns_domain_name)
	OR fqdn = dd.dns_domain_name
	ORDER BY
		length(dd.dns_domain_name) DESC
	LIMIT 1;

	IF _r IS NULL THEN
		RETURN NULL;
	END IF;

	RETURN to_jsonb(_r);
END;
$function$
;

--
-- Process middle (non-trigger) schema jazzhands
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
--
-- Process middle (non-trigger) schema layerx_network_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('layerx_network_manip', 'delete_layer2_networks');
SELECT schema_support.save_grants_for_replay('layerx_network_manip', 'delete_layer2_networks');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS layerx_network_manip.delete_layer2_networks ( integer[],boolean );
CREATE OR REPLACE FUNCTION layerx_network_manip.delete_layer2_networks(layer2_network_id_list integer[], purge_network_interfaces boolean DEFAULT false)
 RETURNS SETOF jazzhands.layer2_network
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	netblock_id_list	integer[];
BEGIN
	IF array_length(layer2_network_id_list, 1) IS NULL THEN
		RETURN;
	END IF;

	BEGIN
		PERFORM local_hooks.delete_layer2_networks_before_hooks(
			layer2_network_id_list := layer2_network_id_list
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;

	PERFORM layerx_network_manip.delete_layer3_networks(
		layer3_network_id_list := ARRAY(
				SELECT layer3_network_id
				FROM layer3_network l3n
				WHERE layer2_network_id = ANY(layer2_network_id_list)
			),
		purge_network_interfaces :=
			delete_layer2_networks.purge_network_interfaces
	);

	DELETE FROM
		layer2_network_collection_layer2_network l2nc
	WHERE
		l2nc.layer2_network_id = ANY(layer2_network_id_list);

	RETURN QUERY DELETE FROM
		layer2_network l2n
	WHERE
		l2n.layer2_network_id = ANY(layer2_network_id_list)
	RETURNING *;

	BEGIN
		PERFORM local_hooks.delete_layer2_networks_after_hooks(
			layer2_network_id_list := layer2_network_id_list
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;

END $function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'layerx_network_manip' AND type = 'function' AND object IN ('delete_layer2_networks');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc delete_layer2_networks failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('layerx_network_manip', 'delete_layer3_networks');
SELECT schema_support.save_grants_for_replay('layerx_network_manip', 'delete_layer3_networks');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS layerx_network_manip.delete_layer3_networks ( integer[],boolean );
CREATE OR REPLACE FUNCTION layerx_network_manip.delete_layer3_networks(layer3_network_id_list integer[], purge_network_interfaces boolean DEFAULT false)
 RETURNS SETOF jazzhands.layer3_network
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	netblock_id_list			integer[];
	network_interface_id_list	integer[];
BEGIN
	IF array_length(layer3_network_id_list, 1) IS NULL THEN
		RETURN;
	END IF;

	BEGIN
		PERFORM local_hooks.delete_layer3_networks_before_hooks(
			layer3_network_id_list := layer3_network_id_list
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;

	IF (purge_network_interfaces) THEN
		SELECT ARRAY(
			SELECT
				n.netblock_id AS netblock_id
			FROM
				layer3_network l3 JOIN
				netblock p USING (netblock_id) JOIN
				netblock n ON (p.netblock_id = n.parent_netblock_id)
			WHERE
				l3.layer3_network_id = ANY(layer3_network_id_list)
		) INTO netblock_id_list;

		WITH nin_del AS (
			DELETE FROM
				layer3_interface_netblock
			WHERE
				netblock_id = ANY(netblock_id_list)
			RETURNING layer3_interface_id
		), snni_del AS (
			DELETE FROM
				shared_netblock_layer3_interface
			WHERE
				shared_netblock_id IN (
					SELECT shared_netblock_id FROM shared_netblock
					WHERE netblock_id = ANY(netblock_id_list)
				)
			RETURNING layer3_interface_id
		)
		SELECT ARRAY(
			SELECT layer3_interface_id FROM nin_del
			UNION
			SELECT layer3_interface_id FROM snni_del
		) INTO network_interface_id_list;

		DELETE FROM
			layer3_interface_purpose nip
		WHERE
			nip.layer3_interface_id IN (
				SELECT
					layer3_interface_id
				FROM
					layer3_interface ni
				WHERE
					ni.layer3_interface_id = ANY(network_interface_id_list)
						AND
					ni.layer3_interface_id NOT IN (
						SELECT
							layer3_interface_id
						FROM
							layer3_interface_netblock
						UNION
						SELECT
							layer3_interface_id
						FROM
							shared_netblock_layer3_interface
					)
			);

		DELETE FROM
			layer3_interface ni
		WHERE
			ni.layer3_interface_id = ANY(network_interface_id_list) AND
			ni.layer3_interface_id NOT IN (
				SELECT layer3_interface_id FROM layer3_interface_netblock
				UNION
				SELECT layer3_interface_id FROM shared_netblock_layer3_interface
			);
	END IF;

	RETURN QUERY WITH x AS (
		SELECT
			p.netblock_id AS netblock_id,
			l3.layer3_network_id AS layer3_network_id
		FROM
			layer3_network l3 JOIN
			netblock p USING (netblock_id)
		WHERE
			l3.layer3_network_id = ANY(layer3_network_id_list)
	), l3_coll_del AS (
		DELETE FROM
			layer3_network_collection_layer3_network
		WHERE
			layer3_network_id IN (SELECT layer3_network_id FROM x)
	), l3_del AS (
		DELETE FROM
			layer3_network
		WHERE
			layer3_network_id in (SELECT layer3_network_id FROM x)
		RETURNING *
	), nb_sel AS (
		SELECT
			n.netblock_id
		FROM
			netblock n JOIN
			x ON (n.parent_netblock_id = x.netblock_id)
	), dns_del AS (
		DELETE FROM
			dns_record
		WHERE
			netblock_id IN (SELECT netblock_id FROM nb_sel)
	), nbc_del as (
		DELETE FROM
			netblock_collection_netblock
		WHERE
			netblock_id IN (SELECT netblock_id FROM x
				UNION SELECT netblock_id FROM nb_sel)
	), nb_del as (
		DELETE FROM
			netblock
		WHERE
			netblock_id IN (SELECT netblock_id FROM nb_sel)
	), sn_del as (
		DELETE FROM
			shared_netblock
		WHERE
			netblock_id IN (SELECT netblock_id FROM nb_sel)
	), nrp_del as (
		DELETE FROM
			property
		WHERE
			network_range_id IN (
				SELECT
					network_range_id
				FROM
					network_range nr JOIN
					x ON (nr.parent_netblock_id = x.netblock_id)
			)
	), nr_del as (
		DELETE FROM
			network_range
		WHERE
			parent_netblock_id IN (SELECT netblock_id FROM x)
		RETURNING
			start_netblock_id, stop_netblock_id
	), nrnb_del AS (
		DELETE FROM
			netblock
		WHERE
			netblock_id IN (
				SELECT start_netblock_id FROM nr_del
				UNION
				SELECT stop_netblock_id FROM nr_del
		)
	), nbd AS (
		DELETE FROM
			netblock
		WHERE
			netblock_id IN (SELECT netblock_id FROM x)
	)
	SELECT * FROM l3_del;

	BEGIN
		PERFORM local_hooks.delete_layer3_networks_after_hooks(
			layer3_network_id_list := layer3_network_id_list
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;
	RETURN;
END $function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'layerx_network_manip' AND type = 'function' AND object IN ('delete_layer3_networks');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc delete_layer3_networks failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process middle (non-trigger) schema logical_port_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process middle (non-trigger) schema lv_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process middle (non-trigger) schema net_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process middle (non-trigger) schema netblock_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('netblock_manip', 'set_interface_addresses');
SELECT schema_support.save_grants_for_replay('netblock_manip', 'set_interface_addresses');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS netblock_manip.set_interface_addresses ( integer,integer,text,text,jsonb,boolean,text,text );
CREATE OR REPLACE FUNCTION netblock_manip.set_interface_addresses(network_interface_id integer DEFAULT NULL::integer, device_id integer DEFAULT NULL::integer, network_interface_name text DEFAULT NULL::text, network_interface_type text DEFAULT 'broadcast'::text, ip_address_hash jsonb DEFAULT NULL::jsonb, create_layer3_networks boolean DEFAULT false, move_addresses text DEFAULT 'if_same_device'::text, address_errors text DEFAULT 'error'::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN netblock_manip.set_layer3_interface_addresses(
		layer3_interface_id := network_interface_id,
		device_id := device_id,
		layer3_interface_name := network_interface_name,
		layer3_interface_type := network_interface_type,
		ip_address_hash := ip_address_hash,
		create_layer3_networks := create_layer3_networks,
		move_addresses := move_addresses,
		address_errors := address_errors
	);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'netblock_manip' AND type = 'function' AND object IN ('set_interface_addresses');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_interface_addresses failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process middle (non-trigger) schema netblock_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('netblock_utils', 'find_best_parent_id');
SELECT schema_support.save_grants_for_replay('netblock_utils', 'find_best_parent_id');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS netblock_utils.find_best_parent_id ( inet,integer,character varying,integer,text,integer,boolean,boolean,boolean );
CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_id(in_ipaddress inet, in_netmask_bits integer DEFAULT NULL::integer, in_netblock_type character varying DEFAULT 'default'::character varying, in_ip_universe_id integer DEFAULT 0, in_is_single_address text DEFAULT 'N'::text, in_netblock_id integer DEFAULT NULL::integer, in_fuzzy_can_subnet boolean DEFAULT false, can_fix_can_subnet boolean DEFAULT false, will_soon_be_dropped boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	p_single	BOOLEAN;
BEGIN
	IF in_is_single_address = 'Y' THEN
		p_single := true;
	ELSE
		p_single := false;
	END IF;

	RETURN netblock_utils.find_best_parent_netblock_id(
		ip_address			:= in_IpAddress,
		netmask_bits		:= in_Netmask_Bits,
		netblock_type		:= in_netblock_type,
		ip_universe_id		:= in_ip_universe_id,
		is_single_address	:= p_single,
		netblock_id			:= in_netblock_id,
		fuzzy_can_subnet	:= in_fuzzy_can_subnet,
		can_fix_can_subnet	:= can_fix_can_subnet
	);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'netblock_utils' AND type = 'function' AND object IN ('find_best_parent_id');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc find_best_parent_id failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('netblock_utils', 'find_best_parent_netblock_id');
SELECT schema_support.save_grants_for_replay('netblock_utils', 'find_best_parent_netblock_id');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS netblock_utils.find_best_parent_netblock_id ( inet,integer,character varying,integer,boolean,integer,boolean,boolean );
CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_netblock_id(ip_address inet, netmask_bits integer DEFAULT NULL::integer, netblock_type character varying DEFAULT 'default'::character varying, ip_universe_id integer DEFAULT 0, is_single_address boolean DEFAULT false, netblock_id integer DEFAULT NULL::integer, fuzzy_can_subnet boolean DEFAULT false, can_fix_can_subnet boolean DEFAULT false)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	par_nbid	netblock.netblock_id%type;
BEGIN
	IF (netmask_bits IS NOT NULL) THEN
		ip_address  := set_masklen(ip_address, netmask_bits);
	END IF;

	select  subq.Netblock_Id
	  into	par_nbid
	  from  ( select n.Netblock_Id, n.Ip_Address
		    from netblock n
		   where
		   	find_best_parent_netblock_id.ip_address <<= n.ip_address
		    and n.is_single_address = false
			and n.netblock_type = find_best_parent_netblock_id.netblock_type
			and n.ip_universe_id = find_best_parent_netblock_id.ip_universe_id
		    and (
				(find_best_parent_netblock_id.is_single_address = false AND
					masklen(n.ip_address) < masklen(find_best_parent_netblock_id.ip_address))
				OR
				(find_best_parent_netblock_id.is_single_address = true AND
					can_subnet = false AND
					(find_best_parent_netblock_id.Netmask_Bits IS NULL
						OR masklen(n.ip_address) =
							netmask_bits))
			)
			and (find_best_parent_netblock_id.netblock_id IS NULL OR
				n.netblock_id != find_best_parent_netblock_id.netblock_id)
		order by masklen(n.ip_address) desc
	) subq LIMIT 1;

	IF par_nbid IS NULL
		AND find_best_parent_netblock_id.is_single_address = true
		AND fuzzy_can_subnet
	THEN
		select  subq.Netblock_Id
		  into	par_nbid
		  from  ( select n.Netblock_Id, n.Ip_Address
			    from netblock n
			   where
			   	find_best_parent_netblock_id.ip_address <<= n.ip_address
			    and n.is_single_address = false
				and n.netblock_type = find_best_parent_netblock_id.netblock_type
				and n.ip_universe_id = find_best_parent_netblock_id.ip_universe_id
			    and
					(find_best_parent_netblock_id.is_single_address = true AND can_subnet = 'Y' AND
						(netmask_bits IS NULL
							OR masklen(n.ip_address) = netmask_bits))
				and (find_best_parent_netblock_id.netblock_id IS NULL OR
					n.netblock_id != find_best_parent_netblock_id.netblock_id)
				and n.netblock_id not IN (
					select p.parent_netblock_id from netblock p
						where p.is_single_address = false
						and p.parent_netblock_id is not null
				)
			order by masklen(n.ip_address) desc
		) subq LIMIT 1;

		IF can_fix_can_subnet AND par_nbid IS NOT NULL THEN
			UPDATE netblock n SET can_subnet = false
			WHERE  n.netblock_id = par_nbid;
		END IF;
	END IF;


	return par_nbid;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'netblock_utils' AND type = 'function' AND object IN ('find_best_parent_netblock_id');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc find_best_parent_netblock_id failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process middle (non-trigger) schema network_strings
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process middle (non-trigger) schema obfuscation_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('obfuscation_utils', 'deobfuscate_text');
SELECT schema_support.save_grants_for_replay('obfuscation_utils', 'deobfuscate_text');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS obfuscation_utils.deobfuscate_text ( text,text,text );
CREATE OR REPLACE FUNCTION obfuscation_utils.deobfuscate_text(encoded text, type text, label text DEFAULT 'default'::text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	_key	BYTEA;
	_de	BYTEA;
	_iv	BYTEA;
	_enc	BYTEA;
	_parts	TEXT[];
	_len	INTEGER;
BEGIN
	_key := obfuscation_utils.get_session_secret(label)::text;
	IF type = 'base64' THEN
		RETURN decode(encoded, 'base64');
	ELSIF type ~ '^pgp' THEN
		IF  type = 'pgp+base64' THEN
			--
			-- not using armor because of compatablity issues with 
			-- Crypt::OpenPGP armoring that I gave up on.
			--
			encoded := decode(encoded, 'base64');
		END IF;
		IF _key IS NULL THEN
			RAISE EXCEPTION 'pgp requries setup';
		END IF;
		_de := pgcrypto.pgp_sym_decrypt_bytea(encoded::bytea, _key::text);
		RETURN encode(_de, 'escape');
	ELSIF type = 'none' THEN
		RETURN encoded;
	ELSIF type ~ 'cbc/pad:pkcs' THEN
		_parts := regexp_matches(encoded, '^([^-]+)-(.+)$');
		_iv := decode(_parts[1], 'base64');
		_enc := decode(_parts[2], 'base64');

		_de := pgcrypto.decrypt_iv(_enc::bytea, _key, _iv, type);
		RETURN encode(_de, 'escape');
	ELSE
		RAISE EXCEPTION 'unknown decryption type %', type
			USING ERRCODE = invalid_parameter;
	END IF;
	RETURN NULL;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'obfuscation_utils' AND type = 'function' AND object IN ('deobfuscate_text');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc deobfuscate_text failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process middle (non-trigger) schema person_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process middle (non-trigger) schema pgcrypto
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process middle (non-trigger) schema physical_address_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process middle (non-trigger) schema port_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process middle (non-trigger) schema rack_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process middle (non-trigger) schema schema_support
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'build_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'build_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.build_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, first_time boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	name_base	TEXT;
BEGIN
	BEGIN
	EXECUTE 'CREATE SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq');
	EXCEPTION WHEN duplicate_table THEN
		NULL;
	END;

	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| $$ ALTER COLUMN "aud#seq" SET NOT NULL, $$
		|| $$ ALTER COLUMN "aud#seq" SET DEFAULT nextval('$$
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name || '_seq')
		|| $$')$$;

	EXECUTE 'ALTER SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq') || ' OWNED BY '
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name)
		|| '.' || quote_ident('aud#seq');


	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident( table_name )
		|| ' ADD PRIMARY KEY ("aud#seq")';

	PERFORM schema_support.rebuild_audit_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('build_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc build_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'end_maintenance');
SELECT schema_support.save_grants_for_replay('schema_support', 'end_maintenance');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.end_maintenance ( integer,integer,boolean );
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(minnumdiff integer DEFAULT 0, minpercent integer DEFAULT 0, skipchecks boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || _myrole;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in begin_maintenance (the INSERT query is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;

	DROP TABLE IF EXISTS __owner_before_stats;
	DROP TABLE IF EXISTS __owner_after_stats;
	RETURN true;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('end_maintenance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc end_maintenance failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, finish_rebuild boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__t' || table_name);


	--
	-- RENAME sequence
	--
	EXECUTE 'ALTER SEQUENCE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq')
		|| ' RENAME TO '
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- fix sequence primary key to have the correct next value
	--
	EXECUTE 'SELECT max("aud#seq") + 1 FROM	 '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('__old__t' || table_name) INTO seq;
	IF seq IS NOT NULL THEN
		EXECUTE 'ALTER SEQUENCE '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident(table_name || '_seq')
			|| ' RESTART WITH ' || seq;
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table_finish');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table_finish');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table_finish ( character varying,character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table_finish(aud_schema character varying, tbl_schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	cols	text[];
	i	text;
	_t	text;
BEGIN
	_t := regexp_replace(rpad(quote_ident('__old__t' || table_name), 63), ' *$', '');
	--
	-- get columns - XXX NOTE:  Need to remove columns not in the new
	-- table...
	--
	SELECT	array_agg(quote_ident(a.attname) ORDER BY a.attnum)
	INTO	cols
	FROM	pg_catalog.pg_attribute a
	INNER JOIN pg_catalog.pg_class c on a.attrelid = c.oid
	INNER JOIN pg_catalog.pg_namespace n on n.oid = c.relnamespace
	LEFT JOIN pg_catalog.pg_description d
			on d.objoid = a.attrelid
			and d.objsubid = a.attnum
	WHERE   n.nspname = quote_ident(aud_schema)
	  AND	c.relname = _t
	  AND	a.attnum > 0
	  AND	NOT a.attisdropped
	;

	IF cols IS NULL THEN
		RAISE EXCEPTION 'Unable to get columns from "%.%"',
			quote_ident(aud_schema), _t;
	END IF;

	EXECUTE 'INSERT INTO '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' ( '
		|| array_to_string(cols, ',') || ' ) SELECT '
		|| array_to_string(cols, ',') || ' FROM '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name)
		|| ' ORDER BY '
		|| quote_ident('aud#seq');


	EXECUTE 'DROP TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__t' || table_name);

	--
	-- drop audit sequence, in case it was not dropped with table.
	--
	EXECUTE 'DROP SEQUENCE IF EXISTS '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('_old_s' || table_name || '_seq');

	--
	-- drop indexes found before that did not get dropped.
	--
	FOR i IN SELECT	c2.relname
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident('__old__' || table_name)
		  AND	contype is NULL
	LOOP
		EXECUTE 'DROP INDEX '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('_' || i);
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table_finish');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table_finish failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_tables');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_tables');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_tables ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_tables(aud_schema character varying, tbl_schema character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		_tags := ARRAY[concat('rebuild_audit_tables_', aud_schema, '_', table_list.table_name)];
		PERFORM schema_support.save_dependent_objects_for_replay(
			schema := aud_schema::varchar,
			object := table_list.table_name::varchar,
			tags:= _tags);
		PERFORM schema_support.save_grants_for_replay(schema := aud_schema,
			object := table_list.table_name,
			tags := _tags);
		PERFORM schema_support.rebuild_audit_table
			( aud_schema, tbl_schema, table_list.table_name );
		PERFORM schema_support.replay_object_recreates(tags := _tags);
		PERFORM schema_support.replay_saved_grants(tags := _tags);
		END LOOP;

	PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_tables');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_tables failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'relation_diff');
SELECT schema_support.save_grants_for_replay('schema_support', 'relation_diff');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.relation_diff ( text,text,text,text,text[],boolean );
CREATE OR REPLACE FUNCTION schema_support.relation_diff(schema text, old_rel text, new_rel text, key_relation text DEFAULT NULL::text, prikeys text[] DEFAULT NULL::text[], raise_exception boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_t1		integer;
	_t2		integer;
	_cnt	integer;
	_cols	TEXT[];
	_pkcol	TEXT[];
	_q		TEXT;
	_f		TEXT;
	_c		RECORD;
	_w		TEXT[];
	_ctl		TEXT[];
	_rv	boolean;
	_oj		jsonb;
	_nj		jsonb;
	_oldschema	TEXT;
	_newschema	TEXT;
    _tmpschema	TEXT;
BEGIN
	SELECT nspname
		INTO _tmpschema
		FROM pg_namespace
		WHERE oid = pg_my_temp_schema();

	--
	-- validate that both old and new tables exist.  This has support for
	-- temporary tabels on either end, which kind of ignore schema.
	--
	IF old_rel ~ '\.' THEN
		_oldschema := regexp_replace(old_rel, '\..*$', '');
		old_rel := regexp_replace(old_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, old_rel;
		IF _t1 = 1 THEN
			_oldschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, old_rel;
			IF _t1 = 1 THEN
				_oldschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, old_rel;
			END IF;
		END IF;
	END IF;
	IF new_rel ~ '\.' THEN
		_newschema := regexp_replace(new_rel, '\..*$', '');
		new_rel := regexp_replace(new_rel, '^[^\.]*\.', '');
	ELSE
		EXECUTE 'SELECT count(*)
			FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE nspname = $1 AND relname = $2'
			INTO _t1 USING schema, new_rel;
		IF _t1 = 1 THEN
			_newschema:= schema;
		ELSE
			EXECUTE 'SELECT count(*)
				FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE nspname = $1 AND relname = $2'
				INTO _t1 USING _tmpschema, new_rel;
			IF _t1 = 1 THEN
				_newschema:= _tmpschema;
			ELSE
				RAISE EXCEPTION 'table %.% does not seem to exist', _schema, new_rel;
			END IF;
		END IF;
	END IF;

	--
	-- at this point, the proper schemas have been figured out.
	--

	RAISE NOTICE '% % % %', _oldschema, old_rel, _newschema, new_rel;

	-- do a simple row count
	EXECUTE format('SELECT count(*) FROM %s.%s', _oldschema, old_rel) INTO _t1;
	EXECUTE format('SELECT count(*) FROM %s.%s', _newschema, new_rel) INTO _t2;

	_rv := true;

	IF _t1 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, old_rel;
		_rv := false;
	END IF;
	IF _t2 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, new_rel;
		_rv := false;
	END IF;

	IF prikeys IS NULL THEN
		-- read into prikeys the primary key for the table
		IF key_relation IS NULL THEN
			key_relation := old_rel;
		END IF;
		prikeys := schema_support.get_pk_columns(_oldschema, key_relation);
	END IF;

	-- read into _cols the column list in common between old_rel and new_rel
	_cols := schema_support.get_common_columns(_oldschema, old_rel, _newschema, new_rel);

	_ctl := NULL;
	FOREACH _f IN ARRAY prikeys
	LOOP
		SELECT array_append(_ctl, quote_ident(_f) ) INTO _ctl;
	END LOOP;
	_pkcol := _ctl;

	--
	-- Number of rows mismatch.  Show the missing rows based on the
	-- primary key.
	--
	IF _t1 != _t2 THEN
		RAISE NOTICE 'table % has % rows; table % has % rows (%)', old_rel, _t1, new_rel, _t2, _t1 - _t2;
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InOld/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InNew/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	IF NOT _rv THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Relations do not match';
		END IF;
		RETURN false;
	END IF;

	-- At this point, the same number of rows appear in both, so need to
	-- figure out rows that are different between them.

	-- SELECT row_to_json(o) as old, row_to_json(n) as new
	-- FROM ( SELECT cols FROM old WHERE prikeys in Vv ) old,
	-- JOIN ( SELECT cols FROM new WHERE prikeys in Vv ) new
	-- USING (prikeys);
	-- WHERE (prikeys) IN
	-- ( SELECT  prikeys FROM (
	--		( SELECT cols FROM old EXCEPT ( SELECT cols FROM new ) )
	-- ))

	_q := ' SELECT row_to_json(old) as old, row_to_json(new) as new FROM ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel) || ' ) old ' ||
		' JOIN ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' ) new ' ||
		' USING ( ' ||  array_to_string(_pkcol,',') ||
		' ) WHERE (' || array_to_string(_pkcol,',') || ' ) IN (' ||
		'SELECT ' || array_to_string(_pkcol,',')  || ' FROM ( ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel) ||
			' EXCEPT ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' )) ' ||
		' ) subq) ORDER BY ' || array_to_string(_pkcol,',')
	;

	_t1 := 0;
	FOR _r IN EXECUTE _q
	LOOP
		_t1 := _t1 + 1;
		FOR _f IN SELECT json_object_keys(_r.new)
		LOOP
			IF _f = ANY ( prikeys ) OR _r.old->>_f IS DISTINCT FROM _r.new->>_f
			THEN
				IF _oj IS NULL THEN
					_oj := jsonb_build_object(_f, _r.old->>_f);
					_nj := jsonb_build_object(_f, _r.new->>_f);
				ELSE
					_oj := _oj || jsonb_build_object(_f, _r.old->>_f);
					_nj := _nj || jsonb_build_object(_f, _r.new->>_f);
				END IF;
			END IF;
		END LOOP;
		RAISE NOTICE 'mismatched row:';
		RAISE NOTICE 'OLD: %', _oj;
		RAISE NOTICE 'NEW: %', _nj;
		_rv := false;
	END LOOP;


	IF NOT _rv AND raise_exception THEN
		RAISE EXCEPTION 'Relations do not match (% rows)', _t1;
	ELSE
		RAISE NOTICE '% rows mismatch', _t1;
	END IF;
	return _rv;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('relation_diff');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc relation_diff failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'replay_saved_grants ( boolean,text,text )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.replay_saved_grants ( boolean,text,text );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'reset_table_sequence');
SELECT schema_support.save_grants_for_replay('schema_support', 'reset_table_sequence');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.reset_table_sequence ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence(schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		WITH s AS (
			SELECT	pg_get_serial_sequence(nspname||'.'||relname,
				a.attname) as seq, a.attname as column
			FROM	pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE	c.relname = table_name
			AND	n.nspname = schema
				AND	a.attnum > 0
				AND	NOT a.attisdropped
		) SELECT s.*, nextval(s.seq) as nv FROM s WHERE seq IS NOT NULL
	LOOP
		EXECUTE 'SELECT max('||quote_ident(_r.column)||')+1 FROM  '
			|| quote_ident(schema)||'.'||quote_ident(table_name)
			INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE 'ALTER SEQUENCE ' || _r.seq || ' RESTART WITH '
				|| m;
		END IF;
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('reset_table_sequence');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc reset_table_sequence failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_constraint_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_constraint_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_constraint_for_replay ( character varying,character varying,boolean,character varying,jsonb,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, newobject character varying DEFAULT NULL::character varying, newmap jsonb DEFAULT NULL::jsonb, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
			pg_get_constraintdef(otherside.oid, true) AS def,
			otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
			myside.nspname as mynspname, myside.relname as myrelname,
			myside.cols as mycols, myside.conname as myconname
		FROM
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY confkey) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey,
					unnest(confkey) as confkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) otherside JOIN
			(
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
				SELECT con.*, a.attname, a.attnum
				FROM
					( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
					) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
			) myside ON myside.conrelid = otherside.confrelid
				AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY IMMEDIATE';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_constraint_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_constraint_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_trigger_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_trigger_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_trigger_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
		AND NOT tgisinternal
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_trigger_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_trigger_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_view_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_view_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_view_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object) ||
					'.' || quote_ident(_c.colname) ||
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_view_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_view_for_replay failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.check_schema_version(version text, schema text DEFAULT NULL::text, raise_exception boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_schema	ALIAS FOR schema;
	in_version	ALIAS FOR version;
	chk_schema	TEXT;
	s_version	TEXT;
	exist		INTEGER[];
	want		INTEGER[];
	i			INTEGER;
BEGIN
	s_version := schema_support.get_schema_version(
		schema := in_schema,
		raise_exception := raise_exception
	);

	IF s_version IS NULL  THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Could not find version'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = 'This should not happen';
		END IF;
		RETURN false;
	END IF;

	-- thx http://sqlfiddle.com/#!15/0d32c/2/0 via stackoverflow
	-- doesn't handle text labels super well, but patches welcome
	exist := regexp_split_to_array(regexp_replace(s_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];
	want := regexp_split_to_array(regexp_replace(in_version, '[^0-9.]+',
		'', 'g'), '[-:\.]')::int[];

	--
	-- NOTE:  this does not (yet) handle software versions well, since it
	-- cosniders :, ., - to all be the same demiter, so they need the
	-- same number of elements.  Don't let the perfect be the enemy of the
	-- good, although I'm sure that sentiment will come back to bite me.
	--

	RETURN exist >= want;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.get_schema_version(schema text DEFAULT NULL::text, raise_exception boolean DEFAULT true)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_schema	ALIAS FOR schema;
	chk_schema	TEXT;
	_sp			TEXT;
	s_version	TEXT;
BEGIN
	IF in_schema IS NOT NULL THEN
		chk_schema := in_schema;
	ELSE
		SHOW search_path INTO _sp;
		_sp := regexp_replace(_sp, ',.*$', '');
		PERFORM *
		FROM	pg_namespace
		WHERE	nspname = _sp;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'Unable to discern schema to check'
				USING ERRCODE = 'invalid_schema_name';
		END IF;
		chk_schema := _sp;
	END IF;

	BEGIN
		SELECT version
		INTO s_version
		FROM schema_support.schema_version
		WHERE schema_version.schema = chk_schema;
	EXCEPTION WHEN undefined_table THEN
		IF raise_exception THEN
			RAISE EXCEPTION '%', SQLERRM
				USING ERRCODE = SQLSTATE,
				HINT = 'Version has likely not been set';
		END IF;
	END;

	RETURN s_version;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.rebuild_all_audit_indexes(aud_schema character varying, tbl_schema character varying, beverbose boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	table_list RECORD;
	_tags		text[];
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		IF beverbose THEN
			RAISE NOTICE '>> Processing ancillary indexes on %.%', aud_schema, table_list.table_name;
		END IF;
		PERFORM schema_support.rebuild_audit_indexes(
			aud_schema := aud_schema,
			tbl_schema := tbl_schema,
			table_name := table_list.table_name
		);
	END LOOP;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_indexes(aud_schema character varying, tbl_schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r	RECORD;
	sch	TEXT;
	name_base	TEXT;
BEGIN
	FOR _r IN
		SELECT c2.relname, pg_get_indexdef(i.indexrelid) as def, con.contype
			FROM pg_catalog.pg_class c
				INNER JOIN pg_namespace n ON relnamespace = n.oid
				INNER JOIN pg_catalog.pg_index i ON c.oid = i.indrelid
				INNER JOIN pg_catalog.pg_class c2 ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_constraint con ON
				(con.conrelid = i.indrelid AND con.conindid = i.indexrelid )
			WHERE c.relname =  table_name
			AND	  n.nspname = aud_schema
			AND	(contype IS NULL OR contype NOT IN ('p','u'))
	LOOP
		EXECUTE format('DROP INDEX %s.%s',
		quote_ident(aud_schema), quote_ident(_r.relname));
	END LOOP;

	name_base := quote_ident( table_name );
	-- 17 is length of _aud#timestmp_idx
	-- md5 is just to make the name unique
	IF char_length(name_base) > 64 - 17 THEN
		-- using lpad as a truncate
		name_base := 'aud_' || lpad(md5(table_name), 10) || lpad(table_name, 64 - 19 - 10 );
	END IF;

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#timestamp_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#timestamp")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#realtime_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#realtime")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( name_base || '_aud#txid_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#txid")';


	PERFORM schema_support.build_audit_table_pkak_indexes(
		aud_schema := aud_schema,
		tbl_schema := tbl_schema,
		table_name := table_name
	);
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(beverbose boolean DEFAULT false, schema text DEFAULT NULL::text, tags text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.set_schema_version(version text, schema text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	in_version	ALIAS FOR version;
	in_schema	ALIAS FOR schema;
	_sp			TEXT;
BEGIN
	-- Make sure that the tracking table exists
	BEGIN
		PERFORM count(*)
		FROM schema_support.schema_version v
		WHERE v.schema = in_schema;
	EXCEPTION WHEN undefined_table THEN
		CREATE TABLE schema_support.schema_version (
			schema	TEXT,
			version	TEXT,
			CONSTRAINT schema_version_pkey PRIMARY KEY (schema)
		);
	END;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Unknown schema %', in_schema
			USING ERRCODE = 'invalid_schema_name';
	END IF;

	INSERT INTO schema_support.schema_version (
		schema, version
	) VALUES (
		in_schema, in_version
	) ON CONFLICT ON CONSTRAINT schema_version_pkey DO UPDATE
		SET version = in_version
		WHERE schema_version.schema = in_schema
	;
END;
$function$
;

--
-- Process middle (non-trigger) schema script_hooks
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process middle (non-trigger) schema snapshot_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process middle (non-trigger) schema time_util
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process middle (non-trigger) schema token_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
--
-- Process middle (non-trigger) schema jazzhands_legacy
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
--
-- Process middle (non-trigger) schema component_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_manip']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'create_component_template_slots');
DROP FUNCTION IF EXISTS component_manip.create_component_template_slots ( integer );
CREATE OR REPLACE FUNCTION component_manip.create_component_template_slots(component_id integer)
 RETURNS SETOF jazzhands.slot
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ctid	jazzhands.component_type.component_type_id%TYPE;
	s		jazzhands.slot%ROWTYPE;
	cid 	ALIAS FOR component_id;
BEGIN
	FOR s IN
		INSERT INTO jazzhands.slot (
			component_id,
			slot_name,
			slot_type_id,
			slot_index,
			component_type_slot_template_id,
			physical_label,
			slot_x_offset,
			slot_y_offset,
			slot_z_offset,
			slot_side
		) SELECT
			cid,
			ctst.slot_name_template,
			ctst.slot_type_id,
			ctst.slot_index,
			ctst.component_type_slot_template_id,
			ctst.physical_label,
			ctst.slot_x_offset,
			ctst.slot_y_offset,
			ctst.slot_z_offset,
			ctst.slot_side
		FROM
			component_type_slot_template ctst JOIN
			component c USING (component_type_id) LEFT JOIN
			slot ON (slot.component_id = cid AND
				slot.component_type_slot_template_id =
				ctst.component_type_slot_template_id
			)
		WHERE
			c.component_id = cid AND
			slot.component_type_slot_template_id IS NULL
		ORDER BY ctst.component_type_slot_template_id
		RETURNING *
	LOOP
		RAISE DEBUG 'Creating slot for component % from template %',
			cid, s.component_type_slot_template_id;
		RETURN NEXT s;
	END LOOP;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'fetch_component');
DROP FUNCTION IF EXISTS component_manip.fetch_component ( integer,text,boolean,text,integer );
CREATE OR REPLACE FUNCTION component_manip.fetch_component(component_type_id integer, serial_number text, no_create boolean DEFAULT false, ownership_status text DEFAULT 'unknown'::text, parent_slot_id integer DEFAULT NULL::integer)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ctid		ALIAS FOR component_type_id;
	sn			ALIAS FOR serial_number;
	psid		ALIAS FOR parent_slot_id;
	os			ALIAS FOR ownership_status;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF sn IS NOT NULL THEN
		SELECT 
			comp.* INTO c
		FROM
			component comp JOIN
			asset a USING (component_id)
		WHERE
			comp.component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			--
			-- Only update the parent slot if it isn't set already
			--
			IF c.parent_slot_id IS NULL THEN
				UPDATE
					component comp
				SET
					parent_slot_id = psid
				WHERE
					comp.component_id = c.component_id;
			END IF;
			RETURN c;
		END IF;
	END IF;

	IF no_create THEN
		RETURN NULL;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id,
		parent_slot_id
	) VALUES (
		ctid,
		parent_slot_id
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			os
		);
	END IF;

	RETURN c;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'insert_component_into_parent_slot');
DROP FUNCTION IF EXISTS component_manip.insert_component_into_parent_slot ( integer,integer,text,text,text,integer,text );
CREATE OR REPLACE FUNCTION component_manip.insert_component_into_parent_slot(parent_component_id integer, component_id integer, slot_name text, slot_function text, slot_type text DEFAULT 'unknown'::text, slot_index integer DEFAULT NULL::integer, physical_label text DEFAULT NULL::text)
 RETURNS jazzhands.slot
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	pcid 	ALIAS FOR parent_component_id;
	cid		ALIAS FOR component_id;
	sf		ALIAS FOR slot_function;
	sn		ALIAS FOR slot_name;
	st		ALIAS FOR slot_type;
	s		RECORD;
	stid	integer;
BEGIN
	--
	-- Look for this slot assigned to the component
	--
	SELECT
		slot.* INTO s
	FROM
		slot JOIN
		slot_type USING (slot_type_id)
	WHERE
		slot.component_id = pcid AND
		slot_type.slot_type = st AND
		slot_type.slot_function = sf AND
		slot.slot_name = sn;

	IF NOT FOUND THEN
		RAISE DEBUG 'Auto-creating slot for component assignment';
		SELECT
			slot_type_id INTO stid
		FROM
			slot_type
		WHERE
			slot_type.slot_type = st AND
			slot_type.slot_function = sf;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type %, function % not found adding component_type',
				st,
				sf
				USING ERRCODE = 'JH501';
		END IF;

		INSERT INTO slot (
			component_id,
			slot_name,
			slot_index,
			slot_type_id,
			physical_label,
			description
		) VALUES (
			pcid,
			sn,
			slot_index,
			stid,
			physical_label,
			'autocreated component slot'
		) RETURNING * INTO s;
	END IF;

	RAISE DEBUG 'Assigning component with component_id % to slot %',
		cid, s.slot_id;

	UPDATE 
		component c
	SET
		parent_slot_id = s.slot_id
	WHERE
		c.component_id = cid;

	RETURN s;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'insert_cpu_component');
DROP FUNCTION IF EXISTS component_manip.insert_cpu_component ( text,bigint,bigint,text,text,text,boolean );
CREATE OR REPLACE FUNCTION component_manip.insert_cpu_component(model text, processor_speed bigint, processor_cores bigint, socket_type text, vendor_name text DEFAULT NULL::text, serial_number text DEFAULT NULL::text, virtual_component boolean DEFAULT false)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company.company_id INTO cid
		FROM
			company JOIN
			company_collection_company ccc using (company_id) JOIN
			company_collection cc using (company_collection_id) JOIN
			property p USING (company_collection_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorCPUProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		ct.component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id) JOIN
		component_property cp ON (
			ct.component_type_id = cp.component_type_id AND
			cp.component_property_type = 'CPU' AND
			cp.component_property_name = 'ProcessorCores' AND
			cp.property_value::integer = processor_cores
		)
	WHERE
		ctcf.component_function = 'CPU' AND
		ct.model = m AND
		ct.is_virtual_component = virtual_component AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = socket_type AND
			slot_function = 'CPU';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type %, function % not found adding component_type',
				socket_type,
				'CPU'
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description,
			is_virtual_component
		) VALUES (
			cid,
			model,
			stid,
			true,
			model,
			virtual_component
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the CPU
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('ProcessorCores', 'CPU', ctid, processor_cores),
			('ProcessorSpeed', 'CPU', ctid, processor_speed);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['CPU']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'insert_disk_component');
DROP FUNCTION IF EXISTS component_manip.insert_disk_component ( text,bigint,text,text,text,text );
CREATE OR REPLACE FUNCTION component_manip.insert_disk_component(model text, bytes bigint, vendor_name text DEFAULT NULL::text, protocol text DEFAULT 'SATA'::text, media_type text DEFAULT 'Rotational'::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company_id INTO cid
		FROM
			company c LEFT JOIN
			property p USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorDiskProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id)
	WHERE
		component_function = 'disk' AND
		ct.model = m AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = protocol AND
			slot_function = 'disk';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function disk not found adding component_type',
				protocol
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			cid,
			model,
			stid,
			true,
			concat_ws(' ', vendor_name, model, media_type, 'disk')
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the disk
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('DiskSize', 'disk', ctid, bytes),
			('DiskProtocol', 'disk', ctid, protocol),
			('MediaType', 'disk', ctid, media_type);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['storage', 'disk']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;

END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'insert_memory_component');
DROP FUNCTION IF EXISTS component_manip.insert_memory_component ( text,bigint,bigint,text,text,text );
CREATE OR REPLACE FUNCTION component_manip.insert_memory_component(model text, memory_size bigint, memory_speed bigint, memory_type text DEFAULT 'DDR3'::text, vendor_name text DEFAULT NULL::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company_id INTO cid
		FROM
			company c LEFT JOIN
			property p USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorMemoryProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id)
	WHERE
		component_function = 'memory' AND
		ct.model = m AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = memory_type AND
			slot_function = 'memory';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function memory not found adding component_type',
				memory_type
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			cid,
			model,
			stid,
			true,
			concat_ws(' ', vendor_name, model, (memory_size || 'MB'), 'memory')
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the memory
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('MemorySize', 'memory', ctid, memory_size),
			('MemorySpeed', 'memory', ctid, memory_speed);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['memory']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'insert_pci_component');
DROP FUNCTION IF EXISTS component_manip.insert_pci_component ( integer,integer,integer,integer,text,text,text,text,text[],text,text );
CREATE OR REPLACE FUNCTION component_manip.insert_pci_component(pci_vendor_id integer, pci_device_id integer, pci_sub_vendor_id integer DEFAULT NULL::integer, pci_subsystem_id integer DEFAULT NULL::integer, pci_vendor_name text DEFAULT NULL::text, pci_device_name text DEFAULT NULL::text, pci_sub_vendor_name text DEFAULT NULL::text, pci_sub_device_name text DEFAULT NULL::text, component_function_list text[] DEFAULT NULL::text[], slot_type text DEFAULT 'unknown'::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	sn			ALIAS FOR serial_number;
	ctid		integer;
	comp_id		integer;
	sub_comp_id	integer;
	stid		integer;
	vendor_name	text;
	sub_vendor_name	text;
	model_name	text;
	c			RECORD;
BEGIN
	IF (pci_sub_vendor_id IS NULL AND pci_subsystem_id IS NOT NULL) OR
			(pci_sub_vendor_id IS NOT NULL AND pci_subsystem_id IS NULL) THEN
		RAISE EXCEPTION
			'pci_sub_vendor_id and pci_subsystem_id must be set together';
	END IF;

	--
	-- See if we have this component type in the database already
	--
	SELECT
		vid.component_type_id INTO ctid
	FROM
		component_property vid JOIN
		component_property did ON (
			vid.component_property_name = 'PCIVendorID' AND
			vid.component_property_type = 'PCI' AND
			did.component_property_name = 'PCIDeviceID' AND
			did.component_property_type = 'PCI' AND
			vid.component_type_id = did.component_type_id ) LEFT JOIN
		component_property svid ON (
			svid.component_property_name = 'PCISubsystemVendorID' AND
			svid.component_property_type = 'PCI' AND
			svid.component_type_id = did.component_type_id ) LEFT JOIN
		component_property sid ON (
			sid.component_property_name = 'PCISubsystemID' AND
			sid.component_property_type = 'PCI' AND
			sid.component_type_id = did.component_type_id )
	WHERE
		vid.property_value = pci_vendor_id::varchar AND
		did.property_value = pci_device_id::varchar AND
		svid.property_value IS NOT DISTINCT FROM pci_sub_vendor_id::varchar AND
		sid.property_value IS NOT DISTINCT FROM pci_subsystem_id::varchar;

	--
	-- The device type doesn't exist, so attempt to insert it
	--

	IF NOT FOUND THEN	
		IF pci_device_name IS NULL OR component_function_list IS NULL THEN
			RAISE EXCEPTION 'component_id not found and pci_device_name or component_function_list was not passed' USING ERRCODE = 'JH501';
		END IF;

		--
		-- Ensure that there's a company linkage for the PCI (subsystem)vendor
		--
		SELECT
			company_id, company_name INTO comp_id, vendor_name
		FROM
			property p JOIN
			company c USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'PCIVendorID' AND
			property_value = pci_vendor_id::text;
		
		IF NOT FOUND THEN
			IF pci_vendor_name IS NULL THEN
				RAISE EXCEPTION 'PCI vendor id mapping not found and pci_vendor_name was not passed' USING ERRCODE = 'JH501';
			END IF;
			SELECT company_id INTO comp_id FROM company
			WHERE company_name = pci_vendor_name;
		
			IF NOT FOUND THEN
				SELECT company_manip.add_company(
					_company_name := pci_vendor_name,
					_company_types := ARRAY['hardware provider'],
					 _description := 'PCI vendor auto-insert'
				) INTO comp_id;
			END IF;

			INSERT INTO property (
				property_name,
				property_type,
				property_value,
				company_id
			) VALUES (
				'PCIVendorID',
				'DeviceProvisioning',
				pci_vendor_id,
				comp_id
			);
			vendor_name := pci_vendor_name;
		END IF;

		SELECT
			company_id, company_name INTO sub_comp_id, sub_vendor_name
		FROM
			property JOIN
			company c USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'PCIVendorID' AND
			property_value = pci_sub_vendor_id::text;
		
		IF NOT FOUND THEN
			IF pci_sub_vendor_name IS NULL THEN
				RAISE EXCEPTION 'PCI subsystem vendor id mapping not found and pci_sub_vendor_name was not passed' USING ERRCODE = 'JH501';
			END IF;
			SELECT company_id INTO sub_comp_id FROM company
			WHERE company_name = pci_sub_vendor_name;
		
			IF NOT FOUND THEN
				SELECT company_manip.add_company(
					_company_name := pci_sub_vendor_name,
					_company_types := ARRAY['hardware provider'],
					 _description := 'PCI vendor auto-insert'
				) INTO sub_comp_id;
			END IF;

			INSERT INTO property (
				property_name,
				property_type,
				property_value,
				company_id
			) VALUES (
				'PCIVendorID',
				'DeviceProvisioning',
				pci_sub_vendor_id,
				sub_comp_id
			);
			sub_vendor_name := pci_sub_vendor_name;
		END IF;

		--
		-- Fetch the slot type
		--

		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = insert_pci_component.slot_type AND
			slot_function = 'PCI';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function PCI not found adding component_type',
				insert_pci_component.slot_type
				USING ERRCODE = 'JH501';
		END IF;

		--
		-- Figure out the best name/description to insert this component with
		--
		IF pci_sub_device_name IS NOT NULL AND pci_sub_device_name != 'Device' THEN
			model_name = concat_ws(' ', 
				sub_vendor_name, pci_sub_device_name,
				'(' || vendor_name, pci_device_name || ')');
		ELSIF pci_sub_device_name = 'Device' THEN
			model_name = concat_ws(' ', 
				vendor_name, '(' || sub_vendor_name || ')', pci_device_name);
		ELSE
			model_name = concat_ws(' ', vendor_name, pci_device_name);
		END IF;
		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			CASE WHEN 
				sub_comp_id IS NULL OR
				pci_sub_device_name IS NULL OR
				pci_sub_device_name = 'Device'
			THEN
				comp_id
			ELSE
				sub_comp_id
			END,
			CASE WHEN
				pci_sub_device_name IS NULL OR
				pci_sub_device_name = 'Device'
			THEN
				pci_device_name
			ELSE
				pci_sub_device_name
			END,
			stid,
			true,
			model_name
		) RETURNING component_type_id INTO ctid;
		--
		-- Insert properties for the PCI vendor/device IDs
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('PCIVendorID', 'PCI', ctid, pci_vendor_id),
			('PCIDeviceID', 'PCI', ctid, pci_device_id);
		
		IF (pci_subsystem_id IS NOT NULL) THEN
			INSERT INTO component_property (
				component_property_name,
				component_property_type,
				component_type_id,
				property_value
			) VALUES 
				('PCISubsystemVendorID', 'PCI', ctid, pci_sub_vendor_id),
				('PCISubsystemID', 'PCI', ctid, pci_subsystem_id);
		END IF;
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(array_append(component_function_list, 'PCI')) x(cf);
	END IF;


	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'migrate_component_template_slots');
DROP FUNCTION IF EXISTS component_manip.migrate_component_template_slots ( integer );
CREATE OR REPLACE FUNCTION component_manip.migrate_component_template_slots(component_id integer)
 RETURNS SETOF jazzhands.slot
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	cid 	ALIAS FOR component_id;
BEGIN
	-- Ensure all of the new slots have appropriate names

	PERFORM component_manip.set_slot_names(
		slot_id_list := ARRAY(
				SELECT s.slot_id FROM slot s WHERE s.component_id = cid
			)
	);

	-- Move everything from the old slot to the new slot if the slot name
	-- and component functions match up, then delete the old slot

	RETURN QUERY
	WITH old_slot AS (
		SELECT
			s.slot_id,
			s.slot_name,
			s.slot_type_id,
			st.slot_function,
			ctst.component_type_slot_template_id
		FROM
			slot s JOIN 
			slot_type st USING (slot_type_id) JOIN
			component c USING (component_id) LEFT JOIN
			component_type_slot_template ctst USING (component_type_slot_template_id)
		WHERE
			s.component_id = cid AND
			ctst.component_type_id IS DISTINCT FROM c.component_type_id
	), new_slot AS (
		SELECT
			s.slot_id,
			s.slot_name,
			s.slot_type_id,
			st.slot_function
		FROM
			slot s JOIN 
			slot_type st USING (slot_type_id) JOIN
			component c USING (component_id) LEFT JOIN
			component_type_slot_template ctst USING (component_type_slot_template_id)
		WHERE
			s.component_id = cid AND
			ctst.component_type_id IS NOT DISTINCT FROM c.component_type_id
	), slot_map AS (
		SELECT
			o.slot_id AS old_slot_id,
			n.slot_id AS new_slot_id
		FROM
			old_slot o JOIN
			new_slot n ON (
				o.slot_name = n.slot_name AND o.slot_function = n.slot_function)
	), slot_1_upd AS (
		UPDATE
			inter_component_connection ic
		SET
			slot1_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot1_id = slot_map.old_slot_id
		RETURNING *
	), slot_2_upd AS (
		UPDATE
			inter_component_connection ic
		SET
			slot2_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot2_id = slot_map.old_slot_id
		RETURNING *
	), prop_upd AS (
		UPDATE
			component_property cp
		SET
			slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			slot_id = slot_map.old_slot_id
		RETURNING *
	), comp_upd AS (
		UPDATE
			component c
		SET
			parent_slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			parent_slot_id = slot_map.old_slot_id
		RETURNING *
	), l3i_upd AS (
		UPDATE
			layer3_interface l3i
		SET
			slot_id = slot_map.new_slot_id
		FROM
			slot_map
		WHERE
			l3i.slot_id = slot_map.old_slot_id
		RETURNING *
	), delete_migrated_slots AS (
		DELETE FROM
			slot
		WHERE
			slot_id IN (SELECT old_slot_id FROM slot_map)
		RETURNING *
	), delete_empty_slots AS (
		DELETE FROM
			slot s
		WHERE
			slot_id IN (
				SELECT os.slot_id FROM
					old_slot os LEFT JOIN
					component_property cp ON (os.slot_id = cp.slot_id) LEFT JOIN
					layer3_interface l3i ON (
						l3i.slot_id = os.slot_id OR
						l3i.slot_id = os.slot_id) LEFT JOIN
					inter_component_connection ic ON (
						slot1_id = os.slot_id OR
						slot2_id = os.slot_id) LEFT JOIN
					component c ON (c.parent_slot_id = os.slot_id)
				WHERE
					ic.inter_component_connection_id IS NULL AND
					c.component_id IS NULL AND
					l3i.layer3_interface_id IS NULL AND
					cp.component_property_id IS NULL AND
					os.component_type_slot_template_id IS NOT NULL
			)
	) SELECT s.* FROM slot s JOIN slot_map sm ON s.slot_id = sm.new_slot_id;

	RETURN;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'remove_component_hier');
DROP FUNCTION IF EXISTS component_manip.remove_component_hier ( integer,boolean );
CREATE OR REPLACE FUNCTION component_manip.remove_component_hier(component_id integer, really_delete boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	slot_list		integer[];
	shelf_list		integer[];
	delete_list		integer[];
	cid				integer;
BEGIN
	cid := component_id;

	SELECT ARRAY(
		SELECT
			slot_id
		FROM
			v_component_hier h JOIN
			slot s ON (h.child_component_id = s.component_id)
		WHERE
			h.component_id = cid)
	INTO slot_list;

	IF really_delete THEN
		SELECT ARRAY(
			SELECT
				child_component_id
			FROM
				v_component_hier h
			WHERE
				h.component_id = cid)
		INTO delete_list;
	ELSE

		SELECT ARRAY(
			SELECT
				child_component_id
			FROM
				v_component_hier h LEFT JOIN
				asset a on (a.component_id = h.child_component_id)
			WHERE
				h.component_id = cid AND
				serial_number IS NOT NULL
		)
		INTO shelf_list;

		SELECT ARRAY(
			SELECT
				child_component_id
			FROM
				v_component_hier h LEFT JOIN
				asset a on (a.component_id = h.child_component_id)
			WHERE
				h.component_id = cid AND
				serial_number IS NULL
		)
		INTO delete_list;

	END IF;

	DELETE FROM
		inter_component_connection
	WHERE
		slot1_id = ANY (slot_list) OR
		slot2_id = ANY (slot_list);

	UPDATE
		component c
	SET
		parent_slot_id = NULL
	WHERE
		c.component_id = ANY (array_cat(delete_list, shelf_list)) AND
		parent_slot_id IS NOT NULL;

	DELETE FROM component_property cp WHERE
		cp.component_id = ANY (delete_list) OR
		slot_id = ANY (slot_list);
		
	DELETE FROM
		slot s
	WHERE
		slot_id = ANY (slot_list) AND
		s.component_id = ANY(delete_list);
		
	DELETE FROM
		component c
	WHERE
		c.component_id = ANY (delete_list);

	RETURN true;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'replace_component');
DROP FUNCTION IF EXISTS component_manip.replace_component ( integer,integer );
CREATE OR REPLACE FUNCTION component_manip.replace_component(old_component_id integer, new_component_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	oc	RECORD;
BEGIN
	SELECT
		* INTO oc
	FROM
		component
	WHERE
		component_id = old_component_id;

	UPDATE
		component
	SET
		parent_slot_id = NULL
	WHERE
		component_id = old_component_id;

	UPDATE 
		component
	SET
		parent_slot_id = oc.parent_slot_id
	WHERE
		component_id = new_component_id;

	UPDATE
		device
	SET
		component_id = new_component_id
	WHERE
		component_id = old_component_id;
	
	UPDATE
		physicalish_volume
	SET
		component_id = new_component_id
	WHERE
		component_id = old_component_id;

	RETURN;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('component_manip', 'set_slot_names');
DROP FUNCTION IF EXISTS component_manip.set_slot_names ( integer[] );
CREATE OR REPLACE FUNCTION component_manip.set_slot_names(slot_id_list integer[] DEFAULT NULL::integer[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	slot_rec	RECORD;
	sn			text;
BEGIN
	-- Get a list of all slots that have replacement values

	FOR slot_rec IN
		SELECT 
			s.slot_id,
			COALESCE(pst.child_slot_name_template, st.slot_name_template)
				AS slot_name_template,
			st.slot_index as slot_index,
			pst.slot_index as parent_slot_index,
			pst.child_slot_offset as child_slot_offset
		FROM
			slot s JOIN
			component_type_slot_template st ON (s.component_type_slot_template_id =
				st.component_type_slot_template_id) JOIN
			component c ON (s.component_id = c.component_id) LEFT JOIN
			slot ps ON (c.parent_slot_id = ps.slot_id) LEFT JOIN
			component_type_slot_template pst ON (ps.component_type_slot_template_id =
				pst.component_type_slot_template_id)
		WHERE
			s.slot_id = ANY(slot_id_list) AND
			(
				st.slot_name_template ~ '%{' OR
				pst.child_slot_name_template ~ '%{'
			)
	LOOP
		sn := slot_rec.slot_name_template;
		IF (slot_rec.slot_index IS NOT NULL) THEN
			sn := regexp_replace(sn,
				'%\{slot_index\}', slot_rec.slot_index::text,
				'g');
		END IF;
		IF (slot_rec.parent_slot_index IS NOT NULL) THEN
			sn := regexp_replace(sn,
				'%\{parent_slot_index\}', slot_rec.parent_slot_index::text,
				'g');
		END IF;
		IF (slot_rec.parent_slot_index IS NOT NULL AND
			slot_rec.slot_index IS NOT NULL) THEN
			sn := regexp_replace(sn,
				'%\{relative_slot_index\}', 
				(slot_rec.parent_slot_index + slot_rec.slot_index)::text,
				'g');
		END IF;
		RAISE DEBUG 'Setting name of slot % to %',
			slot_rec.slot_id,
			sn;
		UPDATE slot SET slot_name = sn WHERE slot_id = slot_rec.slot_id;
	END LOOP;
END;
$function$
;

--
-- Process middle (non-trigger) schema dns_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_manip']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_manip', 'add_dns_domain');
DROP FUNCTION IF EXISTS dns_manip.add_dns_domain ( character varying,character varying,integer[],boolean );
CREATE OR REPLACE FUNCTION dns_manip.add_dns_domain(dns_domain_name character varying, dns_domain_type character varying DEFAULT NULL::character varying, ip_universes integer[] DEFAULT NULL::integer[], add_nameservers boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	elements		text[];
	parent_zone		text;
	parent_id		dns_domain.dns_domain_id%type;
	domain_id		dns_domain.dns_domain_id%type;
	elem			text;
	sofar			text;
	rvs_nblk_id		netblock.netblock_id%type;
	univ			ip_universe.ip_universe_id%type;
	can_haz_generate	boolean;
BEGIN
	IF dns_domain_name IS NULL THEN
		RETURN NULL;
	END IF;
	elements := regexp_split_to_array(dns_domain_name, '\.');
	sofar := '';
	FOREACH elem in ARRAY elements
	LOOP
		IF octet_length(sofar) > 0 THEN
			sofar := sofar || '.';
		END IF;
		sofar := sofar || elem;
		parent_zone := regexp_replace(dns_domain_name, '^'||sofar||'.', '');
		EXECUTE 'SELECT dns_domain_id FROM dns_domain
			WHERE dns_domain_name = $1' INTO parent_id USING parent_zone;
		IF parent_id IS NOT NULL THEN
			EXIT;
		END IF;
	END LOOP;

	SELECT dt.can_generate
	INTO can_haz_generate
	FROM val_dns_domain_type dt
	WHERE dt.dns_domain_type = add_dns_domain.dns_domain_type;

	IF ip_universes IS NULL THEN
		SELECT array_agg(ip_universe_id)
		INTO	ip_universes
		FROM	ip_universe
		WHERE	ip_universe_name = 'default';
	END IF;

	IF dns_domain_type IS NULL THEN
		IF dns_domain_name ~ '^.*(in-addr|ip6)\.arpa$' THEN
			dns_domain_type := 'reverse';
		END IF;
	END IF;

	IF dns_domain_type IS NULL THEN
		RAISE EXCEPTION 'Unable to guess dns_domain_type for %',
			dns_domain_name USING ERRCODE = 'not_null_violation';
	END IF;

	EXECUTE '
		INSERT INTO dns_domain (
			dns_domain_name,
			parent_dns_domain_id,
			dns_domain_type
		) VALUES (
			$1,
			$2,
			$3
		) RETURNING dns_domain_id' INTO domain_id
		USING dns_domain_name,
			parent_id,
			dns_domain_type
	;

	FOREACH univ IN ARRAY ip_universes
	LOOP
		EXECUTE '
			INSERT INTO dns_domain_ip_universe (
				dns_domain_id,
				ip_universe_id,
				soa_class,
				soa_mname,
				soa_rname,
				should_generate
			) VALUES (
				$1,
				$2,
				$3,
				$4,
				$5,
				$6
			);'
			USING domain_id, univ,
				'IN',
				(select property_value from property
					where property_type = 'Defaults'
					and property_name = '_dnsmname' ORDER BY property_id LIMIT 1),
				(select property_value from property
					where property_type = 'Defaults'
					and property_name = '_dnsrname' ORDER BY property_id LIMIT 1),
				can_haz_generate
		;
	END LOOP;

	IF dns_domain_type = 'reverse' THEN
		rvs_nblk_id := dns_manip.get_or_create_inaddr_domain_netblock_link(
			dns_domain_name, domain_id);
	END IF;

	IF add_nameservers THEN
		PERFORM dns_manip.add_ns_records(domain_id);
	END IF;

	--
	-- XXX - need to reconsider how ip universes fit into this.
	IF parent_id IS NOT NULL THEN
		INSERT INTO dns_change_record (
			dns_domain_id
		) SELECT dns_domain_id
		FROM dns_domain
		WHERE dns_domain_id = parent_id
		AND dns_domain_id IN (
			SELECT dns_domain_id
			FROM dns_domain_ip_universe
			WHERE should_generate = true
		);
	END IF;

	RETURN domain_id;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_manip', 'add_domain_from_cidr');
DROP FUNCTION IF EXISTS dns_manip.add_domain_from_cidr ( inet );
CREATE OR REPLACE FUNCTION dns_manip.add_domain_from_cidr(block inet)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ipaddr		text;
	ipnodes		text[];
	domain		text;
	domain_id	dns_domain.dns_domain_id%TYPE;
	j			text;
BEGIN
	-- silently fail for ipv6
	IF family(block) != 4 THEN
		RETURN NULL;
	END IF;
	IF family(block) != 4 THEN
		j := '';
		-- this needs to be tweaked to expand ::, which postgresql does
		-- not easily do.  This requires more thinking than I was up for today.
		ipaddr := regexp_replace(host(block)::text, ':', '', 'g');
	ELSE
		j := '\.';
		ipaddr := host(block);
	END IF;

	EXECUTE 'select array_agg(member order by rn desc)
		from (
        select
			row_number() over () as rn, *
			from
			unnest(regexp_split_to_array($1, $2)) as member
		) x
	' INTO ipnodes USING ipaddr, j;

	IF family(block) = 4 THEN
		domain := array_to_string(ARRAY[ipnodes[2],ipnodes[3],ipnodes[4]], '.')
			|| '.in-addr.arpa';
	ELSE
		domain := array_to_string(ipnodes, '.')
			|| '.ip6.arpa';
	END IF;

	SELECT dns_domain_id INTO domain_id FROM dns_domain where dns_domain_name = domain;
	IF NOT FOUND THEN
		-- domain_id := dns_manip.add_dns_domain(domain);
	END IF;

	RETURN domain_id;
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_manip', 'add_domains_from_netblock');
DROP FUNCTION IF EXISTS dns_manip.add_domains_from_netblock ( integer );
CREATE OR REPLACE FUNCTION dns_manip.add_domains_from_netblock(netblock_id integer)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nid	ALIAS FOR netblock_id;
	block	inet;
	_rv	TEXT;
BEGIN
	SELECT ip_address INTO block FROM netblock n WHERE n.netblock_id = nid;

	RAISE DEBUG 'Creating inverse DNS zones for %s', block;

	SELECT jsonb_agg(jsonb_build_object(
		'dns_domain_id', dns_domain_id,
		'dns_domain_name', dns_domain_name))
	FROM (
		SELECT
			dns_manip.add_dns_domain(
				dns_domain_name := x.dns_domain_name,
				dns_domain_type := 'reverse'
				) as dns_domain_id,
			x.dns_domain_name::text
		FROM dns_utils.get_all_domain_rows_for_cidr(block) x 
		LEFT JOIN dns_domain d USING (dns_domain_name)
		WHERE d.dns_domain_id IS NULL
	) i INTO _rv;

	RETURN _rv; 
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_manip', 'add_ns_records');
DROP FUNCTION IF EXISTS dns_manip.add_ns_records ( integer,boolean );
CREATE OR REPLACE FUNCTION dns_manip.add_ns_records(dns_domain_id integer, purge boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF purge THEN
		EXECUTE '
			DELETE FROM dns_record
			WHERE dns_domain_id = $1
			AND dns_name IS NULL
			AND dns_class = $2
			AND dns_type = $3
			AND dns_value NOT IN (
				SELECT property_value
				FROM property
				WHERE property_name = $4
				AND property_type = $5
			)
		' USING dns_domain_id, 'IN', 'NS', '_authdns', 'Defaults';
	END IF;
	EXECUTE '
		INSERT INTO dns_record (
			dns_domain_id, dns_class, dns_type, dns_value
		) select $1, $2, $3, property_value
		FROM property
		WHERE property_name = $4
		AND property_type = $5
		AND property_value NOT IN (
			SELECT dns_value
			FROM dns_record
			WHERE dns_domain_id = $1
			AND dns_class = $2
			AND dns_type = $3
			AND dns_name IS NULL
		)
	' USING dns_domain_id, 'IN', 'NS', '_authdns', 'Defaults';
END;
$function$
;

-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('dns_manip', 'get_or_create_inaddr_domain_netblock_link');
DROP FUNCTION IF EXISTS dns_manip.get_or_create_inaddr_domain_netblock_link ( character varying,integer );
CREATE OR REPLACE FUNCTION dns_manip.get_or_create_inaddr_domain_netblock_link(dns_domain_name character varying, dns_domain_id integer)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nblk_id	netblock.netblock_id%type;
	blk text;
	root	text;
	brk	text[];
	ipmember text[];
	ip	inet;
	j text;
BEGIN
	brk := regexp_matches(dns_domain_name, '^(.+)\.(in-addr|ip6)\.arpa$');
	IF brk[2] = 'in-addr' THEN
		j := '.';
	ELSE
		j := ':';
	END IF;

	EXECUTE 'select array_agg(member order by rn desc), $2
		from (
        select
			row_number() over () as rn, *
			from
			unnest(regexp_split_to_array($1, $3)) as member
		) x
	' INTO ipmember USING brk[1], j, '\.';

	IF brk[2] = 'in-addr' THEN
		IF array_length(ipmember, 1) > 4 THEN
			RAISE EXCEPTION 'Unable to work with anything smaller than a /24';
		ELSIF array_length(ipmember, 1) != 3 THEN
			-- If this is not a /24, then do not add any rvs association
			RETURN NULL;
		END IF;
		WHILE array_length(ipmember, 1) < 4
		LOOP
			ipmember := array_append(ipmember, '0');
		END LOOP;
		ip := concat(array_to_string(ipmember, j),'/24')::inet;
	ELSE
		ip := concat(
			regexp_replace(
				array_to_string(ipmember, ''), '(....)', '\1:', 'g'),
			':/64')::inet;
	END IF;

	SELECT netblock_id
		INTO	nblk_id
		FROM	netblock
		WHERE	netblock_type = 'dns'
		AND		is_single_address = false
		AND		can_subnet = false
		AND		netblock_status = 'Allocated'
		AND		ip_universe_id = 0
		AND		ip_address = ip;

	IF NOT FOUND THEN
		INSERT INTO netblock (
			ip_address, netblock_type, is_single_address,
			can_subnet, netblock_status, ip_universe_id
		) VALUES (
			ip, 'dns', false,
			false, 'Allocated', 0
		) RETURNING netblock_id INTO nblk_id;
	END IF;

	EXECUTE '
		INSERT INTO dns_record(
			dns_domain_id, dns_class, dns_type, netblock_id
		) values (
			$1, $2, $3, $4
		)
	' USING dns_domain_id, 'IN', 'REVERSE_ZONE_BLOCK_PTR', nblk_id;

	RETURN nblk_id;
END;
$function$
;

--
-- Process middle (non-trigger) schema versioning_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_versioning_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('versioning_utils', 'check_schema_version');
DROP FUNCTION IF EXISTS versioning_utils.check_schema_version ( text,text,boolean );
CREATE OR REPLACE FUNCTION versioning_utils.check_schema_version(version text, schema text DEFAULT NULL::text, raise_exception boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
	RETURN schema_support.check_schema_version(
		version := version,
		schema := schema,
		raise_exception := raise_exception
	);
END;
$function$
;

-- Creating new sequences....
CREATE SEQUENCE layer3_acl_chain_layer3_acl_chain_id_seq;
CREATE SEQUENCE layer3_acl_chain_layer3_interface_layer3_acl_chain_id_seq;
CREATE SEQUENCE layer3_acl_chain_layer3_interface_layer3_interface_id_seq;
CREATE SEQUENCE layer3_acl_group_layer3_acl_group_id_seq;
CREATE SEQUENCE layer3_acl_rule_layer3_acl_rule_id_seq;
CREATE SEQUENCE port_range_port_range_id_seq;
CREATE SEQUENCE service_depend_service_depend_id_seq;
CREATE SEQUENCE service_endpoint_health_check_service_endpoint_health_check_seq;
CREATE SEQUENCE service_endpoint_provider_col_service_endpoint_provider_co_seq1;
CREATE SEQUENCE service_endpoint_provider_col_service_endpoint_provider_col_seq;
CREATE SEQUENCE service_endpoint_provider_coll_service_endpoint_provider_id_seq;
CREATE SEQUENCE service_endpoint_provider_ser_service_endpoint_provider_ser_seq;
CREATE SEQUENCE service_endpoint_provider_service_endpoint_provider_id_seq;
CREATE SEQUENCE service_endpoint_service_endpoint_id_seq;
CREATE SEQUENCE service_endpoint_service_sla_service_endpoint_service_sla_i_seq;
CREATE SEQUENCE service_instance_service_instance_id_seq;
CREATE SEQUENCE service_service_id_seq;
CREATE SEQUENCE service_sla_service_sla_id_seq;
CREATE SEQUENCE service_software_repository_software_artifact_repository_id_seq;
CREATE SEQUENCE service_source_repository_service_source_repository_id_seq;
CREATE SEQUENCE service_version_artifact_software_artifact_name_id_seq;
CREATE SEQUENCE service_version_collection_service_version_collection_id_seq;
CREATE SEQUENCE service_version_service_version_id_seq;
CREATE SEQUENCE service_version_software_arti_software_artifact_repository__seq;
CREATE SEQUENCE software_artifact_name_software_artifact_name_id_seq;
CREATE SEQUENCE software_artifact_repository_software_artifact_repository_i_seq;
CREATE SEQUENCE software_artifact_system_software_artifact_system_id_seq;
CREATE SEQUENCE source_repository_location_source_repository_location_id_seq;
CREATE SEQUENCE source_repository_source_repository_id_seq;
CREATE SEQUENCE source_repository_url_source_repository_id_seq;


-- Processing tables in main schema...
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE layer3_interface_netblock
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'layer3_interface_netblock', 'layer3_interface_netblock');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS fk_netint_nb_nblk_id;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS fk_netint_nb_netint_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'layer3_interface_netblock', newobject := 'layer3_interface_netblock', newmap := '{"ak_l3int_device_netblock_id":{"columns":["device_id","netblock_id"],"def":"UNIQUE (device_id, netblock_id)","deferrable":false,"deferred":false,"name":"ak_l3int_device_netblock_id","type":"u"},"ak_netint_nblk_nblk_id":{"columns":["netblock_id"],"def":"UNIQUE (netblock_id)","deferrable":false,"deferred":false,"name":"ak_netint_nblk_nblk_id","type":"u"},"ak_network_interface_nblk_ni_rank":{"columns":["layer3_interface_id","layer3_interface_rank"],"def":"UNIQUE (layer3_interface_id, layer3_interface_rank) DEFERRABLE","deferrable":true,"deferred":false,"name":"ak_network_interface_nblk_ni_rank","type":"u"},"pk_network_interface_netblock":{"columns":["netblock_id","layer3_interface_id","device_id"],"def":"PRIMARY KEY (netblock_id, layer3_interface_id, device_id)","deferrable":false,"deferred":false,"name":"pk_network_interface_netblock","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS ak_netint_nblk_nblk_id;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS ak_network_interface_nblk_ni_rank;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS pk_network_interface_netblock;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif_netint_nb_nblk_id";
DROP INDEX IF EXISTS "jazzhands"."xif_netint_nb_netint_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_netblock ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_netblock ON jazzhands.layer3_interface_netblock;
DROP FUNCTION IF EXISTS perform_audit_layer3_interface_netblock();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_after ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_net_int_nb_single_address ON jazzhands.layer3_interface_netblock;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'layer3_interface_netblock', tags := ARRAY['table_layer3_interface_netblock']);
---- BEGIN jazzhands_audit.layer3_interface_netblock TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'layer3_interface_netblock', tags := ARRAY['table_layer3_interface_netblock']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'layer3_interface_netblock', 'layer3_interface_netblock');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'layer3_interface_netblock');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.layer3_interface_netblock DROP CONSTRAINT IF EXISTS layer3_interface_netblock_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_ak_netint_nblk_nblk_id";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_ak_network_interface_nblk_ni_rank";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_pk_network_interface_netblock";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.layer3_interface_netblock TEARDOWN


ALTER TABLE layer3_interface_netblock RENAME TO layer3_interface_netblock_v91;
ALTER TABLE jazzhands_audit.layer3_interface_netblock RENAME TO layer3_interface_netblock_v91;

CREATE TABLE jazzhands.layer3_interface_netblock
(
	netblock_id	integer NOT NULL,
	layer3_interface_id	integer NOT NULL,
	device_id	integer NOT NULL,
	layer3_interface_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock', false);
ALTER TABLE layer3_interface_netblock
	ALTER layer3_interface_rank
	SET DEFAULT 0;

INSERT INTO layer3_interface_netblock (
	netblock_id,
	layer3_interface_id,
	device_id,
	layer3_interface_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	netblock_id,
	layer3_interface_id,
	device_id,
	layer3_interface_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM layer3_interface_netblock_v91;


INSERT INTO jazzhands_audit.layer3_interface_netblock (
	netblock_id,
	layer3_interface_id,
	device_id,
	layer3_interface_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	netblock_id,
	layer3_interface_id,
	device_id,
	layer3_interface_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.layer3_interface_netblock_v91;

ALTER TABLE jazzhands.layer3_interface_netblock
	ALTER layer3_interface_rank
	SET DEFAULT 0;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT ak_l3int_device_netblock_id UNIQUE (device_id, netblock_id);
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT ak_netint_nblk_nblk_id UNIQUE (netblock_id);
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT ak_network_interface_nblk_ni_rank UNIQUE (layer3_interface_id, layer3_interface_rank) DEFERRABLE;
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT pk_network_interface_netblock PRIMARY KEY (netblock_id, layer3_interface_id, device_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.layer3_interface_netblock.layer3_interface_rank IS 'specifies the order of priority for the ip address.  generally only the highest priority matters (or highest priority v4 and v6) and is the "primary" if the underlying device supports it.';
-- INDEXES
CREATE INDEX xif_netint_nb_nblk_id ON jazzhands.layer3_interface_netblock USING btree (layer3_interface_id, device_id);
CREATE UNIQUE INDEX xif_netint_nb_netint_id ON jazzhands.layer3_interface_netblock USING btree (netblock_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between layer3_interface_netblock and jazzhands.service_instance
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_instance
--	ADD CONSTRAINT fk_service_instance_dev_nblk
--	FOREIGN KEY (device_id, netblock_id) REFERENCES jazzhands.layer3_interface_netblock(device_id, netblock_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK layer3_interface_netblock and layer3_interface
ALTER TABLE jazzhands.layer3_interface_netblock
	ADD CONSTRAINT fk_netint_nb_nblk_id
	FOREIGN KEY (layer3_interface_id, device_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id, device_id) DEFERRABLE;
-- consider FK layer3_interface_netblock and netblock
ALTER TABLE jazzhands.layer3_interface_netblock
	ADD CONSTRAINT fk_netint_nb_netint_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.net_int_nb_device_id_ins
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_device_id_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	SET CONSTRAINTS fk_netint_nb_nblk_id DEFERRED;
	IF NEW.device_id IS NULL OR TG_OP = 'UPDATE' THEN
		SELECT device_id
		INTO	NEW.device_id
		FROM	layer3_interface
		WHERE	layer3_interface_id = NEW.layer3_interface_id;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.net_int_nb_device_id_ins() FROM public;
CREATE TRIGGER trigger_net_int_nb_device_id_ins BEFORE INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.net_int_nb_device_id_ins();

-- considering NEW jazzhands.net_int_nb_device_id_ins_after
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_device_id_ins_after()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	SET CONSTRAINTS fk_netint_nb_nblk_id IMMEDIATE;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.net_int_nb_device_id_ins_after() FROM public;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_after AFTER INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.net_int_nb_device_id_ins_after();

-- considering NEW jazzhands.net_int_nb_single_address
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_single_address()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	IF NEW.netblock_id IS NOT NULL THEN
		select count(*)
		INTO _tally
		FROM netblock
		WHERE netblock_id = NEW.netblock_id
		AND is_single_address = true
		AND netblock_type = 'default';

		IF _tally = 0 THEN
			RAISE EXCEPTION 'network interfaces must refer to single ip addresses of type default (%,%)', NEW.layer3_interface_id, NEW.netblock_id
				USING errcode = 'foreign_key_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.net_int_nb_single_address() FROM public;
CREATE TRIGGER trigger_net_int_nb_single_address BEFORE INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.net_int_nb_single_address();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_interface_netblock');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_interface_netblock  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_interface_netblock');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock');
DROP TABLE IF EXISTS layer3_interface_netblock_v91;
DROP TABLE IF EXISTS jazzhands_audit.layer3_interface_netblock_v91;
-- DONE DEALING WITH TABLE layer3_interface_netblock (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_interface_netblock failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_interface_netblock failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE network_service
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'network_service', 'network_service');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_csvcenv;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_device_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_dnsid_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_netint_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_netsvctyp_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'network_service', newobject := 'network_service', newmap := '{"pk_network_service":{"columns":["network_service_id"],"def":"PRIMARY KEY (network_service_id)","deferrable":false,"deferred":false,"name":"pk_network_service","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS pk_service;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_ismonitored";
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_netsvctype";
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_svcenv";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_dnsidrecid";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_netdevid";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_netintid";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_network_service ON jazzhands.network_service;
DROP TRIGGER IF EXISTS trigger_audit_network_service ON jazzhands.network_service;
DROP FUNCTION IF EXISTS perform_audit_network_service();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'network_service', tags := ARRAY['table_network_service']);
---- BEGIN jazzhands_audit.network_service TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'network_service', tags := ARRAY['table_network_service']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'network_service', 'network_service');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'network_service');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.network_service DROP CONSTRAINT IF EXISTS network_service_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_network_service_pk_service";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.network_service TEARDOWN


ALTER TABLE network_service RENAME TO network_service_v91;
ALTER TABLE jazzhands_audit.network_service RENAME TO network_service_v91;

CREATE TABLE jazzhands.network_service
(
	network_service_id	integer NOT NULL,
	name	varchar(255)  NULL,
	description	varchar(255)  NULL,
	network_service_type	varchar(50) NOT NULL,
	is_monitored	boolean NOT NULL,
	device_id	integer  NULL,
	layer3_interface_id	integer  NULL,
	dns_record_id	integer  NULL,
	service_environment_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'network_service', false);
ALTER TABLE network_service
	ALTER network_service_id
	SET DEFAULT nextval('jazzhands.network_service_network_service_id_seq'::regclass);

INSERT INTO network_service (
	network_service_id,
	name,
	description,
	network_service_type,
	is_monitored,
	device_id,
	layer3_interface_id,
	dns_record_id,
	service_environment_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	network_service_id,
	name,
	description,
	network_service_type,
	is_monitored,
	device_id,
	layer3_interface_id,
	dns_record_id,
	service_environment_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM network_service_v91;


INSERT INTO jazzhands_audit.network_service (
	network_service_id,
	name,
	description,
	network_service_type,
	is_monitored,
	device_id,
	layer3_interface_id,
	dns_record_id,
	service_environment_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	network_service_id,
	name,
	description,
	network_service_type,
	is_monitored,
	device_id,
	layer3_interface_id,
	dns_record_id,
	service_environment_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.network_service_v91;

ALTER TABLE jazzhands.network_service
	ALTER network_service_id
	SET DEFAULT nextval('jazzhands.network_service_network_service_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.network_service ADD CONSTRAINT pk_network_service PRIMARY KEY (network_service_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX idx_netsvc_ismonitored ON jazzhands.network_service USING btree (is_monitored);
CREATE INDEX idx_netsvc_netsvctype ON jazzhands.network_service USING btree (network_service_type);
CREATE INDEX idx_netsvc_svcenv ON jazzhands.network_service USING btree (service_environment_id);
CREATE INDEX ix_netsvc_dnsidrecid ON jazzhands.network_service USING btree (dns_record_id);
CREATE INDEX ix_netsvc_netdevid ON jazzhands.network_service USING btree (device_id);
CREATE INDEX ix_netsvc_netintid ON jazzhands.network_service USING btree (layer3_interface_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK network_service and service_environment
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_csvcenv
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK network_service and device
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_device_id
	FOREIGN KEY (device_id) REFERENCES jazzhands.device(device_id);
-- consider FK network_service and dns_record
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_dnsid_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK network_service and layer3_interface
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_netint_id
	FOREIGN KEY (layer3_interface_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id);
-- consider FK network_service and val_network_service_type
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_netsvctyp_id
	FOREIGN KEY (network_service_type) REFERENCES jazzhands.val_network_service_type(network_service_type);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('network_service');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_service  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'network_service');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'network_service');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'network_service');
ALTER SEQUENCE jazzhands.network_service_network_service_id_seq
	 OWNED BY network_service.network_service_id;
DROP TABLE IF EXISTS network_service_v91;
DROP TABLE IF EXISTS jazzhands_audit.network_service_v91;
-- DONE DEALING WITH TABLE network_service (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_service failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_service failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE shared_netblock
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'shared_netblock', 'shared_netblock');

-- FOREIGN KEYS FROM
ALTER TABLE shared_netblock_layer3_interface DROP CONSTRAINT IF EXISTS fk_shrdnet_netint_shrdnet_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.shared_netblock DROP CONSTRAINT IF EXISTS fk_shared_net_netblock_id;
ALTER TABLE jazzhands.shared_netblock DROP CONSTRAINT IF EXISTS fk_shrdnet_shrdnet_proto;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'shared_netblock', newobject := 'shared_netblock', newmap := '{"ak_shared_netblock_netblock":{"columns":["netblock_id"],"def":"UNIQUE (netblock_id)","deferrable":false,"deferred":false,"name":"ak_shared_netblock_netblock","type":"u"},"ak_shared_netblock_shared_netblock_netblock":{"columns":["shared_netblock_id","netblock_id"],"def":"UNIQUE (shared_netblock_id, netblock_id)","deferrable":false,"deferred":false,"name":"ak_shared_netblock_shared_netblock_netblock","type":"u"},"pk_shared_netblock":{"columns":["shared_netblock_id"],"def":"PRIMARY KEY (shared_netblock_id)","deferrable":false,"deferred":false,"name":"pk_shared_netblock","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.shared_netblock DROP CONSTRAINT IF EXISTS ak_shared_netblock_netblock;
ALTER TABLE jazzhands.shared_netblock DROP CONSTRAINT IF EXISTS pk_shared_netblock;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1shared_netblock";
DROP INDEX IF EXISTS "jazzhands"."xif2shared_netblock";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock ON jazzhands.shared_netblock;
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock ON jazzhands.shared_netblock;
DROP FUNCTION IF EXISTS perform_audit_shared_netblock();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'shared_netblock', tags := ARRAY['table_shared_netblock']);
---- BEGIN jazzhands_audit.shared_netblock TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'shared_netblock', tags := ARRAY['table_shared_netblock']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'shared_netblock', 'shared_netblock');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'shared_netblock');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.shared_netblock DROP CONSTRAINT IF EXISTS shared_netblock_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_shared_netblock_ak_shared_netblock_netblock";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_shared_netblock_pk_shared_netblock";
DROP INDEX IF EXISTS "jazzhands_audit"."shared_netblock_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."shared_netblock_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."shared_netblock_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.shared_netblock TEARDOWN


ALTER TABLE shared_netblock RENAME TO shared_netblock_v91;
ALTER TABLE jazzhands_audit.shared_netblock RENAME TO shared_netblock_v91;

CREATE TABLE jazzhands.shared_netblock
(
	shared_netblock_id	integer NOT NULL,
	shared_netblock_protocol	varchar(50) NOT NULL,
	netblock_id	integer NOT NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'shared_netblock', false);
ALTER TABLE shared_netblock
	ALTER shared_netblock_id
	SET DEFAULT nextval('jazzhands.shared_netblock_shared_netblock_id_seq'::regclass);

INSERT INTO shared_netblock (
	shared_netblock_id,
	shared_netblock_protocol,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	shared_netblock_id,
	shared_netblock_protocol,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM shared_netblock_v91;


INSERT INTO jazzhands_audit.shared_netblock (
	shared_netblock_id,
	shared_netblock_protocol,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	shared_netblock_id,
	shared_netblock_protocol,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.shared_netblock_v91;

ALTER TABLE jazzhands.shared_netblock
	ALTER shared_netblock_id
	SET DEFAULT nextval('jazzhands.shared_netblock_shared_netblock_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.shared_netblock ADD CONSTRAINT ak_shared_netblock_netblock UNIQUE (netblock_id);
ALTER TABLE jazzhands.shared_netblock ADD CONSTRAINT ak_shared_netblock_shared_netblock_netblock UNIQUE (shared_netblock_id, netblock_id);
ALTER TABLE jazzhands.shared_netblock ADD CONSTRAINT pk_shared_netblock PRIMARY KEY (shared_netblock_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xif1shared_netblock ON jazzhands.shared_netblock USING btree (shared_netblock_protocol);
CREATE INDEX xif2shared_netblock ON jazzhands.shared_netblock USING btree (netblock_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between shared_netblock and jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
--	ADD CONSTRAINT fk_sep_snl3int_snb_snb_nb
--	FOREIGN KEY (shared_netblock_id, netblock_id) REFERENCES jazzhands.shared_netblock(shared_netblock_id, netblock_id) DEFERRABLE;

-- consider FK between shared_netblock and jazzhands.shared_netblock_layer3_interface
ALTER TABLE jazzhands.shared_netblock_layer3_interface
	ADD CONSTRAINT fk_shrdnet_netint_shrdnet_id
	FOREIGN KEY (shared_netblock_id) REFERENCES jazzhands.shared_netblock(shared_netblock_id);

-- FOREIGN KEYS TO
-- consider FK shared_netblock and netblock
ALTER TABLE jazzhands.shared_netblock
	ADD CONSTRAINT fk_shared_net_netblock_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK shared_netblock and val_shared_netblock_protocol
ALTER TABLE jazzhands.shared_netblock
	ADD CONSTRAINT fk_shrdnet_shrdnet_proto
	FOREIGN KEY (shared_netblock_protocol) REFERENCES jazzhands.val_shared_netblock_protocol(shared_netblock_protocol);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('shared_netblock');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for shared_netblock  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'shared_netblock');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'shared_netblock');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'shared_netblock');
ALTER SEQUENCE jazzhands.shared_netblock_shared_netblock_id_seq
	 OWNED BY shared_netblock.shared_netblock_id;
DROP TABLE IF EXISTS shared_netblock_v91;
DROP TABLE IF EXISTS jazzhands_audit.shared_netblock_v91;
-- DONE DEALING WITH TABLE shared_netblock (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('shared_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old shared_netblock failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('shared_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new shared_netblock failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE sw_package
-- ... renaming to software_artifact_name (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'sw_package', 'software_artifact_name');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'sw_package', 'software_artifact_name');

-- FOREIGN KEYS FROM
ALTER TABLE property DROP CONSTRAINT IF EXISTS fk_property_pval_swpkgid;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.sw_package DROP CONSTRAINT IF EXISTS fk_swpkg_ref_vswpkgtype;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'sw_package', newobject := 'software_artifact_name', newmap := '{"ak_software_artifact_name_type":{"columns":["software_artifact_name","software_artifact_type"],"def":"UNIQUE (software_artifact_name, software_artifact_type)","deferrable":false,"deferred":false,"name":"ak_software_artifact_name_type","type":"u"},"pk_software_artifact_name":{"columns":["software_artifact_name_id"],"def":"PRIMARY KEY (software_artifact_name_id)","deferrable":false,"deferred":false,"name":"pk_software_artifact_name","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.sw_package DROP CONSTRAINT IF EXISTS pk_sw_package;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_sw_package ON jazzhands.sw_package;
DROP TRIGGER IF EXISTS trigger_audit_sw_package ON jazzhands.sw_package;
DROP FUNCTION IF EXISTS perform_audit_sw_package();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'sw_package', tags := ARRAY['table_software_artifact_name']);
---- BEGIN jazzhands_audit.sw_package TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'sw_package', tags := ARRAY['table_software_artifact_name']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'sw_package', 'software_artifact_name');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'sw_package');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.sw_package DROP CONSTRAINT IF EXISTS sw_package_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_sw_package_pk_sw_package";
DROP INDEX IF EXISTS "jazzhands_audit"."sw_package_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."sw_package_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."sw_package_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.sw_package TEARDOWN


ALTER TABLE sw_package RENAME TO sw_package_v91;
ALTER TABLE jazzhands_audit.sw_package RENAME TO sw_package_v91;

CREATE TABLE jazzhands.software_artifact_name
(
	software_artifact_name_id	integer NOT NULL,
	software_artifact_name	varchar(50) NOT NULL,
	software_artifact_type	varchar(50) NOT NULL,
	service_id	integer  NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
ALTER SEQUENCE jazzhands_audit.sw_package_seq  RENAME TO software_artifact_name_seq;
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_name', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_name');
ALTER TABLE software_artifact_name
	ALTER software_artifact_name_id
	SET DEFAULT nextval('jazzhands.software_artifact_name_software_artifact_name_id_seq'::regclass);


-- BEGIN Manually written insert function
INSERT INTO software_artifact_name (
	software_artifact_name_id,	      -- new column (software_artifact_name_id)
	software_artifact_name,	 -- new column (software_artifact_name)
	software_artifact_type,	 -- new column (software_artifact_type)
	service_id,	     -- new column (service_id)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	sw_package_id,
	sw_package_name,	   -- new column (software_artifact_name)
	sw_package_type,	   -- new column (software_artifact_type)
	NULL,	   -- new column (service_id)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM sw_package_v91;


INSERT INTO jazzhands_audit.software_artifact_name (
	software_artifact_name_id,	      -- new column (software_artifact_name_id)
	software_artifact_name,	 -- new column (software_artifact_name)
	software_artifact_type,	 -- new column (software_artifact_type)
	service_id,	     -- new column (service_id)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	sw_package_id,
	sw_package_name,	   -- new column (software_artifact_name)
	sw_package_type,	   -- new column (software_artifact_type)
	NULL,	   -- new column (service_id)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.sw_package_v91;


-- END Manually written insert function
ALTER TABLE jazzhands.software_artifact_name
	ALTER software_artifact_name_id
	SET DEFAULT nextval('jazzhands.software_artifact_name_software_artifact_name_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_name ADD CONSTRAINT ak_software_artifact_name_type UNIQUE (software_artifact_name, software_artifact_type);
ALTER TABLE jazzhands.software_artifact_name ADD CONSTRAINT pk_software_artifact_name PRIMARY KEY (software_artifact_name_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_name IS 'Valid names for artifacts for a service';
COMMENT ON COLUMN jazzhands.software_artifact_name.software_artifact_name IS 'name of the artifact in an artifact system (version is elsewhere)';
COMMENT ON COLUMN jazzhands.software_artifact_name.software_artifact_type IS 'type/format of the artifact';
-- INDEXES
CREATE INDEX xifsvc_artifact_name_service_id ON jazzhands.software_artifact_name USING btree (service_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between software_artifact_name and jazzhands.service_version_artifact
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_artifact
--	ADD CONSTRAINT fk_svc_version_artifact_name
--	FOREIGN KEY (software_artifact_name_id) REFERENCES jazzhands.software_artifact_name(software_artifact_name_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK software_artifact_name and service
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.software_artifact_name
--	ADD CONSTRAINT fk_svc_artifact_name_service_id
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK software_artifact_name and val_software_artifact_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.software_artifact_name
--	ADD CONSTRAINT fk_swpkg_ref_vswpkgtype
--	FOREIGN KEY (software_artifact_type) REFERENCES jazzhands.val_software_artifact_type(software_artifact_type) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_name');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_name  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_name');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_name');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_name');
ALTER SEQUENCE jazzhands.software_artifact_name_software_artifact_name_id_seq
	 OWNED BY software_artifact_name.software_artifact_name_id;
DROP TABLE IF EXISTS sw_package_v91;
DROP TABLE IF EXISTS jazzhands_audit.sw_package_v91;
-- DONE DEALING WITH TABLE software_artifact_name (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old sw_package failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_name');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_name failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_sw_package_type
-- ... renaming to val_software_artifact_type (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_sw_package_type', 'val_software_artifact_type');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_sw_package_type', 'val_software_artifact_type');

-- FOREIGN KEYS FROM
ALTER TABLE software_artifact_name DROP CONSTRAINT IF EXISTS fk_swpkg_ref_vswpkgtype;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_sw_package_type', newobject := 'val_software_artifact_type', newmap := '{"pk_val_sw_package_type":{"columns":["software_artifact_type"],"def":"PRIMARY KEY (software_artifact_type)","deferrable":false,"deferred":false,"name":"pk_val_sw_package_type","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_sw_package_type DROP CONSTRAINT IF EXISTS pk_val_sw_package_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_sw_package_type ON jazzhands.val_sw_package_type;
DROP TRIGGER IF EXISTS trigger_audit_val_sw_package_type ON jazzhands.val_sw_package_type;
DROP FUNCTION IF EXISTS perform_audit_val_sw_package_type();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_sw_package_type', tags := ARRAY['table_val_software_artifact_type']);
---- BEGIN jazzhands_audit.val_sw_package_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_sw_package_type', tags := ARRAY['table_val_software_artifact_type']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_sw_package_type', 'val_software_artifact_type');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_sw_package_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_sw_package_type DROP CONSTRAINT IF EXISTS val_sw_package_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_sw_package_type_pk_val_sw_package_type";
DROP INDEX IF EXISTS "jazzhands_audit"."val_sw_package_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_sw_package_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_sw_package_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_sw_package_type TEARDOWN


ALTER TABLE val_sw_package_type RENAME TO val_sw_package_type_v91;
ALTER TABLE jazzhands_audit.val_sw_package_type RENAME TO val_sw_package_type_v91;

CREATE TABLE jazzhands.val_software_artifact_type
(
	software_artifact_type	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
ALTER SEQUENCE jazzhands_audit.val_sw_package_type_seq  RENAME TO val_software_artifact_type_seq;
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_software_artifact_type', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_software_artifact_type');


-- BEGIN Manually written insert function
INSERT INTO val_software_artifact_type (
        software_artifact_type,         -- new column (software_artifact_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        sw_package_type,           -- new column (software_artifact_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM val_sw_package_type_v91;


INSERT INTO jazzhands_audit.val_software_artifact_type (
        software_artifact_type,         -- new column (software_artifact_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        sw_package_type,           -- new column (software_artifact_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.val_sw_package_type_v91;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_software_artifact_type ADD CONSTRAINT pk_val_sw_package_type PRIMARY KEY (software_artifact_type);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_software_artifact_type IS 'Formats for artifacts';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_software_artifact_type and jazzhands.software_artifact_repository_location
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_location
--	ADD CONSTRAINT fk_sw_artifact_repo_loc_sw_artifact_type
--	FOREIGN KEY (software_artifact_type) REFERENCES jazzhands.val_software_artifact_type(software_artifact_type) DEFERRABLE;

-- consider FK between val_software_artifact_type and jazzhands.software_artifact_name
ALTER TABLE jazzhands.software_artifact_name
	ADD CONSTRAINT fk_swpkg_ref_vswpkgtype
	FOREIGN KEY (software_artifact_type) REFERENCES jazzhands.val_software_artifact_type(software_artifact_type) DEFERRABLE;

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_software_artifact_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_software_artifact_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_software_artifact_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_software_artifact_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_software_artifact_type');
DROP TABLE IF EXISTS val_sw_package_type_v91;
DROP TABLE IF EXISTS jazzhands_audit.val_sw_package_type_v91;
-- DONE DEALING WITH TABLE val_software_artifact_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_software_artifact_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_software_artifact_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_checksum_algorithm (jazzhands)
CREATE TABLE jazzhands.val_checksum_algorithm
(
	checksum_algorithm	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_checksum_algorithm', true);
--
-- Copying initialization data
--

INSERT INTO val_checksum_algorithm (
checksum_algorithm,description
) VALUES
	('none',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_checksum_algorithm ADD CONSTRAINT pk_val_checksum_algorithm PRIMARY KEY (checksum_algorithm);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_checksum_algorithm and jazzhands.service_version_artifact
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_artifact
--	ADD CONSTRAINT fk_svc_version_artifact_algorithma
--	FOREIGN KEY (checksum_algorithm) REFERENCES jazzhands.val_checksum_algorithm(checksum_algorithm) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_checksum_algorithm');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_checksum_algorithm  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_checksum_algorithm');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_checksum_algorithm');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_checksum_algorithm');
-- DONE DEALING WITH TABLE val_checksum_algorithm (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_checksum_algorithm');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_checksum_algorithm failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_checksum_algorithm');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_checksum_algorithm failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_device_management_controller_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_device_management_controller_type', 'val_device_management_controller_type');

-- FOREIGN KEYS FROM
ALTER TABLE device_management_controller DROP CONSTRAINT IF EXISTS fk_dev_mgmt_cntrl_val_ctrl_typ;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_device_management_controller_type', newobject := 'val_device_management_controller_type', newmap := '{"pk_val_device_mgmt_ctrl_type":{"columns":["device_management_controller_type"],"def":"PRIMARY KEY (device_management_controller_type)","deferrable":false,"deferred":false,"name":"pk_val_device_mgmt_ctrl_type","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_device_management_controller_type DROP CONSTRAINT IF EXISTS pk_val_device_mgmt_ctrl_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_device_management_controller_type ON jazzhands.val_device_management_controller_type;
DROP TRIGGER IF EXISTS trigger_audit_val_device_management_controller_type ON jazzhands.val_device_management_controller_type;
DROP FUNCTION IF EXISTS perform_audit_val_device_management_controller_type();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_device_management_controller_type', tags := ARRAY['table_val_device_management_controller_type']);
---- BEGIN jazzhands_audit.val_device_management_controller_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_device_management_controller_type', tags := ARRAY['table_val_device_management_controller_type']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_device_management_controller_type', 'val_device_management_controller_type');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_device_management_controller_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_device_management_controller_type DROP CONSTRAINT IF EXISTS val_device_management_controller_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0val_device_management_controller_type_pk_val_device_mgmt_c";
DROP INDEX IF EXISTS "jazzhands_audit"."val_device_management_controller_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_device_management_controller_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_device_management_controller_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_device_management_controller_type TEARDOWN


ALTER TABLE val_device_management_controller_type RENAME TO val_device_management_controller_type_v91;
ALTER TABLE jazzhands_audit.val_device_management_controller_type RENAME TO val_device_management_controller_type_v91;

CREATE TABLE jazzhands.val_device_management_controller_type
(
	device_management_controller_type	varchar(255) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_device_management_controller_type', false);


-- BEGIN Manually written insert function
INSERT INTO val_device_management_controller_type (
	device_management_controller_type,	      -- renamed column (device_management_controller_type)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	device_mgmt_control_type,	       -- renamed column (device_management_controller_type)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_device_management_controller_type_v91;


INSERT INTO jazzhands_audit.val_device_management_controller_type (
	device_management_controller_type,	      -- renamed column (device_management_controller_type)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	device_mgmt_control_type,	   -- renamed column (device_management_controller_type)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_device_management_controller_type_v91;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_device_management_controller_type ADD CONSTRAINT pk_val_device_mgmt_ctrl_type PRIMARY KEY (device_management_controller_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_device_management_controller_type and jazzhands.device_management_controller
ALTER TABLE jazzhands.device_management_controller
	ADD CONSTRAINT fk_dev_mgmt_cntrl_val_ctrl_typ
	FOREIGN KEY (device_management_control_type) REFERENCES jazzhands.val_device_management_controller_type(device_management_controller_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_device_management_controller_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_device_management_controller_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_device_management_controller_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_device_management_controller_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_device_management_controller_type');
DROP TABLE IF EXISTS val_device_management_controller_type_v91;
DROP TABLE IF EXISTS jazzhands_audit.val_device_management_controller_type_v91;
-- DONE DEALING WITH TABLE val_device_management_controller_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_device_management_controller_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_device_management_controller_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_device_management_controller_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_device_management_controller_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_dns_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_dns_type', 'val_dns_type');

-- FOREIGN KEYS FROM
ALTER TABLE dns_record DROP CONSTRAINT IF EXISTS fk_dnsrecord_vdnstype;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_dns_type', newobject := 'val_dns_type', newmap := '{"pk_val_dns_type":{"columns":["dns_type"],"def":"PRIMARY KEY (dns_type)","deferrable":false,"deferred":false,"name":"pk_val_dns_type","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_dns_type DROP CONSTRAINT IF EXISTS pk_val_dns_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.val_dns_type DROP CONSTRAINT IF EXISTS ckc_id_type_val_dns_;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_dns_type ON jazzhands.val_dns_type;
DROP TRIGGER IF EXISTS trigger_audit_val_dns_type ON jazzhands.val_dns_type;
DROP FUNCTION IF EXISTS perform_audit_val_dns_type();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_dns_type', tags := ARRAY['table_val_dns_type']);
---- BEGIN jazzhands_audit.val_dns_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_dns_type', tags := ARRAY['table_val_dns_type']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_dns_type', 'val_dns_type');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_dns_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_dns_type DROP CONSTRAINT IF EXISTS val_dns_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_dns_type_pk_val_dns_type";
DROP INDEX IF EXISTS "jazzhands_audit"."val_dns_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_dns_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_dns_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_dns_type TEARDOWN


ALTER TABLE val_dns_type RENAME TO val_dns_type_v91;
ALTER TABLE jazzhands_audit.val_dns_type RENAME TO val_dns_type_v91;

CREATE TABLE jazzhands.val_dns_type
(
	dns_type	varchar(50) NOT NULL,
	description	varchar(4096)  NULL,
	id_type	varchar(10) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_dns_type', false);

INSERT INTO val_dns_type (
	dns_type,
	description,
	id_type,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	dns_type,
	description,
	id_type,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_dns_type_v91;


INSERT INTO jazzhands_audit.val_dns_type (
	dns_type,
	description,
	id_type,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	dns_type,
	description,
	id_type,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_dns_type_v91;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_dns_type ADD CONSTRAINT pk_val_dns_type PRIMARY KEY (dns_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.val_dns_type ADD CONSTRAINT ckc_id_type_val_dns_
	CHECK (((id_type)::text = ANY ((ARRAY['ID'::character varying, 'LINK'::character varying, 'NON-ID'::character varying, 'HIDDEN'::character varying])::text[])));

-- FOREIGN KEYS FROM
-- consider FK between val_dns_type and jazzhands.dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsrecord_vdnstype
	FOREIGN KEY (dns_type) REFERENCES jazzhands.val_dns_type(dns_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_dns_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_dns_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_dns_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_dns_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_dns_type');
DROP TABLE IF EXISTS val_dns_type_v91;
DROP TABLE IF EXISTS jazzhands_audit.val_dns_type_v91;
-- DONE DEALING WITH TABLE val_dns_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_dns_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_dns_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_dns_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_dns_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_gender
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_gender', 'val_gender');

-- FOREIGN KEYS FROM
ALTER TABLE person DROP CONSTRAINT IF EXISTS fk_person_gender;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_gender', newobject := 'val_gender', newmap := '{"pk_val_gemder":{"columns":["gender"],"def":"PRIMARY KEY (gender)","deferrable":false,"deferred":false,"name":"pk_val_gemder","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_gender DROP CONSTRAINT IF EXISTS pk_val_gemder;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_gender ON jazzhands.val_gender;
DROP TRIGGER IF EXISTS trigger_audit_val_gender ON jazzhands.val_gender;
DROP FUNCTION IF EXISTS perform_audit_val_gender();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_gender', tags := ARRAY['table_val_gender']);
---- BEGIN jazzhands_audit.val_gender TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_gender', tags := ARRAY['table_val_gender']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_gender', 'val_gender');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_gender');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_gender DROP CONSTRAINT IF EXISTS val_gender_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_gender_pk_val_gemder";
DROP INDEX IF EXISTS "jazzhands_audit"."val_gender_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_gender_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_gender_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_gender TEARDOWN


ALTER TABLE val_gender RENAME TO val_gender_v91;
ALTER TABLE jazzhands_audit.val_gender RENAME TO val_gender_v91;

CREATE TABLE jazzhands.val_gender
(
	gender	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_gender', false);

INSERT INTO val_gender (
	gender,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	gender,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_gender_v91;


INSERT INTO jazzhands_audit.val_gender (
	gender,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	gender,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_gender_v91;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_gender ADD CONSTRAINT pk_val_gemder PRIMARY KEY (gender);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_gender and jazzhands.person
ALTER TABLE jazzhands.person
	ADD CONSTRAINT fk_person_gender
	FOREIGN KEY (gender) REFERENCES jazzhands.val_gender(gender);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_gender');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_gender  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_gender');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_gender');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_gender');
DROP TABLE IF EXISTS val_gender_v91;
DROP TABLE IF EXISTS jazzhands_audit.val_gender_v91;
-- DONE DEALING WITH TABLE val_gender (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_gender');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_gender failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_gender');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_gender failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_layer3_acl_group_type (jazzhands)
CREATE TABLE jazzhands.val_layer3_acl_group_type
(
	layer3_acl_group_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_layer3_acl_group_type', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_layer3_acl_group_type ADD CONSTRAINT pk_val_layer3_acl_group_type PRIMARY KEY (layer3_acl_group_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_layer3_acl_group_type and jazzhands.layer3_acl_group
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.layer3_acl_group
--	ADD CONSTRAINT fk_l3acl_group_val_l3acl_group_type
--	FOREIGN KEY (layer3_acl_group_type) REFERENCES jazzhands.val_layer3_acl_group_type(layer3_acl_group_type) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_layer3_acl_group_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_layer3_acl_group_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_layer3_acl_group_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_layer3_acl_group_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_layer3_acl_group_type');
-- DONE DEALING WITH TABLE val_layer3_acl_group_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_acl_group_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_layer3_acl_group_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_acl_group_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_layer3_acl_group_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_port_range_type (jazzhands)
CREATE TABLE jazzhands.val_port_range_type
(
	port_range_type	varchar(255) NOT NULL,
	protocol	varchar(255) NOT NULL,
	range_permitted	boolean NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_port_range_type', true);
--
-- Copying initialization data
--

INSERT INTO val_port_range_type (
port_range_type,protocol,range_permitted,description
) VALUES
	('services','tcp','0',NULL),
	('services','udp','0',NULL),
	('localservices','tcp','0',NULL),
	('localservices','udp','0',NULL)
;
ALTER TABLE jazzhands.val_port_range_type
	ALTER range_permitted
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_port_range_type ADD CONSTRAINT pk_val_port_range_type PRIMARY KEY (port_range_type, protocol);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifport_range_protocol ON jazzhands.val_port_range_type USING btree (protocol);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_port_range_type and jazzhands.port_range
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.port_range
--	ADD CONSTRAINT fk_port_range_val_port_range_type_port_range_type
--	FOREIGN KEY (port_range_type, protocol) REFERENCES jazzhands.val_port_range_type(port_range_type, protocol) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK val_port_range_type and protocol
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.val_port_range_type
--	ADD CONSTRAINT fk_port_range_protocol
--	FOREIGN KEY (protocol) REFERENCES jazzhands.protocol(protocol) DEFERRABLE;


-- TRIGGERS
-- considering NEW jazzhands.val_port_range_sanity_check
CREATE OR REPLACE FUNCTION jazzhands.val_port_range_sanity_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally INTEGER;
BEGIN
	IF NOT NEW.range_permitted  THEN
		SELECT count(*)
		INTO _tally
		fROM port_range
		WHERE protocol = NEW.protocol
		AND port_range_type = NEW.port_range_type
		AND port_start != port_end;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'Existing %:% have ranges',
				NEW.port_range_type, NEW.protocol
				USING ERRCODE = 'invalid_parameter_value',
				HINT = 'check port_start and port_end on existing records';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.val_port_range_sanity_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_val_port_range_sanity_check AFTER UPDATE OF range_permitted ON jazzhands.val_port_range_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.val_port_range_sanity_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_port_range_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_port_range_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_port_range_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_port_range_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_port_range_type');
-- DONE DEALING WITH TABLE val_port_range_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_port_range_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_port_range_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_port_range_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_port_range_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_property', 'val_property');

-- FOREIGN KEYS FROM
ALTER TABLE property_name_collection_property_name DROP CONSTRAINT IF EXISTS fk_prop_col_propnamtyp;
ALTER TABLE property DROP CONSTRAINT IF EXISTS fk_property_nmtyp;
ALTER TABLE val_property_value DROP CONSTRAINT IF EXISTS fk_valproval_namtyp;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_svcemvcoll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_val_devcol_typ_rstr_dc;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_val_devcoll_id;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_acct_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_comp_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_l2netype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_l3netwok_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_nblk_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_property_dnsdomcolltype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_property_netblkcolltype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valnetrng_val_prop;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_propdttyp;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_proptyp;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_pv_actyp_rst;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_vla_property_val_propcolltype;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_property', newobject := 'val_property', newmap := '{"pk_val_property":{"columns":["property_name","property_type"],"def":"PRIMARY KEY (property_name, property_type)","deferrable":false,"deferred":false,"name":"pk_val_property","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS pk_val_property;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif10val_property";
DROP INDEX IF EXISTS "jazzhands"."xif11val_property";
DROP INDEX IF EXISTS "jazzhands"."xif12val_property";
DROP INDEX IF EXISTS "jazzhands"."xif13val_property";
DROP INDEX IF EXISTS "jazzhands"."xif14val_property";
DROP INDEX IF EXISTS "jazzhands"."xif15val_property";
DROP INDEX IF EXISTS "jazzhands"."xif1val_property";
DROP INDEX IF EXISTS "jazzhands"."xif2val_property";
DROP INDEX IF EXISTS "jazzhands"."xif3val_property";
DROP INDEX IF EXISTS "jazzhands"."xif4val_property";
DROP INDEX IF EXISTS "jazzhands"."xif5val_property";
DROP INDEX IF EXISTS "jazzhands"."xif6val_property";
DROP INDEX IF EXISTS "jazzhands"."xif7val_property";
DROP INDEX IF EXISTS "jazzhands"."xif8val_property";
DROP INDEX IF EXISTS "jazzhands"."xif9val_property";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1034200204;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1063245312;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1315394496;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1338302111;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1430936437;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1430936438;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_151657048;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1581934381;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1987241427;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1994384843;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_2002842082;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_2070965452;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_439888051;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_504174938;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_618591244;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_733000589;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_842506143;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS ckc_val_prop_osid;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_property ON jazzhands.val_property;
DROP TRIGGER IF EXISTS trigger_audit_val_property ON jazzhands.val_property;
DROP FUNCTION IF EXISTS perform_audit_val_property();
DROP TRIGGER IF EXISTS trigger_validate_val_property ON jazzhands.val_property;
DROP TRIGGER IF EXISTS trigger_validate_val_property_after ON jazzhands.val_property;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_property', tags := ARRAY['table_val_property']);
---- BEGIN jazzhands_audit.val_property TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_property', tags := ARRAY['table_val_property']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_property', 'val_property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_property');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_property DROP CONSTRAINT IF EXISTS val_property_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_property_pk_val_property";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_property TEARDOWN


ALTER TABLE val_property RENAME TO val_property_v91;
ALTER TABLE jazzhands_audit.val_property RENAME TO val_property_v91;

CREATE TABLE jazzhands.val_property
(
	property_name	varchar(255) NOT NULL,
	property_type	varchar(50) NOT NULL,
	description	varchar(255)  NULL,
	account_collection_type	varchar(50)  NULL,
	company_collection_type	varchar(50)  NULL,
	device_collection_type	varchar(50)  NULL,
	dns_domain_collection_type	varchar(50)  NULL,
	layer2_network_collection_type	varchar(50)  NULL,
	layer3_network_collection_type	varchar(50)  NULL,
	netblock_collection_type	varchar(50)  NULL,
	network_range_type	varchar(50)  NULL,
	property_name_collection_type	varchar(50)  NULL,
	service_environment_collection_type	varchar(50)  NULL,
	service_version_collection_type	varchar(255)  NULL,
	is_multivalue	boolean NOT NULL,
	property_value_account_collection_type_restriction	varchar(50)  NULL,
	property_value_device_collection_type_restriction	varchar(50)  NULL,
	property_value_netblock_collection_type_restriction	varchar(50)  NULL,
	property_value_service_version_collection_type	varchar(255)  NULL,
	property_data_type	varchar(50) NOT NULL,
	property_value_json_schema	jsonb  NULL,
	permit_account_collection_id	character(10) NOT NULL,
	permit_account_id	character(10) NOT NULL,
	permit_account_realm_id	character(10) NOT NULL,
	permit_company_id	character(10) NOT NULL,
	permit_company_collection_id	character(10) NOT NULL,
	permit_device_collection_id	character(10) NOT NULL,
	permit_dns_domain_collection_id	character(10) NOT NULL,
	permit_layer2_network_collection_id	character(10) NOT NULL,
	permit_layer3_network_collection_id	character(10) NOT NULL,
	permit_netblock_collection_id	character(10) NOT NULL,
	permit_network_range_id	character(10) NOT NULL,
	permit_operating_system_id	character(10) NOT NULL,
	permit_operating_system_snapshot_id	character(10) NOT NULL,
	permit_property_name_collection_id	character(10) NOT NULL,
	permit_service_environment_collection_id	character(10) NOT NULL,
	permit_service_version_collection_id	character(10) NOT NULL,
	permit_site_code	character(10) NOT NULL,
	permit_x509_signed_certificate_id	character(10) NOT NULL,
	permit_property_rank	character(10) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_property', false);
ALTER TABLE val_property
	ALTER is_multivalue
	SET DEFAULT false;
ALTER TABLE val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_dns_domain_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_layer2_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_layer3_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_operating_system_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_property_name_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_service_environment_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_service_version_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_x509_signed_certificate_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

INSERT INTO val_property (
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	service_version_collection_type,		-- new column (service_version_collection_type)
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_value_service_version_collection_type,		-- new column (property_value_service_version_collection_type)
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection_id,		-- new column (permit_service_environment_collection_id)
	permit_service_version_collection_id,		-- new column (permit_service_version_collection_id)
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	NULL,		-- new column (service_version_collection_type)
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	NULL,		-- new column (property_value_service_version_collection_type)
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	'PROHIBITED'::bpchar,		-- new column (permit_service_environment_collection_id)
	'PROHIBITED'::bpchar,		-- new column (permit_service_version_collection_id)
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_property_v91;


INSERT INTO jazzhands_audit.val_property (
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	service_version_collection_type,		-- new column (service_version_collection_type)
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_value_service_version_collection_type,		-- new column (property_value_service_version_collection_type)
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection_id,		-- new column (permit_service_environment_collection_id)
	permit_service_version_collection_id,		-- new column (permit_service_version_collection_id)
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	NULL,		-- new column (service_version_collection_type)
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	NULL,		-- new column (property_value_service_version_collection_type)
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	NULL,		-- new column (permit_service_environment_collection_id)
	NULL,		-- new column (permit_service_version_collection_id)
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_property_v91;

ALTER TABLE jazzhands.val_property
	ALTER is_multivalue
	SET DEFAULT false;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_dns_domain_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_layer2_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_layer3_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_operating_system_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_property_name_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_service_environment_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_service_version_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_x509_signed_certificate_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_property ADD CONSTRAINT pk_val_property PRIMARY KEY (property_name, property_type);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_property IS 'valid values and attributes for (name,type) pairs in the property table.  This defines how triggers enforce aspects of the property table';
COMMENT ON COLUMN jazzhands.val_property.property_name IS 'property name for validation purposes';
COMMENT ON COLUMN jazzhands.val_property.property_type IS 'property type for validation purposes';
COMMENT ON COLUMN jazzhands.val_property.account_collection_type IS 'type restriction of the account_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.company_collection_type IS 'type restriction of company_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.device_collection_type IS 'type restriction of device_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.dns_domain_collection_type IS 'type restriction of dns_domain_collection_id restriction on LHS';
COMMENT ON COLUMN jazzhands.val_property.netblock_collection_type IS 'type restriction of netblock_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.property_name_collection_type IS 'type restriction of property_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.service_environment_collection_type IS 'type restriction of service_enviornment_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.is_multivalue IS 'If N, acts like an alternate key on property.(lhs,property_name,property_type)';
COMMENT ON COLUMN jazzhands.val_property.property_value_account_collection_type_restriction IS 'if property_value is account_collection_Id, this limits the account_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_value_device_collection_type_restriction IS 'if property_value is devicet_collection_Id, this limits the devicet_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_value_netblock_collection_type_restriction IS 'if property_value isnetblockt_collection_Id, this limits the netblockt_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_data_type IS 'which, if any, of the property_table_* columns should be used for this value.   May turn more complex enforcement via trigger';
COMMENT ON COLUMN jazzhands.val_property.permit_account_collection_id IS 'defines permissibility/requirement of account_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_account_id IS 'defines permissibility/requirement of account_idon LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_account_realm_id IS 'defines permissibility/requirement of account_realm_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_company_id IS 'defines permissibility/requirement of company_id on LHS of property.  *NOTE*  THIS COLUMN WILL BE REMOVED IN >0.65';
COMMENT ON COLUMN jazzhands.val_property.permit_company_collection_id IS 'defines permissibility/requirement of company_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_device_collection_id IS 'defines permissibility/requirement of device_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_dns_domain_collection_id IS 'defines permissibility/requirement of dns_domain_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_layer2_network_collection_id IS 'defines permissibility/requirement of layer2_network_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_layer3_network_collection_id IS 'defines permissibility/requirement of layer3_network_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_netblock_collection_id IS 'defines permissibility/requirement of netblock_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_operating_system_id IS 'defines permissibility/requirement of operating_system_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_operating_system_snapshot_id IS 'defines permissibility/requirement of operating_system_snapshot_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_property_name_collection_id IS 'defines permissibility/requirement of property_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_service_environment_collection_id IS 'defines permissibility/requirement of service_env_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_site_code IS 'defines permissibility/requirement of site_code on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_property_rank IS 'defines permissibility of property_rank, and if it should be part of the "lhs" of the given property';
-- INDEXES
CREATE INDEX xif10val_property ON jazzhands.val_property USING btree (netblock_collection_type);
CREATE INDEX xif12val_property ON jazzhands.val_property USING btree (service_environment_collection_type);
CREATE INDEX xif13val_property ON jazzhands.val_property USING btree (layer3_network_collection_type);
CREATE INDEX xif14val_property ON jazzhands.val_property USING btree (layer2_network_collection_type);
CREATE INDEX xif15val_property ON jazzhands.val_property USING btree (network_range_type);
CREATE INDEX xif1val_property ON jazzhands.val_property USING btree (property_data_type);
CREATE INDEX xif2val_property ON jazzhands.val_property USING btree (property_type);
CREATE INDEX xif3val_property ON jazzhands.val_property USING btree (property_value_account_collection_type_restriction);
CREATE INDEX xif4val_property ON jazzhands.val_property USING btree (property_value_netblock_collection_type_restriction);
CREATE INDEX xif5val_property ON jazzhands.val_property USING btree (property_value_device_collection_type_restriction);
CREATE INDEX xif6val_property ON jazzhands.val_property USING btree (account_collection_type);
CREATE INDEX xif7val_property ON jazzhands.val_property USING btree (company_collection_type);
CREATE INDEX xif8val_property ON jazzhands.val_property USING btree (device_collection_type);
CREATE INDEX xif9val_property ON jazzhands.val_property USING btree (dns_domain_collection_type);
CREATE INDEX xifval_prop_pv_svc_version_collection_type ON jazzhands.val_property USING btree (property_value_service_version_collection_type);
CREATE INDEX xifval_prop_svc_version_collection_type ON jazzhands.val_property USING btree (service_version_collection_type);
CREATE INDEX xifval_property_val_propcolltype ON jazzhands.val_property USING btree (property_name_collection_type);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1034200204
	CHECK ((permit_account_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1063245312
	CHECK ((permit_property_rank = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1279907540
	CHECK ((permit_service_environment_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1315394496
	CHECK ((permit_operating_system_snapshot_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1430936437
	CHECK ((permit_layer2_network_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1430936438
	CHECK ((permit_layer3_network_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_151657048
	CHECK ((permit_account_realm_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1581934381
	CHECK ((permit_property_name_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1987241427
	CHECK ((permit_account_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1994384843
	CHECK ((permit_netblock_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_2002842082
	CHECK ((permit_company_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_2070965452
	CHECK ((permit_device_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_439888051
	CHECK ((permit_dns_domain_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_504174938
	CHECK ((permit_network_range_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_618591244
	CHECK ((permit_x509_signed_certificate_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_733000589
	CHECK ((permit_company_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_842506143
	CHECK ((permit_site_code = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT ckc_val_prop_osid
	CHECK ((permit_operating_system_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));

-- FOREIGN KEYS FROM
-- consider FK between val_property and jazzhands.property_name_collection_property_name
ALTER TABLE jazzhands.property_name_collection_property_name
	ADD CONSTRAINT fk_prop_col_propnamtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK between val_property and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nmtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK between val_property and jazzhands.val_property_value
ALTER TABLE jazzhands.val_property_value
	ADD CONSTRAINT fk_valproval_namtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);

-- FOREIGN KEYS TO
-- consider FK val_property and val_service_environment_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_svcemvcoll_type
	FOREIGN KEY (service_environment_collection_type) REFERENCES jazzhands.val_service_environment_collection_type(service_environment_collection_type);
-- consider FK val_property and val_device_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_val_devcol_typ_rstr_dc
	FOREIGN KEY (property_value_device_collection_type_restriction) REFERENCES jazzhands.val_device_collection_type(device_collection_type);
-- consider FK val_property and val_device_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_val_devcoll_id
	FOREIGN KEY (device_collection_type) REFERENCES jazzhands.val_device_collection_type(device_collection_type);
-- consider FK val_property and val_account_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_acct_coll_type
	FOREIGN KEY (account_collection_type) REFERENCES jazzhands.val_account_collection_type(account_collection_type);
-- consider FK val_property and val_company_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_comp_coll_type
	FOREIGN KEY (company_collection_type) REFERENCES jazzhands.val_company_collection_type(company_collection_type);
-- consider FK val_property and val_layer2_network_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_l2netype
	FOREIGN KEY (layer2_network_collection_type) REFERENCES jazzhands.val_layer2_network_collection_type(layer2_network_collection_type);
-- consider FK val_property and val_layer3_network_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_l3netwok_type
	FOREIGN KEY (layer3_network_collection_type) REFERENCES jazzhands.val_layer3_network_collection_type(layer3_network_collection_type);
-- consider FK val_property and val_netblock_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_nblk_coll_type
	FOREIGN KEY (property_value_netblock_collection_type_restriction) REFERENCES jazzhands.val_netblock_collection_type(netblock_collection_type);
-- consider FK val_property and val_service_version_collection_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.val_property
--	ADD CONSTRAINT fk_val_prop_pv_svc_version_collection_type
--	FOREIGN KEY (property_value_service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type);

-- consider FK val_property and val_service_version_collection_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.val_property
--	ADD CONSTRAINT fk_val_prop_svc_version_collection_type
--	FOREIGN KEY (service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type);

-- consider FK val_property and val_dns_domain_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_property_dnsdomcolltype
	FOREIGN KEY (dns_domain_collection_type) REFERENCES jazzhands.val_dns_domain_collection_type(dns_domain_collection_type);
-- consider FK val_property and val_netblock_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_property_netblkcolltype
	FOREIGN KEY (netblock_collection_type) REFERENCES jazzhands.val_netblock_collection_type(netblock_collection_type);
-- consider FK val_property and val_property_name_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_property_val_propcolltype
	FOREIGN KEY (property_name_collection_type) REFERENCES jazzhands.val_property_name_collection_type(property_name_collection_type);
-- consider FK val_property and val_network_range_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valnetrng_val_prop
	FOREIGN KEY (network_range_type) REFERENCES jazzhands.val_network_range_type(network_range_type);
-- consider FK val_property and val_property_data_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_propdttyp
	FOREIGN KEY (property_data_type) REFERENCES jazzhands.val_property_data_type(property_data_type);
-- consider FK val_property and val_property_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_proptyp
	FOREIGN KEY (property_type) REFERENCES jazzhands.val_property_type(property_type);
-- consider FK val_property and val_account_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_pv_actyp_rst
	FOREIGN KEY (property_value_account_collection_type_restriction) REFERENCES jazzhands.val_account_collection_type(account_collection_type);

-- TRIGGERS
-- considering NEW jazzhands.validate_val_property
CREATE OR REPLACE FUNCTION jazzhands.validate_val_property()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	IF NEW.property_data_type = 'json' AND NEW.property_value_json_schema IS NULL THEN
		RAISE 'property_data_type json requires a schema to be set'
			USING ERRCODE = 'invalid_parameter_value';
	ELSIF NEW.property_data_type != 'json' AND NEW.property_value_json_schema IS NOT NULL THEN
		RAISE 'property_data_type % may not have a json schema set',
			NEW.property_data_type
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF TG_OP = 'UPDATE' AND OLD.property_data_type != NEW.property_data_type THEN
		SELECT	count(*)
		INTO	_tally
		WHERE	property_name = NEW.property_name
		AND		property_type = NEW.property_type;

		IF _tally > 0  THEN
			RAISE 'May not change property type if there are existing proeprties'
				USING ERRCODE = 'foreign_key_violation';

		END IF;
	END IF;

	IF TG_OP = 'INSERT' AND NEW.permit_company_id != 'PROHIBITED' OR
		( TG_OP = 'UPDATE' AND NEW.permit_company_id != 'PROHIBITED' AND
			OLD.permit_company_id IS DISTINCT FROM NEW.permit_company_id )
	THEN
		RAISE 'property.company_id is being retired.  Please use per-company collections'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.validate_val_property() FROM public;
CREATE TRIGGER trigger_validate_val_property BEFORE INSERT OR UPDATE OF property_data_type, property_value_json_schema, permit_company_id ON jazzhands.val_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_val_property();

-- considering NEW jazzhands.validate_val_property_after
CREATE OR REPLACE FUNCTION jazzhands.validate_val_property_after()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	property%ROWTYPE;
BEGIN
	FOR _r IN SELECT * FROM property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type
	LOOP
		PERFORM property_utils.validate_property(_r);
	END LOOP;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.validate_val_property_after() FROM public;
CREATE CONSTRAINT TRIGGER trigger_validate_val_property_after AFTER UPDATE ON jazzhands.val_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_val_property_after();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_property');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_property');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_property');
DROP TABLE IF EXISTS val_property_v91;
DROP TABLE IF EXISTS jazzhands_audit.val_property_v91;
-- DONE DEALING WITH TABLE val_property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_affinity (jazzhands)
CREATE TABLE jazzhands.val_service_affinity
(
	service_affinity	varchar(255) NOT NULL,
	service_affinity_rank	integer NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_affinity', true);
--
-- Copying initialization data
--

INSERT INTO val_service_affinity (
service_affinity,service_affinity_rank,description
) VALUES
	('device','100',NULL),
	('parent_device','200',NULL),
	('rack','300',NULL),
	('rack_row','400',NULL),
	('site','500',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_affinity ADD CONSTRAINT ak_val_svc_affinity_rank UNIQUE (service_affinity_rank);
ALTER TABLE jazzhands.val_service_affinity ADD CONSTRAINT pk_val_service_affinity PRIMARY KEY (service_affinity);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_service_affinity IS 'Possible affinities for service dependencies.   Gives hints as to how to deploy automatically.';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_affinity and jazzhands.service_sla
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_sla
--	ADD CONSTRAINT fk_service_sla_maximum_affinity
--	FOREIGN KEY (maximum_service_affinity) REFERENCES jazzhands.val_service_affinity(service_affinity) DEFERRABLE;

-- consider FK between val_service_affinity and jazzhands.service_sla
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_sla
--	ADD CONSTRAINT fk_service_sla_minimum_affinity
--	FOREIGN KEY (minimum_service_affinity) REFERENCES jazzhands.val_service_affinity(service_affinity) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_affinity');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_affinity  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_affinity');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_affinity');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_affinity');
-- DONE DEALING WITH TABLE val_service_affinity (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_affinity');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_affinity failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_affinity');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_affinity failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_endpoint_provider_collection_type (jazzhands)
CREATE TABLE jazzhands.val_service_endpoint_provider_collection_type
(
	service_endpoint_provider_collection_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	max_num_members	integer  NULL,
	max_num_collections	integer  NULL,
	can_have_hierarchy	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_collection_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_endpoint_provider_collection_type (
service_endpoint_provider_collection_type,description,max_num_members,max_num_collections,can_have_hierarchy
) VALUES
	('per-service-endpoint-provider',NULL,'1',NULL,'0')
;
ALTER TABLE jazzhands.val_service_endpoint_provider_collection_type
	ALTER can_have_hierarchy
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_endpoint_provider_collection_type ADD CONSTRAINT pk_val_service_endpoint_provider_collection_type PRIMARY KEY (service_endpoint_provider_collection_type);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.val_service_endpoint_provider_collection_type.can_have_hierarchy IS 'This column exists for consistency and possible future expansion.  There is no hier table at the time of this writing.';
-- INDEXES

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.val_service_endpoint_provider_collection_type ADD CONSTRAINT ckc_require_false_1211256172
	CHECK ((can_have_hierarchy = false));

-- FOREIGN KEYS FROM
-- consider FK between val_service_endpoint_provider_collection_type and jazzhands.service_endpoint_provider_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_collection
--	ADD CONSTRAINT fk_servce_endpoint_provider_collection_val_type
--	FOREIGN KEY (service_endpoint_provider_collection_type) REFERENCES jazzhands.val_service_endpoint_provider_collection_type(service_endpoint_provider_collection_type) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_endpoint_provider_collection_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_endpoint_provider_collection_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_endpoint_provider_collection_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_collection_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_collection_type');
-- DONE DEALING WITH TABLE val_service_endpoint_provider_collection_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_endpoint_provider_collection_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_endpoint_provider_collection_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_endpoint_provider_collection_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_endpoint_provider_collection_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_endpoint_provider_type (jazzhands)
CREATE TABLE jazzhands.val_service_endpoint_provider_type
(
	service_endpoint_provider_type	varchar(255) NOT NULL,
	maximum_members	integer  NULL,
	translates_addresses	boolean NOT NULL,
	proxies_connections	boolean NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_endpoint_provider_type (
service_endpoint_provider_type,maximum_members,translates_addresses,proxies_connections,description
) VALUES
	('direct',NULL,'0','0',NULL),
	('loadbalancer',NULL,'0','1',NULL),
	('ecmp',NULL,'0','0',NULL)
;
ALTER TABLE jazzhands.val_service_endpoint_provider_type
	ALTER translates_addresses
	SET DEFAULT false;
ALTER TABLE jazzhands.val_service_endpoint_provider_type
	ALTER proxies_connections
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_endpoint_provider_type ADD CONSTRAINT pk_val_service_endpoint_provider_type PRIMARY KEY (service_endpoint_provider_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_endpoint_provider_type and jazzhands.service_endpoint_provider
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider
--	ADD CONSTRAINT fk_svc_endpoint_provider_val_type
--	FOREIGN KEY (service_endpoint_provider_type) REFERENCES jazzhands.val_service_endpoint_provider_type(service_endpoint_provider_type) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_endpoint_provider_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_endpoint_provider_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_endpoint_provider_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_endpoint_provider_type');
-- DONE DEALING WITH TABLE val_service_endpoint_provider_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_endpoint_provider_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_endpoint_provider_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_endpoint_provider_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_endpoint_provider_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_feature (jazzhands)
CREATE TABLE jazzhands.val_service_feature
(
	service_feature	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_feature', true);
--
-- Copying initialization data
--

INSERT INTO val_service_feature (
service_feature,description
) VALUES
	('read',NULL),
	('write',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_feature ADD CONSTRAINT pk_val_service_feature PRIMARY KEY (service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_service_feature IS 'Valid features names.  Whether or not they are permited for a given service is handled elsewhere';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_feature and jazzhands.service_depend_service_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_depend_service_feature
--	ADD CONSTRAINT fk_svc_depend_service_feature_service_feature
--	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;

-- consider FK between val_service_feature and jazzhands.service_endpoint_service_sla_service_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_service_sla_service_feature
--	ADD CONSTRAINT fk_svc_endpoint_svc_sla_service_feature_feature
--	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;

-- consider FK between val_service_feature and jazzhands.service_instance_provided_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_instance_provided_feature
--	ADD CONSTRAINT fk_svc_inst_prov_feature_feature
--	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;

-- consider FK between val_service_feature and jazzhands.service_version_collection_permitted_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_permitted_feature
--	ADD CONSTRAINT fk_svc_ver_call_permitted_feature
--	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_feature');
-- DONE DEALING WITH TABLE val_service_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_source_control_purpose (jazzhands)
CREATE TABLE jazzhands.val_service_source_control_purpose
(
	service_source_control_purpose	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_source_control_purpose', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_source_control_purpose ADD CONSTRAINT pk_val_service_source_control_purpose PRIMARY KEY (service_source_control_purpose);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_service_source_control_purpose IS 'Describes business purpose of source repository location';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_source_control_purpose and jazzhands.source_repository_location
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_location
--	ADD CONSTRAINT fk_src_repo_location_purpose
--	FOREIGN KEY (service_source_control_purpose) REFERENCES jazzhands.val_service_source_control_purpose(service_source_control_purpose) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_source_control_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_source_control_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_source_control_purpose');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_source_control_purpose');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_source_control_purpose');
-- DONE DEALING WITH TABLE val_service_source_control_purpose (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_source_control_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_source_control_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_source_control_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_source_control_purpose failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_type (jazzhands)
CREATE TABLE jazzhands.val_service_type
(
	service_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_type (
service_type,description
) VALUES
	('network',NULL),
	('socket',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_type ADD CONSTRAINT pk_val_service_type PRIMARY KEY (service_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_type and jazzhands.service
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service
--	ADD CONSTRAINT fk_service_service_type
--	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;

-- consider FK between val_service_type and jazzhands.service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version
--	ADD CONSTRAINT fk_svc_version_service_type
--	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_type');
-- DONE DEALING WITH TABLE val_service_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_version_collection_type (jazzhands)
CREATE TABLE jazzhands.val_service_version_collection_type
(
	service_version_collection_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	max_num_members	integer  NULL,
	max_num_collections	integer  NULL,
	can_have_hierarchy	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_version_collection_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_version_collection_type (
service_version_collection_type,description,max_num_members,max_num_collections,can_have_hierarchy
) VALUES
	('current-services',NULL,NULL,NULL,'0'),
	('all-services',NULL,NULL,NULL,'0')
;
ALTER TABLE jazzhands.val_service_version_collection_type
	ALTER can_have_hierarchy
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_version_collection_type ADD CONSTRAINT pk_val_service_version_collection_type PRIMARY KEY (service_version_collection_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_version_collection_type and jazzhands.service_version_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection
--	ADD CONSTRAINT fk_service_version_collection_val_collection_type
--	FOREIGN KEY (service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type) DEFERRABLE;

-- consider FK between val_service_version_collection_type and jazzhands.val_property
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_pv_svc_version_collection_type
	FOREIGN KEY (property_value_service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type);
-- consider FK between val_service_version_collection_type and jazzhands.val_property
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_svc_version_collection_type
	FOREIGN KEY (service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_version_collection_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_version_collection_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_version_collection_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_version_collection_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_version_collection_type');
-- DONE DEALING WITH TABLE val_service_version_collection_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_version_collection_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_version_collection_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_version_collection_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_version_collection_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_software_artifact_relationship (jazzhands)
CREATE TABLE jazzhands.val_software_artifact_relationship
(
	software_artifact_relationship	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_software_artifact_relationship', true);
--
-- Copying initialization data
--

INSERT INTO val_software_artifact_relationship (
software_artifact_relationship,description
) VALUES
	('depend',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_software_artifact_relationship ADD CONSTRAINT pk_val_software_artifact_relationship PRIMARY KEY (software_artifact_relationship);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_software_artifact_relationship and jazzhands.software_artifact_repository_relation
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_relation
--	ADD CONSTRAINT fk_sw_artifact_repo_relation_realtionship
--	FOREIGN KEY (software_artifact_relationship) REFERENCES jazzhands.val_software_artifact_relationship(software_artifact_relationship) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_software_artifact_relationship');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_software_artifact_relationship  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_software_artifact_relationship');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_software_artifact_relationship');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_software_artifact_relationship');
-- DONE DEALING WITH TABLE val_software_artifact_relationship (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_software_artifact_relationship');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_software_artifact_relationship failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_software_artifact_relationship');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_software_artifact_relationship failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_source_repository_method (jazzhands)
CREATE TABLE jazzhands.val_source_repository_method
(
	source_repository_method	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_source_repository_method', true);
--
-- Copying initialization data
--

INSERT INTO val_source_repository_method (
source_repository_method,description
) VALUES
	('git',NULL),
	('svn',NULL),
	('cvs',NULL),
	('mercurial',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_source_repository_method ADD CONSTRAINT pk_val_source_repository_method PRIMARY KEY (source_repository_method);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_source_repository_method and jazzhands.source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository
--	ADD CONSTRAINT fk_src_repo_src_repo_method
--	FOREIGN KEY (source_repository_method) REFERENCES jazzhands.val_source_repository_method(source_repository_method) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_source_repository_method');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_source_repository_method  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_source_repository_method');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_source_repository_method');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_source_repository_method');
-- DONE DEALING WITH TABLE val_source_repository_method (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_method');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_source_repository_method failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_method');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_source_repository_method failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_source_repository_url_purpose (jazzhands)
CREATE TABLE jazzhands.val_source_repository_url_purpose
(
	source_repository_url_purpose	varchar(50) NOT NULL,
	description	varchar(50)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_source_repository_url_purpose', true);
--
-- Copying initialization data
--

INSERT INTO val_source_repository_url_purpose (
source_repository_url_purpose,description
) VALUES
	('checkout',NULL),
	('browse',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_source_repository_url_purpose ADD CONSTRAINT pk_val_source_repository_url_purpose PRIMARY KEY (source_repository_url_purpose);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_source_repository_url_purpose and jazzhands.source_repository_url
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_url
--	ADD CONSTRAINT fk_src_repo_url_url_purpose
--	FOREIGN KEY (source_repository_url_purpose) REFERENCES jazzhands.val_source_repository_url_purpose(source_repository_url_purpose) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_source_repository_url_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_source_repository_url_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_source_repository_url_purpose');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_source_repository_url_purpose');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_source_repository_url_purpose');
-- DONE DEALING WITH TABLE val_source_repository_url_purpose (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_url_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_source_repository_url_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_url_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_source_repository_url_purpose failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE account_authentication_log
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'account_authentication_log', 'account_authentication_log');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.account_authentication_log DROP CONSTRAINT IF EXISTS fk_acctauthlog_accid;
ALTER TABLE jazzhands.account_authentication_log DROP CONSTRAINT IF EXISTS fk_auth_resource;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'account_authentication_log', newobject := 'account_authentication_log', newmap := '{"pk_account_auth_log":{"columns":["account_id","account_authentication_timestamp","authentication_resource","account_authentication_seq"],"def":"PRIMARY KEY (account_id, account_authentication_timestamp, authentication_resource, account_authentication_seq)","deferrable":false,"deferred":false,"name":"pk_account_auth_log","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.account_authentication_log DROP CONSTRAINT IF EXISTS pk_account_auth_log;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xieacctauthlog_ts_arsrc";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_account_authentication_log ON jazzhands.account_authentication_log;
DROP TRIGGER IF EXISTS trigger_audit_account_authentication_log ON jazzhands.account_authentication_log;
DROP FUNCTION IF EXISTS perform_audit_account_authentication_log();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'account_authentication_log', tags := ARRAY['table_account_authentication_log']);
---- BEGIN jazzhands_audit.account_authentication_log TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'account_authentication_log', tags := ARRAY['table_account_authentication_log']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'account_authentication_log', 'account_authentication_log');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'account_authentication_log');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.account_authentication_log DROP CONSTRAINT IF EXISTS account_authentication_log_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."account_authentication_log_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."account_authentication_log_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."account_authentication_log_aud#txid_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_account_authentication_log_pk_account_auth_log";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.account_authentication_log TEARDOWN


ALTER TABLE account_authentication_log RENAME TO account_authentication_log_v91;
ALTER TABLE jazzhands_audit.account_authentication_log RENAME TO account_authentication_log_v91;

CREATE TABLE jazzhands.account_authentication_log
(
	account_id	integer NOT NULL,
	account_authentication_timestamp	timestamp without time zone NOT NULL,
	authentication_resource	varchar(50) NOT NULL,
	account_authentication_seq	integer NOT NULL,
	was_authentication_successful	boolean NOT NULL,
	authentication_resource_instance	varchar(50) NOT NULL,
	authentication_origin	varchar(50) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'account_authentication_log', false);

INSERT INTO account_authentication_log (
	account_id,
	account_authentication_timestamp,
	authentication_resource,
	account_authentication_seq,
	was_authentication_successful,
	authentication_resource_instance,
	authentication_origin,
	data_ins_user,
	data_ins_date
) SELECT
	account_id,
	account_authentication_timestamp,
	authentication_resource,
	account_authentication_seq,
	was_authentication_successful,
	authentication_resource_instance,
	authentication_origin,
	data_ins_user,
	data_ins_date
FROM account_authentication_log_v91;


INSERT INTO jazzhands_audit.account_authentication_log (
	account_id,
	account_authentication_timestamp,
	authentication_resource,
	account_authentication_seq,
	was_authentication_successful,
	authentication_resource_instance,
	authentication_origin,
	data_ins_user,
	data_ins_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	account_id,
	account_authentication_timestamp,
	authentication_resource,
	account_authentication_seq,
	was_authentication_successful,
	authentication_resource_instance,
	authentication_origin,
	data_ins_user,
	data_ins_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.account_authentication_log_v91;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.account_authentication_log ADD CONSTRAINT pk_account_auth_log PRIMARY KEY (account_id, account_authentication_timestamp, authentication_resource, account_authentication_seq);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.account_authentication_log IS 'Captures all system user authorizations for access to Vonage resources.';
COMMENT ON COLUMN jazzhands.account_authentication_log.account_authentication_seq IS 'This sequence is to support table PK with timestamps recived rounded to the secend and generating duplicates.';
COMMENT ON COLUMN jazzhands.account_authentication_log.authentication_resource_instance IS 'Keeps track of the server where a user was authenticating for a given resource';
COMMENT ON COLUMN jazzhands.account_authentication_log.authentication_origin IS 'Keeps track of where the request for authentication originated from.';
-- INDEXES
CREATE INDEX xieacctauthlog_ts_arsrc ON jazzhands.account_authentication_log USING btree (account_authentication_timestamp, authentication_resource);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK account_authentication_log and account
ALTER TABLE jazzhands.account_authentication_log
	ADD CONSTRAINT fk_acctauthlog_accid
	FOREIGN KEY (account_id) REFERENCES jazzhands.account(account_id);
-- consider FK account_authentication_log and val_authentication_resource
ALTER TABLE jazzhands.account_authentication_log
	ADD CONSTRAINT fk_auth_resource
	FOREIGN KEY (authentication_resource) REFERENCES jazzhands.val_authentication_resource(authentication_resource);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('account_authentication_log');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for account_authentication_log  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'account_authentication_log');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'account_authentication_log');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'account_authentication_log');
DROP TABLE IF EXISTS account_authentication_log_v91;
DROP TABLE IF EXISTS jazzhands_audit.account_authentication_log_v91;
-- DONE DEALING WITH TABLE account_authentication_log (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_authentication_log');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old account_authentication_log failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_authentication_log');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new account_authentication_log failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE approval_process_chain
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'approval_process_chain', 'approval_process_chain');

-- FOREIGN KEYS FROM
ALTER TABLE approval_process DROP CONSTRAINT IF EXISTS fk_app_proc_1st_app_proc_chnid;
ALTER TABLE approval_instance_step DROP CONSTRAINT IF EXISTS fk_appinststep_app_prcchnid;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_appproc_chn_resp_period;
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_apprchn_app_proc_chn;
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_apprchn_rej_proc_chn;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'approval_process_chain', newobject := 'approval_process_chain', newmap := '{"pk_approval_process_chain":{"columns":["approval_process_chain_id"],"def":"PRIMARY KEY (approval_process_chain_id)","deferrable":false,"deferred":false,"name":"pk_approval_process_chain","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS pk_approval_process_chain;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1approval_process_chain";
DROP INDEX IF EXISTS "jazzhands"."xif2approval_process_chain";
DROP INDEX IF EXISTS "jazzhands"."xif3approval_process_chain";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_approval_process_chain ON jazzhands.approval_process_chain;
DROP TRIGGER IF EXISTS trigger_audit_approval_process_chain ON jazzhands.approval_process_chain;
DROP FUNCTION IF EXISTS perform_audit_approval_process_chain();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'approval_process_chain', tags := ARRAY['table_approval_process_chain']);
---- BEGIN jazzhands_audit.approval_process_chain TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'approval_process_chain', tags := ARRAY['table_approval_process_chain']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'approval_process_chain', 'approval_process_chain');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'approval_process_chain');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.approval_process_chain DROP CONSTRAINT IF EXISTS approval_process_chain_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#txid_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_approval_process_chain_pk_approval_process_chain";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.approval_process_chain TEARDOWN


ALTER TABLE approval_process_chain RENAME TO approval_process_chain_v91;
ALTER TABLE jazzhands_audit.approval_process_chain RENAME TO approval_process_chain_v91;

CREATE TABLE jazzhands.approval_process_chain
(
	approval_process_chain_id	integer NOT NULL,
	approval_process_chain_name	varchar(50) NOT NULL,
	approval_chain_response_period	varchar(50)  NULL,
	description	varchar(255)  NULL,
	message	varchar(4096)  NULL,
	email_message	varchar(4096)  NULL,
	email_subject_prefix	varchar(50)  NULL,
	email_subject_suffix	varchar(50)  NULL,
	max_escalation_level	integer  NULL,
	escalation_delay	integer  NULL,
	escalation_reminder_gap	integer  NULL,
	approving_entity	varchar(50)  NULL,
	refresh_all_data	boolean NOT NULL,
	accept_approval_process_chain_id	integer  NULL,
	reject_approval_process_chain_id	integer  NULL,
	permit_immediate_resolution	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'approval_process_chain', false);
ALTER TABLE approval_process_chain
	ALTER approval_process_chain_id
	SET DEFAULT nextval('jazzhands.approval_process_chain_approval_process_chain_id_seq'::regclass);
ALTER TABLE approval_process_chain
	ALTER approval_chain_response_period
	SET DEFAULT '1 week'::character varying;
ALTER TABLE approval_process_chain
	ALTER refresh_all_data
	SET DEFAULT false;
ALTER TABLE approval_process_chain
	ALTER permit_immediate_resolution
	SET DEFAULT false;

INSERT INTO approval_process_chain (
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM approval_process_chain_v91;


INSERT INTO jazzhands_audit.approval_process_chain (
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.approval_process_chain_v91;

ALTER TABLE jazzhands.approval_process_chain
	ALTER approval_process_chain_id
	SET DEFAULT nextval('jazzhands.approval_process_chain_approval_process_chain_id_seq'::regclass);
ALTER TABLE jazzhands.approval_process_chain
	ALTER approval_chain_response_period
	SET DEFAULT '1 week'::character varying;
ALTER TABLE jazzhands.approval_process_chain
	ALTER refresh_all_data
	SET DEFAULT false;
ALTER TABLE jazzhands.approval_process_chain
	ALTER permit_immediate_resolution
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.approval_process_chain ADD CONSTRAINT pk_approval_process_chain PRIMARY KEY (approval_process_chain_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.approval_process_chain.permit_immediate_resolution IS 'Approval functions are permitted toshort circuit to completed regardless of the existnace of an accept or reject.  Used for situations where the approval/request chagne process are in a stalemate.';
-- INDEXES
CREATE INDEX xif1approval_process_chain ON jazzhands.approval_process_chain USING btree (approval_chain_response_period);
CREATE INDEX xif2approval_process_chain ON jazzhands.approval_process_chain USING btree (accept_approval_process_chain_id);
CREATE INDEX xif3approval_process_chain ON jazzhands.approval_process_chain USING btree (accept_approval_process_chain_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between approval_process_chain and jazzhands.approval_process
ALTER TABLE jazzhands.approval_process
	ADD CONSTRAINT fk_app_proc_1st_app_proc_chnid
	FOREIGN KEY (first_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);
-- consider FK between approval_process_chain and jazzhands.approval_instance_step
ALTER TABLE jazzhands.approval_instance_step
	ADD CONSTRAINT fk_appinststep_app_prcchnid
	FOREIGN KEY (approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);

-- FOREIGN KEYS TO
-- consider FK approval_process_chain and val_approval_chain_response_period
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_appproc_chn_resp_period
	FOREIGN KEY (approval_chain_response_period) REFERENCES jazzhands.val_approval_chain_response_period(approval_chain_response_period);
-- consider FK approval_process_chain and approval_process_chain
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_apprchn_app_proc_chn
	FOREIGN KEY (accept_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);
-- consider FK approval_process_chain and approval_process_chain
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_apprchn_rej_proc_chn
	FOREIGN KEY (accept_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('approval_process_chain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for approval_process_chain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'approval_process_chain');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'approval_process_chain');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'approval_process_chain');
ALTER SEQUENCE jazzhands.approval_process_chain_approval_process_chain_id_seq
	 OWNED BY approval_process_chain.approval_process_chain_id;
DROP TABLE IF EXISTS approval_process_chain_v91;
DROP TABLE IF EXISTS jazzhands_audit.approval_process_chain_v91;
-- DONE DEALING WITH TABLE approval_process_chain (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old approval_process_chain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new approval_process_chain failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE dns_record
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'dns_record', 'dns_record');

-- FOREIGN KEYS FROM
ALTER TABLE device DROP CONSTRAINT IF EXISTS fk_device_id_dnsrecord;
ALTER TABLE dns_record_relation DROP CONSTRAINT IF EXISTS fk_dns_rec_ref_dns_rec_rltn;
ALTER TABLE dns_record_relation DROP CONSTRAINT IF EXISTS fk_dnsrec_ref_dnsrecrltn_rl_id;
ALTER TABLE network_service DROP CONSTRAINT IF EXISTS fk_netsvc_dnsid_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dns_rec_ip_universe;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dns_record_vdnsclass;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsid_dnsdom_id;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsid_nblk_id;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsrec_vdnssrvsrvc;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsrecord_vdnstype;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsvalref_dns_recid;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_ref_dnsrec_dnserc;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'dns_record', newobject := 'dns_record', newmap := '{"ak_dns_record_dnsrec_domainid":{"columns":["dns_record_id","dns_domain_id"],"def":"UNIQUE (dns_record_id, dns_domain_id)","deferrable":false,"deferred":false,"name":"ak_dns_record_dnsrec_domainid","type":"u"},"pk_dns_record":{"columns":["dns_record_id"],"def":"PRIMARY KEY (dns_record_id)","deferrable":false,"deferred":false,"name":"pk_dns_record","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS ak_dns_record_dnsrec_domainid;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS pk_dns_record;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_dns_record_lower_dns_name";
DROP INDEX IF EXISTS "jazzhands"."idx_dnsrec_dnsclass";
DROP INDEX IF EXISTS "jazzhands"."idx_dnsrec_dnssrvservice";
DROP INDEX IF EXISTS "jazzhands"."xif_dns_rec_ip_universe";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsid_dnsdom_id";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsid_nblk_id";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsrecord_vdnstype";
DROP INDEX IF EXISTS "jazzhands"."xif_ref_dnsrec_dnserc";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS ckc_dns_srv_protocol_dns_reco;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_dns_record ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_audit_dns_record ON jazzhands.dns_record;
DROP FUNCTION IF EXISTS perform_audit_dns_record();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_dns_record ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_a_rec_validation ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_non_a_rec_validation ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_rec_prevent_dups ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_check_name ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_cname_checker ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_enabled_check ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_update_nontime ON jazzhands.dns_record;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'dns_record', tags := ARRAY['table_dns_record']);
---- BEGIN jazzhands_audit.dns_record TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'dns_record', tags := ARRAY['table_dns_record']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'dns_record', 'dns_record');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'dns_record');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.dns_record DROP CONSTRAINT IF EXISTS dns_record_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_record_ak_dns_record_dnsrec_domainid";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_record_pk_dns_record";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.dns_record TEARDOWN


ALTER TABLE dns_record RENAME TO dns_record_v91;
ALTER TABLE jazzhands_audit.dns_record RENAME TO dns_record_v91;

CREATE TABLE jazzhands.dns_record
(
	dns_record_id	integer NOT NULL,
	dns_name	varchar(255)  NULL,
	dns_domain_id	integer NOT NULL,
	dns_ttl	integer  NULL,
	dns_class	varchar(50) NOT NULL,
	dns_type	varchar(50) NOT NULL,
	dns_value	varchar(512)  NULL,
	dns_priority	integer  NULL,
	dns_srv_service	varchar(50)  NULL,
	dns_srv_protocol	varchar(4)  NULL,
	dns_srv_weight	integer  NULL,
	dns_srv_port	integer  NULL,
	netblock_id	integer  NULL,
	ip_universe_id	integer NOT NULL,
	reference_dns_record_id	integer  NULL,
	dns_value_record_id	integer  NULL,
	should_generate_ptr	boolean NOT NULL,
	external_id	varchar(255)  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'dns_record', false);
ALTER TABLE dns_record
	ALTER dns_record_id
	SET DEFAULT nextval('jazzhands.dns_record_dns_record_id_seq'::regclass);
ALTER TABLE dns_record
	ALTER dns_class
	SET DEFAULT 'IN'::character varying;
ALTER TABLE dns_record
	ALTER should_generate_ptr
	SET DEFAULT true;
ALTER TABLE dns_record
	ALTER is_enabled
	SET DEFAULT true;

INSERT INTO dns_record (
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM dns_record_v91;


INSERT INTO jazzhands_audit.dns_record (
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.dns_record_v91;

ALTER TABLE jazzhands.dns_record
	ALTER dns_record_id
	SET DEFAULT nextval('jazzhands.dns_record_dns_record_id_seq'::regclass);
ALTER TABLE jazzhands.dns_record
	ALTER dns_class
	SET DEFAULT 'IN'::character varying;
ALTER TABLE jazzhands.dns_record
	ALTER should_generate_ptr
	SET DEFAULT true;
ALTER TABLE jazzhands.dns_record
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT ak_dns_record_dnsrec_domainid UNIQUE (dns_record_id, dns_domain_id);
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT pk_dns_record PRIMARY KEY (dns_record_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.dns_record.dns_value IS 'free form text value to be used for the value, if appropriate.';
COMMENT ON COLUMN jazzhands.dns_record.netblock_id IS 'netblock_id that contains the IP address that is the value of this dns record';
COMMENT ON COLUMN jazzhands.dns_record.reference_dns_record_id IS 'pointer to another dns record that provides the name (must be in the same domain)';
COMMENT ON COLUMN jazzhands.dns_record.dns_value_record_id IS 'points to another dns record that provides the value, how that works depends on the type';
COMMENT ON COLUMN jazzhands.dns_record.should_generate_ptr IS 'only valid for A/AAAA records, automatically manage the PTR record for the IP address';
COMMENT ON COLUMN jazzhands.dns_record.external_id IS 'unique identifer in external system that maps to this record';
-- INDEXES
CREATE INDEX idx_dns_record_lower_dns_name ON jazzhands.dns_record USING btree (lower(dns_name::text));
CREATE INDEX idx_dnsrec_dnsclass ON jazzhands.dns_record USING btree (dns_class);
CREATE INDEX idx_dnsrec_dnssrvservice ON jazzhands.dns_record USING btree (dns_srv_service);
CREATE INDEX xif_dns_rec_ip_universe ON jazzhands.dns_record USING btree (ip_universe_id);
CREATE INDEX xif_dnsid_dnsdom_id ON jazzhands.dns_record USING btree (dns_domain_id);
CREATE INDEX xif_dnsid_nblk_id ON jazzhands.dns_record USING btree (netblock_id);
CREATE INDEX xif_dnsrecord_vdnstype ON jazzhands.dns_record USING btree (dns_type);
CREATE INDEX xif_ref_dnsrec_dnserc ON jazzhands.dns_record USING btree (reference_dns_record_id, dns_domain_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT ckc_dns_srv_protocol_dns_reco
	CHECK (((dns_srv_protocol IS NULL) OR (((dns_srv_protocol)::text = ANY ((ARRAY['tcp'::character varying, 'udp'::character varying])::text[])) AND ((dns_srv_protocol)::text = lower((dns_srv_protocol)::text)))));

-- FOREIGN KEYS FROM
-- consider FK between dns_record and jazzhands.device
ALTER TABLE jazzhands.device
	ADD CONSTRAINT fk_device_id_dnsrecord
	FOREIGN KEY (identifying_dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;
-- consider FK between dns_record and jazzhands.dns_record_relation
ALTER TABLE jazzhands.dns_record_relation
	ADD CONSTRAINT fk_dns_rec_ref_dns_rec_rltn
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK between dns_record and jazzhands.dns_record_relation
ALTER TABLE jazzhands.dns_record_relation
	ADD CONSTRAINT fk_dnsrec_ref_dnsrecrltn_rl_id
	FOREIGN KEY (related_dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK between dns_record and jazzhands.network_service
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_dnsid_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK between dns_record and jazzhands.service_endpoint
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint
--	ADD CONSTRAINT fk_service_endpoint_dns_rec_id
--	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;

-- consider FK between dns_record and jazzhands.service_endpoint_provider
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider
--	ADD CONSTRAINT fk_service_endpoint_provider_dns_record_id
--	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK dns_record and ip_universe
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dns_rec_ip_universe
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK dns_record and val_dns_class
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dns_record_vdnsclass
	FOREIGN KEY (dns_class) REFERENCES jazzhands.val_dns_class(dns_class);
-- consider FK dns_record and dns_domain
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsid_dnsdom_id
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK dns_record and netblock
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsid_nblk_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK dns_record and val_dns_srv_service
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsrec_vdnssrvsrvc
	FOREIGN KEY (dns_srv_service) REFERENCES jazzhands.val_dns_srv_service(dns_srv_service);
-- consider FK dns_record and val_dns_type
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsrecord_vdnstype
	FOREIGN KEY (dns_type) REFERENCES jazzhands.val_dns_type(dns_type);
-- consider FK dns_record and dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsvalref_dns_recid
	FOREIGN KEY (dns_value_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK dns_record and dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_ref_dnsrec_dnserc
	FOREIGN KEY (reference_dns_record_id, dns_domain_id) REFERENCES jazzhands.dns_record(dns_record_id, dns_domain_id);

-- TRIGGERS
-- considering NEW jazzhands.check_ip_universe_dns_record
CREATE OR REPLACE FUNCTION jazzhands.check_ip_universe_dns_record()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nb	integer[];
BEGIN
	IF TG_OP = 'UPDATE' THEN
		IF NEW.netblock_id != OLD.netblock_id THEN
			nb = ARRAY[OLD.netblock_id, NEW.netblock_id];
		ELSE
			nb = ARRAY[NEW.netblock_id];
		END IF;
	ELSE
		nb = ARRAY[NEW.netblock_id];
	END IF;

	PERFORM *
	FROM netblock
	WHERE netblock_id = ANY(nb)
	AND ip_universe_id != NEW.ip_universe_id;

	IF FOUND THEN
		RAISE EXCEPTION
			'IP Universes for dns_records must match dns records and netblocks'
			USING ERRCODE = 'foreign_key_violation';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.check_ip_universe_dns_record() FROM public;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_dns_record AFTER INSERT OR UPDATE OF dns_record_id, ip_universe_id ON jazzhands.dns_record DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_ip_universe_dns_record();

-- considering NEW jazzhands.dns_a_rec_validation
CREATE OR REPLACE FUNCTION jazzhands.dns_a_rec_validation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ip		netblock.ip_address%type;
	_sing	netblock.is_single_address%type;
BEGIN

	--
	-- arguably, this belongs elsewhere in a non-"validation" trigger,
	-- but that only matters if this wants to be a constraint trigger.
	--
	IF NEW.ip_universe_id IS NULL THEN
		IF NEW.netblock_id IS NOT NULL THEN
			SELECT ip_universe_id INTO NEW.ip_universe_id
			FROM netblock
			WHERE netblock_id = NEW.netblock_id;
		ELSIF NEW.dns_value_record_id IS NOT NULL THEN
			SELECT ip_universe_id INTO NEW.ip_universe_id
			FROM dns_record
			WHERE dns_record_id = NEW.dns_value_record_id;
		ELSE
			-- old default.
			NEW.ip_universe_id = 0;
		END IF;
	END IF;

/*
	IF NEW.dns_type NOT IN ('A', 'AAAA', 'REVERSE_ZONE_BLOCK_PTR') THEN
		IF NEW.netblock_id IS NOT NULL THEN
			RAISE EXCEPTION 'Attempt to set % record with netblock',
				NEW.dns_type
				USING ERRCODE = 'not_null_violation';
		END IF;
		IF TG_OP = 'INSERT' THEN
			RETURN NEW;
		ELSIF TG_OP = 'UPDATE' AND
			OLD.dns_type IS NOT DISTINCT FROM NEW.dns_type
		THEN
			RETURN NEW;
		END IF;
	END IF;
 */

	IF NEW.dns_type in ('A', 'AAAA') THEN
		IF ( NEW.netblock_id IS NULL AND NEW.dns_value_record_id IS NULL ) THEN
			RAISE EXCEPTION 'Attempt to set % record without netblocks',
				NEW.dns_type
				USING ERRCODE = 'not_null_violation';
		ELSIF NEW.dns_value_record_id IS NOT NULL THEN
			PERFORM *
			FROM dns_record d
			WHERE d.dns_record_id = NEW.dns_value_record_id
			AND d.dns_type = NEW.dns_type
			AND d.dns_class = NEW.dns_class;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'Attempt to set % value record without the correct netblock',
					NEW.dns_type
					USING ERRCODE = 'not_null_violation';
			END IF;
		END IF;

		IF ( NEW.should_generate_ptr = true AND NEW.dns_value_record_id IS NOT NULL ) THEN
			RAISE EXCEPTION 'It is not permitted to set should_generate_ptr and use a dns_value_record_id'
				USING ERRCODE = 'foreign_key_violation';
		END IF;
	END IF;

	IF NEW.netblock_Id is not NULL and
			( NEW.dns_value IS NOT NULL OR NEW.dns_value_record_id IS NOT NULL ) THEN
		RAISE EXCEPTION 'Both dns_value and netblock_id may not be set'
			USING ERRCODE = 'JH001';
	END IF;

	IF NEW.dns_value IS NOT NULL AND NEW.dns_value_record_id IS NOT NULL THEN
		RAISE EXCEPTION 'Both dns_value and dns_value_record_id may not be set'
			USING ERRCODE = 'JH001';
	END IF;

	-- XXX need to deal with changing a netblock type and breaking dns_record..
	IF NEW.netblock_id IS NOT NULL THEN
		SELECT ip_address, is_single_address
		  INTO _ip, _sing
		  FROM netblock
		 WHERE netblock_id = NEW.netblock_id;

		IF NEW.dns_type = 'A' AND family(_ip) != '4' THEN
			RAISE EXCEPTION 'A records must be assigned to non-IPv4 records'
				USING ERRCODE = 'JH200';
		END IF;

		IF NEW.dns_type = 'AAAA' AND family(_ip) != '6' THEN
			RAISE EXCEPTION 'AAAA records must be assigned to non-IPv6 records'
				USING ERRCODE = 'JH200';
		END IF;

		IF _sing = false AND NEW.dns_type IN ('A','AAAA') THEN
			RAISE EXCEPTION 'Non-single addresses may not have % records', NEW.dns_type
				USING ERRCODE = 'foreign_key_violation';
		END IF;

	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_a_rec_validation() FROM public;
CREATE TRIGGER trigger_dns_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_a_rec_validation();

-- considering NEW jazzhands.dns_non_a_rec_validation
CREATE OR REPLACE FUNCTION jazzhands.dns_non_a_rec_validation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ip		netblock.ip_address%type;
BEGIN
	IF NEW.dns_type NOT in ('A', 'AAAA', 'REVERSE_ZONE_BLOCK_PTR') AND
			( NEW.dns_value IS NULL AND NEW.dns_value_record_id IS NULL ) THEN
		RAISE EXCEPTION 'Attempt to set % record without a value',
			NEW.dns_type
			USING ERRCODE = 'not_null_violation';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_non_a_rec_validation() FROM public;
CREATE TRIGGER trigger_dns_non_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_non_a_rec_validation();

-- considering NEW jazzhands.dns_rec_prevent_dups
CREATE OR REPLACE FUNCTION jazzhands.dns_rec_prevent_dups()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	-- should not be able to insert the same record(s) twice
	SELECT	count(*)
		INTO	_tally
		FROM (
			SELECT
					db.dns_record_id,
					coalesce(ref.dns_name, db.dns_name) as dns_name,
					db.dns_domain_id, db.dns_ttl,
					db.dns_class, db.dns_type,
					coalesce(val.dns_value, db.dns_value) AS dns_value,
					db.dns_priority, db.dns_srv_service, db.dns_srv_protocol,
					db.dns_srv_weight, db.dns_srv_port, db.ip_universe_id,
					coalesce(val.netblock_id, db.netblock_id) AS netblock_id,
					db.reference_dns_record_id, db.dns_value_record_id,
					db.should_generate_ptr, db.is_enabled
				FROM dns_record db
					LEFT JOIN (
							SELECT dns_record_id AS reference_dns_record_id,
									dns_name
							FROM dns_record
							WHERE dns_domain_id = NEW.dns_domain_id
						) ref USING (reference_dns_record_id)
					LEFT JOIN (
							SELECT dns_record_id AS dns_value_record_id,
									dns_value, netblock_id
							FROM dns_record
						) val USING (dns_value_record_id)
				WHERE db.dns_record_id != NEW.dns_record_id
				AND (lower(coalesce(ref.dns_name, db.dns_name))
							IS NOT DISTINCT FROM lower(NEW.dns_name))
				AND ( db.dns_domain_id = NEW.dns_domain_id )
				AND ( db.dns_class = NEW.dns_class )
				AND ( db.dns_type = NEW.dns_type )
				AND db.dns_srv_service IS NOT DISTINCT FROM NEW.dns_srv_service
				AND db.dns_srv_protocol IS NOT DISTINCT FROM NEW.dns_srv_protocol
				AND db.dns_srv_port IS NOT DISTINCT FROM NEW.dns_srv_port
				AND db.ip_universe_id IS NOT DISTINCT FROM NEW.ip_universe_id
				AND db.is_enabled = true
			) dns
			LEFT JOIN dns_record val
				ON ( NEW.dns_value_record_id = val.dns_record_id )
		WHERE
			dns.dns_domain_id = NEW.dns_domain_id
		AND
			dns.dns_value IS NOT DISTINCT FROM
				coalesce(val.dns_value, NEW.dns_value)
		AND
			dns.netblock_id IS NOT DISTINCT FROM
				coalesce(val.netblock_id, NEW.netblock_id)
	;

	IF _tally != 0 THEN
		RAISE EXCEPTION 'Attempt to insert the same dns record - % %', _tally,
			NEW USING ERRCODE = 'unique_violation';
	END IF;

	IF NEW.DNS_TYPE = 'A' OR NEW.DNS_TYPE = 'AAAA' THEN
		IF NEW.SHOULD_GENERATE_PTR = true THEN
			SELECT	count(*)
			 INTO	_tally
			 FROM	dns_record
			WHERE dns_class = 'IN'
			AND dns_type = 'A'
			AND should_generate_ptr = true
			AND is_enabled = true
			AND netblock_id = NEW.NETBLOCK_ID
			AND dns_record_id != NEW.DNS_RECORD_ID;

			IF _tally != 0 THEN
				RAISE EXCEPTION 'May not have more than one SHOULD_GENERATE_PTR record on the same IP on netblock_id %', NEW.netblock_id
					USING ERRCODE = 'JH201';
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_rec_prevent_dups() FROM public;
CREATE CONSTRAINT TRIGGER trigger_dns_rec_prevent_dups AFTER INSERT OR UPDATE ON jazzhands.dns_record NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_rec_prevent_dups();

-- considering NEW jazzhands.dns_record_check_name
CREATE OR REPLACE FUNCTION jazzhands.dns_record_check_name()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.DNS_NAME IS NOT NULL THEN
		-- rfc rfc952
		IF NEW.DNS_NAME ~ '[^-a-zA-Z0-9\._\*]+' THEN
			RAISE EXCEPTION 'Invalid DNS NAME %',
				NEW.DNS_NAME
				USING ERRCODE = 'integrity_constraint_violation';
		END IF;

		-- PTRs on wildcard records break thing and make no sense.
		IF NEW.DNS_NAME ~ '\*' AND NEW.SHOULD_GENERATE_PTR = true THEN
			RAISE EXCEPTION 'Wildcard DNS Record % can not have auto-set PTR',
				NEW.DNS_NAME
				USING ERRCODE = 'integrity_constraint_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_record_check_name() FROM public;
CREATE TRIGGER trigger_dns_record_check_name BEFORE INSERT OR UPDATE OF dns_name, should_generate_ptr ON jazzhands.dns_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_record_check_name();

-- considering NEW jazzhands.dns_record_cname_checker
CREATE OR REPLACE FUNCTION jazzhands.dns_record_cname_checker()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
	_d		RECORD;
	_dom	TEXT;
BEGIN
	--- XXX - need to seriously think about ip_universes here.
	-- These should also move to the v_dns view once it's cached.  They were
	-- there before, but it was too slow here.

	SELECT dns_name, dns_domain_id, dns_class,
		COUNT(*) FILTER (WHERE dns_type = 'CNAME') AS num_cnames,
		COUNT(*) FILTER (WHERE dns_type != 'CNAME') AS num_not_cnames
	INTO _r
	FROM	(
		SELECT dns_name, dns_domain_id, dns_type, dns_class, ip_universe_id
			FROM dns_record
			WHERE reference_dns_record_id IS NULL
			AND is_enabled = 'Y'
		UNION ALL
		SELECT ref.dns_name, d.dns_domain_id, d.dns_type, d.dns_class,
				d.ip_universe_id
			FROM dns_record d
			JOIN dns_record ref
				ON ref.dns_record_id = d.reference_dns_record_id
			WHERE d.is_enabled = 'Y'
	) smash
	WHERE lower(dns_name) IS NOT DISTINCT FROM lower(NEW.dns_name)
	AND dns_domain_id = NEW.dns_domain_id
	-- AND ip_universe_id = NEW.ip_universe_id
	-- AND dns_class = NEW.dns_class
	GROUP BY 1, 2, 3;

	IF ( _r.num_cnames > 0 AND _r.num_not_cnames > 0 ) OR _r.num_cnames > 1 THEN
		SELECT dns_domain_name INTO _dom FROM dns_domain
		WHERE dns_domain_id = NEW.dns_domain_id ;

		if NEW.dns_name IS NULL THEN
			RAISE EXCEPTION '% may not have CNAME and other records (%/%)',
				_dom, _r.num_cnames, _r.num_not_cnames
				USING ERRCODE = 'unique_violation';
		ELSE
			RAISE EXCEPTION '%.% may not have CNAME and other records (%/%)',
				NEW.dns_name, _dom, _r.num_cnames, _r.num_not_cnames
				USING ERRCODE = 'unique_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_record_cname_checker() FROM public;
CREATE CONSTRAINT TRIGGER trigger_dns_record_cname_checker AFTER INSERT OR UPDATE OF dns_class, dns_type, dns_name, dns_domain_id, is_enabled ON jazzhands.dns_record NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_record_cname_checker();

-- considering NEW jazzhands.dns_record_enabled_check
CREATE OR REPLACE FUNCTION jazzhands.dns_record_enabled_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF new.IS_ENABLED = false THEN
		PERFORM *
		FROM dns_record
		WHERE dns_value_record_id = NEW.dns_record_id
		OR reference_dns_record_id = NEW.dns_record_id;

		IF FOUND THEN
			RAISE EXCEPTION 'Can not disabled records referred to by other enabled records.'
				USING ERRCODE = 'JH001';
		END IF;
	END IF;

	IF new.IS_ENABLED = true THEN
		PERFORM *
		FROM dns_record
		WHERE ( NEW.dns_value_record_id = dns_record_id
				OR NEW.reference_dns_record_id = dns_record_id
		) AND is_enabled = false;

		IF FOUND THEN
			RAISE EXCEPTION 'Can not enable records referencing disabled records.'
				USING ERRCODE = 'JH001';
		END IF;
	END IF;


	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_record_enabled_check() FROM public;
CREATE TRIGGER trigger_dns_record_enabled_check BEFORE INSERT OR UPDATE OF is_enabled ON jazzhands.dns_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_record_enabled_check();

-- considering NEW jazzhands.dns_record_update_nontime
CREATE OR REPLACE FUNCTION jazzhands.dns_record_update_nontime()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_dnsdomainid	DNS_DOMAIN.DNS_DOMAIN_ID%type;
	_ipaddr			NETBLOCK.IP_ADDRESS%type;
	_mkold			boolean;
	_mknew			boolean;
	_mkdom			boolean;
	_mkip			boolean;
BEGIN
	_mkold = false;
	_mkold = false;
	_mknew = true;

	IF TG_OP = 'DELETE' THEN
		_mknew := false;
		_mkold := true;
		_mkdom := true;
		if  OLD.netblock_id is not null  THEN
			_mkip := true;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		_mkold := false;
		_mkdom := true;
		if  NEW.netblock_id is not null  THEN
			_mkip := true;
		END IF;
	ELSIF TG_OP = 'UPDATE' THEN
		IF OLD.DNS_DOMAIN_ID != NEW.DNS_DOMAIN_ID THEN
			_mkold := true;
			_mkip := true;
		END IF;
		_mkdom := true;

		IF OLD.dns_name IS DISTINCT FROM NEW.dns_name THEN
			_mknew := true;
			IF NEW.DNS_TYPE = 'A' OR NEW.DNS_TYPE = 'AAAA' THEN
				IF NEW.SHOULD_GENERATE_PTR = true THEN
					_mkip := true;
				END IF;
			END IF;
		END IF;

		IF OLD.SHOULD_GENERATE_PTR != NEW.SHOULD_GENERATE_PTR THEN
			_mkold := true;
			_mkip := true;
		END IF;

		IF (OLD.netblock_id IS DISTINCT FROM NEW.netblock_id) THEN
			_mkold := true;
			_mknew := true;
			_mkip := true;
		END IF;
	END IF;

	if _mkold THEN
		IF _mkdom THEN
			_dnsdomainid := OLD.dns_domain_id;
		ELSE
			_dnsdomainid := NULL;
		END IF;
		if _mkip and OLD.netblock_id is not NULL THEN
			SELECT	ip_address
			  INTO	_ipaddr
			  FROM	netblock
			 WHERE	netblock_id  = OLD.netblock_id;
		ELSE
			_ipaddr := NULL;
		END IF;
		insert into DNS_CHANGE_RECORD
			(dns_domain_id, ip_address) VALUES (_dnsdomainid, _ipaddr);
	END IF;
	if _mknew THEN
		if _mkdom THEN
			_dnsdomainid := NEW.dns_domain_id;
		ELSE
			_dnsdomainid := NULL;
		END IF;
		if _mkip and NEW.netblock_id is not NULL THEN
			SELECT	ip_address
			  INTO	_ipaddr
			  FROM	netblock
			 WHERE	netblock_id  = NEW.netblock_id;
		ELSE
			_ipaddr := NULL;
		END IF;
		insert into DNS_CHANGE_RECORD
			(dns_domain_id, ip_address) VALUES (_dnsdomainid, _ipaddr);
	END IF;

	--
	-- deal with records pointing to this one.  only values are done because
	-- references are forced by ak to be in the same zone.
	IF TG_OP = 'INSERT' THEN
		INSERT INTO dns_change_record (dns_domain_id)
			SELECT DISTINCT dns_domain_id
			FROM dns_record
			WHERE dns_value_record_id = NEW.dns_record_id
			AND dns_domain_id != NEW.dns_domain_id;
	ELSIF TG_OP = 'UPDATE' THEN
		INSERT INTO dns_change_record (dns_domain_id)
			SELECT DISTINCT dns_domain_id
			FROM dns_record
			WHERE dns_value_record_id = NEW.dns_record_id
			AND dns_domain_id NOT IN (OLD.dns_domain_id, NEW.dns_domain_id);
	END IF;

	IF TG_OP = 'DELETE' THEN
		return OLD;
	END IF;
	return NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.dns_record_update_nontime() FROM public;
CREATE TRIGGER trigger_dns_record_update_nontime AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_record_update_nontime();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('dns_record');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for dns_record  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'dns_record');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'dns_record');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'dns_record');
ALTER SEQUENCE jazzhands.dns_record_dns_record_id_seq
	 OWNED BY dns_record.dns_record_id;
DROP TABLE IF EXISTS dns_record_v91;
DROP TABLE IF EXISTS jazzhands_audit.dns_record_v91;
-- DONE DEALING WITH TABLE dns_record (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old dns_record failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new dns_record failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE ip_universe
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'ip_universe', 'ip_universe');

-- FOREIGN KEYS FROM
ALTER TABLE dns_record DROP CONSTRAINT IF EXISTS fk_dns_rec_ip_universe;
ALTER TABLE dns_change_record DROP CONSTRAINT IF EXISTS fk_dnschgrec_ip_universe;
ALTER TABLE dns_domain_ip_universe DROP CONSTRAINT IF EXISTS fk_dnsdom_ipu_ipu;
ALTER TABLE ip_universe_visibility DROP CONSTRAINT IF EXISTS fk_ip_universe_vis_ip_univ;
ALTER TABLE ip_universe_visibility DROP CONSTRAINT IF EXISTS fk_ip_universe_vis_ip_univ_vis;
ALTER TABLE netblock DROP CONSTRAINT IF EXISTS fk_nblk_ip_universe_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.ip_universe DROP CONSTRAINT IF EXISTS fk_ip_universe_namespace;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'ip_universe', newobject := 'ip_universe', newmap := '{"ak_ip_universe_name":{"columns":["ip_universe_name"],"def":"UNIQUE (ip_universe_name)","deferrable":false,"deferred":false,"name":"ak_ip_universe_name","type":"u"},"pk_ip_universe":{"columns":["ip_universe_id"],"def":"PRIMARY KEY (ip_universe_id)","deferrable":false,"deferred":false,"name":"pk_ip_universe","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.ip_universe DROP CONSTRAINT IF EXISTS ak_ip_universe_name;
ALTER TABLE jazzhands.ip_universe DROP CONSTRAINT IF EXISTS pk_ip_universe;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1ip_universe";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_ip_universe ON jazzhands.ip_universe;
DROP TRIGGER IF EXISTS trigger_audit_ip_universe ON jazzhands.ip_universe;
DROP FUNCTION IF EXISTS perform_audit_ip_universe();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'ip_universe', tags := ARRAY['table_ip_universe']);
---- BEGIN jazzhands_audit.ip_universe TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'ip_universe', tags := ARRAY['table_ip_universe']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'ip_universe', 'ip_universe');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'ip_universe');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.ip_universe DROP CONSTRAINT IF EXISTS ip_universe_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_ip_universe_ak_ip_universe_name";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_ip_universe_pk_ip_universe";
DROP INDEX IF EXISTS "jazzhands_audit"."ip_universe_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."ip_universe_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."ip_universe_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.ip_universe TEARDOWN


ALTER TABLE ip_universe RENAME TO ip_universe_v91;
ALTER TABLE jazzhands_audit.ip_universe RENAME TO ip_universe_v91;

CREATE TABLE jazzhands.ip_universe
(
	ip_universe_id	integer NOT NULL,
	ip_universe_name	varchar(50) NOT NULL,
	ip_namespace	varchar(50) NOT NULL,
	should_generate_dns	boolean NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'ip_universe', false);
ALTER TABLE ip_universe
	ALTER ip_universe_id
	SET DEFAULT nextval('jazzhands.ip_universe_ip_universe_id_seq'::regclass);

INSERT INTO ip_universe (
	ip_universe_id,
	ip_universe_name,
	ip_namespace,
	should_generate_dns,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	ip_universe_id,
	ip_universe_name,
	ip_namespace,
	should_generate_dns,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM ip_universe_v91;


INSERT INTO jazzhands_audit.ip_universe (
	ip_universe_id,
	ip_universe_name,
	ip_namespace,
	should_generate_dns,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	ip_universe_id,
	ip_universe_name,
	ip_namespace,
	should_generate_dns,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.ip_universe_v91;

ALTER TABLE jazzhands.ip_universe
	ALTER ip_universe_id
	SET DEFAULT nextval('jazzhands.ip_universe_ip_universe_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.ip_universe ADD CONSTRAINT ak_ip_universe_name UNIQUE (ip_universe_name);
ALTER TABLE jazzhands.ip_universe ADD CONSTRAINT pk_ip_universe PRIMARY KEY (ip_universe_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.ip_universe.ip_namespace IS 'defines the namespace for a given ip universe -- all universes in this namespace are considered unique for netblock validations';
COMMENT ON COLUMN jazzhands.ip_universe.should_generate_dns IS 'Indicates if any zones should generated rooted in this universe.   Primarily used to turn off DNS generation for universes that exist as shims between two networks (such as the internet can see, inside can not, for inbound NAT''d addresses).';
-- INDEXES
CREATE INDEX xif1ip_universe ON jazzhands.ip_universe USING btree (ip_namespace);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between ip_universe and jazzhands.dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dns_rec_ip_universe
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK between ip_universe and jazzhands.dns_change_record
ALTER TABLE jazzhands.dns_change_record
	ADD CONSTRAINT fk_dnschgrec_ip_universe
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK between ip_universe and jazzhands.dns_domain_ip_universe
ALTER TABLE jazzhands.dns_domain_ip_universe
	ADD CONSTRAINT fk_dnsdom_ipu_ipu
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK between ip_universe and jazzhands.ip_universe_visibility
ALTER TABLE jazzhands.ip_universe_visibility
	ADD CONSTRAINT fk_ip_universe_vis_ip_univ
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK between ip_universe and jazzhands.ip_universe_visibility
ALTER TABLE jazzhands.ip_universe_visibility
	ADD CONSTRAINT fk_ip_universe_vis_ip_univ_vis
	FOREIGN KEY (visible_ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK between ip_universe and jazzhands.netblock
ALTER TABLE jazzhands.netblock
	ADD CONSTRAINT fk_nblk_ip_universe_id
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);

-- FOREIGN KEYS TO
-- consider FK ip_universe and val_ip_namespace
ALTER TABLE jazzhands.ip_universe
	ADD CONSTRAINT fk_ip_universe_namespace
	FOREIGN KEY (ip_namespace) REFERENCES jazzhands.val_ip_namespace(ip_namespace);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('ip_universe');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for ip_universe  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'ip_universe');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'ip_universe');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'ip_universe');
ALTER SEQUENCE jazzhands.ip_universe_ip_universe_id_seq
	 OWNED BY ip_universe.ip_universe_id;
DROP TABLE IF EXISTS ip_universe_v91;
DROP TABLE IF EXISTS jazzhands_audit.ip_universe_v91;
-- DONE DEALING WITH TABLE ip_universe (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('ip_universe');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old ip_universe failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('ip_universe');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new ip_universe failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE layer3_acl_chain (jazzhands)
CREATE TABLE jazzhands.layer3_acl_chain
(
	layer3_acl_chain_id	integer NOT NULL,
	layer3_acl_group_id	integer NOT NULL,
	layer3_acl_chain_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_acl_chain', true);
ALTER TABLE jazzhands.layer3_acl_chain
	ALTER layer3_acl_chain_id
	SET DEFAULT nextval('jazzhands.layer3_acl_chain_layer3_acl_chain_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_chain ADD CONSTRAINT ak_layer3_acl_chain_chain_id_rank UNIQUE (layer3_acl_chain_id, layer3_acl_chain_rank);
ALTER TABLE jazzhands.layer3_acl_chain ADD CONSTRAINT pk_layer3_acl_chain PRIMARY KEY (layer3_acl_chain_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.layer3_acl_chain IS 'ordered list of groups of rulesthat make up a layer3_acl';
-- INDEXES
CREATE INDEX xifl3_acl_chain_l3acl_group_id ON jazzhands.layer3_acl_chain USING btree (layer3_acl_group_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between layer3_acl_chain and jazzhands.layer3_acl_chain_layer3_interface
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.layer3_acl_chain_layer3_interface
--	ADD CONSTRAINT fk_l3_acl_chain_l3int_l3_acl_chain_id
--	FOREIGN KEY (layer3_acl_chain_id) REFERENCES jazzhands.layer3_acl_chain(layer3_acl_chain_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK layer3_acl_chain and layer3_acl_group
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_acl_chain
--	ADD CONSTRAINT fk_l3_acl_chain_l3acl_group_id
--	FOREIGN KEY (layer3_acl_group_id) REFERENCES jazzhands.layer3_acl_group(layer3_acl_group_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_acl_chain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_acl_chain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_acl_chain');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_acl_chain');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_acl_chain');
ALTER SEQUENCE jazzhands.layer3_acl_chain_layer3_acl_chain_id_seq
	 OWNED BY layer3_acl_chain.layer3_acl_chain_id;
-- DONE DEALING WITH TABLE layer3_acl_chain (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_acl_chain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_acl_chain failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE layer3_acl_chain_layer3_interface (jazzhands)
CREATE TABLE jazzhands.layer3_acl_chain_layer3_interface
(
	layer3_acl_chain_id	integer NOT NULL,
	layer3_interface_id	integer NOT NULL,
	traffic_direction	varchar(50) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_acl_chain_layer3_interface', true);
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface
	ALTER layer3_acl_chain_id
	SET DEFAULT nextval('jazzhands.layer3_acl_chain_layer3_interface_layer3_acl_chain_id_seq'::regclass);
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface
	ALTER layer3_interface_id
	SET DEFAULT nextval('jazzhands.layer3_acl_chain_layer3_interface_layer3_interface_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface ADD CONSTRAINT ak_l3_acl_chain_l3_int_direction UNIQUE (layer3_interface_id, traffic_direction);
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface ADD CONSTRAINT pk_layer3_acl_chain_layer3_interface PRIMARY KEY (layer3_acl_chain_id, layer3_interface_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.layer3_acl_chain_layer3_interface IS 'Mapping of an acl chain to a layer3_interface.  This will go away in favor of layer3_routing_domains.';
-- INDEXES
CREATE INDEX xifl3_acl_chain_l3int_l3_acl_chain_id ON jazzhands.layer3_acl_chain_layer3_interface USING btree (layer3_acl_chain_id);
CREATE INDEX xifl3_acl_chain_l3int_l3intid ON jazzhands.layer3_acl_chain_layer3_interface USING btree (layer3_interface_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK layer3_acl_chain_layer3_interface and layer3_acl_chain
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface
	ADD CONSTRAINT fk_l3_acl_chain_l3int_l3_acl_chain_id
	FOREIGN KEY (layer3_acl_chain_id) REFERENCES jazzhands.layer3_acl_chain(layer3_acl_chain_id) DEFERRABLE;
-- consider FK layer3_acl_chain_layer3_interface and layer3_interface
ALTER TABLE jazzhands.layer3_acl_chain_layer3_interface
	ADD CONSTRAINT fk_l3_acl_chain_l3int_l3intid
	FOREIGN KEY (layer3_interface_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_acl_chain_layer3_interface');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_acl_chain_layer3_interface  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_acl_chain_layer3_interface');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_acl_chain_layer3_interface');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_acl_chain_layer3_interface');
ALTER SEQUENCE jazzhands.layer3_acl_chain_layer3_interface_layer3_acl_chain_id_seq
	 OWNED BY layer3_acl_chain_layer3_interface.layer3_acl_chain_id;
ALTER SEQUENCE jazzhands.layer3_acl_chain_layer3_interface_layer3_interface_id_seq
	 OWNED BY layer3_acl_chain_layer3_interface.layer3_interface_id;
-- DONE DEALING WITH TABLE layer3_acl_chain_layer3_interface (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_chain_layer3_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_acl_chain_layer3_interface failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_chain_layer3_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_acl_chain_layer3_interface failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE layer3_acl_group (jazzhands)
CREATE TABLE jazzhands.layer3_acl_group
(
	layer3_acl_group_id	integer NOT NULL,
	layer3_acl_group_name	varchar(255) NOT NULL,
	layer3_acl_group_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_acl_group', true);
ALTER TABLE jazzhands.layer3_acl_group
	ALTER layer3_acl_group_id
	SET DEFAULT nextval('jazzhands.layer3_acl_group_layer3_acl_group_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_group ADD CONSTRAINT pk_layer3_acl_group PRIMARY KEY (layer3_acl_group_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.layer3_acl_group IS 'Groups of individual layer3 acls';
-- INDEXES
CREATE INDEX xifl3acl_group_val_l3acl_group_type ON jazzhands.layer3_acl_group USING btree (layer3_acl_group_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between layer3_acl_group and jazzhands.layer3_acl_chain
ALTER TABLE jazzhands.layer3_acl_chain
	ADD CONSTRAINT fk_l3_acl_chain_l3acl_group_id
	FOREIGN KEY (layer3_acl_group_id) REFERENCES jazzhands.layer3_acl_group(layer3_acl_group_id) DEFERRABLE;
-- consider FK between layer3_acl_group and jazzhands.layer3_acl_rule
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.layer3_acl_rule
--	ADD CONSTRAINT fk_l3acl_rule_l3acl_group_id
--	FOREIGN KEY (layer3_acl_group_id) REFERENCES jazzhands.layer3_acl_group(layer3_acl_group_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK layer3_acl_group and val_layer3_acl_group_type
ALTER TABLE jazzhands.layer3_acl_group
	ADD CONSTRAINT fk_l3acl_group_val_l3acl_group_type
	FOREIGN KEY (layer3_acl_group_type) REFERENCES jazzhands.val_layer3_acl_group_type(layer3_acl_group_type) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_acl_group');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_acl_group  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_acl_group');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_acl_group');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_acl_group');
ALTER SEQUENCE jazzhands.layer3_acl_group_layer3_acl_group_id_seq
	 OWNED BY layer3_acl_group.layer3_acl_group_id;
-- DONE DEALING WITH TABLE layer3_acl_group (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_group');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_acl_group failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_group');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_acl_group failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE layer3_acl_rule (jazzhands)
CREATE TABLE jazzhands.layer3_acl_rule
(
	layer3_acl_rule_id	integer NOT NULL,
	is_enabled	boolean NOT NULL,
	layer3_acl_group_id	integer NOT NULL,
	layer3_acl_rank	integer NOT NULL,
	service_depend_id	integer  NULL,
	description	varchar(4096)  NULL,
	layer3_acl_action	varchar(255) NOT NULL,
	source_netblock_collection_id	integer NOT NULL,
	source_port_relation_restriction	varchar(50)  NULL,
	source_port_range_id	integer  NULL,
	destination_netblock_collection_id	integer NOT NULL,
	destination_port_relation_restriction	varchar(50)  NULL,
	destination_port_range_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_acl_rule', true);
ALTER TABLE jazzhands.layer3_acl_rule
	ALTER layer3_acl_rule_id
	SET DEFAULT nextval('jazzhands.layer3_acl_rule_layer3_acl_rule_id_seq'::regclass);
ALTER TABLE jazzhands.layer3_acl_rule
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT ak_l3acl_rule_group_rank UNIQUE (layer3_acl_group_id, layer3_acl_rank);
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT pk_layer3_acl_rule PRIMARY KEY (layer3_acl_rule_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.layer3_acl_rule IS 'Access Control Entries for layer3 traffic';
COMMENT ON COLUMN jazzhands.layer3_acl_rule.service_depend_id IS 'indicates that this ACL rule applies to a specific inter-service relationship';
-- INDEXES
CREATE INDEX xifl3acl_rule_l3acl_dst_nblk_collection ON jazzhands.layer3_acl_rule USING btree (destination_netblock_collection_id);
CREATE INDEX xifl3acl_rule_l3acl_dst_port_range ON jazzhands.layer3_acl_rule USING btree (destination_port_range_id);
CREATE INDEX xifl3acl_rule_l3acl_group_id ON jazzhands.layer3_acl_rule USING btree (layer3_acl_group_id);
CREATE INDEX xifl3acl_rule_l3acl_service_depend_id ON jazzhands.layer3_acl_rule USING btree (service_depend_id);
CREATE INDEX xifl3acl_rule_l3acl_src_netblk_collection ON jazzhands.layer3_acl_rule USING btree (source_netblock_collection_id);
CREATE INDEX xifl3acl_rule_l3acl_src_port_range ON jazzhands.layer3_acl_rule USING btree (source_port_range_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT ckc_l3_acl_action
	CHECK (((layer3_acl_action)::text = ANY ((ARRAY['permit'::character varying, 'deny'::character varying])::text[])));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK layer3_acl_rule and netblock_collection
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_nblk_collection
	FOREIGN KEY (destination_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id) DEFERRABLE;
-- consider FK layer3_acl_rule and port_range
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_acl_rule
--	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_port_range
--	FOREIGN KEY (destination_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- consider FK layer3_acl_rule and layer3_acl_group
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_group_id
	FOREIGN KEY (layer3_acl_group_id) REFERENCES jazzhands.layer3_acl_group(layer3_acl_group_id) DEFERRABLE;
-- consider FK layer3_acl_rule and service_layer3_acl
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_acl_rule
--	ADD CONSTRAINT fk_l3acl_rule_l3acl_service_depend_id
--	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_layer3_acl(service_depend_id) DEFERRABLE;

-- consider FK layer3_acl_rule and netblock_collection
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_netblk_collection
	FOREIGN KEY (source_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id) DEFERRABLE;
-- consider FK layer3_acl_rule and port_range
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_acl_rule
--	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_port_range
--	FOREIGN KEY (source_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_acl_rule');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_acl_rule  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_acl_rule');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_acl_rule');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_acl_rule');
ALTER SEQUENCE jazzhands.layer3_acl_rule_layer3_acl_rule_id_seq
	 OWNED BY layer3_acl_rule.layer3_acl_rule_id;
-- DONE DEALING WITH TABLE layer3_acl_rule (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_rule');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_acl_rule failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_rule');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_acl_rule failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE port_range (jazzhands)
CREATE TABLE jazzhands.port_range
(
	port_range_id	integer NOT NULL,
	port_range_name	varchar(255) NOT NULL,
	port_range_type	varchar(255) NOT NULL,
	protocol	varchar(255) NOT NULL,
	port_start	integer NOT NULL,
	port_end	integer NOT NULL,
	is_singleton	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'port_range', true);
--
-- Copying initialization data
--

INSERT INTO port_range (
port_range_id,port_range_name,port_range_type,protocol,port_start,port_end,is_singleton
) VALUES
	(1,'postgresql','services','tcp','5432','5432','1'),
	(2,'http','services','tcp','80','80','1'),
	(3,'https','services','tcp','443','443','1'),
	(4,'domain','services','tcp','53','53','1'),
	(5,'domain','services','udp','53','53','1')
;
ALTER TABLE jazzhands.port_range
	ALTER port_range_id
	SET DEFAULT nextval('jazzhands.port_range_port_range_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.port_range ADD CONSTRAINT ak_port_range_name_type_protocol UNIQUE (port_range_name, port_range_type, protocol);
ALTER TABLE jazzhands.port_range ADD CONSTRAINT pk_port_range PRIMARY KEY (port_range_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.port_range.port_range_name IS 'name of the range of ports (may be one port)';
COMMENT ON COLUMN jazzhands.port_range.port_range_type IS 'namespace for names';
COMMENT ON COLUMN jazzhands.port_range.protocol IS 'protocol, typically low level network protocol';
COMMENT ON COLUMN jazzhands.port_range.is_singleton IS 'if set, this the start and end ports are forced to be the same.';
-- INDEXES
CREATE INDEX xifport_range_val_port_range_type_port_range_type ON jazzhands.port_range USING btree (port_range_type, protocol);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between port_range and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_port_range
	FOREIGN KEY (destination_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK between port_range and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_port_range
	FOREIGN KEY (source_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK between port_range and jazzhands.service_endpoint_provider_service_instance
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_service_instance
--	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_pr_id
--	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- consider FK between port_range and jazzhands.service_endpoint
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint
--	ADD CONSTRAINT fk_svc_endpoint_port_range_id
--	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK port_range and val_port_range_type
ALTER TABLE jazzhands.port_range
	ADD CONSTRAINT fk_port_range_val_port_range_type_port_range_type
	FOREIGN KEY (port_range_type, protocol) REFERENCES jazzhands.val_port_range_type(port_range_type, protocol) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.port_range_manage_singleton
CREATE OR REPLACE FUNCTION jazzhands.port_range_manage_singleton()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.is_singleton IS NULL THEN
		IF NEW.port_start = NEW.port_end THEN
			NEW.is_singleton = true;
		ELSE
			NEW.is_singleton = false;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.port_range_manage_singleton() FROM public;
CREATE TRIGGER trigger_port_range_manage_singleton BEFORE INSERT ON jazzhands.port_range FOR EACH ROW EXECUTE PROCEDURE jazzhands.port_range_manage_singleton();

-- considering NEW jazzhands.port_range_sanity_check
CREATE OR REPLACE FUNCTION jazzhands.port_range_sanity_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NOT NEW.is_singleton THEN
		SELECT *
		INTO _r
		FROM val_port_range_type
		WHERE port_range_type = NEW.port_range_type
		AND protocol = NEW.protocol;

		IF NOT _r.range_permitted THEN
			RAISE EXCEPTION 'Ranges are not permitted on %:%',
				NEW.port_range_type, NEW.protocol
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	ELSE
		IF NEW.port_start != NEW.port_end THEN
			RAISE EXCEPTION 'singletons may not have a different start and end port'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.port_range_sanity_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_port_range_sanity_check AFTER INSERT OR UPDATE OF port_start, port_end, is_singleton ON jazzhands.port_range NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.port_range_sanity_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('port_range');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for port_range  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'port_range');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'port_range');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'port_range');
ALTER SEQUENCE jazzhands.port_range_port_range_id_seq
	 OWNED BY port_range.port_range_id;
-- DONE DEALING WITH TABLE port_range (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('port_range');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old port_range failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('port_range');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new port_range failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'property', 'property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_compcoll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_l2_netcollid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_l3_netcoll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_net_range_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_os_snapshot;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_pv_devcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_svc_env_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_x509_crt_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acct_col;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acctid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acctrealmid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_compid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_devcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_dns_dom_collect;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_nblk_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_nmtyp;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_osid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_prop_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pv_nblkcol_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_acct_colid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_private_key_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_pwdtyp;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_swpkgid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_tokcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_site_code;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_val_enc_key;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'property', newobject := 'property', newmap := '{"pk_property":{"columns":["property_id"],"def":"PRIMARY KEY (property_id)","deferrable":false,"deferred":false,"name":"pk_property","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS pk_property;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."ufprop_network_range_id";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_compcoll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_os_snapshot";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_pv_devcolid";
DROP INDEX IF EXISTS "jazzhands"."xif_property_acctrealmid";
DROP INDEX IF EXISTS "jazzhands"."xif_property_dns_dom_collect";
DROP INDEX IF EXISTS "jazzhands"."xif_property_nblk_coll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_prop_coll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_pv_nblkcol_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_account_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_acctcol_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_compid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_devcolid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_l2_netcoll_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_l3_netcoll_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_nmtyp";
DROP INDEX IF EXISTS "jazzhands"."xifprop_osid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_acct_colid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_enc_key_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_private_key_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_pwdtyp";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_swpkgid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_tokcolid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_site_code";
DROP INDEX IF EXISTS "jazzhands"."xifprop_svcenv";
DROP INDEX IF EXISTS "jazzhands"."xifprop_x509_signed_cert_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_property ON jazzhands.property;
DROP TRIGGER IF EXISTS trigger_audit_property ON jazzhands.property;
DROP FUNCTION IF EXISTS perform_audit_property();
DROP TRIGGER IF EXISTS trigger_validate_property ON jazzhands.property;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'property', tags := ARRAY['table_property']);
---- BEGIN jazzhands_audit.property TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'property', tags := ARRAY['table_property']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'property', 'property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'property');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.property DROP CONSTRAINT IF EXISTS property_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_property_pk_property";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.property TEARDOWN


ALTER TABLE property RENAME TO property_v91;
ALTER TABLE jazzhands_audit.property RENAME TO property_v91;

CREATE TABLE jazzhands.property
(
	property_id	integer NOT NULL,
	account_collection_id	integer  NULL,
	account_id	integer  NULL,
	account_realm_id	integer  NULL,
	company_collection_id	integer  NULL,
	company_id	integer  NULL,
	device_collection_id	integer  NULL,
	dns_domain_collection_id	integer  NULL,
	layer2_network_collection_id	integer  NULL,
	layer3_network_collection_id	integer  NULL,
	netblock_collection_id	integer  NULL,
	network_range_id	integer  NULL,
	operating_system_id	integer  NULL,
	operating_system_snapshot_id	integer  NULL,
	property_name_collection_id	integer  NULL,
	service_environment_collection_id	integer  NULL,
	service_version_collection_id	integer  NULL,
	site_code	varchar(50)  NULL,
	x509_signed_certificate_id	integer  NULL,
	property_name	varchar(255) NOT NULL,
	property_type	varchar(50) NOT NULL,
	property_value	varchar(1024)  NULL,
	property_value_account_collection_id	integer  NULL,
	property_value_boolean	boolean  NULL,
	property_value_device_collection_id	integer  NULL,
	property_value_encryption_key_id	integer  NULL,
	property_value_json	jsonb  NULL,
	property_value_netblock_collection_id	integer  NULL,
	property_value_password_type	varchar(50)  NULL,
	property_value_private_key_id	integer  NULL,
	property_value_service_version_collection_id	integer  NULL,
	property_value_timestamp	timestamp without time zone  NULL,
	property_value_token_collection_id	integer  NULL,
	property_rank	integer  NULL,
	start_date	timestamp without time zone  NULL,
	finish_date	timestamp without time zone  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'property', false);
ALTER TABLE property
	ALTER property_id
	SET DEFAULT nextval('jazzhands.property_property_id_seq'::regclass);
ALTER TABLE property
	ALTER is_enabled
	SET DEFAULT true;


-- BEGIN Manually written insert function
INSERT INTO property (
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	service_version_collection_id,		-- new column (service_version_collection_id)
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,
	property_value_service_version_collection_id,		-- new column (property_value_service_version_collection_id)
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	NULL,		-- new column (service_version_collection_id)
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,
	NULL,		-- new column (property_value_service_version_collection_id)
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM property_v91;


INSERT INTO jazzhands_audit.property (
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	service_version_collection_id,		-- new column (service_version_collection_id)
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,
	property_value_service_version_collection_id,		-- new column (property_value_service_version_collection_id)
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	NULL,		-- new column (service_version_collection_id)
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,
	NULL,		-- new column (property_value_service_version_collection_id)
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.property_v91;



-- END Manually written insert function
ALTER TABLE jazzhands.property
	ALTER property_id
	SET DEFAULT nextval('jazzhands.property_property_id_seq'::regclass);
ALTER TABLE jazzhands.property
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.property ADD CONSTRAINT pk_property PRIMARY KEY (property_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.property IS 'generic mechanism to create arbitrary associations between lhs database objects and assign them to zero or one other database objects/strings/lists/etc.  They are trigger enforced based on characteristics in val_property and val_property_value where foreign key enforcement does not work.';
COMMENT ON COLUMN jazzhands.property.property_id IS 'primary key for table to uniquely identify rows.';
COMMENT ON COLUMN jazzhands.property.account_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.account_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.account_realm_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.company_id IS 'LHS settable based on val_property.  THIS COLUMN IS DEPRECATED AND WILL BE REMOVED >= 0.66';
COMMENT ON COLUMN jazzhands.property.device_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.dns_domain_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.netblock_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.operating_system_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.operating_system_snapshot_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.property_name_collection_id IS 'LHS settable based on val_property.  NOTE, this is actually collections of property_name,property_type';
COMMENT ON COLUMN jazzhands.property.site_code IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.x509_signed_certificate_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.property.property_name IS 'textual name of a property';
COMMENT ON COLUMN jazzhands.property.property_type IS 'textual type of a department';
COMMENT ON COLUMN jazzhands.property.property_value IS 'RHS - general purpose column for value of property not defined by other types.  This may be enforced by fk (trigger) if val_property.property_data_type is list (fk is to val_property_value).   permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_account_collection_id IS 'RHS, fk to account_collection,    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_device_collection_id IS 'RHS - fk to device_collection.    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_netblock_collection_id IS 'RHS - fk to network_collection.    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_password_type IS 'RHS - fk to val_password_type.     permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_private_key_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.property.property_value_timestamp IS 'RHS - value is a timestamp , permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_token_collection_id IS 'RHS - fk to token_collection_id.     permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_rank IS 'for multivalues, specifies the order.  If set, this basically becomes part of the "ak" for the lhs.';
COMMENT ON COLUMN jazzhands.property.start_date IS 'date/time that the assignment takes effect or NULL.  .  The view v_property filters this out.';
COMMENT ON COLUMN jazzhands.property.finish_date IS 'date/time that the assignment ceases taking effect or NULL.  .  The view v_property filters this out.';
COMMENT ON COLUMN jazzhands.property.is_enabled IS 'indiciates if the property is temporarily disabled or not.  The view v_property filters this out.';
-- INDEXES
CREATE INDEX ufprop_network_range_id ON jazzhands.property USING btree (network_range_id);
CREATE INDEX xif_prop_compcoll_id ON jazzhands.property USING btree (company_collection_id);
CREATE INDEX xif_prop_os_snapshot ON jazzhands.property USING btree (operating_system_snapshot_id);
CREATE INDEX xif_prop_pv_devcolid ON jazzhands.property USING btree (property_value_device_collection_id);
CREATE INDEX xif_property_acctrealmid ON jazzhands.property USING btree (account_realm_id);
CREATE INDEX xif_property_dns_dom_collect ON jazzhands.property USING btree (dns_domain_collection_id);
CREATE INDEX xif_property_nblk_coll_id ON jazzhands.property USING btree (netblock_collection_id);
CREATE INDEX xif_property_prop_coll_id ON jazzhands.property USING btree (property_name_collection_id);
CREATE INDEX xif_property_pv_nblkcol_id ON jazzhands.property USING btree (property_value_netblock_collection_id);
CREATE INDEX xifprop_account_id ON jazzhands.property USING btree (account_id);
CREATE INDEX xifprop_acctcol_id ON jazzhands.property USING btree (account_collection_id);
CREATE INDEX xifprop_compid ON jazzhands.property USING btree (company_id);
CREATE INDEX xifprop_devcolid ON jazzhands.property USING btree (device_collection_id);
CREATE INDEX xifprop_l2_netcoll_id ON jazzhands.property USING btree (layer2_network_collection_id);
CREATE INDEX xifprop_l3_netcoll_id ON jazzhands.property USING btree (layer3_network_collection_id);
CREATE INDEX xifprop_nmtyp ON jazzhands.property USING btree (property_name, property_type);
CREATE INDEX xifprop_osid ON jazzhands.property USING btree (operating_system_id);
CREATE INDEX xifprop_pv_sver_coll_id ON jazzhands.property USING btree (property_value_service_version_collection_id);
CREATE INDEX xifprop_pval_acct_colid ON jazzhands.property USING btree (property_value_account_collection_id);
CREATE INDEX xifprop_pval_enc_key_id ON jazzhands.property USING btree (property_value_encryption_key_id);
CREATE INDEX xifprop_pval_private_key_id ON jazzhands.property USING btree (property_value_private_key_id);
CREATE INDEX xifprop_pval_pwdtyp ON jazzhands.property USING btree (property_value_password_type);
CREATE INDEX xifprop_pval_tokcolid ON jazzhands.property USING btree (property_value_token_collection_id);
CREATE INDEX xifprop_site_code ON jazzhands.property USING btree (site_code);
CREATE INDEX xifprop_svcenv ON jazzhands.property USING btree (service_environment_collection_id);
CREATE INDEX xifprop_x509_signed_cert_id ON jazzhands.property USING btree (x509_signed_certificate_id);
CREATE INDEX xifproperty_sver_coll_id ON jazzhands.property USING btree (service_version_collection_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK property and company_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_compcoll_id
	FOREIGN KEY (company_collection_id) REFERENCES jazzhands.company_collection(company_collection_id);
-- consider FK property and layer2_network_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_l2_netcollid
	FOREIGN KEY (layer2_network_collection_id) REFERENCES jazzhands.layer2_network_collection(layer2_network_collection_id);
-- consider FK property and layer3_network_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_l3_netcoll_id
	FOREIGN KEY (layer3_network_collection_id) REFERENCES jazzhands.layer3_network_collection(layer3_network_collection_id);
-- consider FK property and network_range
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_net_range_id
	FOREIGN KEY (network_range_id) REFERENCES jazzhands.network_range(network_range_id);
-- consider FK property and operating_system_snapshot
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_os_snapshot
	FOREIGN KEY (operating_system_snapshot_id) REFERENCES jazzhands.operating_system_snapshot(operating_system_snapshot_id);
-- consider FK property and device_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_pv_devcolid
	FOREIGN KEY (property_value_device_collection_id) REFERENCES jazzhands.device_collection(device_collection_id);
-- consider FK property and service_version_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.property
--	ADD CONSTRAINT fk_prop_pv_sver_coll_id
--	FOREIGN KEY (property_value_service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id);

-- consider FK property and service_environment_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_svc_env_coll_id
	FOREIGN KEY (service_environment_collection_id) REFERENCES jazzhands.service_environment_collection(service_environment_collection_id);
-- consider FK property and x509_signed_certificate
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_x509_crt_id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK property and account_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acct_col
	FOREIGN KEY (account_collection_id) REFERENCES jazzhands.account_collection(account_collection_id);
-- consider FK property and account
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acctid
	FOREIGN KEY (account_id) REFERENCES jazzhands.account(account_id);
-- consider FK property and account_realm
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acctrealmid
	FOREIGN KEY (account_realm_id) REFERENCES jazzhands.account_realm(account_realm_id);
-- consider FK property and company
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_compid
	FOREIGN KEY (company_id) REFERENCES jazzhands.company(company_id) DEFERRABLE;
-- consider FK property and device_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_devcolid
	FOREIGN KEY (device_collection_id) REFERENCES jazzhands.device_collection(device_collection_id);
-- consider FK property and dns_domain_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_dns_dom_collect
	FOREIGN KEY (dns_domain_collection_id) REFERENCES jazzhands.dns_domain_collection(dns_domain_collection_id);
-- consider FK property and netblock_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nblk_coll_id
	FOREIGN KEY (netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id);
-- consider FK property and val_property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nmtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK property and operating_system
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_osid
	FOREIGN KEY (operating_system_id) REFERENCES jazzhands.operating_system(operating_system_id);
-- consider FK property and property_name_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_prop_coll_id
	FOREIGN KEY (property_name_collection_id) REFERENCES jazzhands.property_name_collection(property_name_collection_id);
-- consider FK property and netblock_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pv_nblkcol_id
	FOREIGN KEY (property_value_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id);
-- consider FK property and account_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_acct_colid
	FOREIGN KEY (property_value_account_collection_id) REFERENCES jazzhands.account_collection(account_collection_id);
-- consider FK property and private_key
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_private_key_id
	FOREIGN KEY (property_value_private_key_id) REFERENCES jazzhands.private_key(private_key_id);
-- consider FK property and val_password_type
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_pwdtyp
	FOREIGN KEY (property_value_password_type) REFERENCES jazzhands.val_password_type(password_type);
-- consider FK property and token_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_tokcolid
	FOREIGN KEY (property_value_token_collection_id) REFERENCES jazzhands.token_collection(token_collection_id);
-- consider FK property and site
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_site_code
	FOREIGN KEY (site_code) REFERENCES jazzhands.site(site_code);
-- consider FK property and service_version_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.property
--	ADD CONSTRAINT fk_property_sver_coll_id
--	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id);

-- consider FK property and encryption_key
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_val_enc_key
	FOREIGN KEY (property_value_encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- TRIGGERS
-- considering NEW jazzhands.validate_property
CREATE OR REPLACE FUNCTION jazzhands.validate_property()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN property_utils.validate_property(NEW);
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.validate_property() FROM public;
CREATE TRIGGER trigger_validate_property BEFORE INSERT OR UPDATE ON jazzhands.property FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_property();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'property');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'property');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'property');
ALTER SEQUENCE jazzhands.property_property_id_seq
	 OWNED BY property.property_id;
DROP TABLE IF EXISTS property_v91;
DROP TABLE IF EXISTS jazzhands_audit.property_v91;
-- DONE DEALING WITH TABLE property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE protocol (jazzhands)
CREATE TABLE jazzhands.protocol
(
	protocol	varchar(255) NOT NULL,
	protocol_number	integer  NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'protocol', true);
--
-- Copying initialization data
--

INSERT INTO protocol (
protocol,protocol_number,description
) VALUES
	('none','0',NULL),
	('tcpconnect','0',NULL),
	('ssl','0',NULL),
	('tcp','6',NULL),
	('udp','17',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.protocol ADD CONSTRAINT pk_protocol PRIMARY KEY (protocol);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between protocol and jazzhands.val_port_range_type
ALTER TABLE jazzhands.val_port_range_type
	ADD CONSTRAINT fk_port_range_protocol
	FOREIGN KEY (protocol) REFERENCES jazzhands.protocol(protocol) DEFERRABLE;
-- consider FK between protocol and jazzhands.service_endpoint_health_check
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_health_check
--	ADD CONSTRAINT fk_service_endpoint_health_check_protocol
--	FOREIGN KEY (protocol) REFERENCES jazzhands.protocol(protocol) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('protocol');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for protocol  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'protocol');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'protocol');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'protocol');
-- DONE DEALING WITH TABLE protocol (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('protocol');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old protocol failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('protocol');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new protocol failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service (jazzhands)
CREATE TABLE jazzhands.service
(
	service_id	integer NOT NULL,
	service_name	varchar(255) NOT NULL,
	service_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	is_active	boolean NOT NULL,
	is_synthesized	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service', true);
ALTER TABLE jazzhands.service
	ALTER service_id
	SET DEFAULT nextval('jazzhands.service_service_id_seq'::regclass);
ALTER TABLE jazzhands.service
	ALTER is_active
	SET DEFAULT true;
ALTER TABLE jazzhands.service
	ALTER is_synthesized
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service ADD CONSTRAINT pk_service PRIMARY KEY (service_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.service.service_name IS 'universal name for the service; acts as an AK (not an AK with the type).';
COMMENT ON COLUMN jazzhands.service.service_type IS 'The _current_ type of the service.  This is propagated to each new service version.  Services names are _NOT_ unique within this namespace unlike other parts of the schema.';
COMMENT ON COLUMN jazzhands.service.is_active IS 'Service is not yet or is no longer in use';
COMMENT ON COLUMN jazzhands.service.is_synthesized IS 'The service was made up by some subsystem to glue features together (these are typcially not shown to users)';
-- INDEXES
CREATE INDEX xifservice_service_type ON jazzhands.service USING btree (service_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service and jazzhands.service_depend
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_service_id
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK between service and jazzhands.service_endpoint
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint
--	ADD CONSTRAINT fk_service_endpoint_svc
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK between service and jazzhands.service_software_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_software_repository
--	ADD CONSTRAINT fk_service_software_repository_service_id
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK between service and jazzhands.service_source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_source_repository
--	ADD CONSTRAINT fk_service_source_repo_service_id
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK between service and jazzhands.service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version
--	ADD CONSTRAINT fk_service_version_service_id
--	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- consider FK between service and jazzhands.software_artifact_name
ALTER TABLE jazzhands.software_artifact_name
	ADD CONSTRAINT fk_svc_artifact_name_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service and val_service_type
ALTER TABLE jazzhands.service
	ADD CONSTRAINT fk_service_service_type
	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.create_all_services_collection
CREATE OR REPLACE FUNCTION jazzhands.create_all_services_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection (
			service_version_collection_name, service_version_collection_type
		) VALUES
			( NEW.service_name, 'all-services' ),
			( NEW.service_name, 'current-services' );
	ELSIF TG_OP = 'UPDATE' THEN
		UPDATE service_version_collection
		SET service_version_collection_name = NEW.service_name
		WHERE service_version_collection_type
			IN ( 'all-services', 'current-services')
		AND service_version_collection_name = OLD.service_name;
	ELSIF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.create_all_services_collection() FROM public;
CREATE TRIGGER trigger_create_all_services_collection AFTER INSERT OR UPDATE OF service_name ON jazzhands.service FOR EACH ROW EXECUTE PROCEDURE jazzhands.create_all_services_collection();

-- considering NEW jazzhands.create_all_services_collection
CREATE OR REPLACE FUNCTION jazzhands.create_all_services_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection (
			service_version_collection_name, service_version_collection_type
		) VALUES
			( NEW.service_name, 'all-services' ),
			( NEW.service_name, 'current-services' );
	ELSIF TG_OP = 'UPDATE' THEN
		UPDATE service_version_collection
		SET service_version_collection_name = NEW.service_name
		WHERE service_version_collection_type
			IN ( 'all-services', 'current-services')
		AND service_version_collection_name = OLD.service_name;
	ELSIF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.create_all_services_collection() FROM public;
CREATE TRIGGER trigger_create_all_services_collection_del BEFORE DELETE ON jazzhands.service FOR EACH ROW EXECUTE PROCEDURE jazzhands.create_all_services_collection();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service');
ALTER SEQUENCE jazzhands.service_service_id_seq
	 OWNED BY service.service_id;
-- DONE DEALING WITH TABLE service (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_depend (jazzhands)
CREATE TABLE jazzhands.service_depend
(
	service_depend_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	service_id	integer NOT NULL,
	minimum_service_version_id	integer  NULL,
	maximum_service_version_id	integer  NULL,
	service_sla_id	integer  NULL,
	service_endpoint_provider_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_depend', true);
ALTER TABLE jazzhands.service_depend
	ALTER service_depend_id
	SET DEFAULT nextval('jazzhands.service_depend_service_depend_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_depend ADD CONSTRAINT ak_svc_depend_vers_svc_sla UNIQUE (service_version_id, service_id, service_sla_id);
ALTER TABLE jazzhands.service_depend ADD CONSTRAINT pk_service_depend PRIMARY KEY (service_depend_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_depend IS 'Required relationships between services.  These are not explicit mappings, rather indicates of what is required to make things work to be resolved at runtime.';
COMMENT ON COLUMN jazzhands.service_depend.service_version_id IS 'The dependee';
COMMENT ON COLUMN jazzhands.service_depend.service_id IS 'Dependee requires this service';
COMMENT ON COLUMN jazzhands.service_depend.minimum_service_version_id IS 'Optional minium service version to satisfy the dependency';
COMMENT ON COLUMN jazzhands.service_depend.maximum_service_version_id IS 'Optional maximum service version to satisfy the dependency';
COMMENT ON COLUMN jazzhands.service_depend.service_sla_id IS 'Servie Level Agreement required to fufill the dependency (to be fleshed out)';
COMMENT ON COLUMN jazzhands.service_depend.service_endpoint_provider_id IS 'The service endpoint that manages this dependency (optional)';
-- INDEXES
CREATE INDEX xifservice_depend_max_service_version_id ON jazzhands.service_depend USING btree (maximum_service_version_id);
CREATE INDEX xifservice_depend_min_service_version_id ON jazzhands.service_depend USING btree (minimum_service_version_id);
CREATE INDEX xifservice_depend_service_endpoint_provider_id ON jazzhands.service_depend USING btree (service_endpoint_provider_id);
CREATE INDEX xifservice_depend_service_id ON jazzhands.service_depend USING btree (service_id);
CREATE INDEX xifservice_depend_service_sla_id ON jazzhands.service_depend USING btree (service_sla_id);
CREATE INDEX xifservice_depend_service_version_id ON jazzhands.service_depend USING btree (service_version_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_depend and jazzhands.service_layer3_acl
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_layer3_acl
--	ADD CONSTRAINT fk_service_l3acl_depend_id
--	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_depend(service_depend_id) DEFERRABLE;

-- consider FK between service_depend and jazzhands.service_depend_service_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_depend_service_feature
--	ADD CONSTRAINT fk_svc_depend_service_feature_service_depend_id
--	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_depend(service_depend_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_depend and service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_max_service_version_id
--	FOREIGN KEY (maximum_service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- consider FK service_depend and service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_min_service_version_id
--	FOREIGN KEY (minimum_service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- consider FK service_depend and service_endpoint_provider
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_service_endpoint_provider_id
--	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;

-- consider FK service_depend and service
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_depend and service_sla
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_service_sla_id
--	FOREIGN KEY (service_sla_id) REFERENCES jazzhands.service_sla(service_sla_id) DEFERRABLE;

-- consider FK service_depend and service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_depend
--	ADD CONSTRAINT fk_service_depend_service_version_id
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_depend');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_depend  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_depend');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_depend');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_depend');
ALTER SEQUENCE jazzhands.service_depend_service_depend_id_seq
	 OWNED BY service_depend.service_depend_id;
-- DONE DEALING WITH TABLE service_depend (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_depend failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_depend failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_depend_service_feature (jazzhands)
CREATE TABLE jazzhands.service_depend_service_feature
(
	service_depend_id	integer NOT NULL,
	service_feature	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_depend_service_feature', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_depend_service_feature ADD CONSTRAINT pk_service_depend_service_feature PRIMARY KEY (service_depend_id, service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_depend_service_feature IS 'Features required for a specific service dependency.';
-- INDEXES
CREATE INDEX xifsvc_depend_service_feature_service_depend_id ON jazzhands.service_depend_service_feature USING btree (service_depend_id);
CREATE INDEX xifsvc_depend_service_feature_service_feature ON jazzhands.service_depend_service_feature USING btree (service_feature);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_depend_service_feature and service_depend
ALTER TABLE jazzhands.service_depend_service_feature
	ADD CONSTRAINT fk_svc_depend_service_feature_service_depend_id
	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_depend(service_depend_id) DEFERRABLE;
-- consider FK service_depend_service_feature and val_service_feature
ALTER TABLE jazzhands.service_depend_service_feature
	ADD CONSTRAINT fk_svc_depend_service_feature_service_feature
	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_depend_feature_check
CREATE OR REPLACE FUNCTION jazzhands.service_depend_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'UPDATE' AND OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	PERFORM *
	FROM (select service_depend_id, service_id from service_version) sd
		JOIN service_version USING (service_id)
		JOIN service_instance si USING (service_version_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_id)
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_permitted_feature svcpf
			USING (service_version_collection_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND	sd.service_depend = NEW.service_depend_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'service_feature is not offered by any versions of service'
       		USING ERRCODE = 'foreign_key_violation',
       		HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_depend_feature_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_depend_feature_check AFTER INSERT OR UPDATE OF service_feature ON jazzhands.service_depend_service_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_depend_feature_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_depend_service_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_depend_service_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_depend_service_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_depend_service_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_depend_service_feature');
-- DONE DEALING WITH TABLE service_depend_service_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_depend_service_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_depend_service_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint (jazzhands)
CREATE TABLE jazzhands.service_endpoint
(
	service_endpoint_id	integer NOT NULL,
	service_id	integer NOT NULL,
	dns_record_id	integer  NULL,
	port_range_id	integer  NULL,
	service_endpoint_uri	varchar(512)  NULL,
	description	varchar(4096)  NULL,
	is_synthesized	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint', true);
ALTER TABLE jazzhands.service_endpoint
	ALTER service_endpoint_id
	SET DEFAULT nextval('jazzhands.service_endpoint_service_endpoint_id_seq'::regclass);
ALTER TABLE jazzhands.service_endpoint
	ALTER is_synthesized
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint ADD CONSTRAINT pk_service_endpoint PRIMARY KEY (service_endpoint_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint IS 'Models the thing that gets talked to for a service usually a DNS name+port or could be path inside a name+portion a dns name.';
COMMENT ON COLUMN jazzhands.service_endpoint.dns_record_id IS 'For network services, the DNS name that is used to refer to this service endpoint';
COMMENT ON COLUMN jazzhands.service_endpoint.port_range_id IS 'For network services, the port that provides the service';
COMMENT ON COLUMN jazzhands.service_endpoint.service_endpoint_uri IS 'optinal UI elements that provide the service (inside the dns record)';
COMMENT ON COLUMN jazzhands.service_endpoint.is_synthesized IS 'The service was made up by some subsystem to glue features together (these are typcially not shown to users)';
-- INDEXES
CREATE INDEX xifservice_endpoint_dns_rec_id ON jazzhands.service_endpoint USING btree (dns_record_id);
CREATE INDEX xifservice_endpoint_svc ON jazzhands.service_endpoint USING btree (service_id);
CREATE INDEX xifsvc_endpoint_port_range_id ON jazzhands.service_endpoint USING btree (port_range_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_endpoint and jazzhands.service_endpoint_health_check
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_health_check
--	ADD CONSTRAINT fk_service_endpoint_health_check_svc_endpoint_id
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- consider FK between service_endpoint and jazzhands.service_endpoint_service_sla
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_service_sla
--	ADD CONSTRAINT fk_service_endpoint_service_sla_endpoint_id
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- consider FK between service_endpoint and jazzhands.service_endpoint_x509_certificate
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_x509_certificate
--	ADD CONSTRAINT fk_service_endpoint_x509_certificate_seid
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- consider FK between service_endpoint and jazzhands.source_repository_url
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_url
--	ADD CONSTRAINT fk_svc_endpoint_source_repo_url
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);

-- consider FK between service_endpoint and jazzhands.service_endpoint_service_endpoint_provider_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_service_endpoint_provider_collection
--	ADD CONSTRAINT fk_svc_endpoint_svc_endpoint_prov_collection_endpoint_id
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_endpoint and dns_record
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_service_endpoint_dns_rec_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;
-- consider FK service_endpoint and service
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_service_endpoint_svc
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_endpoint and port_range
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_svc_endpoint_port_range_id
	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_endpoint_direct_check
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.dns_record_id IS NOT NULL OR NEW.port_range_id IS NOT NULL THEN
		SELECT	sep.*
		INTO	_r
		FROM	service_endpoint_service_endpoint_provider_collection
				JOIN service_endpoint_provider_collection
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider_collection_service_endpoint_provider
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider sep
					USING (service_endpoint_provider_id)
		WHERE	service_endpoint_id = NEW.service_endpoint_id;

		IF FOUND THEN
			--
			-- It is possible that these don't need to match, but that use
			-- case needs to be thought through, so it is disallowed for now.
			--
			IF _r.service_endpoint_provider_type = 'direct' THEN
				IF _r.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
					RAISE EXCEPTION 'dns_record_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
				IF _r.port_range_id IS DISTINCT FROM NEW.port_range_id THEN
					RAISE EXCEPTION 'port_range_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_endpoint_direct_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_direct_check AFTER INSERT OR UPDATE OF dns_record_id, port_range_id ON jazzhands.service_endpoint NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_endpoint_direct_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint');
ALTER SEQUENCE jazzhands.service_endpoint_service_endpoint_id_seq
	 OWNED BY service_endpoint.service_endpoint_id;
-- DONE DEALING WITH TABLE service_endpoint (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_health_check (jazzhands)
CREATE TABLE jazzhands.service_endpoint_health_check
(
	service_endpoint_health_check_id	integer NOT NULL,
	is_enabled	boolean NOT NULL,
	service_endpoint_id	integer NOT NULL,
	protocol	varchar(255) NOT NULL,
	service_endpoint_health_check_rank	integer NOT NULL,
	request_string	varchar(255)  NULL,
	search_string	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_health_check', true);
ALTER TABLE jazzhands.service_endpoint_health_check
	ALTER service_endpoint_health_check_id
	SET DEFAULT nextval('jazzhands.service_endpoint_health_check_service_endpoint_health_check_seq'::regclass);
ALTER TABLE jazzhands.service_endpoint_health_check
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_endpoint_health_check
	ALTER service_endpoint_health_check_rank
	SET DEFAULT 10;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_health_check ADD CONSTRAINT ak_svc_ep_health_chk_endpoint_id_rank UNIQUE (service_endpoint_id, service_endpoint_health_check_rank);
ALTER TABLE jazzhands.service_endpoint_health_check ADD CONSTRAINT pk_service_endpoint_health_check PRIMARY KEY (service_endpoint_health_check_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_health_check IS 'Ways to check to see if a service is healthy. There can be more than one and it is likely this will be fleshed out more over time.';
COMMENT ON COLUMN jazzhands.service_endpoint_health_check.protocol IS 'Protocol used for the health check';
COMMENT ON COLUMN jazzhands.service_endpoint_health_check.service_endpoint_health_check_rank IS 'Order to run health checks';
COMMENT ON COLUMN jazzhands.service_endpoint_health_check.request_string IS 'How to invoke the health check';
COMMENT ON COLUMN jazzhands.service_endpoint_health_check.search_string IS 'How to tell if the health check was succesful';
-- INDEXES
CREATE INDEX xifservice_endpoint_health_check_protocol ON jazzhands.service_endpoint_health_check USING btree (protocol);
CREATE INDEX xifservice_endpoint_health_check_svc_endpoint_id ON jazzhands.service_endpoint_health_check USING btree (service_endpoint_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_health_check and protocol
ALTER TABLE jazzhands.service_endpoint_health_check
	ADD CONSTRAINT fk_service_endpoint_health_check_protocol
	FOREIGN KEY (protocol) REFERENCES jazzhands.protocol(protocol) DEFERRABLE;
-- consider FK service_endpoint_health_check and service_endpoint
ALTER TABLE jazzhands.service_endpoint_health_check
	ADD CONSTRAINT fk_service_endpoint_health_check_svc_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_health_check');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_health_check  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_health_check');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_health_check');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_health_check');
ALTER SEQUENCE jazzhands.service_endpoint_health_check_service_endpoint_health_check_seq
	 OWNED BY service_endpoint_health_check.service_endpoint_health_check_id;
-- DONE DEALING WITH TABLE service_endpoint_health_check (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_health_check');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_health_check failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_health_check');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_health_check failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_provider (jazzhands)
CREATE TABLE jazzhands.service_endpoint_provider
(
	service_endpoint_provider_id	integer NOT NULL,
	service_endpoint_provider_name	varchar(255) NOT NULL,
	service_endpoint_provider_type	varchar(255) NOT NULL,
	dns_record_id	integer  NULL,
	netblock_id	integer  NULL,
	description	varchar(4096)  NULL,
	is_synthesized	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_provider', true);
ALTER TABLE jazzhands.service_endpoint_provider
	ALTER service_endpoint_provider_id
	SET DEFAULT nextval('jazzhands.service_endpoint_provider_service_endpoint_provider_id_seq'::regclass);
ALTER TABLE jazzhands.service_endpoint_provider
	ALTER is_synthesized
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_provider ADD CONSTRAINT ak_service_endpoint_provider_netblock_id UNIQUE (service_endpoint_provider_id, netblock_id);
ALTER TABLE jazzhands.service_endpoint_provider ADD CONSTRAINT ak_svc_ep_name_type UNIQUE (service_endpoint_provider_name, service_endpoint_provider_type);
ALTER TABLE jazzhands.service_endpoint_provider ADD CONSTRAINT pk_service_endpoint_provider PRIMARY KEY (service_endpoint_provider_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_provider IS 'Models somethign that actually terminates traffic (load balancer, shared IP, direct-to-host, etc)';
COMMENT ON COLUMN jazzhands.service_endpoint_provider.service_endpoint_provider_name IS 'human readable name of endpoint (for sanity, not actually used)';
COMMENT ON COLUMN jazzhands.service_endpoint_provider.dns_record_id IS 'Desination of CNAMEs that provide the service (mutually exclusive with netblock_id)';
COMMENT ON COLUMN jazzhands.service_endpoint_provider.netblock_id IS 'IP address that actually provides the service (mutually exlusive with dns_record_id)';
-- INDEXES
CREATE INDEX xifservice_endpoint_provider_dns_record_id ON jazzhands.service_endpoint_provider USING btree (dns_record_id);
CREATE INDEX xifservice_endpoint_provider_netblock_id ON jazzhands.service_endpoint_provider USING btree (netblock_id);
CREATE INDEX xifsvc_endpoint_provider_val_type ON jazzhands.service_endpoint_provider USING btree (service_endpoint_provider_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_endpoint_provider and jazzhands.service_endpoint_provider_collection_service_endpoint_provider
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_collection_service_endpoint_provider
--	ADD CONSTRAINT fk_sepc_sep_epid
--	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;

-- consider FK between service_endpoint_provider and jazzhands.service_depend
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_service_endpoint_provider_id
	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;
-- consider FK between service_endpoint_provider and jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
--	ADD CONSTRAINT fk_service_endpoint_prov_x509_certificate_sepid
--	FOREIGN KEY (service_endpoint_provider_id, netblock_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id, netblock_id) DEFERRABLE;

-- consider FK between service_endpoint_provider and jazzhands.service_endpoint_provider_service_instance
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_service_instance
--	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_ep_id
--	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_endpoint_provider and dns_record
ALTER TABLE jazzhands.service_endpoint_provider
	ADD CONSTRAINT fk_service_endpoint_provider_dns_record_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;
-- consider FK service_endpoint_provider and netblock
ALTER TABLE jazzhands.service_endpoint_provider
	ADD CONSTRAINT fk_service_endpoint_provider_netblock_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id) DEFERRABLE;
-- consider FK service_endpoint_provider and val_service_endpoint_provider_type
ALTER TABLE jazzhands.service_endpoint_provider
	ADD CONSTRAINT fk_svc_endpoint_provider_val_type
	FOREIGN KEY (service_endpoint_provider_type) REFERENCES jazzhands.val_service_endpoint_provider_type(service_endpoint_provider_type) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_endpoint_provider_direct_check
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_provider_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.service_endpoint_provider_type = 'direct' THEN
		IF NEW.dns_record_id IS NOT NULL THEN
			SELECT	se.*
			INTO	_r
			FROM	service_endpoint se
					JOIN service_endpoint_service_endpoint_provider_collection
						USING (service_endpoint_id)
					JOIN service_endpoint_provider_collection
						USING (service_endpoint_provider_collection_id)
					JOIN service_endpoint_provider_collection_service_endpoint_provider
						USING (service_endpoint_provider_collection_id)
			WHERE	service_endpoint_provider_id =
				NEW.service_endpoint_provider_id;

			IF FOUND THEN
				--
				-- It is possible that these don't need to match, but that use
				-- case needs to be thought through, so it is disallowed for now.
				--
				IF _r.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
					RAISE EXCEPTION 'dns_record_id of service_endpoint_provider and service_endpoint must match (% %', _r.dns_record_id, NEW.dns_record_id
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to direct connects';
				END IF;
				IF _r.port_range_id IS DISTINCT FROM NEW.port_range_id THEN
					RAISE EXCEPTION 'port_range of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
			END IF;
		END IF;
	-- This doesn't work right with cname failver in gtm, so commenting out,
	-- but it's possible it needs to be rethought.
	-- ELSIF NEW.dns_record_id IS NOT NULL THEN
	--	RAISE EXCEPTION 'direct providers must have their dns record in sync with their endpoint'
	--	USING ERRCODE = 'foreign_key_violation',
	--	HINT = 'This check may be overly agressive';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_endpoint_provider_direct_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_provider_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_type, dns_record_id ON jazzhands.service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_endpoint_provider_direct_check();

-- considering NEW jazzhands.service_endpoint_provider_dns_netblock_check
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_provider_dns_netblock_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.dns_record_id IS NULL AND  NEW.netblock_id IS NULL AND NEW.service_endpoint_provider_type != 'direct'THEN
		RAISE EXCEPTION 'One of dns_record_id OR netblock_id must be set for types other than direct'
       		USING ERRCODE = 'not_null_violation';
	ELSIF NEW.dns_record_id IS NOT NULL AND NEW.netblock_id IS NOT NULL THEN
		RAISE EXCEPTION 'Only One of dns_record_id OR netblock_id must be set'
       		USING ERRCODE = 'not_null_violation';
	END IF;

	-- XXX it is probable additional checks must be made on this.

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_endpoint_provider_dns_netblock_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_provider_dns_netblock_check AFTER INSERT OR UPDATE OF dns_record_id, netblock_id ON jazzhands.service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_endpoint_provider_dns_netblock_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_provider');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_provider  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_provider');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_provider');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_provider');
ALTER SEQUENCE jazzhands.service_endpoint_provider_service_endpoint_provider_id_seq
	 OWNED BY service_endpoint_provider.service_endpoint_provider_id;
-- DONE DEALING WITH TABLE service_endpoint_provider (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_provider failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_provider failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_provider_collection (jazzhands)
CREATE TABLE jazzhands.service_endpoint_provider_collection
(
	service_endpoint_provider_collection_id	integer NOT NULL,
	service_endpoint_provider_collection_name	varchar(255) NOT NULL,
	service_endpoint_provider_collection_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection', true);
ALTER TABLE jazzhands.service_endpoint_provider_collection
	ALTER service_endpoint_provider_collection_id
	SET DEFAULT nextval('jazzhands.service_endpoint_provider_col_service_endpoint_provider_col_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_provider_collection ADD CONSTRAINT ak_sep_coll_name_type UNIQUE (service_endpoint_provider_collection_name, service_endpoint_provider_collection_type);
ALTER TABLE jazzhands.service_endpoint_provider_collection ADD CONSTRAINT pk_service_endpoint_provider_collection PRIMARY KEY (service_endpoint_provider_collection_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_provider_collection IS 'A group of service providers (things that terminate traffic) logically grouped together for arbitrary business reasons';
-- INDEXES
CREATE INDEX xifservce_endpoint_provider_collection_val_type ON jazzhands.service_endpoint_provider_collection USING btree (service_endpoint_provider_collection_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_endpoint_provider_collection and jazzhands.service_endpoint_provider_collection_service_endpoint_provider
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_provider_collection_service_endpoint_provider
--	ADD CONSTRAINT fk_sepc_sep_coll_id
--	FOREIGN KEY (service_endpoint_provider_collection_id) REFERENCES jazzhands.service_endpoint_provider_collection(service_endpoint_provider_collection_id) DEFERRABLE;

-- consider FK between service_endpoint_provider_collection and jazzhands.service_endpoint_service_endpoint_provider_collection
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_service_endpoint_provider_collection
--	ADD CONSTRAINT fk_svc_endpoint_svc_endpoint_prov_coll_coll_id
--	FOREIGN KEY (service_endpoint_provider_collection_id) REFERENCES jazzhands.service_endpoint_provider_collection(service_endpoint_provider_collection_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_endpoint_provider_collection and val_service_endpoint_provider_collection_type
ALTER TABLE jazzhands.service_endpoint_provider_collection
	ADD CONSTRAINT fk_servce_endpoint_provider_collection_val_type
	FOREIGN KEY (service_endpoint_provider_collection_type) REFERENCES jazzhands.val_service_endpoint_provider_collection_type(service_endpoint_provider_collection_type) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_provider_collection');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_provider_collection  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_provider_collection');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection');
ALTER SEQUENCE jazzhands.service_endpoint_provider_col_service_endpoint_provider_col_seq
	 OWNED BY service_endpoint_provider_collection.service_endpoint_provider_collection_id;
-- DONE DEALING WITH TABLE service_endpoint_provider_collection (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_provider_collection failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_provider_collection failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_provider_collection_service_endpoint_provider (jazzhands)
CREATE TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider
(
	service_endpoint_provider_collection_id	integer NOT NULL,
	service_endpoint_provider_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection_service_endpoint_provider', true);
ALTER TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider
	ALTER service_endpoint_provider_collection_id
	SET DEFAULT nextval('jazzhands.service_endpoint_provider_col_service_endpoint_provider_co_seq1'::regclass);
ALTER TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider
	ALTER service_endpoint_provider_id
	SET DEFAULT nextval('jazzhands.service_endpoint_provider_coll_service_endpoint_provider_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider ADD CONSTRAINT pk_svc_endpoint_provider_collection_service_endpoint_provider PRIMARY KEY (service_endpoint_provider_collection_id, service_endpoint_provider_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifsepc_sep_coll_id ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider USING btree (service_endpoint_provider_collection_id);
CREATE INDEX xifsepc_sep_epid ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider USING btree (service_endpoint_provider_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_provider_collection_service_endpoint_provider and service_endpoint_provider_collection
ALTER TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider
	ADD CONSTRAINT fk_sepc_sep_coll_id
	FOREIGN KEY (service_endpoint_provider_collection_id) REFERENCES jazzhands.service_endpoint_provider_collection(service_endpoint_provider_collection_id) DEFERRABLE;
-- consider FK service_endpoint_provider_collection_service_endpoint_provider and service_endpoint_provider
ALTER TABLE jazzhands.service_endpoint_provider_collection_service_endpoint_provider
	ADD CONSTRAINT fk_sepc_sep_epid
	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.svc_ep_coll_sep_direct_check
CREATE OR REPLACE FUNCTION jazzhands.svc_ep_coll_sep_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_coltype	TEXT;
	_septype	TEXT;
BEGIN

	SELECT service_endpoint_provider_collection_type
	INTO _coltype
	FROM service_endpoint_provider_collection
	WHERE service_endpoint_provider_collection_id =
		NEW.service_endpoint_provider_collection_id;

	SELECT service_endpoint_provider_type
	INTO _septype
	FROM service_endpoint_provider
	WHERE service_endpoint_provider_id =
		NEW.service_endpoint_provider_id;

	IF _septype = 'direct' AND _coltype != 'per-service-endpoint-provider' THEN
		RAISE EXCEPTION 'direct providers must have an upstream collection of per-service-endpoint-provider type'
		USING ERRCODE = 'invalid_parameter_value',
		HINT = 'This check should be smarter';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.svc_ep_coll_sep_direct_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_svc_ep_coll_sep_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_collection_id, service_endpoint_provider_id ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.svc_ep_coll_sep_direct_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_provider_collection_service_endpoint_provider');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_provider_collection_service_endpoint_provider  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_provider_collection_service_endpoint_provider');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection_service_endpoint_provider');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_collection_service_endpoint_provider');
ALTER SEQUENCE jazzhands.service_endpoint_provider_col_service_endpoint_provider_co_seq1
	 OWNED BY service_endpoint_provider_collection_service_endpoint_provider.service_endpoint_provider_collection_id;
ALTER SEQUENCE jazzhands.service_endpoint_provider_coll_service_endpoint_provider_id_seq
	 OWNED BY service_endpoint_provider_collection_service_endpoint_provider.service_endpoint_provider_id;
-- DONE DEALING WITH TABLE service_endpoint_provider_collection_service_endpoint_provider (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_collection_service_endpoint_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_provider_collection_service_endpoint_provider failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_collection_service_endpoint_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_provider_collection_service_endpoint_provider failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_provider_service_instance (jazzhands)
CREATE TABLE jazzhands.service_endpoint_provider_service_instance
(
	service_endpoint_provider_service_instance_id	integer NOT NULL,
	is_enabled	boolean NOT NULL,
	service_endpoint_provider_id	integer NOT NULL,
	service_instance_id	integer NOT NULL,
	port_range_id	integer  NULL,
	service_endpoint_provider_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_service_instance', true);
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ALTER service_endpoint_provider_service_instance_id
	SET DEFAULT nextval('jazzhands.service_endpoint_provider_ser_service_endpoint_provider_ser_seq'::regclass);
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ALTER service_endpoint_provider_rank
	SET DEFAULT 10;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_provider_service_instance ADD CONSTRAINT ak_sep_svc_instance UNIQUE (service_endpoint_provider_id, service_instance_id, port_range_id);
ALTER TABLE jazzhands.service_endpoint_provider_service_instance ADD CONSTRAINT pk_service_endpoint_provider_service_instance PRIMARY KEY (service_endpoint_provider_service_instance_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_provider_service_instance IS 'Models the connection between the thing that terminates a service and the process that actually does the service on a host.  This could be direct-to-host or could be upstream that is behind a load balancer';
COMMENT ON COLUMN jazzhands.service_endpoint_provider_service_instance.service_instance_id IS 'the service_instance on a device that actually is the service, typically process on a device';
COMMENT ON COLUMN jazzhands.service_endpoint_provider_service_instance.port_range_id IS 'the port on a device that actually is the service, typically process on a device';
COMMENT ON COLUMN jazzhands.service_endpoint_provider_service_instance.service_endpoint_provider_rank IS 'possibly to go away';
-- INDEXES
CREATE INDEX xifservice_endpoint_provider_service_instance_ep_id ON jazzhands.service_endpoint_provider_service_instance USING btree (service_endpoint_provider_id);
CREATE INDEX xifservice_endpoint_provider_service_instance_pr_id ON jazzhands.service_endpoint_provider_service_instance USING btree (port_range_id);
CREATE INDEX xifservice_endpoint_provider_service_instance_siid ON jazzhands.service_endpoint_provider_service_instance USING btree (service_instance_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_provider_service_instance and service_endpoint_provider
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_ep_id
	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id) DEFERRABLE;
-- consider FK service_endpoint_provider_service_instance and port_range
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_pr_id
	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK service_endpoint_provider_service_instance and service_instance
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_endpoint_provider_service_instance
--	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_siid
--	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_provider_service_instance');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_provider_service_instance  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_provider_service_instance');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_service_instance');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_service_instance');
ALTER SEQUENCE jazzhands.service_endpoint_provider_ser_service_endpoint_provider_ser_seq
	 OWNED BY service_endpoint_provider_service_instance.service_endpoint_provider_service_instance_id;
-- DONE DEALING WITH TABLE service_endpoint_provider_service_instance (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_provider_service_instance failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_provider_service_instance failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_provider_shared_netblock_layer3_interface (jazzhands)
CREATE TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
(
	service_endpoint_provider_id	integer NOT NULL,
	netblock_id	integer NOT NULL,
	shared_netblock_id	integer NOT NULL,
	layer3_interface_id	integer NOT NULL,
	x509_signed_certificate_id	integer  NULL,
	x509_certificate_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_shared_netblock_layer3_interface', true);
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ALTER x509_certificate_rank
	SET DEFAULT 10;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface ADD CONSTRAINT ak_sep_snl3int_sep_l3int_rank UNIQUE (service_endpoint_provider_id, layer3_interface_id, x509_certificate_rank);
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface ADD CONSTRAINT pk_service_endpoint_provider_shared_netblock_layer3_interface PRIMARY KEY (service_endpoint_provider_id, netblock_id, shared_netblock_id, layer3_interface_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.service_endpoint_provider_shared_netblock_layer3_interface.x509_signed_certificate_id IS 'Uniquely identifies Certificate on a specific endpoint';
-- INDEXES
CREATE INDEX xifsep_snl3int_snb_snb_int ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface USING btree (shared_netblock_id, layer3_interface_id);
CREATE INDEX xifsep_snl3int_snb_snb_nb ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface USING btree (shared_netblock_id, netblock_id);
CREATE INDEX xifservice_endpoint_prov_x509_certificate_sepid ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface USING btree (service_endpoint_provider_id, netblock_id);
CREATE INDEX xifservice_endpoint_prov_x509_certificate_x509id ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface USING btree (x509_signed_certificate_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_provider_shared_netblock_layer3_interface and shared_netblock_layer3_interface
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ADD CONSTRAINT fk_sep_snl3int_snb_snb_int
	FOREIGN KEY (shared_netblock_id, layer3_interface_id) REFERENCES jazzhands.shared_netblock_layer3_interface(shared_netblock_id, layer3_interface_id) DEFERRABLE;
-- consider FK service_endpoint_provider_shared_netblock_layer3_interface and shared_netblock
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ADD CONSTRAINT fk_sep_snl3int_snb_snb_nb
	FOREIGN KEY (shared_netblock_id, netblock_id) REFERENCES jazzhands.shared_netblock(shared_netblock_id, netblock_id) DEFERRABLE;
-- consider FK service_endpoint_provider_shared_netblock_layer3_interface and service_endpoint_provider
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ADD CONSTRAINT fk_service_endpoint_prov_x509_certificate_sepid
	FOREIGN KEY (service_endpoint_provider_id, netblock_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id, netblock_id) DEFERRABLE;
-- consider FK service_endpoint_provider_shared_netblock_layer3_interface and x509_signed_certificate
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ADD CONSTRAINT fk_service_endpoint_prov_x509_certificate_x509id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_provider_shared_netblock_layer3_interface');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_provider_shared_netblock_layer3_interface  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_provider_shared_netblock_layer3_interface');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_shared_netblock_layer3_interface');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_provider_shared_netblock_layer3_interface');
-- DONE DEALING WITH TABLE service_endpoint_provider_shared_netblock_layer3_interface (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_shared_netblock_layer3_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_provider_shared_netblock_layer3_interface failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_provider_shared_netblock_layer3_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_provider_shared_netblock_layer3_interface failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_service_endpoint_provider_collection (jazzhands)
CREATE TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
(
	service_endpoint_id	integer NOT NULL,
	service_endpoint_provider_collection_id	integer NOT NULL,
	service_endpoint_relation_type	varchar(255) NOT NULL,
	service_endpoint_relation_key	varchar(255) NOT NULL,
	weight	integer NOT NULL,
	maximum_capacity	integer NOT NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_service_endpoint_provider_collection', true);
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ALTER service_endpoint_relation_key
	SET DEFAULT 'none'::character varying;
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ALTER weight
	SET DEFAULT 0;
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ALTER maximum_capacity
	SET DEFAULT 100;
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection ADD CONSTRAINT pk_service_endpoint_service_endpoint_provider_collection PRIMARY KEY (service_endpoint_id, service_endpoint_provider_collection_id, service_endpoint_relation_type, service_endpoint_relation_key);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_service_endpoint_provider_collection IS 'Connects service_endpoints to things that can possibly or do provide the service.  Things like geoip DNS and the like make this a _may_.';
COMMENT ON COLUMN jazzhands.service_endpoint_service_endpoint_provider_collection.weight IS 'to be deprecated, possibly replaced by property/json blob';
COMMENT ON COLUMN jazzhands.service_endpoint_service_endpoint_provider_collection.maximum_capacity IS 'to be deprecated, possibly replaced by property/json blob';
-- INDEXES
CREATE INDEX xifsvc_endpoint_svc_endpoint_prov_coll_coll_id ON jazzhands.service_endpoint_service_endpoint_provider_collection USING btree (service_endpoint_provider_collection_id);
CREATE INDEX xifsvc_endpoint_svc_endpoint_prov_collection_endpoint_id ON jazzhands.service_endpoint_service_endpoint_provider_collection USING btree (service_endpoint_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_service_endpoint_provider_collection and service_endpoint_provider_collection
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ADD CONSTRAINT fk_svc_endpoint_svc_endpoint_prov_coll_coll_id
	FOREIGN KEY (service_endpoint_provider_collection_id) REFERENCES jazzhands.service_endpoint_provider_collection(service_endpoint_provider_collection_id) DEFERRABLE;
-- consider FK service_endpoint_service_endpoint_provider_collection and service_endpoint
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ADD CONSTRAINT fk_svc_endpoint_svc_endpoint_prov_collection_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.svc_end_prov_svc_end_col_direct_check
CREATE OR REPLACE FUNCTION jazzhands.svc_end_prov_svc_end_col_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	-- At the moment, no checks "up" to service_endpoint
	--
	-- sanity checks for things to match
	--
	IF NEW.service_endpoint_relation_type = 'direct' THEN
		IF NEW.service_endpoint_relation_key != 'none' THEN
			RAISE EXCEPTION 'direct must have a key of none'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'direct-to-host service configuration is very particular';
		END IF;

		PERFORM *
		FROM service_endpoint_provider_collection
		WHERE service_endpoint_provider_collection_type =
			'per-service-endpoint-provider'
		AND service_endpoint_provider_collection_id =
			NEW.service_endpoint_provider_collection_id;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'direct must point to a service_collection_type of per-service-endpoint-provider'
			USING ERRCODE = 'foreign_key_violation',
			HINT = 'direct-to-host service configuration is very particular';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.svc_end_prov_svc_end_col_direct_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_svc_end_prov_svc_end_col_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_collection_id, service_endpoint_relation_type, service_endpoint_relation_key ON jazzhands.service_endpoint_service_endpoint_provider_collection NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.svc_end_prov_svc_end_col_direct_check();

-- considering NEW jazzhands.svc_ep_svc_epp_coll_direct
CREATE OR REPLACE FUNCTION jazzhands.svc_ep_svc_epp_coll_direct()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.service_endpoint_relation_type = 'per-service-endpoint-provider' THEN
		IF NEW.service_endpoint_relation_key != 'none' THEN
			RAISE EXCEPTION 'per-service-endpoint-provider is immutable because of direct connection'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'This check should be smarter';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.svc_ep_svc_epp_coll_direct() FROM public;
CREATE CONSTRAINT TRIGGER trigger_svc_ep_svc_epp_coll_direct AFTER INSERT OR UPDATE OF service_endpoint_relation_type, service_endpoint_relation_key ON jazzhands.service_endpoint_service_endpoint_provider_collection NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.svc_ep_svc_epp_coll_direct();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_service_endpoint_provider_collection');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_service_endpoint_provider_collection  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_service_endpoint_provider_collection');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_service_endpoint_provider_collection');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_service_endpoint_provider_collection');
-- DONE DEALING WITH TABLE service_endpoint_service_endpoint_provider_collection (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_endpoint_provider_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_service_endpoint_provider_collection failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_endpoint_provider_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_service_endpoint_provider_collection failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_service_sla (jazzhands)
CREATE TABLE jazzhands.service_endpoint_service_sla
(
	service_endpoint_service_sla_id	integer NOT NULL,
	service_endpoint_id	integer NOT NULL,
	service_sla_id	integer NOT NULL,
	service_environment_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla', true);
ALTER TABLE jazzhands.service_endpoint_service_sla
	ALTER service_endpoint_service_sla_id
	SET DEFAULT nextval('jazzhands.service_endpoint_service_sla_service_endpoint_service_sla_i_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_service_sla ADD CONSTRAINT ak_svc_endpoint_svc_sla_sep_id_sla_seid UNIQUE (service_endpoint_id, service_sla_id, service_environment_id);
ALTER TABLE jazzhands.service_endpoint_service_sla ADD CONSTRAINT pk_service_endpoint_service_sla PRIMARY KEY (service_endpoint_service_sla_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_service_sla IS 'SLAs provided by a service_endpoint.  In all liklihood, this will be fleshed out more.';
-- INDEXES
CREATE INDEX xifservice_endpoint_service_sla_endpoint_id ON jazzhands.service_endpoint_service_sla USING btree (service_endpoint_id);
CREATE INDEX xifservice_endpoint_service_sla_service_environment_id ON jazzhands.service_endpoint_service_sla USING btree (service_environment_id);
CREATE INDEX xifservice_endpoint_service_sla_service_sla_id ON jazzhands.service_endpoint_service_sla USING btree (service_sla_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_endpoint_service_sla and jazzhands.service_endpoint_service_sla_service_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_endpoint_service_sla_service_feature
--	ADD CONSTRAINT fk_svc_endpoint_svc_sla_service_feature_id
--	FOREIGN KEY (service_endpoint_service_sla_id) REFERENCES jazzhands.service_endpoint_service_sla(service_endpoint_service_sla_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_endpoint_service_sla and service_endpoint
ALTER TABLE jazzhands.service_endpoint_service_sla
	ADD CONSTRAINT fk_service_endpoint_service_sla_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;
-- consider FK service_endpoint_service_sla and service_environment
ALTER TABLE jazzhands.service_endpoint_service_sla
	ADD CONSTRAINT fk_service_endpoint_service_sla_service_environment_id
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id) DEFERRABLE;
-- consider FK service_endpoint_service_sla and service_sla
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_endpoint_service_sla
--	ADD CONSTRAINT fk_service_endpoint_service_sla_service_sla_id
--	FOREIGN KEY (service_sla_id) REFERENCES jazzhands.service_sla(service_sla_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_service_sla');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_service_sla  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_service_sla');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla');
ALTER SEQUENCE jazzhands.service_endpoint_service_sla_service_endpoint_service_sla_i_seq
	 OWNED BY service_endpoint_service_sla.service_endpoint_service_sla_id;
-- DONE DEALING WITH TABLE service_endpoint_service_sla (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_sla');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_service_sla failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_sla');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_service_sla failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_service_sla_service_feature (jazzhands)
CREATE TABLE jazzhands.service_endpoint_service_sla_service_feature
(
	service_endpoint_service_sla_id	integer NOT NULL,
	service_feature	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla_service_feature', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_service_sla_service_feature ADD CONSTRAINT pk_service_endpoint_service_sla_service_feature PRIMARY KEY (service_endpoint_service_sla_id, service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_service_sla_service_feature IS 'Indicates features provided by a given endpoint. This is tied through the SLA.';
-- INDEXES
CREATE INDEX xifsvc_endpoint_svc_sla_service_feature_feature ON jazzhands.service_endpoint_service_sla_service_feature USING btree (service_feature);
CREATE INDEX xifsvc_endpoint_svc_sla_service_feature_id ON jazzhands.service_endpoint_service_sla_service_feature USING btree (service_endpoint_service_sla_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_service_sla_service_feature and val_service_feature
ALTER TABLE jazzhands.service_endpoint_service_sla_service_feature
	ADD CONSTRAINT fk_svc_endpoint_svc_sla_service_feature_feature
	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;
-- consider FK service_endpoint_service_sla_service_feature and service_endpoint_service_sla
ALTER TABLE jazzhands.service_endpoint_service_sla_service_feature
	ADD CONSTRAINT fk_svc_endpoint_svc_sla_service_feature_id
	FOREIGN KEY (service_endpoint_service_sla_id) REFERENCES jazzhands.service_endpoint_service_sla(service_endpoint_service_sla_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_service_sla_service_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_service_sla_service_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_service_sla_service_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla_service_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_service_sla_service_feature');
-- DONE DEALING WITH TABLE service_endpoint_service_sla_service_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_sla_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_service_sla_service_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_service_sla_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_service_sla_service_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_endpoint_x509_certificate (jazzhands)
CREATE TABLE jazzhands.service_endpoint_x509_certificate
(
	service_endpoint_id	integer NOT NULL,
	x509_signed_certificate_id	integer NOT NULL,
	x509_certificate_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint_x509_certificate', true);
ALTER TABLE jazzhands.service_endpoint_x509_certificate
	ALTER x509_certificate_rank
	SET DEFAULT 10;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint_x509_certificate ADD CONSTRAINT ak_se_x509_id_rank UNIQUE (service_endpoint_id, x509_certificate_rank);
ALTER TABLE jazzhands.service_endpoint_x509_certificate ADD CONSTRAINT pk_service_endpoint_x509_certificate PRIMARY KEY (service_endpoint_id, x509_signed_certificate_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint_x509_certificate IS 'If a certificate is used for all instances of an endpoint (provided from the db), this maps that.  service_endpoint_provider_shared_netblock_layer3_interface is used for individual nodes to map their own certificates.';
COMMENT ON COLUMN jazzhands.service_endpoint_x509_certificate.x509_signed_certificate_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.service_endpoint_x509_certificate.x509_certificate_rank IS 'There may be more than one certifiate, this specifies importance.  This can be used to incrementally roll out certificates';
-- INDEXES
CREATE INDEX xifservice_endpoint_x509_certificate_seid ON jazzhands.service_endpoint_x509_certificate USING btree (service_endpoint_id);
CREATE INDEX xifservice_endpoint_x509_certificate_x509id ON jazzhands.service_endpoint_x509_certificate USING btree (x509_signed_certificate_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_endpoint_x509_certificate and service_endpoint
ALTER TABLE jazzhands.service_endpoint_x509_certificate
	ADD CONSTRAINT fk_service_endpoint_x509_certificate_seid
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;
-- consider FK service_endpoint_x509_certificate and x509_signed_certificate
ALTER TABLE jazzhands.service_endpoint_x509_certificate
	ADD CONSTRAINT fk_service_endpoint_x509_certificate_x509id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint_x509_certificate');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint_x509_certificate  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint_x509_certificate');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint_x509_certificate');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint_x509_certificate');
-- DONE DEALING WITH TABLE service_endpoint_x509_certificate (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint_x509_certificate failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint_x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint_x509_certificate failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_instance (jazzhands)
CREATE TABLE jazzhands.service_instance
(
	service_instance_id	integer NOT NULL,
	device_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	netblock_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_instance', true);
ALTER TABLE jazzhands.service_instance
	ALTER service_instance_id
	SET DEFAULT nextval('jazzhands.service_instance_service_instance_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_instance ADD CONSTRAINT ak_svc_instance_device_id_version UNIQUE (device_id, service_version_id);
ALTER TABLE jazzhands.service_instance ADD CONSTRAINT pk_service_instance PRIMARY KEY (service_instance_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_instance IS 'Model the presence of something that serves up a service on a device';
COMMENT ON COLUMN jazzhands.service_instance.service_version_id IS 'This is where a specific version of a service is mapped to a host';
-- INDEXES
CREATE INDEX xifservice_instance_dev_nblk ON jazzhands.service_instance USING btree (device_id, netblock_id);
CREATE INDEX xifservice_instance_svcversionid ON jazzhands.service_instance USING btree (service_version_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_instance and jazzhands.service_endpoint_provider_service_instance
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_siid
	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;
-- consider FK between service_instance and jazzhands.service_instance_provided_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_instance_provided_feature
--	ADD CONSTRAINT fk_svc_inst_prov_feature_inst_id
--	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_instance and layer3_interface_netblock
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_dev_nblk
	FOREIGN KEY (device_id, netblock_id) REFERENCES jazzhands.layer3_interface_netblock(device_id, netblock_id) DEFERRABLE;
-- consider FK service_instance and service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_instance
--	ADD CONSTRAINT fk_service_instance_svcversionid
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_instance');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_instance  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_instance');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_instance');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_instance');
ALTER SEQUENCE jazzhands.service_instance_service_instance_id_seq
	 OWNED BY service_instance.service_instance_id;
-- DONE DEALING WITH TABLE service_instance (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_instance failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_instance failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_instance_provided_feature (jazzhands)
CREATE TABLE jazzhands.service_instance_provided_feature
(
	service_instance_id	integer NOT NULL,
	service_feature	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_instance_provided_feature', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_instance_provided_feature ADD CONSTRAINT pk_service_instance_provided_feature PRIMARY KEY (service_instance_id, service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_instance_provided_feature IS 'If a service has features, this enumerates the ones that a given instance provides for mapping dependencies.';
-- INDEXES
CREATE INDEX xifsvc_inst_prov_feature_feature ON jazzhands.service_instance_provided_feature USING btree (service_feature);
CREATE INDEX xifsvc_inst_prov_feature_inst_id ON jazzhands.service_instance_provided_feature USING btree (service_instance_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_instance_provided_feature and val_service_feature
ALTER TABLE jazzhands.service_instance_provided_feature
	ADD CONSTRAINT fk_svc_inst_prov_feature_feature
	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;
-- consider FK service_instance_provided_feature and service_instance
ALTER TABLE jazzhands.service_instance_provided_feature
	ADD CONSTRAINT fk_svc_inst_prov_feature_inst_id
	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_instance_feature_check
CREATE OR REPLACE FUNCTION jazzhands.service_instance_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_version_collection_permitted_feature svcpf
		-- may not need this join
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_collection_id)
		JOIN service_instance si USING (service_version_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND		si.service_instance_id = NEW.service_instance_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Feature not permitted for this service'
       		USING ERRCODE = 'foreign_key_violation',
       		HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_instance_feature_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_instance_feature_check AFTER INSERT ON jazzhands.service_instance_provided_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_instance_feature_check();

-- considering NEW jazzhands.service_instance_service_feature_rename
CREATE OR REPLACE FUNCTION jazzhands.service_instance_service_feature_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_instance_service_feature_rename() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_instance_service_feature_rename AFTER UPDATE OF service_feature, service_instance_id ON jazzhands.service_instance_provided_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_instance_service_feature_rename();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_instance_provided_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_instance_provided_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_instance_provided_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_instance_provided_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_instance_provided_feature');
-- DONE DEALING WITH TABLE service_instance_provided_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance_provided_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_instance_provided_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance_provided_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_instance_provided_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_layer3_acl (jazzhands)
CREATE TABLE jazzhands.service_layer3_acl
(
	service_depend_id	integer NOT NULL,
	description	varchar(4096)  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_layer3_acl', true);
ALTER TABLE jazzhands.service_layer3_acl
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_layer3_acl ADD CONSTRAINT pk_service_layer3_acl PRIMARY KEY (service_depend_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_layer3_acl IS 'Foreign key enforcement to tie a service realtionship to acl rules and to enable/dsiable them.  This may go away in the future.';
-- INDEXES
CREATE UNIQUE INDEX xifservice_l3acl_depend_id ON jazzhands.service_layer3_acl USING btree (service_depend_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_layer3_acl and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_service_depend_id
	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_layer3_acl(service_depend_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service_layer3_acl and service_depend
ALTER TABLE jazzhands.service_layer3_acl
	ADD CONSTRAINT fk_service_l3acl_depend_id
	FOREIGN KEY (service_depend_id) REFERENCES jazzhands.service_depend(service_depend_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_layer3_acl');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_layer3_acl  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_layer3_acl');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_layer3_acl');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_layer3_acl');
-- DONE DEALING WITH TABLE service_layer3_acl (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_layer3_acl');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_layer3_acl failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_layer3_acl');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_layer3_acl failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_sla (jazzhands)
CREATE TABLE jazzhands.service_sla
(
	service_sla_id	integer NOT NULL,
	service_sla_name	varchar(255) NOT NULL,
	service_availability	integer  NULL,
	minimum_service_affinity	varchar(255)  NULL,
	maximum_service_affinity	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_sla', true);
--
-- Copying initialization data
--

INSERT INTO service_sla (
service_sla_id,service_sla_name,service_availability,minimum_service_affinity,maximum_service_affinity
) VALUES
	(1,'always','100',NULL,NULL),
	(2,'same-site',NULL,'site','site'),
	(3,'same-parent',NULL,'parent_device','parent_device'),
	(4,'same-device',NULL,'device','device')
;
ALTER TABLE jazzhands.service_sla
	ALTER service_sla_id
	SET DEFAULT nextval('jazzhands.service_sla_service_sla_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_sla ADD CONSTRAINT ak_service_sla_service_sla_name UNIQUE (service_sla_name);
ALTER TABLE jazzhands.service_sla ADD CONSTRAINT pk_service_sla PRIMARY KEY (service_sla_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_sla IS 'Service Level Agreements for Services.   This is currently more of a placeholder.';
COMMENT ON COLUMN jazzhands.service_sla.service_sla_name IS 'human readable name';
COMMENT ON COLUMN jazzhands.service_sla.service_availability IS 'percentagef time available to satisfy this SLA';
COMMENT ON COLUMN jazzhands.service_sla.minimum_service_affinity IS 'minimum affinity that satisfies this SLA';
COMMENT ON COLUMN jazzhands.service_sla.maximum_service_affinity IS 'maximum affinity that satisfies this SLA';
-- INDEXES
CREATE INDEX xifservice_sla_maximum_affinity ON jazzhands.service_sla USING btree (maximum_service_affinity);
CREATE INDEX xifservice_sla_minimum_affinity ON jazzhands.service_sla USING btree (minimum_service_affinity);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_sla and jazzhands.service_depend
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_service_sla_id
	FOREIGN KEY (service_sla_id) REFERENCES jazzhands.service_sla(service_sla_id) DEFERRABLE;
-- consider FK between service_sla and jazzhands.service_endpoint_service_sla
ALTER TABLE jazzhands.service_endpoint_service_sla
	ADD CONSTRAINT fk_service_endpoint_service_sla_service_sla_id
	FOREIGN KEY (service_sla_id) REFERENCES jazzhands.service_sla(service_sla_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service_sla and val_service_affinity
ALTER TABLE jazzhands.service_sla
	ADD CONSTRAINT fk_service_sla_maximum_affinity
	FOREIGN KEY (maximum_service_affinity) REFERENCES jazzhands.val_service_affinity(service_affinity) DEFERRABLE;
-- consider FK service_sla and val_service_affinity
ALTER TABLE jazzhands.service_sla
	ADD CONSTRAINT fk_service_sla_minimum_affinity
	FOREIGN KEY (minimum_service_affinity) REFERENCES jazzhands.val_service_affinity(service_affinity) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_sla');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_sla  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_sla');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_sla');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_sla');
ALTER SEQUENCE jazzhands.service_sla_service_sla_id_seq
	 OWNED BY service_sla.service_sla_id;
-- DONE DEALING WITH TABLE service_sla (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_sla');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_sla failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_sla');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_sla failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_software_repository (jazzhands)
CREATE TABLE jazzhands.service_software_repository
(
	service_id	integer NOT NULL,
	software_artifact_repository_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_software_repository', true);
ALTER TABLE jazzhands.service_software_repository
	ALTER software_artifact_repository_id
	SET DEFAULT nextval('jazzhands.service_software_repository_software_artifact_repository_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_software_repository ADD CONSTRAINT pk_service_software_repository PRIMARY KEY (service_id, software_artifact_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_software_repository IS 'Where artifacts for services can show up.  This may be used for trigger enforcement so that versions only show up certain places or can possibly be used to indicate which build services should be used to generate an artifact';
-- INDEXES
CREATE INDEX xifservice_software_repository_service_id ON jazzhands.service_software_repository USING btree (service_id);
CREATE INDEX xifservice_software_repository_sw_pkg_repo_id ON jazzhands.service_software_repository USING btree (software_artifact_repository_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_software_repository and service
ALTER TABLE jazzhands.service_software_repository
	ADD CONSTRAINT fk_service_software_repository_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_software_repository and software_artifact_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_software_repository
--	ADD CONSTRAINT fk_service_software_repository_sw_pkg_repo_id
--	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_software_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_software_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_software_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_software_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_software_repository');
ALTER SEQUENCE jazzhands.service_software_repository_software_artifact_repository_id_seq
	 OWNED BY service_software_repository.software_artifact_repository_id;
-- DONE DEALING WITH TABLE service_software_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_software_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_software_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_software_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_software_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_source_repository (jazzhands)
CREATE TABLE jazzhands.service_source_repository
(
	service_source_repository_id	integer NOT NULL,
	service_id	integer NOT NULL,
	source_repository_location_id	integer NOT NULL,
	service_source_policy_repository_path	varchar(255)  NULL,
	is_enabled	boolean NOT NULL,
	is_primary	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_source_repository', true);
ALTER TABLE jazzhands.service_source_repository
	ALTER service_source_repository_id
	SET DEFAULT nextval('jazzhands.service_source_repository_service_source_repository_id_seq'::regclass);
ALTER TABLE jazzhands.service_source_repository
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_source_repository
	ALTER is_primary
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_source_repository ADD CONSTRAINT ak_service_src_repo_svc_location UNIQUE (service_id, source_repository_location_id);
ALTER TABLE jazzhands.service_source_repository ADD CONSTRAINT pk_service_source_repository PRIMARY KEY (service_source_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_source_repository IS 'Indicates SCM respositories where source code can be found.';
COMMENT ON COLUMN jazzhands.service_source_repository.service_source_policy_repository_path IS 'optional path inside a checked out repository where source can be found';
-- INDEXES
CREATE INDEX xifservice_source_repo_service_id ON jazzhands.service_source_repository USING btree (service_id);
CREATE INDEX xifservice_source_repo_srcrepoid ON jazzhands.service_source_repository USING btree (source_repository_location_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_source_repository and jazzhands.service_version_source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_source_repository
--	ADD CONSTRAINT fk_svc_ver_src_repo_svc_src_repo_id
--	FOREIGN KEY (service_source_repository_id) REFERENCES jazzhands.service_source_repository(service_source_repository_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_source_repository and service
ALTER TABLE jazzhands.service_source_repository
	ADD CONSTRAINT fk_service_source_repo_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_source_repository and source_repository_location
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_source_repository
--	ADD CONSTRAINT fk_service_source_repo_srcrepoid
--	FOREIGN KEY (source_repository_location_id) REFERENCES jazzhands.source_repository_location(source_repository_location_id) DEFERRABLE;


-- TRIGGERS
-- considering NEW jazzhands.service_source_repository_sanity
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_sanity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	--
	-- check to see if there's another primary, if so fail.
	---
	IF NEW.is_primary THEN
		SELECT count(*) INTO _tally
		FROM service_source_repository
		WHERE service_id = NEW.service_id
		AND service_source_repository_id != NEW.service_source_repository_id
		AND is_primary;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'A primary source repository already exists for this service'
				USING ERRCODE = 'unique_violation';
		END IF;

	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_source_repository_sanity() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_source_repository_sanity AFTER INSERT OR UPDATE OF is_primary ON jazzhands.service_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_source_repository_sanity();

-- considering NEW jazzhands.service_source_repository_service_match_check
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	RAISE EXCEPTION 'Can not change service_id or service_source_repository_id due to missing trigger'
		USING HINT = 'need trigger that compares to service_version_source_repository_service_match_check';
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_source_repository_service_match_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_source_repository_service_match_check AFTER UPDATE OF service_id, service_source_repository_id ON jazzhands.service_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_source_repository_service_match_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_source_repository');
ALTER SEQUENCE jazzhands.service_source_repository_service_source_repository_id_seq
	 OWNED BY service_source_repository.service_source_repository_id;
-- DONE DEALING WITH TABLE service_source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version (jazzhands)
CREATE TABLE jazzhands.service_version
(
	service_version_id	integer NOT NULL,
	service_id	integer NOT NULL,
	service_type	varchar(255) NOT NULL,
	version_name	varchar(255) NOT NULL,
	is_enabled	boolean NOT NULL,
	is_deprecated	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version', true);
ALTER TABLE jazzhands.service_version
	ALTER service_version_id
	SET DEFAULT nextval('jazzhands.service_version_service_version_id_seq'::regclass);
ALTER TABLE jazzhands.service_version
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_version
	ALTER is_deprecated
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version ADD CONSTRAINT ak_service_version_service_id_version_name UNIQUE (service_id, version_name);
ALTER TABLE jazzhands.service_version ADD CONSTRAINT pk_service_version PRIMARY KEY (service_version_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version IS 'Each release of a service has a row here.  There may also be synthesized rows here.';
COMMENT ON COLUMN jazzhands.service_version.service_type IS 'The service type for this version.  This may vary from version to version.';
COMMENT ON COLUMN jazzhands.service_version.is_deprecated IS 'service version is no longer in use or in the process of being turned down';
-- INDEXES
CREATE INDEX xifservice_version_service_id ON jazzhands.service_version USING btree (service_id);
CREATE INDEX xifsvc_version_service_type ON jazzhands.service_version USING btree (service_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_version and jazzhands.service_depend
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_max_service_version_id
	FOREIGN KEY (maximum_service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_depend
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_min_service_version_id
	FOREIGN KEY (minimum_service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_depend
ALTER TABLE jazzhands.service_depend
	ADD CONSTRAINT fk_service_depend_service_version_id
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_instance
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_svcversionid
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_version_artifact
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_artifact
--	ADD CONSTRAINT fk_service_version_artifact_service_version_id
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- consider FK between service_version and jazzhands.service_version_collection_service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_service_version
--	ADD CONSTRAINT fk_service_version_collection_service_version_version
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- consider FK between service_version and jazzhands.service_version_software_artifact_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_software_artifact_repository
--	ADD CONSTRAINT fk_service_version_software_artifact_repository_svi
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- consider FK between service_version and jazzhands.service_version_source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_source_repository
--	ADD CONSTRAINT fk_service_version_source_repository_svi
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_version and service
ALTER TABLE jazzhands.service_version
	ADD CONSTRAINT fk_service_version_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_version and val_service_type
ALTER TABLE jazzhands.service_version
	ADD CONSTRAINT fk_svc_version_service_type
	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.manip_all_svc_collection_members
CREATE OR REPLACE FUNCTION jazzhands.manip_all_svc_collection_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'all-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'current-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'all-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'current-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);

		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.manip_all_svc_collection_members() FROM public;
CREATE TRIGGER trigger_manip_all_svc_collection_members AFTER INSERT ON jazzhands.service_version FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_all_svc_collection_members();

-- considering NEW jazzhands.manip_all_svc_collection_members
CREATE OR REPLACE FUNCTION jazzhands.manip_all_svc_collection_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'all-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'current-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'all-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'current-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);

		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.manip_all_svc_collection_members() FROM public;
CREATE TRIGGER trigger_manip_all_svc_collection_members_del BEFORE DELETE ON jazzhands.service_version FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_all_svc_collection_members();

-- considering NEW jazzhands.propagate_service_type_to_version
CREATE OR REPLACE FUNCTION jazzhands.propagate_service_type_to_version()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.service_type IS NULL THEN
		SELECT service_type
		INTO NEW.service_type
		FROM service
		WHERE service_id = NEW.service_id;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.propagate_service_type_to_version() FROM public;
CREATE TRIGGER trigger_propagate_service_type_to_version BEFORE INSERT ON jazzhands.service_version FOR EACH ROW EXECUTE PROCEDURE jazzhands.propagate_service_type_to_version();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version');
ALTER SEQUENCE jazzhands.service_version_service_version_id_seq
	 OWNED BY service_version.service_version_id;
-- DONE DEALING WITH TABLE service_version (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_artifact (jazzhands)
CREATE TABLE jazzhands.service_version_artifact
(
	service_version_id	integer NOT NULL,
	checksum_algorithm	varchar(255) NOT NULL,
	software_artifact_name_id	integer NOT NULL,
	software_artifact_repository_id	integer NOT NULL,
	checksum	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_artifact', true);
ALTER TABLE jazzhands.service_version_artifact
	ALTER software_artifact_name_id
	SET DEFAULT nextval('jazzhands.service_version_artifact_software_artifact_name_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_artifact ADD CONSTRAINT pk_service_version_artifact PRIMARY KEY (service_version_id, checksum_algorithm, software_artifact_name_id, software_artifact_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_artifact IS 'Maps service versions to where to find their artifacts.';
-- INDEXES
CREATE INDEX xifservice_version_artifact_service_version_id ON jazzhands.service_version_artifact USING btree (service_version_id);
CREATE INDEX xifsvc_ver_artifact_sw_art_repo_id ON jazzhands.service_version_artifact USING btree (software_artifact_repository_id);
CREATE INDEX xifsvc_version_artifact_algorithma ON jazzhands.service_version_artifact USING btree (checksum_algorithm);
CREATE INDEX xifsvc_version_artifact_name ON jazzhands.service_version_artifact USING btree (software_artifact_name_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.service_version_artifact ADD CONSTRAINT ckc_checksum_2053854841
	CHECK (((((checksum_algorithm)::text = 'none'::text) AND (checksum IS NULL)) OR (((checksum_algorithm)::text <> 'none'::text) AND (checksum IS NOT NULL))));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_artifact and service_version
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_service_version_artifact_service_version_id
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_artifact and software_artifact_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_version_artifact
--	ADD CONSTRAINT fk_svc_ver_artifact_sw_art_repo_id
--	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- consider FK service_version_artifact and val_checksum_algorithm
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_version_artifact_algorithma
	FOREIGN KEY (checksum_algorithm) REFERENCES jazzhands.val_checksum_algorithm(checksum_algorithm) DEFERRABLE;
-- consider FK service_version_artifact and software_artifact_name
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_version_artifact_name
	FOREIGN KEY (software_artifact_name_id) REFERENCES jazzhands.software_artifact_name(software_artifact_name_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_artifact');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_artifact  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_artifact');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_artifact');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_artifact');
ALTER SEQUENCE jazzhands.service_version_artifact_software_artifact_name_id_seq
	 OWNED BY service_version_artifact.software_artifact_name_id;
-- DONE DEALING WITH TABLE service_version_artifact (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_artifact');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_artifact failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_artifact');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_artifact failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_collection (jazzhands)
CREATE TABLE jazzhands.service_version_collection
(
	service_version_collection_id	integer NOT NULL,
	service_version_collection_name	varchar(255) NOT NULL,
	service_version_collection_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	external_id	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_collection', true);
ALTER TABLE jazzhands.service_version_collection
	ALTER service_version_collection_id
	SET DEFAULT nextval('jazzhands.service_version_collection_service_version_collection_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_collection ADD CONSTRAINT pk_service_version_collection PRIMARY KEY (service_version_collection_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_collection IS 'Collections of service versions.  Some are automatically managed to make dealing with them easier.';
COMMENT ON COLUMN jazzhands.service_version_collection.external_id IS 'opaque id used in remote system to identifty this object.  Used for syncing an authoritative copy.';
-- INDEXES
CREATE INDEX xifservice_version_collection_val_collection_type ON jazzhands.service_version_collection USING btree (service_version_collection_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_version_collection and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_pv_sver_coll_id
	FOREIGN KEY (property_value_service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id);
-- consider FK between service_version_collection and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_sver_coll_id
	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id);
-- consider FK between service_version_collection and jazzhands.service_version_collection_hier
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_hier
--	ADD CONSTRAINT fk_service_version_collection_hier_child
--	FOREIGN KEY (child_service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;

-- consider FK between service_version_collection and jazzhands.service_version_collection_hier
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_hier
--	ADD CONSTRAINT fk_service_version_collection_hier_parent
--	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;

-- consider FK between service_version_collection and jazzhands.service_version_collection_permitted_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_permitted_feature
--	ADD CONSTRAINT fk_svc_ver_call_coll_id
--	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;

-- consider FK between service_version_collection and jazzhands.service_version_collection_service_version
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_version_collection_service_version
--	ADD CONSTRAINT fk_svc_version_collection_svc_version_coll_id
--	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_version_collection and val_service_version_collection_type
ALTER TABLE jazzhands.service_version_collection
	ADD CONSTRAINT fk_service_version_collection_val_collection_type
	FOREIGN KEY (service_version_collection_type) REFERENCES jazzhands.val_service_version_collection_type(service_version_collection_type) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_collection');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_collection  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_collection');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_collection');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_collection');
ALTER SEQUENCE jazzhands.service_version_collection_service_version_collection_id_seq
	 OWNED BY service_version_collection.service_version_collection_id;
-- DONE DEALING WITH TABLE service_version_collection (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_collection failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_collection failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_collection_hier (jazzhands)
CREATE TABLE jazzhands.service_version_collection_hier
(
	service_version_collection_id	integer NOT NULL,
	child_service_version_collection_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_collection_hier', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_collection_hier ADD CONSTRAINT pk_service_version_collection_hier PRIMARY KEY (service_version_collection_id, child_service_version_collection_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifservice_version_collection_hier_child ON jazzhands.service_version_collection_hier USING btree (child_service_version_collection_id);
CREATE INDEX xifservice_version_collection_hier_parent ON jazzhands.service_version_collection_hier USING btree (service_version_collection_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_collection_hier and service_version_collection
ALTER TABLE jazzhands.service_version_collection_hier
	ADD CONSTRAINT fk_service_version_collection_hier_child
	FOREIGN KEY (child_service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;
-- consider FK service_version_collection_hier and service_version_collection
ALTER TABLE jazzhands.service_version_collection_hier
	ADD CONSTRAINT fk_service_version_collection_hier_parent
	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_collection_hier');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_collection_hier  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_collection_hier');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_collection_hier');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_collection_hier');
-- DONE DEALING WITH TABLE service_version_collection_hier (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_hier');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_collection_hier failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_hier');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_collection_hier failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_collection_permitted_feature (jazzhands)
CREATE TABLE jazzhands.service_version_collection_permitted_feature
(
	service_version_collection_id	integer NOT NULL,
	service_feature	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_collection_permitted_feature', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_collection_permitted_feature ADD CONSTRAINT pk_service_version_collection_permitted_feature PRIMARY KEY (service_version_collection_id, service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_collection_permitted_feature IS 'Features that a given service version collection are permitted to offer';
-- INDEXES
CREATE INDEX xifsvc_ver_call_coll_id ON jazzhands.service_version_collection_permitted_feature USING btree (service_version_collection_id);
CREATE INDEX xifsvc_ver_call_permitted_feature ON jazzhands.service_version_collection_permitted_feature USING btree (service_feature);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_collection_permitted_feature and service_version_collection
ALTER TABLE jazzhands.service_version_collection_permitted_feature
	ADD CONSTRAINT fk_svc_ver_call_coll_id
	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;
-- consider FK service_version_collection_permitted_feature and val_service_feature
ALTER TABLE jazzhands.service_version_collection_permitted_feature
	ADD CONSTRAINT fk_svc_ver_call_permitted_feature
	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_version_feature_permitted_rename
CREATE OR REPLACE FUNCTION jazzhands.service_version_feature_permitted_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_version_feature_permitted_rename() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_version_feature_permitted_rename AFTER UPDATE OF service_feature ON jazzhands.service_version_collection_permitted_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_version_feature_permitted_rename();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_collection_permitted_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_collection_permitted_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_collection_permitted_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_collection_permitted_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_collection_permitted_feature');
-- DONE DEALING WITH TABLE service_version_collection_permitted_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_permitted_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_collection_permitted_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_permitted_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_collection_permitted_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_collection_service_version (jazzhands)
CREATE TABLE jazzhands.service_version_collection_service_version
(
	service_version_collection_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_collection_service_version', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_collection_service_version ADD CONSTRAINT pk_service_version_collection_service_version PRIMARY KEY (service_version_collection_id, service_version_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifservice_version_collection_service_version_version ON jazzhands.service_version_collection_service_version USING btree (service_version_id);
CREATE INDEX xifsvc_version_collection_svc_version_coll_id ON jazzhands.service_version_collection_service_version USING btree (service_version_collection_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_collection_service_version and service_version
ALTER TABLE jazzhands.service_version_collection_service_version
	ADD CONSTRAINT fk_service_version_collection_service_version_version
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_collection_service_version and service_version_collection
ALTER TABLE jazzhands.service_version_collection_service_version
	ADD CONSTRAINT fk_svc_version_collection_svc_version_coll_id
	FOREIGN KEY (service_version_collection_id) REFERENCES jazzhands.service_version_collection(service_version_collection_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_collection_service_version');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_collection_service_version  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_collection_service_version');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_collection_service_version');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_collection_service_version');
-- DONE DEALING WITH TABLE service_version_collection_service_version (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_collection_service_version failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_collection_service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_collection_service_version failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_software_artifact_repository (jazzhands)
CREATE TABLE jazzhands.service_version_software_artifact_repository
(
	service_version_id	integer NOT NULL,
	software_artifact_repository_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_software_artifact_repository', true);
ALTER TABLE jazzhands.service_version_software_artifact_repository
	ALTER software_artifact_repository_id
	SET DEFAULT nextval('jazzhands.service_version_software_arti_software_artifact_repository__seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_software_artifact_repository ADD CONSTRAINT pk_service_version_software_artifact_repository PRIMARY KEY (service_version_id, software_artifact_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_software_artifact_repository IS 'This is probably redundnt with service_version_artifact and will merge with that. XXX';
-- INDEXES
CREATE INDEX xifservice_version_software_artifact_repository_svi ON jazzhands.service_version_software_artifact_repository USING btree (service_version_id);
CREATE INDEX xiservice_version_software_sw_atfict_repo_id ON jazzhands.service_version_software_artifact_repository USING btree (software_artifact_repository_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_software_artifact_repository and service_version
ALTER TABLE jazzhands.service_version_software_artifact_repository
	ADD CONSTRAINT fk_service_version_software_artifact_repository_svi
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_software_artifact_repository and software_artifact_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_version_software_artifact_repository
--	ADD CONSTRAINT fk_service_version_software_sw_atfict_repo_id
--	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_software_artifact_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_software_artifact_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_software_artifact_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_software_artifact_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_software_artifact_repository');
ALTER SEQUENCE jazzhands.service_version_software_arti_software_artifact_repository__seq
	 OWNED BY service_version_software_artifact_repository.software_artifact_repository_id;
-- DONE DEALING WITH TABLE service_version_software_artifact_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE service_version_source_repository (jazzhands)
CREATE TABLE jazzhands.service_version_source_repository
(
	service_source_repository_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	software_tag	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_source_repository', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_source_repository ADD CONSTRAINT pk_service_version_source_repository PRIMARY KEY (service_source_repository_id, service_version_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_source_repository IS 'Where to find the exact source code to a specifc service version';
COMMENT ON COLUMN jazzhands.service_version_source_repository.software_tag IS 'tag in SCM that referes to this release';
-- INDEXES
CREATE INDEX xifservice_version_source_repository_svi ON jazzhands.service_version_source_repository USING btree (service_version_id);
CREATE INDEX xifsvc_ver_src_repo_svc_src_repo_id ON jazzhands.service_version_source_repository USING btree (service_source_repository_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_source_repository and service_version
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_service_version_source_repository_svi
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_source_repository and service_source_repository
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_svc_ver_src_repo_svc_src_repo_id
	FOREIGN KEY (service_source_repository_id) REFERENCES jazzhands.service_source_repository(service_source_repository_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_version_source_repository_service_match_check
CREATE OR REPLACE FUNCTION jazzhands.service_version_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_source_repository
	WHERE service_source_repository_id = NEW.service_source_repository_id
	AND service_id = (SELECT service_id FROM service_version WHERE service_version_id = NEW.service_version_id);

	IF NOT FOUND THEN
		RAISE EXCEPTION 'source repository is not associted with the service'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'consider adding a row to service_source_repository';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_version_source_repository_service_match_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_version_source_repository_service_match_check AFTER INSERT OR UPDATE OF service_version_id, service_source_repository_id ON jazzhands.service_version_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_version_source_repository_service_match_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_source_repository');
-- DONE DEALING WITH TABLE service_version_source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE software_artifact_repository (jazzhands)
CREATE TABLE jazzhands.software_artifact_repository
(
	software_artifact_repository_id	integer NOT NULL,
	software_artifact_repository_name	varchar(255) NOT NULL,
	software_artifact_system_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_repository', true);
ALTER TABLE jazzhands.software_artifact_repository
	ALTER software_artifact_repository_id
	SET DEFAULT nextval('jazzhands.software_artifact_repository_software_artifact_repository_i_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository ADD CONSTRAINT ak_sw_artifcate_repo_system_id_name UNIQUE (software_artifact_system_id, software_artifact_repository_name);
ALTER TABLE jazzhands.software_artifact_repository ADD CONSTRAINT pk_software_artifact_repository PRIMARY KEY (software_artifact_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_repository IS 'Repositories inside artifact systems that actually provide artifacts for installation';
-- INDEXES
CREATE INDEX xifsoftware_artifact_repository_location_pkg_repo_id ON jazzhands.software_artifact_repository USING btree (software_artifact_system_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between software_artifact_repository and jazzhands.service_software_repository
ALTER TABLE jazzhands.service_software_repository
	ADD CONSTRAINT fk_service_software_repository_sw_pkg_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.service_version_software_artifact_repository
ALTER TABLE jazzhands.service_version_software_artifact_repository
	ADD CONSTRAINT fk_service_version_software_sw_atfict_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_location
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_location
--	ADD CONSTRAINT fk_software_artifact_repo_loc_sw_art_repo_id
--	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_relation
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_relation
--	ADD CONSTRAINT fk_software_artifact_repository_relation_repository
--	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_relation
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_relation
--	ADD CONSTRAINT fk_software_artifact_repository_relation_repository_other
--	FOREIGN KEY (related_software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- consider FK between software_artifact_repository and jazzhands.service_version_artifact
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_ver_artifact_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK software_artifact_repository and software_artifact_system
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.software_artifact_repository
--	ADD CONSTRAINT fk_software_artifact_repository_location_pkg_repo_id
--	FOREIGN KEY (software_artifact_system_id) REFERENCES jazzhands.software_artifact_system(software_artifact_system_id) DEFERRABLE;


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository');
ALTER SEQUENCE jazzhands.software_artifact_repository_software_artifact_repository_i_seq
	 OWNED BY software_artifact_repository.software_artifact_repository_id;
-- DONE DEALING WITH TABLE software_artifact_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE software_artifact_repository_location (jazzhands)
CREATE TABLE jazzhands.software_artifact_repository_location
(
	software_artifact_repository_id	integer NOT NULL,
	software_artifact_repository_location_type	varchar(255) NOT NULL,
	software_artifact_type	varchar(50) NOT NULL,
	repository_uri	varchar(255) NOT NULL,
	service_environment_collection_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_repository_location', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository_location ADD CONSTRAINT pk_software_artifact_repository_location PRIMARY KEY (software_artifact_repository_id, software_artifact_repository_location_type);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_repository_location IS 'Locations inside artifact repositories.  This may go away or merge into software_artifact_repository.';
-- INDEXES
CREATE INDEX xifsoftware_artifact_repo_loc_sw_art_repo_id ON jazzhands.software_artifact_repository_location USING btree (software_artifact_repository_id);
CREATE INDEX xifsoftware_artifact_repo_location_se_col_id ON jazzhands.software_artifact_repository_location USING btree (service_environment_collection_id);
CREATE INDEX xifsw_artifact_repo_loc_sw_artifact_type ON jazzhands.software_artifact_repository_location USING btree (software_artifact_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK software_artifact_repository_location and software_artifact_repository
ALTER TABLE jazzhands.software_artifact_repository_location
	ADD CONSTRAINT fk_software_artifact_repo_loc_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK software_artifact_repository_location and service_environment_collection
ALTER TABLE jazzhands.software_artifact_repository_location
	ADD CONSTRAINT fk_software_artifact_repo_location_se_col_id
	FOREIGN KEY (service_environment_collection_id) REFERENCES jazzhands.service_environment_collection(service_environment_collection_id) DEFERRABLE;
-- consider FK software_artifact_repository_location and val_software_artifact_type
ALTER TABLE jazzhands.software_artifact_repository_location
	ADD CONSTRAINT fk_sw_artifact_repo_loc_sw_artifact_type
	FOREIGN KEY (software_artifact_type) REFERENCES jazzhands.val_software_artifact_type(software_artifact_type) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_repository_location');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_repository_location  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_repository_location');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_repository_location');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository_location');
-- DONE DEALING WITH TABLE software_artifact_repository_location (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_repository_location failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_repository_location failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE software_artifact_repository_relation (jazzhands)
CREATE TABLE jazzhands.software_artifact_repository_relation
(
	software_artifact_repository_id	integer NOT NULL,
	related_software_artifact_repository_id	integer NOT NULL,
	software_artifact_relationship	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_repository_relation', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository_relation ADD CONSTRAINT pk_software_artifact_repository_relation PRIMARY KEY (software_artifact_repository_id, related_software_artifact_repository_id, software_artifact_relationship);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_repository_relation IS 'Artifact repositories that require other artifact repositories.  This is typically used to indicate repositories that should travel together';
-- INDEXES
CREATE INDEX xifsoftware_artifact_repository_relation_repository ON jazzhands.software_artifact_repository_relation USING btree (software_artifact_repository_id);
CREATE INDEX xifsoftware_artifact_repository_relation_repository_other ON jazzhands.software_artifact_repository_relation USING btree (related_software_artifact_repository_id);
CREATE INDEX xir_992 ON jazzhands.software_artifact_repository_relation USING btree (software_artifact_relationship);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK software_artifact_repository_relation and software_artifact_repository
ALTER TABLE jazzhands.software_artifact_repository_relation
	ADD CONSTRAINT fk_software_artifact_repository_relation_repository
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK software_artifact_repository_relation and software_artifact_repository
ALTER TABLE jazzhands.software_artifact_repository_relation
	ADD CONSTRAINT fk_software_artifact_repository_relation_repository_other
	FOREIGN KEY (related_software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK software_artifact_repository_relation and val_software_artifact_relationship
ALTER TABLE jazzhands.software_artifact_repository_relation
	ADD CONSTRAINT fk_sw_artifact_repo_relation_realtionship
	FOREIGN KEY (software_artifact_relationship) REFERENCES jazzhands.val_software_artifact_relationship(software_artifact_relationship) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_repository_relation');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_repository_relation  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_repository_relation');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_repository_relation');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository_relation');
-- DONE DEALING WITH TABLE software_artifact_repository_relation (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_relation');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_repository_relation failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_relation');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_repository_relation failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE software_artifact_system (jazzhands)
CREATE TABLE jazzhands.software_artifact_system
(
	software_artifact_system_id	integer NOT NULL,
	software_artifact_system_name	varchar(255) NOT NULL,
	software_artifact_system_url	varchar(512) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_system', true);
ALTER TABLE jazzhands.software_artifact_system
	ALTER software_artifact_system_id
	SET DEFAULT nextval('jazzhands.software_artifact_system_software_artifact_system_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_system ADD CONSTRAINT ak_sw_artifcate_system_name UNIQUE (software_artifact_system_name);
ALTER TABLE jazzhands.software_artifact_system ADD CONSTRAINT pk_software_artifact_system PRIMARY KEY (software_artifact_system_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_system IS 'Systems that contain repositories that are used to provide artifacts';
-- INDEXES

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.software_artifact_system ADD CONSTRAINT ckc_valid_url_2059589952
	CHECK (((software_artifact_system_url)::text ~ '^([a-z][-_a-z0-9]*)://[^\s/$.?#].[^\s]*$'::text));

-- FOREIGN KEYS FROM
-- consider FK between software_artifact_system and jazzhands.software_artifact_repository
ALTER TABLE jazzhands.software_artifact_repository
	ADD CONSTRAINT fk_software_artifact_repository_location_pkg_repo_id
	FOREIGN KEY (software_artifact_system_id) REFERENCES jazzhands.software_artifact_system(software_artifact_system_id) DEFERRABLE;

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_system');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_system  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_system');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_system');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_system');
ALTER SEQUENCE jazzhands.software_artifact_system_software_artifact_system_id_seq
	 OWNED BY software_artifact_system.software_artifact_system_id;
-- DONE DEALING WITH TABLE software_artifact_system (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_system');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_system failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_system');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_system failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository (jazzhands)
CREATE TABLE jazzhands.source_repository
(
	source_repository_id	integer NOT NULL,
	source_repository_name	varchar(255) NOT NULL,
	source_repository_method	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository', true);
ALTER TABLE jazzhands.source_repository
	ALTER source_repository_id
	SET DEFAULT nextval('jazzhands.source_repository_source_repository_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository ADD CONSTRAINT ak_source_repository_src_repo_name UNIQUE (source_repository_name);
ALTER TABLE jazzhands.source_repository ADD CONSTRAINT pk_source_repository PRIMARY KEY (source_repository_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifsrc_repo_src_repo_method ON jazzhands.source_repository USING btree (source_repository_method);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository and jazzhands.source_repository_location
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_location
--	ADD CONSTRAINT fk_src_repo_location_src_repo_id
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;

-- consider FK between source_repository and jazzhands.source_repository_url
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_url
--	ADD CONSTRAINT fk_src_repo_url_src_repo_id
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK source_repository and val_source_repository_method
ALTER TABLE jazzhands.source_repository
	ADD CONSTRAINT fk_src_repo_src_repo_method
	FOREIGN KEY (source_repository_method) REFERENCES jazzhands.val_source_repository_method(source_repository_method) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository');
ALTER SEQUENCE jazzhands.source_repository_source_repository_id_seq
	 OWNED BY source_repository.source_repository_id;
-- DONE DEALING WITH TABLE source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository_location (jazzhands)
CREATE TABLE jazzhands.source_repository_location
(
	source_repository_location_id	integer NOT NULL,
	source_repository_id	integer NOT NULL,
	service_source_control_purpose	varchar(255) NOT NULL,
	service_source_repository_path	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_location', true);
ALTER TABLE jazzhands.source_repository_location
	ALTER source_repository_location_id
	SET DEFAULT nextval('jazzhands.source_repository_location_source_repository_location_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_location ADD CONSTRAINT pk_source_repository_location PRIMARY KEY (source_repository_location_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.source_repository_location.service_source_control_purpose IS 'business purpose of the contents of the repository';
COMMENT ON COLUMN jazzhands.source_repository_location.service_source_repository_path IS 'path inside a repository to find source';
-- INDEXES
CREATE INDEX xifsrc_repo_location_purpose ON jazzhands.source_repository_location USING btree (service_source_control_purpose);
CREATE INDEX xifsrc_repo_location_src_repo_id ON jazzhands.source_repository_location USING btree (source_repository_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository_location and jazzhands.service_source_repository
ALTER TABLE jazzhands.service_source_repository
	ADD CONSTRAINT fk_service_source_repo_srcrepoid
	FOREIGN KEY (source_repository_location_id) REFERENCES jazzhands.source_repository_location(source_repository_location_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK source_repository_location and val_service_source_control_purpose
ALTER TABLE jazzhands.source_repository_location
	ADD CONSTRAINT fk_src_repo_location_purpose
	FOREIGN KEY (service_source_control_purpose) REFERENCES jazzhands.val_service_source_control_purpose(service_source_control_purpose) DEFERRABLE;
-- consider FK source_repository_location and source_repository
ALTER TABLE jazzhands.source_repository_location
	ADD CONSTRAINT fk_src_repo_location_src_repo_id
	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_location');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_location  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_location');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_location');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_location');
ALTER SEQUENCE jazzhands.source_repository_location_source_repository_location_id_seq
	 OWNED BY source_repository_location.source_repository_location_id;
-- DONE DEALING WITH TABLE source_repository_location (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_location failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_location failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository_url (jazzhands)
CREATE TABLE jazzhands.source_repository_url
(
	source_repository_id	integer NOT NULL,
	source_repository_url_purpose	varchar(50) NOT NULL,
	source_repository_url	varchar(512)  NULL,
	service_endpoint_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_url', true);
ALTER TABLE jazzhands.source_repository_url
	ALTER source_repository_id
	SET DEFAULT nextval('jazzhands.source_repository_url_source_repository_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_url ADD CONSTRAINT pk_source_repository_url PRIMARY KEY (source_repository_id, source_repository_url_purpose);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.source_repository_url.source_repository_url_purpose IS 'what the url is used for';
COMMENT ON COLUMN jazzhands.source_repository_url.source_repository_url IS 'temporary column to be replaced by service_endpoint_id';
COMMENT ON COLUMN jazzhands.source_repository_url.service_endpoint_id IS 'Must be set if source_repository_url is not set. This will eventually replace that column completely.';
-- INDEXES
CREATE INDEX xifsrc_repo_url_src_repo_id ON jazzhands.source_repository_url USING btree (source_repository_id);
CREATE INDEX xifsrc_repo_url_url_purpose ON jazzhands.source_repository_url USING btree (source_repository_url_purpose);
CREATE INDEX xifsvc_endpoint_source_repo_url ON jazzhands.source_repository_url USING btree (service_endpoint_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.source_repository_url ADD CONSTRAINT ckc_valid_url_1827807252
	CHECK (((source_repository_url)::text ~ '^([a-z][-_a-z0-9]*)://[^\s/$.?#].[^\s]*$'::text));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK source_repository_url and source_repository
ALTER TABLE jazzhands.source_repository_url
	ADD CONSTRAINT fk_src_repo_url_src_repo_id
	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;
-- consider FK source_repository_url and val_source_repository_url_purpose
ALTER TABLE jazzhands.source_repository_url
	ADD CONSTRAINT fk_src_repo_url_url_purpose
	FOREIGN KEY (source_repository_url_purpose) REFERENCES jazzhands.val_source_repository_url_purpose(source_repository_url_purpose) DEFERRABLE;
-- consider FK source_repository_url and service_endpoint
ALTER TABLE jazzhands.source_repository_url
	ADD CONSTRAINT fk_svc_endpoint_source_repo_url
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);

-- TRIGGERS
-- considering NEW jazzhands.source_repository_url_endpoint_enforcement
CREATE OR REPLACE FUNCTION jazzhands.source_repository_url_endpoint_enforcement()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.source_repository_url IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either source_repository_url or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.source_repository_url IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of source_repository_url or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.source_repository_url_endpoint_enforcement() FROM public;
CREATE CONSTRAINT TRIGGER trigger_source_repository_url_endpoint_enforcement AFTER INSERT OR UPDATE OF source_repository_url, service_endpoint_id ON jazzhands.source_repository_url NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.source_repository_url_endpoint_enforcement();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_url');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_url  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_url');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_url');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_url');
ALTER SEQUENCE jazzhands.source_repository_url_source_repository_id_seq
	 OWNED BY source_repository_url.source_repository_id;
-- DONE DEALING WITH TABLE source_repository_url (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_url');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_url failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_url');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_url failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE static_route_template
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'static_route_template', 'static_route_template');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_netblock_st_rt_dst_net;
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_netblock_st_rt_src_net;
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_static_rt_net_interface;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'static_route_template', newobject := 'static_route_template', newmap := '{"pk_static_route_template":{"columns":["static_route_template_id"],"def":"PRIMARY KEY (static_route_template_id)","deferrable":false,"deferred":false,"name":"pk_static_route_template","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS pk_static_route_template;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_static_route_template ON jazzhands.static_route_template;
DROP TRIGGER IF EXISTS trigger_audit_static_route_template ON jazzhands.static_route_template;
DROP FUNCTION IF EXISTS perform_audit_static_route_template();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'static_route_template', tags := ARRAY['table_static_route_template']);
---- BEGIN jazzhands_audit.static_route_template TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'static_route_template', tags := ARRAY['table_static_route_template']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'static_route_template', 'static_route_template');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'static_route_template');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.static_route_template DROP CONSTRAINT IF EXISTS static_route_template_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_static_route_template_pk_static_route_template";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.static_route_template TEARDOWN


ALTER TABLE static_route_template RENAME TO static_route_template_v91;
ALTER TABLE jazzhands_audit.static_route_template RENAME TO static_route_template_v91;

CREATE TABLE jazzhands.static_route_template
(
	static_route_template_id	integer NOT NULL,
	netblock_source_id	integer NOT NULL,
	layer3_interface_destination_id	integer NOT NULL,
	netblock_id	integer NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'static_route_template', false);
ALTER TABLE static_route_template
	ALTER static_route_template_id
	SET DEFAULT nextval('jazzhands.static_route_template_static_route_template_id_seq'::regclass);

INSERT INTO static_route_template (
	static_route_template_id,
	netblock_source_id,
	layer3_interface_destination_id,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	static_route_template_id,
	netblock_source_id,
	layer3_interface_destination_id,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM static_route_template_v91;


INSERT INTO jazzhands_audit.static_route_template (
	static_route_template_id,
	netblock_source_id,
	layer3_interface_destination_id,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	static_route_template_id,
	netblock_source_id,
	layer3_interface_destination_id,
	netblock_id,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.static_route_template_v91;

ALTER TABLE jazzhands.static_route_template
	ALTER static_route_template_id
	SET DEFAULT nextval('jazzhands.static_route_template_static_route_template_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.static_route_template ADD CONSTRAINT pk_static_route_template PRIMARY KEY (static_route_template_id);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK static_route_template and netblock
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_netblock_st_rt_dst_net
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK static_route_template and netblock
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_netblock_st_rt_src_net
	FOREIGN KEY (netblock_source_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK static_route_template and layer3_interface
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_static_rt_net_interface
	FOREIGN KEY (layer3_interface_destination_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('static_route_template');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route_template  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'static_route_template');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'static_route_template');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'static_route_template');
ALTER SEQUENCE jazzhands.static_route_template_static_route_template_id_seq
	 OWNED BY static_route_template.static_route_template_id;
DROP TABLE IF EXISTS static_route_template_v91;
DROP TABLE IF EXISTS jazzhands_audit.static_route_template_v91;
-- DONE DEALING WITH TABLE static_route_template (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route_template failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route_template failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'property', 'property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'property', tags := ARRAY['view_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.property;
CREATE VIEW audit.property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id AS property_collection_id,
    property.service_environment_collection_id AS service_env_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
    property.property_value,
    property.property_value_timestamp,
    property.property_value_account_collection_id AS property_value_account_coll_id,
    property.property_value_device_collection_id AS property_value_device_coll_id,
    property.property_value_json,
    property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    property.property_value_password_type,
    NULL::integer AS property_value_sw_package_id,
    property.property_value_token_collection_id AS property_value_token_col_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
        CASE
            WHEN property.is_enabled IS NULL THEN NULL::text
            WHEN property.is_enabled = true THEN 'Y'::text
            WHEN property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date,
    property."aud#action",
    property."aud#timestamp",
    property."aud#realtime",
    property."aud#txid",
    property."aud#user",
    property."aud#seq"
   FROM jazzhands_audit.property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('property','property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE property (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE sw_package
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'sw_package', 'sw_package');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'sw_package', tags := ARRAY['view_sw_package']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.sw_package;
CREATE VIEW audit.sw_package AS
 SELECT software_artifact_name.software_artifact_name_id AS sw_package_id,
    software_artifact_name.software_artifact_name AS sw_package_name,
    software_artifact_name.software_artifact_type AS sw_package_type,
    software_artifact_name.description,
    software_artifact_name.data_ins_user,
    software_artifact_name.data_ins_date,
    software_artifact_name.data_upd_user,
    software_artifact_name.data_upd_date,
    software_artifact_name."aud#action",
    software_artifact_name."aud#timestamp",
    software_artifact_name."aud#realtime",
    software_artifact_name."aud#txid",
    software_artifact_name."aud#user",
    software_artifact_name."aud#seq"
   FROM jazzhands_audit.software_artifact_name;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('sw_package','sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of sw_package failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('sw_package');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for sw_package  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE sw_package (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old sw_package failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new sw_package failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_device_mgmt_ctrl_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_device_mgmt_ctrl_type', 'val_device_mgmt_ctrl_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_device_mgmt_ctrl_type', tags := ARRAY['view_val_device_mgmt_ctrl_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_device_mgmt_ctrl_type;
CREATE VIEW audit.val_device_mgmt_ctrl_type AS
 SELECT val_device_management_controller_type.device_management_controller_type AS device_mgmt_control_type,
    val_device_management_controller_type.description,
    val_device_management_controller_type.data_ins_user,
    val_device_management_controller_type.data_ins_date,
    val_device_management_controller_type.data_upd_user,
    val_device_management_controller_type.data_upd_date,
    val_device_management_controller_type."aud#action",
    val_device_management_controller_type."aud#timestamp",
    val_device_management_controller_type."aud#realtime",
    val_device_management_controller_type."aud#txid",
    val_device_management_controller_type."aud#user",
    val_device_management_controller_type."aud#seq"
   FROM jazzhands_audit.val_device_management_controller_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_device_mgmt_ctrl_type','val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_device_mgmt_ctrl_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_device_mgmt_ctrl_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_device_mgmt_ctrl_type (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_property', 'val_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_property', tags := ARRAY['view_val_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_property;
CREATE VIEW audit.val_property AS
 SELECT val_property.property_name,
    val_property.property_type,
    val_property.description,
    val_property.account_collection_type,
    val_property.company_collection_type,
    val_property.device_collection_type,
    val_property.dns_domain_collection_type,
    val_property.layer2_network_collection_type,
    val_property.layer3_network_collection_type,
    val_property.netblock_collection_type,
    val_property.network_range_type,
    val_property.property_name_collection_type AS property_collection_type,
    val_property.service_environment_collection_type AS service_env_collection_type,
        CASE
            WHEN val_property.is_multivalue IS NULL THEN NULL::text
            WHEN val_property.is_multivalue = true THEN 'Y'::text
            WHEN val_property.is_multivalue = false THEN 'N'::text
            ELSE NULL::text
        END AS is_multivalue,
    val_property.property_value_account_collection_type_restriction AS prop_val_acct_coll_type_rstrct,
    val_property.property_value_device_collection_type_restriction AS prop_val_dev_coll_type_rstrct,
    val_property.property_value_netblock_collection_type_restriction AS prop_val_nblk_coll_type_rstrct,
    val_property.property_data_type,
    val_property.property_value_json_schema,
    val_property.permit_account_collection_id,
    val_property.permit_account_id,
    val_property.permit_account_realm_id,
    val_property.permit_company_id,
    val_property.permit_company_collection_id,
    val_property.permit_device_collection_id,
    val_property.permit_dns_domain_collection_id AS permit_dns_domain_coll_id,
    val_property.permit_layer2_network_collection_id AS permit_layer2_network_coll_id,
    val_property.permit_layer3_network_collection_id AS permit_layer3_network_coll_id,
    val_property.permit_netblock_collection_id,
    val_property.permit_network_range_id,
    val_property.permit_operating_system_id,
    val_property.permit_operating_system_snapshot_id AS permit_os_snapshot_id,
    val_property.permit_property_name_collection_id AS permit_property_collection_id,
    val_property.permit_service_environment_collection_id AS permit_service_env_collection,
    val_property.permit_site_code,
    val_property.permit_x509_signed_certificate_id AS permit_x509_signed_cert_id,
    val_property.permit_property_rank,
    val_property.data_ins_user,
    val_property.data_ins_date,
    val_property.data_upd_user,
    val_property.data_upd_date,
    val_property."aud#action",
    val_property."aud#timestamp",
    val_property."aud#realtime",
    val_property."aud#txid",
    val_property."aud#user",
    val_property."aud#seq"
   FROM jazzhands_audit.val_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_property','val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_property (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_sw_package_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_sw_package_type', 'val_sw_package_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_sw_package_type', tags := ARRAY['view_val_sw_package_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_sw_package_type;
CREATE VIEW audit.val_sw_package_type AS
 SELECT val_software_artifact_type.software_artifact_type AS sw_package_type,
    val_software_artifact_type.description,
    val_software_artifact_type.data_ins_user,
    val_software_artifact_type.data_ins_date,
    val_software_artifact_type.data_upd_user,
    val_software_artifact_type.data_upd_date,
    val_software_artifact_type."aud#action",
    val_software_artifact_type."aud#timestamp",
    val_software_artifact_type."aud#realtime",
    val_software_artifact_type."aud#txid",
    val_software_artifact_type."aud#user",
    val_software_artifact_type."aud#seq"
   FROM jazzhands_audit.val_software_artifact_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_sw_package_type','val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_sw_package_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_sw_package_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_sw_package_type (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE v_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_property', 'v_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_property', tags := ARRAY['view_v_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_property;
CREATE VIEW jazzhands.v_property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id,
    property.service_environment_collection_id,
    property.service_version_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
    property.property_value,
    property.property_value_account_collection_id,
    property.property_value_boolean,
    property.property_value_device_collection_id,
    property.property_value_encryption_key_id,
    property.property_value_json,
    property.property_value_netblock_collection_id,
    property.property_value_password_type,
    property.property_value_private_key_id,
    property.property_value_service_version_collection_id,
    property.property_value_timestamp,
    property.property_value_token_collection_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
    property.is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date
   FROM jazzhands.property
  WHERE property.is_enabled = true AND (property.start_date IS NULL AND property.finish_date IS NULL OR property.start_date IS NULL AND now() <= property.finish_date OR property.start_date <= now() AND property.finish_date IS NULL OR property.start_date <= now() AND now() <= property.finish_date);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_property','v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_site_netblock_expanded_assigned
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_site_netblock_expanded_assigned', 'v_site_netblock_expanded_assigned');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_site_netblock_expanded_assigned', tags := ARRAY['view_v_site_netblock_expanded_assigned']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_site_netblock_expanded_assigned;
CREATE VIEW jazzhands.v_site_netblock_expanded_assigned AS
 SELECT meat.site_code,
    meat.netblock_id
   FROM ( SELECT p.site_code,
            n.netblock_id,
            rank() OVER (PARTITION BY n.netblock_id ORDER BY (array_length(hc.path, 1)), (array_length(n.path, 1))) AS tier
           FROM jazzhands.netblock_collection_netblock ncn
             JOIN jazzhands_cache.ct_netblock_collection_hier_from_ancestor hc USING (netblock_collection_id)
             JOIN jazzhands_cache.ct_netblock_hier n ON ncn.netblock_id = n.root_netblock_id
             JOIN ( SELECT property.property_id,
                    property.account_collection_id,
                    property.account_id,
                    property.account_realm_id,
                    property.company_collection_id,
                    property.company_id,
                    property.device_collection_id,
                    property.dns_domain_collection_id,
                    property.layer2_network_collection_id,
                    property.layer3_network_collection_id,
                    property.netblock_collection_id,
                    property.network_range_id,
                    property.operating_system_id,
                    property.operating_system_snapshot_id,
                    property.property_name_collection_id,
                    property.service_environment_collection_id,
                    property.service_version_collection_id,
                    property.site_code,
                    property.x509_signed_certificate_id,
                    property.property_name,
                    property.property_type,
                    property.property_value,
                    property.property_value_account_collection_id,
                    property.property_value_boolean,
                    property.property_value_device_collection_id,
                    property.property_value_encryption_key_id,
                    property.property_value_json,
                    property.property_value_netblock_collection_id,
                    property.property_value_password_type,
                    property.property_value_private_key_id,
                    property.property_value_service_version_collection_id,
                    property.property_value_timestamp,
                    property.property_value_token_collection_id,
                    property.property_rank,
                    property.start_date,
                    property.finish_date,
                    property.is_enabled,
                    property.data_ins_user,
                    property.data_ins_date,
                    property.data_upd_user,
                    property.data_upd_date
                   FROM jazzhands.property
                  WHERE property.property_name::text = 'per-site-netblock_collection'::text AND property.property_type::text = 'automated'::text) p USING (netblock_collection_id)) meat
  WHERE meat.tier = 1;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_site_netblock_expanded_assigned','v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_site_netblock_expanded_assigned');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_site_netblock_expanded_assigned  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_site_netblock_expanded_assigned (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--
-- Process all procs in jazzhands_cache
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_cache', 'cache_netblock_hier_handler');
SELECT schema_support.save_grants_for_replay('jazzhands_cache', 'cache_netblock_hier_handler');
CREATE OR REPLACE FUNCTION jazzhands_cache.cache_netblock_hier_handler()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cnt	INTEGER;
	_r		RECORD;
	_n		RECORD;
BEGIN
	IF TG_OP IN ('UPDATE','INSERT') AND NEW.is_single_address = 'Y' THEN
		RETURN NULL;
	END IF;

	IF TG_OP IN ('DELETE','UPDATE') THEN
		RAISE DEBUG 'ENTER cache_netblock_hier_handler OLD: % %',
			TG_OP, to_json(OLD);
	END IF;
	IF TG_OP IN ('INSERT','UPDATE') THEN
		RAISE DEBUG 'ENTER cache_netblock_hier_handler NEW: % %',
			TG_OP, to_json(NEW);
		IF NEW.parent_netblock_id IS NOT NULL AND NEW.netblock_id = NEW.parent_netblock_id THEN
			RAISE DEBUG 'aborting because this row is self referrential';
			RETURN NULL;
		END IF;
	END IF;

	--
	-- Delete any rows that are invalidated due to a parent change.
	-- Any parent change means recreating all the rows related to the node
	-- that changes; due to how the netblock triggers work, this may result
	-- in records being changed multiple times.
	--
	IF TG_OP = 'DELETE' OR
		(
			TG_OP = 'UPDATE' AND OLD.parent_netblock_id IS NOT NULL
		)
	THEN
		RAISE DEBUG '% cleanup for %, % [%]',
			TG_OP, OLD.netblock_id, OLD.parent_netblock_id, OLD.ip_address;
		FOR _r IN
		DELETE FROM jazzhands_cache.ct_netblock_hier
		WHERE	OLD.netblock_id = ANY(path)
		RETURNING *
		LOOP
			RAISE DEBUG '-> rm/DEL %', to_json(_r);
		END LOOP;
		get diagnostics _cnt = row_count;
		RAISE DEBUG 'nbcache: Deleting upstream references to netblock % from cache == %',
			OLD.netblock_id, _cnt;
	ELSIF TG_OP = 'INSERT' THEN
		FOR _r IN
		DELETE FROM jazzhands_cache.ct_netblock_hier
		-- WHERE	NEW.netblock_id = ANY(path)
		WHERE root_netblocK_id = NEW.netblock_id
		RETURNING *
		LOOP
			RAISE DEBUG '-> rm/INS?! %', to_json(_r);
		END LOOP;
	END IF;


	--
	-- XXX deal with parent becoming NULL!
	--

	IF TG_OP IN ('INSERT', 'UPDATE') THEN
		RAISE DEBUG 'nbcache: % reference for new netblock %, % [%]',
			TG_OP, NEW.netblock_id, NEW.parent_netblock_id, NEW.ip_address;

		--
		-- This runs even if parent_netblock_id is NULL in order to get the
		-- row that includes the netblock into itself.
		--
		FOR _r IN
		WITH RECURSIVE tier (
			root_netblock_id,
			intermediate_netblock_id,
			netblock_id,
			path
		)AS (
			SELECT parent_netblock_id,
				parent_netblock_id,
				netblock_id,
				ARRAY[netblock_id, parent_netblock_id]
			FROM netblock WHERE netblock_id = NEW.netblock_id
			AND parent_netblock_id IS NOT NULL
		UNION ALL
			SELECT n.parent_netblock_id,
				tier.intermediate_netblock_id,
				tier.netblock_id,
				array_append(tier.path, n.parent_netblock_id)
			FROM tier
				JOIN netblock n ON n.netblock_id = tier.root_netblock_id
			WHERE n.parent_netblock_id IS NOT NULL
		), combo AS (
			SELECT * FROM tier
			UNION ALL
			SELECT netblock_id, netblock_id, netblock_id, ARRAY[netblock_id]
			FROM netblock WHERE netblock_id = NEW.netblock_id
		) SELECT * FROM combo
			WHERE path NOT IN (
				--
				-- This is really to exclude things that existed because of
				-- an update, such as adding a new parent to something that
				-- previously did not have one.
				SELECT path FROM jazzhands_cache.ct_netblock_hier
			)
		LOOP
			RAISE DEBUG 'nb/ins up %', to_json(_r);
			INSERT INTO jazzhands_cache.ct_netblock_hier (
				root_netblock_id, intermediate_netblock_id,
				netblock_id, path
			) VALUES (
				_r.root_netblock_id, _r.intermediate_netblock_id,
				_r.netblock_id, _r.path
			);
		END LOOP;

		FOR _r IN
			SELECT h.*, ip_address
			FROM jazzhands_cache.ct_netblock_hier h
				JOIN netblock n ON
					n.netblock_id = h.root_netblock_id
			AND n.parent_netblock_id = NEW.netblock_id
			-- AND array_length(path, 1) > 1
		LOOP
			RAISE DEBUG 'nb/ins from %', to_json(_r);
			_r.root_netblock_id := NEW.netblock_id;
			IF array_length(_r.path, 1) = 1 THEN
				_r.intermediate_netblock_id := NEW.netblock_id;
			ELSE
				_r.intermediate_netblock_id := _r.intermediate_netblock_id;
			END IF;
			_r.netblock_id := _r.netblock_id;
			_r.path := array_append(_r.path, NEW.netblock_id);

			RAISE DEBUG '... %', to_json(_r);
			INSERT INTO jazzhands_cache.ct_netblock_hier (
				root_netblock_id, intermediate_netblock_id,
				netblock_id, path
			) VALUES (
				_r.root_netblock_id, _r.intermediate_netblock_id,
				_r.netblock_id, _r.path
			);
		END LOOP;

		--
		-- now combine all the kids and all the parents with this row in
		-- the middle
		--
		IF TG_OP = 'INSERT' THEN
			FOR _r IN
				SELECT
					hpar.root_netblock_id,
					hkid.intermediate_netblock_id as intermediate_netblock_id,
					hkid.netblock_id,
					array_cat( hkid.path, hpar.path[2:]) as path,
					hkid.path as hkid_path,
					hpar.path as hpar_path
				FROM jazzhands_cache.ct_netblock_hier hkid
					JOIN jazzhands_cache.ct_netblock_hier hpar
						ON hkid.root_netblock_id = hpar.netblock_id
				WHERE hpar.netblock_id = NEW.netblock_id
				AND array_length(hpar.path, 1) > 1
				AND array_length(hkid.path, 1) > 2
			LOOP
				RAISE DEBUG 'XXX nb ins/comp: %', to_json(_r);
				INSERT INTO jazzhands_cache.ct_netblock_hier (
					root_netblock_id, intermediate_netblock_id,
					netblock_id, path
				) VALUES (
					_r.root_netblock_id, _r.intermediate_netblock_id,
					_r.netblock_id, _r.path
				);
				END LOOP;
		END IF;
	END IF;
	RAISE DEBUG 'EXIT jazzhands_cache.cache_netblock_hier_handler';
	RETURN NULL;
END
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_cache' AND type = 'function' AND object IN ('cache_netblock_hier_handler');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc cache_netblock_hier_handler failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
--
-- Process all procs in account_collection_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process all procs in account_password_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
--
-- Process all procs in approval_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
--
-- Process all procs in audit
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Process all procs in auto_ac_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process all procs in backend_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
--
-- Process all procs in company_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
--
-- Process all procs in component_connection_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process all procs in component_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_manip']);
--
-- Process all procs in component_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process all procs in device_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process all procs in device_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
--
-- Process all procs in dns_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_manip']);
--
-- Process all procs in dns_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
--
-- Process all procs in jazzhands
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'create_component_slots_by_trigger');
SELECT schema_support.save_grants_for_replay('jazzhands', 'create_component_slots_by_trigger');
CREATE OR REPLACE FUNCTION jazzhands.create_component_slots_by_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	-- For inserts, just do a simple slot creation, for updates, things
	-- get more complicated, so try to migrate slots

	IF (TG_OP = 'INSERT' OR OLD.component_type_id != NEW.component_type_id)
	THEN
		PERFORM component_manip.create_component_template_slots(
			component_id := NEW.component_id);
	END IF;
	IF (TG_OP = 'UPDATE' AND OLD.component_type_id != NEW.component_type_id)
	THEN
		PERFORM component_manip.migrate_component_template_slots(
			component_id := NEW.component_id
		);
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('create_component_slots_by_trigger');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc create_component_slots_by_trigger failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'dns_rec_prevent_dups');
SELECT schema_support.save_grants_for_replay('jazzhands', 'dns_rec_prevent_dups');
CREATE OR REPLACE FUNCTION jazzhands.dns_rec_prevent_dups()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	-- should not be able to insert the same record(s) twice
	SELECT	count(*)
		INTO	_tally
		FROM (
			SELECT
					db.dns_record_id,
					coalesce(ref.dns_name, db.dns_name) as dns_name,
					db.dns_domain_id, db.dns_ttl,
					db.dns_class, db.dns_type,
					coalesce(val.dns_value, db.dns_value) AS dns_value,
					db.dns_priority, db.dns_srv_service, db.dns_srv_protocol,
					db.dns_srv_weight, db.dns_srv_port, db.ip_universe_id,
					coalesce(val.netblock_id, db.netblock_id) AS netblock_id,
					db.reference_dns_record_id, db.dns_value_record_id,
					db.should_generate_ptr, db.is_enabled
				FROM dns_record db
					LEFT JOIN (
							SELECT dns_record_id AS reference_dns_record_id,
									dns_name
							FROM dns_record
							WHERE dns_domain_id = NEW.dns_domain_id
						) ref USING (reference_dns_record_id)
					LEFT JOIN (
							SELECT dns_record_id AS dns_value_record_id,
									dns_value, netblock_id
							FROM dns_record
						) val USING (dns_value_record_id)
				WHERE db.dns_record_id != NEW.dns_record_id
				AND (lower(coalesce(ref.dns_name, db.dns_name))
							IS NOT DISTINCT FROM lower(NEW.dns_name))
				AND ( db.dns_domain_id = NEW.dns_domain_id )
				AND ( db.dns_class = NEW.dns_class )
				AND ( db.dns_type = NEW.dns_type )
				AND db.dns_srv_service IS NOT DISTINCT FROM NEW.dns_srv_service
				AND db.dns_srv_protocol IS NOT DISTINCT FROM NEW.dns_srv_protocol
				AND db.dns_srv_port IS NOT DISTINCT FROM NEW.dns_srv_port
				AND db.ip_universe_id IS NOT DISTINCT FROM NEW.ip_universe_id
				AND db.is_enabled = true
			) dns
			LEFT JOIN dns_record val
				ON ( NEW.dns_value_record_id = val.dns_record_id )
		WHERE
			dns.dns_domain_id = NEW.dns_domain_id
		AND
			dns.dns_value IS NOT DISTINCT FROM
				coalesce(val.dns_value, NEW.dns_value)
		AND
			dns.netblock_id IS NOT DISTINCT FROM
				coalesce(val.netblock_id, NEW.netblock_id)
	;

	IF _tally != 0 THEN
		RAISE EXCEPTION 'Attempt to insert the same dns record - % %', _tally,
			NEW USING ERRCODE = 'unique_violation';
	END IF;

	IF NEW.DNS_TYPE = 'A' OR NEW.DNS_TYPE = 'AAAA' THEN
		IF NEW.SHOULD_GENERATE_PTR = true THEN
			SELECT	count(*)
			 INTO	_tally
			 FROM	dns_record
			WHERE dns_class = 'IN'
			AND dns_type = 'A'
			AND should_generate_ptr = true
			AND is_enabled = true
			AND netblock_id = NEW.NETBLOCK_ID
			AND dns_record_id != NEW.DNS_RECORD_ID;

			IF _tally != 0 THEN
				RAISE EXCEPTION 'May not have more than one SHOULD_GENERATE_PTR record on the same IP on netblock_id %', NEW.netblock_id
					USING ERRCODE = 'JH201';
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('dns_rec_prevent_dups');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc dns_rec_prevent_dups failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'set_slot_names_by_trigger');
SELECT schema_support.save_grants_for_replay('jazzhands', 'set_slot_names_by_trigger');
CREATE OR REPLACE FUNCTION jazzhands.set_slot_names_by_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM component_manip.set_slot_names(
		slot_id_list := ARRAY(
				SELECT slot_id FROM slot WHERE component_id = NEW.component_id
			)
	);
	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('set_slot_names_by_trigger');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_slot_names_by_trigger failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.create_all_services_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection (
			service_version_collection_name, service_version_collection_type
		) VALUES
			( NEW.service_name, 'all-services' ),
			( NEW.service_name, 'current-services' );
	ELSIF TG_OP = 'UPDATE' THEN
		UPDATE service_version_collection
		SET service_version_collection_name = NEW.service_name
		WHERE service_version_collection_type
			IN ( 'all-services', 'current-services')
		AND service_version_collection_name = OLD.service_name;
	ELSIF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.device_collection_device_after_row_hooks()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	BEGIN
		IF TG_OP = 'DELETE' THEN
			PERFORM local_hooks.device_collection_device_after_row_hooks(TG_OP, OLD, NULL);
		ELSIF TG_OP = 'UPDATE' THEN
			PERFORM local_hooks.device_collection_device_after_row_hooks(TG_OP, OLD, NEW);
		ELSIF TG_OP = 'INSERT' THEN
			PERFORM local_hooks.device_collection_device_after_row_hooks(TG_OP, NULL, NEW);
		END IF;
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
			PERFORM 1;
	END;
	RETURN NULL;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.device_collection_hier_after_row_hooks()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	BEGIN
		IF TG_OP = 'DELETE' THEN
			PERFORM local_hooks.device_collection_hier_after_row_hooks(TG_OP, OLD, NULL);
		ELSIF TG_OP = 'UPDATE' THEN
			PERFORM local_hooks.device_collection_hier_after_row_hooks(TG_OP, OLD, NEW);
		ELSIF TG_OP = 'INSERT' THEN
			PERFORM local_hooks.device_collection_hier_after_row_hooks(TG_OP, NULL, NEW);
		END IF;
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
			PERFORM 1;
	END;
	RETURN NULL;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.manip_all_svc_collection_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'all-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'current-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'all-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'current-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);

		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.port_range_manage_singleton()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.is_singleton IS NULL THEN
		IF NEW.port_start = NEW.port_end THEN
			NEW.is_singleton = true;
		ELSE
			NEW.is_singleton = false;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.port_range_sanity_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NOT NEW.is_singleton THEN
		SELECT *
		INTO _r
		FROM val_port_range_type
		WHERE port_range_type = NEW.port_range_type
		AND protocol = NEW.protocol;

		IF NOT _r.range_permitted THEN
			RAISE EXCEPTION 'Ranges are not permitted on %:%',
				NEW.port_range_type, NEW.protocol
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	ELSE
		IF NEW.port_start != NEW.port_end THEN
			RAISE EXCEPTION 'singletons may not have a different start and end port'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.propagate_service_type_to_version()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.service_type IS NULL THEN
		SELECT service_type
		INTO NEW.service_type
		FROM service
		WHERE service_id = NEW.service_id;
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_depend_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'UPDATE' AND OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	PERFORM *
	FROM (select service_depend_id, service_id from service_version) sd
		JOIN service_version USING (service_id)
		JOIN service_instance si USING (service_version_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_id)
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_permitted_feature svcpf
			USING (service_version_collection_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND	sd.service_depend = NEW.service_depend_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'service_feature is not offered by any versions of service'
       		USING ERRCODE = 'foreign_key_violation',
       		HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.dns_record_id IS NOT NULL OR NEW.port_range_id IS NOT NULL THEN
		SELECT	sep.*
		INTO	_r
		FROM	service_endpoint_service_endpoint_provider_collection
				JOIN service_endpoint_provider_collection
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider_collection_service_endpoint_provider
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider sep
					USING (service_endpoint_provider_id)
		WHERE	service_endpoint_id = NEW.service_endpoint_id;

		IF FOUND THEN
			--
			-- It is possible that these don't need to match, but that use
			-- case needs to be thought through, so it is disallowed for now.
			--
			IF _r.service_endpoint_provider_type = 'direct' THEN
				IF _r.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
					RAISE EXCEPTION 'dns_record_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
				IF _r.port_range_id IS DISTINCT FROM NEW.port_range_id THEN
					RAISE EXCEPTION 'port_range_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_provider_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.service_endpoint_provider_type = 'direct' THEN
		IF NEW.dns_record_id IS NOT NULL THEN
			SELECT	se.*
			INTO	_r
			FROM	service_endpoint se
					JOIN service_endpoint_service_endpoint_provider_collection
						USING (service_endpoint_id)
					JOIN service_endpoint_provider_collection
						USING (service_endpoint_provider_collection_id)
					JOIN service_endpoint_provider_collection_service_endpoint_provider
						USING (service_endpoint_provider_collection_id)
			WHERE	service_endpoint_provider_id =
				NEW.service_endpoint_provider_id;

			IF FOUND THEN
				--
				-- It is possible that these don't need to match, but that use
				-- case needs to be thought through, so it is disallowed for now.
				--
				IF _r.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
					RAISE EXCEPTION 'dns_record_id of service_endpoint_provider and service_endpoint must match (% %', _r.dns_record_id, NEW.dns_record_id
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to direct connects';
				END IF;
				IF _r.port_range_id IS DISTINCT FROM NEW.port_range_id THEN
					RAISE EXCEPTION 'port_range of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
			END IF;
		END IF;
	-- This doesn't work right with cname failver in gtm, so commenting out,
	-- but it's possible it needs to be rethought.
	-- ELSIF NEW.dns_record_id IS NOT NULL THEN
	--	RAISE EXCEPTION 'direct providers must have their dns record in sync with their endpoint'
	--	USING ERRCODE = 'foreign_key_violation',
	--	HINT = 'This check may be overly agressive';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_provider_dns_netblock_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.dns_record_id IS NULL AND  NEW.netblock_id IS NULL AND NEW.service_endpoint_provider_type != 'direct'THEN
		RAISE EXCEPTION 'One of dns_record_id OR netblock_id must be set for types other than direct'
       		USING ERRCODE = 'not_null_violation';
	ELSIF NEW.dns_record_id IS NOT NULL AND NEW.netblock_id IS NOT NULL THEN
		RAISE EXCEPTION 'Only One of dns_record_id OR netblock_id must be set'
       		USING ERRCODE = 'not_null_violation';
	END IF;

	-- XXX it is probable additional checks must be made on this.

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_instance_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_version_collection_permitted_feature svcpf
		-- may not need this join
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_collection_id)
		JOIN service_instance si USING (service_version_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND		si.service_instance_id = NEW.service_instance_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Feature not permitted for this service'
       		USING ERRCODE = 'foreign_key_violation',
       		HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_instance_service_feature_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_sanity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	--
	-- check to see if there's another primary, if so fail.
	---
	IF NEW.is_primary THEN
		SELECT count(*) INTO _tally
		FROM service_source_repository
		WHERE service_id = NEW.service_id
		AND service_source_repository_id != NEW.service_source_repository_id
		AND is_primary;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'A primary source repository already exists for this service'
				USING ERRCODE = 'unique_violation';
		END IF;

	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	RAISE EXCEPTION 'Can not change service_id or service_source_repository_id due to missing trigger'
		USING HINT = 'need trigger that compares to service_version_source_repository_service_match_check';
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_version_feature_permitted_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
       		USING ERRCODE = 'invalid_paramater',
       		HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_version_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_source_repository
	WHERE service_source_repository_id = NEW.service_source_repository_id
	AND service_id = (SELECT service_id FROM service_version WHERE service_version_id = NEW.service_version_id);

	IF NOT FOUND THEN
		RAISE EXCEPTION 'source repository is not associted with the service'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'consider adding a row to service_source_repository';
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.source_repository_url_endpoint_enforcement()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.source_repository_url IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either source_repository_url or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.source_repository_url IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of source_repository_url or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.svc_end_prov_svc_end_col_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	-- At the moment, no checks "up" to service_endpoint
	--
	-- sanity checks for things to match
	--
	IF NEW.service_endpoint_relation_type = 'direct' THEN
		IF NEW.service_endpoint_relation_key != 'none' THEN
			RAISE EXCEPTION 'direct must have a key of none'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'direct-to-host service configuration is very particular';
		END IF;

		PERFORM *
		FROM service_endpoint_provider_collection
		WHERE service_endpoint_provider_collection_type =
			'per-service-endpoint-provider'
		AND service_endpoint_provider_collection_id =
			NEW.service_endpoint_provider_collection_id;

		IF NOT FOUND THEN
			RAISE EXCEPTION 'direct must point to a service_collection_type of per-service-endpoint-provider'
			USING ERRCODE = 'foreign_key_violation',
			HINT = 'direct-to-host service configuration is very particular';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.svc_ep_coll_sep_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_coltype	TEXT;
	_septype	TEXT;
BEGIN

	SELECT service_endpoint_provider_collection_type
	INTO _coltype
	FROM service_endpoint_provider_collection
	WHERE service_endpoint_provider_collection_id =
		NEW.service_endpoint_provider_collection_id;

	SELECT service_endpoint_provider_type
	INTO _septype
	FROM service_endpoint_provider
	WHERE service_endpoint_provider_id =
		NEW.service_endpoint_provider_id;

	IF _septype = 'direct' AND _coltype != 'per-service-endpoint-provider' THEN
		RAISE EXCEPTION 'direct providers must have an upstream collection of per-service-endpoint-provider type'
		USING ERRCODE = 'invalid_parameter_value',
		HINT = 'This check should be smarter';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.svc_ep_svc_epp_coll_direct()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.service_endpoint_relation_type = 'per-service-endpoint-provider' THEN
		IF NEW.service_endpoint_relation_key != 'none' THEN
			RAISE EXCEPTION 'per-service-endpoint-provider is immutable because of direct connection'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'This check should be smarter';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.val_port_range_sanity_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally INTEGER;
BEGIN
	IF NOT NEW.range_permitted  THEN
		SELECT count(*)
		INTO _tally
		fROM port_range
		WHERE protocol = NEW.protocol
		AND port_range_type = NEW.port_range_type
		AND port_start != port_end;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'Existing %:% have ranges',
				NEW.port_range_type, NEW.protocol
				USING ERRCODE = 'invalid_parameter_value',
				HINT = 'check port_start and port_end on existing records';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

--
-- Process all procs in layerx_network_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process all procs in logical_port_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process all procs in lv_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process all procs in net_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process all procs in netblock_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process all procs in netblock_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process all procs in network_strings
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process all procs in obfuscation_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process all procs in person_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process all procs in pgcrypto
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process all procs in physical_address_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process all procs in port_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process all procs in rack_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process all procs in schema_support
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'replay_saved_grants ( boolean,text,text )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.replay_saved_grants ( boolean,text,text );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
--
-- Process all procs in script_hooks
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process all procs in snapshot_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process all procs in time_util
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process all procs in token_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
--
-- Process all procs in versioning_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_versioning_utils']);
--
-- Recreate the saved views in the base schema
--
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', type := 'view');


-- BEGIN Misc that does not apply to above

--
-- INDEX names were adjusted because of uniqueness problem and this rebuilds
-- all of them so the names properly match.
--
SELECT schema_support.rebuild_all_audit_indexes(
    'jazzhands_audit', 'jazzhands', true);

DROP TRIGGER IF EXISTS trigger_audit_token_sequence ON
	jazzhands.token_sequence;

DROP INDEX IF EXISTS jazzhands_cache.ix_jazzhands_legacy_device_device_id;

CREATE INDEX aud_dns_domain_ak_dns_domain_name ON jazzhands_audit.dns_domain 
	USING btree (dns_domain_name);

DELETE FROM val_property_data_type
WHERE property_data_type = 'sw_package_id';

INSERT INTO val_property_type ( property_type)
VALUES
	('launch'),
	('documentation');

INSERT INTO val_property (
	property_type, property_name,
	permit_service_version_collection_id, property_data_type, is_multivalue
) VALUES
	('launch', 'location', 'REQUIRED', 'list', true),
	('launch', 'dedicated', 'REQUIRED', 'boolean', false),
	('launch', 'minimum_cpu', 'REQUIRED', 'number', false),
	('launch', 'minimum_memory', 'REQUIRED', 'number', false),
	('launch', 'minimum_disk', 'REQUIRED', 'number', false),
	('documentation', 'manual', 'REQUIRED', 'string', false)
;

INSERT INTO val_property_value (
	property_type, property_name, valid_property_value
) VALUES
	('launch', 'location', 'baremetal'),
	('launch', 'location', 'virtual-machine')
;

INSERT INTO val_property (
	property_type, property_name,
	permit_service_version_collection_id, permit_netblock_collection_id, property_data_type
) VALUES
	('launch', 'launch-netblocks', 'REQUIRED', 'REQUIRED', 'none')
;


INSERT INTO val_property_type ( property_type)
VALUES
	('role');

--
-- this should probably trigger automated account collections
-- somehow
--
INSERT INTO val_property (
	property_type, property_name,
	permit_service_version_collection_id, property_data_type
) VALUES
	('role', 'owner', 'REQUIRED', 'account_collection_id'),
	('role', 'admin', 'REQUIRED', 'account_collection_id'),
	('role', 'iud_role', 'REQUIRED', 'account_collection_id'),
	('role', 'ro_role', 'REQUIRED', 'account_collection_id'),
	('role', 'log_watcher', 'REQUIRED', 'account_collection_id')
;

DO
$$
BEGIN
	insert into val_software_artifact_type (software_artifact_type)
	VALUES
        	('rpm'),
        	('deb'),
        	('oci-container'),
        	('docker22-container');
EXCEPTION WHEN unique_violation THEN
	RAISE NOTICE 'skiipping inserts into val_software_artifact_type';
END;
$$;



-- END Misc that does not apply to above
--
-- BEGIN: process_ancillary_schema(jazzhands_legacy)
--
--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property', 'property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'property', tags := ARRAY['view_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.property;
CREATE VIEW jazzhands_legacy.property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id AS property_collection_id,
    property.service_environment_collection_id AS service_env_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
        CASE
            WHEN property.property_value_boolean = true THEN 'Y'::character varying
            WHEN property.property_value_boolean = false THEN 'N'::character varying
            ELSE property.property_value
        END AS property_value,
    property.property_value_timestamp,
    property.property_value_account_collection_id AS property_value_account_coll_id,
    property.property_value_device_collection_id AS property_value_device_coll_id,
    property.property_value_json,
    property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    property.property_value_password_type,
    NULL::integer AS property_value_sw_package_id,
    property.property_value_token_collection_id AS property_value_token_col_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
        CASE
            WHEN property.is_enabled IS NULL THEN NULL::text
            WHEN property.is_enabled = true THEN 'Y'::text
            WHEN property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date
   FROM jazzhands.property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('property','property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.property_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN
	DELETE FROM jazzhands.property
	WHERE  property_id = OLD.property_id  RETURNING *
	INTO _or;

	SELECT property_data_type INTO _dt
	FROM val_property
	WHERE property_name = OLD.property_name
	AND property_type = OLD.property_type;

	OLD.property_id = _or.property_id;
	OLD.account_collection_id = _or.account_collection_id;
	OLD.account_id = _or.account_id;
	OLD.account_realm_id = _or.account_realm_id;
	OLD.company_collection_id = _or.company_collection_id;
	OLD.company_id = _or.company_id;
	OLD.device_collection_id = _or.device_collection_id;
	OLD.dns_domain_collection_id = _or.dns_domain_collection_id;
	OLD.layer2_network_collection_id = _or.layer2_network_collection_id;
	OLD.layer3_network_collection_id = _or.layer3_network_collection_id;
	OLD.netblock_collection_id = _or.netblock_collection_id;
	OLD.network_range_id = _or.network_range_id;
	OLD.operating_system_id = _or.operating_system_id;
	OLD.operating_system_snapshot_id = _or.operating_system_snapshot_id;
	OLD.property_collection_id = _or.property_name_collection_id;
	OLD.service_env_collection_id = _or.service_environment_collection_id;
	OLD.site_code = _or.site_code;
	OLD.x509_signed_certificate_id = _or.x509_signed_certificate_id;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		OLD.property_value = CASE
			WHEN _or.property_value_boolean = true THEN 'Y'
			WHEN _or.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		OLD.property_value = _or.property_value;
	END IF;
	OLD.property_value_timestamp = _or.property_value_timestamp;
	OLD.property_value_account_coll_id = _or.property_value_account_collection_id;
	OLD.property_value_device_coll_id = _or.property_value_device_collection_id;
	OLD.property_value_json = _or.property_value_json;
	OLD.property_value_nblk_coll_id = _or.property_value_netblock_collection_id;
	OLD.property_value_password_type = _or.property_value_password_type;
	OLD.property_value_sw_package_id = NULL;
	OLD.property_value_token_col_id = _or.property_value_token_collection_id;
	OLD.property_rank = _or.property_rank;
	OLD.start_date = _or.start_date;
	OLD.finish_date = _or.finish_date;
	OLD.is_enabled = CASE WHEN _or.is_enabled = true THEN 'Y' WHEN _or.is_enabled = false THEN 'N' ELSE NULL END;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.property_del() FROM public;
CREATE TRIGGER trigger_property_del INSTEAD OF DELETE ON jazzhands_legacy.property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.property_del();

-- considering NEW jazzhands_legacy.property_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN

	IF NEW.property_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_id));
	END IF;

	IF NEW.account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_id));
	END IF;

	IF NEW.account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_id));
	END IF;

	IF NEW.account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_realm_id));
	END IF;

	IF NEW.company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_id));
	END IF;

	IF NEW.company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_id));
	END IF;

	IF NEW.device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_id));
	END IF;

	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF NEW.netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF NEW.network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_id));
	END IF;

	IF NEW.operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_id));
	END IF;

	IF NEW.operating_system_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF NEW.property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_id));
	END IF;

	IF NEW.service_env_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF NEW.site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.site_code));
	END IF;

	IF NEW.x509_signed_certificate_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.property_value IS NOT NULL THEN
		SELECT property_data_type INTO _dt
			FROM val_property
			WHERE property_name = NEW.property_name
			AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			_cq := array_append(_cq, quote_ident('property_value_boolean'));
			_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.property_value = 'Y' THEN true WHEN NEW.property_value = 'N' THEN false ELSE NULL END) || '::boolean');
		ELSE
			_cq := array_append(_cq, quote_ident('property_value'));
			_vq := array_append(_vq, quote_nullable(NEW.property_value));
		END IF;
	END IF;

	IF NEW.property_value_timestamp IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_timestamp'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF NEW.property_value_account_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF NEW.property_value_device_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF NEW.property_value_json IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json));
	END IF;

	IF NEW.property_value_nblk_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF NEW.property_value_password_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_password_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_password_type));
	END IF;

	IF NEW.property_value_sw_package_id IS NOT NULL THEN
		RAISE EXCEPTION 'property_value_sw_package_id can not be set'
			USING ERRCODE = invalid_parameter_value,
			HINT = 'sw_package become software_artifacts and were dropped from property in 0.91';
	END IF;

	IF NEW.property_value_token_col_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_token_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF NEW.property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.property_rank));
	END IF;

	IF NEW.start_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('start_date'));
		_vq := array_append(_vq, quote_nullable(NEW.start_date));
	END IF;

	IF NEW.finish_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('finish_date'));
		_vq := array_append(_vq, quote_nullable(NEW.finish_date));
	END IF;

	IF NEW.is_enabled IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_enabled'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_enabled = 'Y' THEN true WHEN NEW.is_enabled = 'N' THEN false ELSE NULL END));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_id = _nr.property_id;
	NEW.account_collection_id = _nr.account_collection_id;
	NEW.account_id = _nr.account_id;
	NEW.account_realm_id = _nr.account_realm_id;
	NEW.company_collection_id = _nr.company_collection_id;
	NEW.company_id = _nr.company_id;
	NEW.device_collection_id = _nr.device_collection_id;
	NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
	NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
	NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
	NEW.netblock_collection_id = _nr.netblock_collection_id;
	NEW.network_range_id = _nr.network_range_id;
	NEW.operating_system_id = _nr.operating_system_id;
	NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
	NEW.property_collection_id = _nr.property_name_collection_id;
	NEW.service_env_collection_id = _nr.service_environment_collection_id;
	NEW.site_code = _nr.site_code;
	NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		NEW.property_value = _nr.property_value;
	END IF;
	NEW.property_value_timestamp = _nr.property_value_timestamp;
	NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
	NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
	NEW.property_value_json = _nr.property_value_json;
	NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
	NEW.property_value_password_type = _nr.property_value_password_type;
	NEW.property_value_sw_package_id = NULL;
	NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
	NEW.property_rank = _nr.property_rank;
	NEW.start_date = _nr.start_date;
	NEW.finish_date = _nr.finish_date;
	NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.property_ins() FROM public;
CREATE TRIGGER trigger_property_ins INSTEAD OF INSERT ON jazzhands_legacy.property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.property_ins();

-- considering NEW jazzhands_legacy.property_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.property%rowtype;
	_nr	jazzhands.property%rowtype;
	_uq	text[];
	_dt	TEXT;
BEGIN
	IF OLD.property_id IS DISTINCT FROM NEW.property_id THEN
_uq := array_append(_uq, 'property_id = ' || quote_nullable(NEW.property_id));
	END IF;

	IF OLD.account_collection_id IS DISTINCT FROM NEW.account_collection_id THEN
_uq := array_append(_uq, 'account_collection_id = ' || quote_nullable(NEW.account_collection_id));
	END IF;

	IF OLD.account_id IS DISTINCT FROM NEW.account_id THEN
_uq := array_append(_uq, 'account_id = ' || quote_nullable(NEW.account_id));
	END IF;

	IF OLD.account_realm_id IS DISTINCT FROM NEW.account_realm_id THEN
_uq := array_append(_uq, 'account_realm_id = ' || quote_nullable(NEW.account_realm_id));
	END IF;

	IF OLD.company_collection_id IS DISTINCT FROM NEW.company_collection_id THEN
_uq := array_append(_uq, 'company_collection_id = ' || quote_nullable(NEW.company_collection_id));
	END IF;

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.device_collection_id IS DISTINCT FROM NEW.device_collection_id THEN
_uq := array_append(_uq, 'device_collection_id = ' || quote_nullable(NEW.device_collection_id));
	END IF;

	IF OLD.dns_domain_collection_id IS DISTINCT FROM NEW.dns_domain_collection_id THEN
_uq := array_append(_uq, 'dns_domain_collection_id = ' || quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF OLD.layer2_network_collection_id IS DISTINCT FROM NEW.layer2_network_collection_id THEN
_uq := array_append(_uq, 'layer2_network_collection_id = ' || quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF OLD.layer3_network_collection_id IS DISTINCT FROM NEW.layer3_network_collection_id THEN
_uq := array_append(_uq, 'layer3_network_collection_id = ' || quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF OLD.netblock_collection_id IS DISTINCT FROM NEW.netblock_collection_id THEN
_uq := array_append(_uq, 'netblock_collection_id = ' || quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF OLD.network_range_id IS DISTINCT FROM NEW.network_range_id THEN
_uq := array_append(_uq, 'network_range_id = ' || quote_nullable(NEW.network_range_id));
	END IF;

	IF OLD.operating_system_id IS DISTINCT FROM NEW.operating_system_id THEN
_uq := array_append(_uq, 'operating_system_id = ' || quote_nullable(NEW.operating_system_id));
	END IF;

	IF OLD.operating_system_snapshot_id IS DISTINCT FROM NEW.operating_system_snapshot_id THEN
_uq := array_append(_uq, 'operating_system_snapshot_id = ' || quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF OLD.property_collection_id IS DISTINCT FROM NEW.property_collection_id THEN
_uq := array_append(_uq, 'property_name_collection_id = ' || quote_nullable(NEW.property_collection_id));
	END IF;

	IF OLD.service_env_collection_id IS DISTINCT FROM NEW.service_env_collection_id THEN
_uq := array_append(_uq, 'service_environment_collection_id = ' || quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF OLD.site_code IS DISTINCT FROM NEW.site_code THEN
_uq := array_append(_uq, 'site_code = ' || quote_nullable(NEW.site_code));
	END IF;

	IF OLD.x509_signed_certificate_id IS DISTINCT FROM NEW.x509_signed_certificate_id THEN
_uq := array_append(_uq, 'x509_signed_certificate_id = ' || quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.property_value IS DISTINCT FROM NEW.property_value THEN
		SELECT property_data_type INTO _dt
		FROM val_property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			IF NEW.property_value = 'Y' THEN
				_uq := array_append(_uq, 'property_value_boolean = true');
			ELSIF NEW.property_value = 'N' THEN
				_uq := array_append(_uq, 'property_value_boolean = false');
			ELSE
				_uq := array_append(_uq, 'property_value = NULL');
			END IF;
		ELSE
			_uq := array_append(_uq, 'property_value = ' || quote_nullable(NEW.property_value));
			_uq := array_append(_uq, 'property_value_boolean = NULL');
		END IF;
	END IF;

	IF OLD.property_value_timestamp IS DISTINCT FROM NEW.property_value_timestamp THEN
_uq := array_append(_uq, 'property_value_timestamp = ' || quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF OLD.property_value_account_coll_id IS DISTINCT FROM NEW.property_value_account_coll_id THEN
_uq := array_append(_uq, 'property_value_account_collection_id = ' || quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF OLD.property_value_device_coll_id IS DISTINCT FROM NEW.property_value_device_coll_id THEN
_uq := array_append(_uq, 'property_value_device_collection_id = ' || quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF OLD.property_value_json IS DISTINCT FROM NEW.property_value_json THEN
_uq := array_append(_uq, 'property_value_json = ' || quote_nullable(NEW.property_value_json));
	END IF;

	IF OLD.property_value_nblk_coll_id IS DISTINCT FROM NEW.property_value_nblk_coll_id THEN
_uq := array_append(_uq, 'property_value_netblock_collection_id = ' || quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF OLD.property_value_password_type IS DISTINCT FROM NEW.property_value_password_type THEN
_uq := array_append(_uq, 'property_value_password_type = ' || quote_nullable(NEW.property_value_password_type));
	END IF;

	IF OLD.property_value_sw_package_id IS DISTINCT FROM NEW.property_value_sw_package_id THEN
		RAISE EXCEPTION 'property_value_sw_package_id can not be set'
			USING ERRCODE = invalid_parameter_value,
			HINT = 'sw_package become software_artifacts and were dropped from property in 0.91';
	END IF;

	IF OLD.property_value_token_col_id IS DISTINCT FROM NEW.property_value_token_col_id THEN
_uq := array_append(_uq, 'property_value_token_collection_id = ' || quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF OLD.property_rank IS DISTINCT FROM NEW.property_rank THEN
_uq := array_append(_uq, 'property_rank = ' || quote_nullable(NEW.property_rank));
	END IF;

	IF OLD.start_date IS DISTINCT FROM NEW.start_date THEN
_uq := array_append(_uq, 'start_date = ' || quote_nullable(NEW.start_date));
	END IF;

	IF OLD.finish_date IS DISTINCT FROM NEW.finish_date THEN
_uq := array_append(_uq, 'finish_date = ' || quote_nullable(NEW.finish_date));
	END IF;

	IF OLD.is_enabled IS DISTINCT FROM NEW.is_enabled THEN
IF NEW.is_enabled = 'Y' THEN
	_uq := array_append(_uq, 'is_enabled = true');
ELSIF NEW.is_enabled = 'N' THEN
	_uq := array_append(_uq, 'is_enabled = false');
ELSE
	_uq := array_append(_uq, 'is_enabled = NULL');
END IF;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_id = $1 RETURNING *'  USING OLD.property_id
			INTO _nr;

		NEW.property_id = _nr.property_id;
		NEW.account_collection_id = _nr.account_collection_id;
		NEW.account_id = _nr.account_id;
		NEW.account_realm_id = _nr.account_realm_id;
		NEW.company_collection_id = _nr.company_collection_id;
		NEW.company_id = _nr.company_id;
		NEW.device_collection_id = _nr.device_collection_id;
		NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
		NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
		NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
		NEW.netblock_collection_id = _nr.netblock_collection_id;
		NEW.network_range_id = _nr.network_range_id;
		NEW.operating_system_id = _nr.operating_system_id;
		NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
		NEW.property_collection_id = _nr.property_name_collection_id;
		NEW.service_env_collection_id = _nr.service_environment_collection_id;
		NEW.site_code = _nr.site_code;
		NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;

		IF _dt IS NOT DISTINCT FROM 'boolean' THEN
			NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
		ELSE
			NEW.property_value = _nr.property_value;
		END IF;

		NEW.property_value_timestamp = _nr.property_value_timestamp;
		NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
		NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
		NEW.property_value_json = _nr.property_value_json;
		NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
		NEW.property_value_password_type = _nr.property_value_password_type;
		NEW.property_value_sw_package_id = NULL;
		NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
		NEW.property_rank = _nr.property_rank;
		NEW.start_date = _nr.start_date;
		NEW.finish_date = _nr.finish_date;
		NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.property_upd() FROM public;
CREATE TRIGGER trigger_property_upd INSTEAD OF UPDATE ON jazzhands_legacy.property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.property_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE sw_package
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'sw_package', 'sw_package');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'sw_package', tags := ARRAY['view_sw_package']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.sw_package;
CREATE VIEW jazzhands_legacy.sw_package AS
 SELECT software_artifact_name.software_artifact_name_id AS sw_package_id,
    software_artifact_name.software_artifact_name AS sw_package_name,
    software_artifact_name.software_artifact_type AS sw_package_type,
    software_artifact_name.description,
    software_artifact_name.data_ins_user,
    software_artifact_name.data_ins_date,
    software_artifact_name.data_upd_user,
    software_artifact_name.data_upd_date
   FROM jazzhands.software_artifact_name;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('sw_package','sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of sw_package failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('sw_package');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for sw_package  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE sw_package (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old sw_package failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('sw_package');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new sw_package failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_property', 'v_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_property', tags := ARRAY['view_v_property']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_property', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_property;
CREATE VIEW jazzhands_legacy.v_property AS
 SELECT v_property.property_id,
    v_property.account_collection_id,
    v_property.account_id,
    v_property.account_realm_id,
    v_property.company_collection_id,
    v_property.company_id,
    v_property.device_collection_id,
    v_property.dns_domain_collection_id,
    v_property.layer2_network_collection_id,
    v_property.layer3_network_collection_id,
    v_property.netblock_collection_id,
    v_property.network_range_id,
    v_property.operating_system_id,
    v_property.operating_system_snapshot_id,
    v_property.property_name_collection_id AS property_collection_id,
    v_property.service_environment_collection_id AS service_env_collection_id,
    v_property.site_code,
    v_property.x509_signed_certificate_id,
    v_property.property_name,
    v_property.property_type,
        CASE
            WHEN v_property.property_value_boolean = true THEN 'Y'::character varying
            WHEN v_property.property_value_boolean = false THEN 'N'::character varying
            ELSE v_property.property_value
        END::character varying(1024) AS property_value,
    v_property.property_value_timestamp,
    v_property.property_value_account_collection_id AS property_value_account_coll_id,
    v_property.property_value_device_collection_id AS property_value_device_coll_id,
    v_property.property_value_json,
    v_property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    v_property.property_value_password_type,
    NULL::integer AS property_value_sw_package_id,
    v_property.property_value_token_collection_id AS property_value_token_col_id,
    v_property.property_rank,
    v_property.start_date,
    v_property.finish_date,
        CASE
            WHEN v_property.is_enabled IS NULL THEN NULL::text
            WHEN v_property.is_enabled = true THEN 'Y'::text
            WHEN v_property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    v_property.data_ins_user,
    v_property.data_ins_date,
    v_property.data_upd_user,
    v_property.data_upd_date
   FROM jazzhands.v_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_property','v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_device_mgmt_ctrl_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_device_mgmt_ctrl_type', 'val_device_mgmt_ctrl_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_device_mgmt_ctrl_type', tags := ARRAY['view_val_device_mgmt_ctrl_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_device_mgmt_ctrl_type;
CREATE VIEW jazzhands_legacy.val_device_mgmt_ctrl_type AS
 SELECT val_device_management_controller_type.device_management_controller_type AS device_mgmt_control_type,
    val_device_management_controller_type.description,
    val_device_management_controller_type.data_ins_user,
    val_device_management_controller_type.data_ins_date,
    val_device_management_controller_type.data_upd_user,
    val_device_management_controller_type.data_upd_date
   FROM jazzhands.val_device_management_controller_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_device_mgmt_ctrl_type','val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_device_mgmt_ctrl_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_device_mgmt_ctrl_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_device_mgmt_ctrl_type (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_device_mgmt_ctrl_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_device_mgmt_ctrl_type failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_property', 'val_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_property', tags := ARRAY['view_val_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_property;
CREATE VIEW jazzhands_legacy.val_property AS
 SELECT val_property.property_name,
    val_property.property_type,
    val_property.description,
    val_property.account_collection_type,
    val_property.company_collection_type,
    val_property.device_collection_type,
    val_property.dns_domain_collection_type,
    val_property.layer2_network_collection_type,
    val_property.layer3_network_collection_type,
    val_property.netblock_collection_type,
    val_property.network_range_type,
    val_property.property_name_collection_type AS property_collection_type,
    val_property.service_environment_collection_type AS service_env_collection_type,
        CASE
            WHEN val_property.is_multivalue IS NULL THEN NULL::text
            WHEN val_property.is_multivalue = true THEN 'Y'::text
            WHEN val_property.is_multivalue = false THEN 'N'::text
            ELSE NULL::text
        END AS is_multivalue,
    val_property.property_value_account_collection_type_restriction AS prop_val_acct_coll_type_rstrct,
    val_property.property_value_device_collection_type_restriction AS prop_val_dev_coll_type_rstrct,
    val_property.property_value_netblock_collection_type_restriction AS prop_val_nblk_coll_type_rstrct,
    val_property.property_data_type,
    val_property.property_value_json_schema,
    val_property.permit_account_collection_id,
    val_property.permit_account_id,
    val_property.permit_account_realm_id,
    val_property.permit_company_id,
    val_property.permit_company_collection_id,
    val_property.permit_device_collection_id,
    val_property.permit_dns_domain_collection_id AS permit_dns_domain_coll_id,
    val_property.permit_layer2_network_collection_id AS permit_layer2_network_coll_id,
    val_property.permit_layer3_network_collection_id AS permit_layer3_network_coll_id,
    val_property.permit_netblock_collection_id,
    val_property.permit_network_range_id,
    val_property.permit_operating_system_id,
    val_property.permit_operating_system_snapshot_id AS permit_os_snapshot_id,
    val_property.permit_property_name_collection_id AS permit_property_collection_id,
    val_property.permit_service_environment_collection_id AS permit_service_env_collection,
    val_property.permit_site_code,
    val_property.permit_x509_signed_certificate_id AS permit_x509_signed_cert_id,
    val_property.permit_property_rank,
    val_property.data_ins_user,
    val_property.data_ins_date,
    val_property.data_upd_user,
    val_property.data_upd_date
   FROM jazzhands.val_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_property','val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();
ALTER TABLE jazzhands_legacy.val_property
	ALTER is_multivalue
	SET DEFAULT 'N'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_dns_domain_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_layer2_network_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_layer3_network_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_os_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_property_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_service_env_collection
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_x509_signed_cert_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.val_property_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.val_property%rowtype;
BEGIN
	DELETE FROM jazzhands.val_property
	WHERE  property_name = OLD.property_name  AND  property_type = OLD.property_type  RETURNING *
	INTO _or;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	OLD.description = _or.description;
	OLD.account_collection_type = _or.account_collection_type;
	OLD.company_collection_type = _or.company_collection_type;
	OLD.device_collection_type = _or.device_collection_type;
	OLD.dns_domain_collection_type = _or.dns_domain_collection_type;
	OLD.layer2_network_collection_type = _or.layer2_network_collection_type;
	OLD.layer3_network_collection_type = _or.layer3_network_collection_type;
	OLD.netblock_collection_type = _or.netblock_collection_type;
	OLD.network_range_type = _or.network_range_type;
	OLD.property_collection_type = _or.property_name_collection_type;
	OLD.service_env_collection_type = _or.service_environment_collection_type;
	OLD.is_multivalue = CASE WHEN _or.is_multivalue = true THEN 'Y' WHEN _or.is_multivalue = false THEN 'N' ELSE NULL END;
	OLD.prop_val_acct_coll_type_rstrct = _or.property_value_account_collection_type_restriction;
	OLD.prop_val_dev_coll_type_rstrct = _or.property_value_device_collection_type_restriction;
	OLD.prop_val_nblk_coll_type_rstrct = _or.property_value_netblock_collection_type_restriction;
	OLD.property_data_type = _or.property_data_type;
	OLD.property_value_json_schema = _or.property_value_json_schema;
	OLD.permit_account_collection_id = _or.permit_account_collection_id;
	OLD.permit_account_id = _or.permit_account_id;
	OLD.permit_account_realm_id = _or.permit_account_realm_id;
	OLD.permit_company_id = _or.permit_company_id;
	OLD.permit_company_collection_id = _or.permit_company_collection_id;
	OLD.permit_device_collection_id = _or.permit_device_collection_id;
	OLD.permit_dns_domain_coll_id = _or.permit_dns_domain_collection_id;
	OLD.permit_layer2_network_coll_id = _or.permit_layer2_network_collection_id;
	OLD.permit_layer3_network_coll_id = _or.permit_layer3_network_collection_id;
	OLD.permit_netblock_collection_id = _or.permit_netblock_collection_id;
	OLD.permit_network_range_id = _or.permit_network_range_id;
	OLD.permit_operating_system_id = _or.permit_operating_system_id;
	OLD.permit_os_snapshot_id = _or.permit_operating_system_snapshot_id;
	OLD.permit_property_collection_id = _or.permit_property_name_collection_id;
	OLD.permit_service_env_collection = _or.permit_service_environment_collection_id;
	OLD.permit_site_code = _or.permit_site_code;
	OLD.permit_x509_signed_cert_id = _or.permit_x509_signed_certificate_id;
	OLD.permit_property_rank = _or.permit_property_rank;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.val_property_del() FROM public;
CREATE TRIGGER trigger_val_property_del INSTEAD OF DELETE ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.val_property_del();

-- considering NEW jazzhands_legacy.val_property_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.val_property%rowtype;
BEGIN

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.account_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_type));
	END IF;

	IF NEW.company_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_type));
	END IF;

	IF NEW.device_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_type));
	END IF;

	IF NEW.dns_domain_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF NEW.layer2_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF NEW.layer3_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF NEW.netblock_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF NEW.network_range_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_type'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_type));
	END IF;

	IF NEW.property_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_type));
	END IF;

	IF NEW.service_env_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF NEW.is_multivalue IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_multivalue'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_multivalue = 'Y' THEN true WHEN NEW.is_multivalue = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.prop_val_acct_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_dev_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_nblk_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF NEW.property_data_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_data_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_data_type));
	END IF;

	IF NEW.property_value_json_schema IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json_schema'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF NEW.permit_account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF NEW.permit_account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_id));
	END IF;

	IF NEW.permit_account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF NEW.permit_company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_id));
	END IF;

	IF NEW.permit_company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF NEW.permit_device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF NEW.permit_dns_domain_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF NEW.permit_layer2_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF NEW.permit_layer3_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF NEW.permit_netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF NEW.permit_network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF NEW.permit_operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF NEW.permit_os_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF NEW.permit_property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF NEW.permit_service_env_collection IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_service_environment_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF NEW.permit_site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_site_code));
	END IF;

	IF NEW.permit_x509_signed_cert_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF NEW.permit_property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_rank));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.val_property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	NEW.description = _nr.description;
	NEW.account_collection_type = _nr.account_collection_type;
	NEW.company_collection_type = _nr.company_collection_type;
	NEW.device_collection_type = _nr.device_collection_type;
	NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
	NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
	NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
	NEW.netblock_collection_type = _nr.netblock_collection_type;
	NEW.network_range_type = _nr.network_range_type;
	NEW.property_collection_type = _nr.property_name_collection_type;
	NEW.service_env_collection_type = _nr.service_environment_collection_type;
	NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
	NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
	NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
	NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
	NEW.property_data_type = _nr.property_data_type;
	NEW.property_value_json_schema = _nr.property_value_json_schema;
	NEW.permit_account_collection_id = _nr.permit_account_collection_id;
	NEW.permit_account_id = _nr.permit_account_id;
	NEW.permit_account_realm_id = _nr.permit_account_realm_id;
	NEW.permit_company_id = _nr.permit_company_id;
	NEW.permit_company_collection_id = _nr.permit_company_collection_id;
	NEW.permit_device_collection_id = _nr.permit_device_collection_id;
	NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
	NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
	NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
	NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
	NEW.permit_network_range_id = _nr.permit_network_range_id;
	NEW.permit_operating_system_id = _nr.permit_operating_system_id;
	NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
	NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
	NEW.permit_service_env_collection = _nr.permit_service_environment_collection_id;
	NEW.permit_site_code = _nr.permit_site_code;
	NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
	NEW.permit_property_rank = _nr.permit_property_rank;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.val_property_ins() FROM public;
CREATE TRIGGER trigger_val_property_ins INSTEAD OF INSERT ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.val_property_ins();

-- considering NEW jazzhands_legacy.val_property_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.val_property%rowtype;
	_nr	jazzhands.val_property%rowtype;
	_uq	text[];
BEGIN

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.account_collection_type IS DISTINCT FROM NEW.account_collection_type THEN
_uq := array_append(_uq, 'account_collection_type = ' || quote_nullable(NEW.account_collection_type));
	END IF;

	IF OLD.company_collection_type IS DISTINCT FROM NEW.company_collection_type THEN
_uq := array_append(_uq, 'company_collection_type = ' || quote_nullable(NEW.company_collection_type));
	END IF;

	IF OLD.device_collection_type IS DISTINCT FROM NEW.device_collection_type THEN
_uq := array_append(_uq, 'device_collection_type = ' || quote_nullable(NEW.device_collection_type));
	END IF;

	IF OLD.dns_domain_collection_type IS DISTINCT FROM NEW.dns_domain_collection_type THEN
_uq := array_append(_uq, 'dns_domain_collection_type = ' || quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF OLD.layer2_network_collection_type IS DISTINCT FROM NEW.layer2_network_collection_type THEN
_uq := array_append(_uq, 'layer2_network_collection_type = ' || quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF OLD.layer3_network_collection_type IS DISTINCT FROM NEW.layer3_network_collection_type THEN
_uq := array_append(_uq, 'layer3_network_collection_type = ' || quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF OLD.netblock_collection_type IS DISTINCT FROM NEW.netblock_collection_type THEN
_uq := array_append(_uq, 'netblock_collection_type = ' || quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF OLD.network_range_type IS DISTINCT FROM NEW.network_range_type THEN
_uq := array_append(_uq, 'network_range_type = ' || quote_nullable(NEW.network_range_type));
	END IF;

	IF OLD.property_collection_type IS DISTINCT FROM NEW.property_collection_type THEN
_uq := array_append(_uq, 'property_name_collection_type = ' || quote_nullable(NEW.property_collection_type));
	END IF;

	IF OLD.service_env_collection_type IS DISTINCT FROM NEW.service_env_collection_type THEN
_uq := array_append(_uq, 'service_environment_collection_type = ' || quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF OLD.is_multivalue IS DISTINCT FROM NEW.is_multivalue THEN
IF NEW.is_multivalue = 'Y' THEN
	_uq := array_append(_uq, 'is_multivalue = true');
ELSIF NEW.is_multivalue = 'N' THEN
	_uq := array_append(_uq, 'is_multivalue = false');
ELSE
	_uq := array_append(_uq, 'is_multivalue = NULL');
END IF;
	END IF;

	IF OLD.prop_val_acct_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_acct_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_account_collection_type_restriction = ' || quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_dev_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_dev_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_device_collection_type_restriction = ' || quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_nblk_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_nblk_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_netblock_collection_type_restriction = ' || quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF OLD.property_data_type IS DISTINCT FROM NEW.property_data_type THEN
		_uq := array_append(_uq, 'property_data_type = ' || quote_nullable(NEW.property_data_type));
	END IF;

	IF OLD.property_value_json_schema IS DISTINCT FROM NEW.property_value_json_schema THEN
_uq := array_append(_uq, 'property_value_json_schema = ' || quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF OLD.permit_account_collection_id IS DISTINCT FROM NEW.permit_account_collection_id THEN
_uq := array_append(_uq, 'permit_account_collection_id = ' || quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF OLD.permit_account_id IS DISTINCT FROM NEW.permit_account_id THEN
_uq := array_append(_uq, 'permit_account_id = ' || quote_nullable(NEW.permit_account_id));
	END IF;

	IF OLD.permit_account_realm_id IS DISTINCT FROM NEW.permit_account_realm_id THEN
_uq := array_append(_uq, 'permit_account_realm_id = ' || quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF OLD.permit_company_id IS DISTINCT FROM NEW.permit_company_id THEN
_uq := array_append(_uq, 'permit_company_id = ' || quote_nullable(NEW.permit_company_id));
	END IF;

	IF OLD.permit_company_collection_id IS DISTINCT FROM NEW.permit_company_collection_id THEN
_uq := array_append(_uq, 'permit_company_collection_id = ' || quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF OLD.permit_device_collection_id IS DISTINCT FROM NEW.permit_device_collection_id THEN
_uq := array_append(_uq, 'permit_device_collection_id = ' || quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF OLD.permit_dns_domain_coll_id IS DISTINCT FROM NEW.permit_dns_domain_coll_id THEN
_uq := array_append(_uq, 'permit_dns_domain_collection_id = ' || quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF OLD.permit_layer2_network_coll_id IS DISTINCT FROM NEW.permit_layer2_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer2_network_collection_id = ' || quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF OLD.permit_layer3_network_coll_id IS DISTINCT FROM NEW.permit_layer3_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer3_network_collection_id = ' || quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF OLD.permit_netblock_collection_id IS DISTINCT FROM NEW.permit_netblock_collection_id THEN
_uq := array_append(_uq, 'permit_netblock_collection_id = ' || quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF OLD.permit_network_range_id IS DISTINCT FROM NEW.permit_network_range_id THEN
_uq := array_append(_uq, 'permit_network_range_id = ' || quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF OLD.permit_operating_system_id IS DISTINCT FROM NEW.permit_operating_system_id THEN
_uq := array_append(_uq, 'permit_operating_system_id = ' || quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF OLD.permit_os_snapshot_id IS DISTINCT FROM NEW.permit_os_snapshot_id THEN
_uq := array_append(_uq, 'permit_operating_system_snapshot_id = ' || quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF OLD.permit_property_collection_id IS DISTINCT FROM NEW.permit_property_collection_id THEN
_uq := array_append(_uq, 'permit_property_name_collection_id = ' || quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF OLD.permit_service_env_collection IS DISTINCT FROM NEW.permit_service_env_collection THEN
_uq := array_append(_uq, 'permit_service_environment_collection_id = ' || quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF OLD.permit_site_code IS DISTINCT FROM NEW.permit_site_code THEN
_uq := array_append(_uq, 'permit_site_code = ' || quote_nullable(NEW.permit_site_code));
	END IF;

	IF OLD.permit_x509_signed_cert_id IS DISTINCT FROM NEW.permit_x509_signed_cert_id THEN
_uq := array_append(_uq, 'permit_x509_signed_certificate_id = ' || quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF OLD.permit_property_rank IS DISTINCT FROM NEW.permit_property_rank THEN
_uq := array_append(_uq, 'permit_property_rank = ' || quote_nullable(NEW.permit_property_rank));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.val_property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_name = $1 AND  property_type = $2 RETURNING *'  USING OLD.property_name, OLD.property_type
			INTO _nr;

		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;
		NEW.description = _nr.description;
		NEW.account_collection_type = _nr.account_collection_type;
		NEW.company_collection_type = _nr.company_collection_type;
		NEW.device_collection_type = _nr.device_collection_type;
		NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
		NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
		NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
		NEW.netblock_collection_type = _nr.netblock_collection_type;
		NEW.network_range_type = _nr.network_range_type;
		NEW.property_collection_type = _nr.property_name_collection_type;
		NEW.service_env_collection_type = _nr.service_environment_collection_type;
		NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
		NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
		NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
		NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
		NEW.property_data_type = _nr.property_data_type;
		NEW.property_value_json_schema = _nr.property_value_json_schema;
		NEW.permit_account_collection_id = _nr.permit_account_collection_id;
		NEW.permit_account_id = _nr.permit_account_id;
		NEW.permit_account_realm_id = _nr.permit_account_realm_id;
		NEW.permit_company_id = _nr.permit_company_id;
		NEW.permit_company_collection_id = _nr.permit_company_collection_id;
		NEW.permit_device_collection_id = _nr.permit_device_collection_id;
		NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
		NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
		NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
		NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
		NEW.permit_network_range_id = _nr.permit_network_range_id;
		NEW.permit_operating_system_id = _nr.permit_operating_system_id;
		NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
		NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
		NEW.permit_service_env_collection = _nr.permit_service_environment_collection_id;
		NEW.permit_site_code = _nr.permit_site_code;
		NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
		NEW.permit_property_rank = _nr.permit_property_rank;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.val_property_upd() FROM public;
CREATE TRIGGER trigger_val_property_upd INSTEAD OF UPDATE ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.val_property_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_sw_package_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_sw_package_type', 'val_sw_package_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_sw_package_type', tags := ARRAY['view_val_sw_package_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_sw_package_type;
CREATE VIEW jazzhands_legacy.val_sw_package_type AS
 SELECT val_software_artifact_type.software_artifact_type AS sw_package_type,
    val_software_artifact_type.description,
    val_software_artifact_type.data_ins_user,
    val_software_artifact_type.data_ins_date,
    val_software_artifact_type.data_upd_user,
    val_software_artifact_type.data_upd_date
   FROM jazzhands.val_software_artifact_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_sw_package_type','val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_sw_package_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_sw_package_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_sw_package_type (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_sw_package_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_sw_package_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_sw_package_type failed but that is ok';
	NULL;
END;
$$;


--------------------------------------------------------------------
-- DEALING WITH proc jazzhands_legacy.x509_certificate_upd -> x509_certificate_upd 

-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'x509_certificate_upd', 'x509_certificate_upd');

-- DROP OLD FUNCTION
-- triggers on this function (if applicable)
DROP TRIGGER IF EXISTS trigger_x509_certificate_upd ON jazzhands_legacy.x509_certificate;
-- consider old oid 27501669
DROP TRIGGER IF EXISTS trigger_x509_certificate_upd ON jazzhands_legacy.x509_certificate;
DROP FUNCTION IF EXISTS jazzhands_legacy.x509_certificate_upd();

-- RECREATE FUNCTION

-- DROP OLD FUNCTION (in case type changed)
-- considering NEW jazzhands_legacy.x509_certificate_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	crt	jazzhands.x509_signed_certificate%rowtype;
	key	jazzhands.private_key%rowtype;
	csr	jazzhands.certificate_signing_request%rowtype;
	_uq	text[];
BEGIN
	SELECT * INTO crt FROM jazzhands.x509_signed_certificate
        WHERE x509_signed_certificate_id = OLD.x509_cert_id;

	IF crt.private_key_ID IS NULL AND NEW.private_key IS NOT NULL THEN
		INSERT INTO private_key (
			private_key_encryption_type,
			is_active,
			subject_key_identifier,
			private_key,
			passphrase,
			encryption_key_id
		) VALUES (
			'rsa',
			NEW.is_active,
			NEW.subject_key_identifier,
			NEW.private_key,
			NEW.passphrase,
			NEW.encryption_key_id
		) RETURNING * INTO key;
	ELSE IF crt.private_key_id IS NOT NULL THEN
		SELECT * INTO key FROM jazzhands.private_key k
			WHERE k.private_key_id =  crt.private_key_id;

		-- delete happens at the end, after update
		IF NEW.private_key IS NOT NULL THEN
			IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
				_uq := array_append(_uq,
					'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
				);
			END IF;
			IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
				IF NEW.is_active = 'Y' THEN
					_uq := array_append(_uq, 'is_active = true');
				ELSIF NEW.is_active = 'N' THEN
					_uq := array_append(_uq, 'is_active = false');
				ELSE
					_uq := array_append(_uq, 'is_active = NULL');
				END IF;
			END IF;
			IF OLD.private_key IS DISTINCT FROM NEW.private_key THEN
				_uq := array_append(_uq,
					'private_key = ' || quote_nullable(NEW.private_key)
				);
			END IF;
			IF OLD.passphrase IS DISTINCT FROM NEW.passphrase THEN
				_uq := array_append(_uq,
					'passphrase = ' || quote_nullable(NEW.passphrase)
				);
			END IF;
			IF OLD.encryption_key_id IS DISTINCT FROM NEW.encryption_key_id THEN
				_uq := array_append(_uq,
					'encryption_key_id = ' || quote_nullable(NEW.encryption_key_id)
				);
			END IF;
			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.private_key 		= key.private_key;
		NEW.is_active 			= CASE WHEN key.is_active THEN 'Y' ELSE 'N' END;
		NEW.passphrase 			= key.passphrase;
		NEW.encryption_key_id	= key.encryption_key_id;
	END IF;

	-- private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF crt.certificate_signing_request_id IS NULL AND NEW.certificate_sign_req IS NOT NULL THEN
		INSERT INTO jazzhands.certificate_signing_request (
			friendly_name,
			subject,
			certificate_signing_request,
			private_key_id
		) VALUES (
			NEW.friendly_name,
			NEW.subject,
			NEW.certificate_sign_req,
			key.private_key_id
		) RETURNING * INTO csr;
	ELSIF crt.certificate_signing_request_id IS NOT NULL THEN
		SELECT * INTO csr FROM jazzhands.certificate_signing_request c
			WHERE c.certificate_signing_request_id =  crt.certificate_signing_request_id;

		-- delete happens at the end, after update
		IF NEW.certificate_sign_req IS NOT NULL THEN
			IF OLD.certificate_sign_req IS DISTINCT FROM NEW.certificate_sign_req THEN
				_uq := array_append(_uq,
					'certificate_signing_request = ' || quote_nullable(NEW.certificate_sign_req)
				);
			END IF;
			IF OLD.subject IS DISTINCT FROM NEW.subject THEN
				_uq := array_append(_uq,
					'subject = ' || quote_nullable(NEW.subject)
				);
			END IF;
			IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
				_uq := array_append(_uq,
					'friendly_name = ' || quote_nullable(NEW.friendly_name)
				);
			END IF;
			IF OLD.private_key IS DISTINCT FROM key.private_key THEN
				_uq := array_append(_uq,
					'private_key = ' || quote_nullable(NEW.private_key)
				);
			END IF;

			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.certificate_sign_req 	= csr.certificate_signing_request;
	END IF;

	-- csr and private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
		IF NEW.is_active = 'Y' THEN
			_uq := array_append(_uq, 'is_active = true');
		ELSIF NEW.is_active = 'N' THEN
			_uq := array_append(_uq, 'is_active = false');
		ELSE
			_uq := array_append(_uq, 'is_active = NULL');
		END IF;
	END IF;

	END IF;
	IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
		_uq := array_append(_uq,
			'friendly_name = ' || quote_literal(NEW.friendly_name)
		);
	END IF;
	IF OLD.subject IS DISTINCT FROM NEW.subject THEN
		_uq := array_append(_uq,
			'subject = ' || quote_literal(NEW.subject)
		);
	END IF;
	IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
		_uq := array_append(_uq,
			'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
		);
	END IF;

	IF OLD.is_certificate_authority IS DISTINCT FROM NEW.is_certificate_authority THEN
		IF NEW.is_certificate_authority = 'Y' THEN
			_uq := array_append(_uq, 'is_certificate_authority = true');
		ELSIF NEW.is_certificate_authority = 'N' THEN
			_uq := array_append(_uq, 'is_certificate_authority = false');
		ELSE
			_uq := array_append(_uq, 'is_certificate_authority = NULL');
		END IF;
	END IF;

	IF OLD.signing_cert_id IS DISTINCT FROM NEW.signing_cert_id THEN
		_uq := array_append(_uq,
			'signing_cert_id = ' || quote_nullable(NEW.signing_cert_id)
		);
	END IF;
	IF OLD.x509_ca_cert_serial_number IS DISTINCT FROM NEW.x509_ca_cert_serial_number THEN
		_uq := array_append(_uq,
			'x509_ca_cert_serial_number = ' || quote_nullable(NEW.x509_ca_cert_serial_number)
		);
	END IF;
	IF OLD.public_key IS DISTINCT FROM NEW.public_key THEN
		_uq := array_append(_uq,
			'public_key = ' || quote_nullable(NEW.public_key)
		);
	END IF;
	IF OLD.valid_from IS DISTINCT FROM NEW.valid_from THEN
		_uq := array_append(_uq,
			'valid_from = ' || quote_nullable(NEW.valid_from)
		);
	END IF;
	IF OLD.valid_to IS DISTINCT FROM NEW.valid_to THEN
		_uq := array_append(_uq,
			'valid_to = ' || quote_nullable(NEW.valid_to)
		);
	END IF;
	IF OLD.x509_revocation_date IS DISTINCT FROM NEW.x509_revocation_date THEN
		_uq := array_append(_uq,
			'x509_revocation_date = ' || quote_nullable(NEW.x509_revocation_date)
		);
	END IF;
	IF OLD.x509_revocation_reason IS DISTINCT FROM NEW.x509_revocation_reason THEN
		_uq := array_append(_uq,
			'x509_revocation_reason = ' || quote_nullable(NEW.x509_revocation_reason)
		);
	END IF;
	IF OLD.ocsp_uri IS DISTINCT FROM NEW.ocsp_uri THEN
		_uq := array_append(_uq,
			'ocsp_uri = ' || quote_nullable(NEW.ocsp_uri)
		);
	END IF;
	IF OLD.crl_uri IS DISTINCT FROM NEW.crl_uri THEN
		_uq := array_append(_uq,
			'crl_uri = ' || quote_nullable(NEW.crl_uri)
		);
	END IF;

	IF array_length(_uq, 1) > 0 THEN
		EXECUTE 'UPDATE x509_signed_certificate SET '
			|| array_to_string(_uq, ', ')
			|| ' WHERE x509_signed_certificate_id = '
			|| NEW.x509_cert_id;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.x509_signed_certificate SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  x509_signed_certificate_id = $1 RETURNING *'  USING OLD.x509_cert_id
			INTO crt;

		NEW.x509_cert_id = crt.x509_signed_certificate_id;
		NEW.friendly_name = crt.friendly_name;
		NEW.is_active = CASE WHEN crt.is_active = true THEN 'Y' WHEN crt.is_active = false THEN 'N' ELSE NULL END;
		NEW.is_certificate_authority = CASE WHEN crt.is_certificate_authority = true THEN 'Y' WHEN crt.is_certificate_authority = false THEN 'N' ELSE NULL END;
		NEW.signing_cert_id = crt.signing_cert_id;
		NEW.x509_ca_cert_serial_number = crt.x509_ca_cert_serial_number;
		NEW.public_key = crt.public_key;
		NEW.subject = crt.subject;
		NEW.subject_key_identifier = crt.subject_key_identifier;
		NEW.valid_from = crt.valid_from;
		NEW.valid_to = crt.valid_to;
		NEW.x509_revocation_date = crt.x509_revocation_date;
		NEW.x509_revocation_reason = crt.x509_revocation_reason;
		NEW.ocsp_uri = crt.ocsp_uri;
		NEW.crl_uri = crt.crl_uri;
		NEW.data_ins_user = crt.data_ins_user;
		NEW.data_ins_date = crt.data_ins_date;
		NEW.data_upd_user = crt.data_upd_user;
		NEW.data_upd_date = crt.data_upd_date;
	END IF;

	IF OLD.certificate_sign_req IS NOT NULL AND NEW.certificate_sign_req IS NULL THEN
		DELETE FROM jazzhands.certificate_signing_request
		WHERE certificate_signing_request_id = crt.certificate_signing_request_id;
	END IF;

	IF OLD.private_key IS NOT NULL AND NEW.private_key IS NULL THEN
		DELETE FROM jazzhands.private_key
		WHERE private_key_id = crt.private_key_id;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.x509_certificate_upd() FROM public;
-- triggers on this function (if applicable)
DROP TRIGGER IF EXISTS trigger_x509_certificate_upd ON jazzhands_legacy.x509_certificate;
CREATE TRIGGER trigger_x509_certificate_upd INSTEAD OF UPDATE ON jazzhands_legacy.x509_certificate FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.x509_certificate_upd();

-- DONE WITH proc jazzhands_legacy.x509_certificate_upd -> x509_certificate_upd 
--------------------------------------------------------------------


--------------------------------------------------------------------
-- DEALING WITH proc jazzhands_legacy.property_upd -> property_upd 

-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property_upd', 'property_upd');

-- DROP OLD FUNCTION
-- triggers on this function (if applicable)
DROP TRIGGER IF EXISTS trigger_property_upd ON jazzhands_legacy.property;
-- consider old oid 27501469
DROP TRIGGER IF EXISTS trigger_property_upd ON jazzhands_legacy.property;
DROP FUNCTION IF EXISTS jazzhands_legacy.property_upd();

-- RECREATE FUNCTION

-- DROP OLD FUNCTION (in case type changed)
-- considering NEW jazzhands_legacy.property_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.property%rowtype;
	_nr	jazzhands.property%rowtype;
	_uq	text[];
	_dt	TEXT;
BEGIN
	IF OLD.property_id IS DISTINCT FROM NEW.property_id THEN
_uq := array_append(_uq, 'property_id = ' || quote_nullable(NEW.property_id));
	END IF;

	IF OLD.account_collection_id IS DISTINCT FROM NEW.account_collection_id THEN
_uq := array_append(_uq, 'account_collection_id = ' || quote_nullable(NEW.account_collection_id));
	END IF;

	IF OLD.account_id IS DISTINCT FROM NEW.account_id THEN
_uq := array_append(_uq, 'account_id = ' || quote_nullable(NEW.account_id));
	END IF;

	IF OLD.account_realm_id IS DISTINCT FROM NEW.account_realm_id THEN
_uq := array_append(_uq, 'account_realm_id = ' || quote_nullable(NEW.account_realm_id));
	END IF;

	IF OLD.company_collection_id IS DISTINCT FROM NEW.company_collection_id THEN
_uq := array_append(_uq, 'company_collection_id = ' || quote_nullable(NEW.company_collection_id));
	END IF;

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.device_collection_id IS DISTINCT FROM NEW.device_collection_id THEN
_uq := array_append(_uq, 'device_collection_id = ' || quote_nullable(NEW.device_collection_id));
	END IF;

	IF OLD.dns_domain_collection_id IS DISTINCT FROM NEW.dns_domain_collection_id THEN
_uq := array_append(_uq, 'dns_domain_collection_id = ' || quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF OLD.layer2_network_collection_id IS DISTINCT FROM NEW.layer2_network_collection_id THEN
_uq := array_append(_uq, 'layer2_network_collection_id = ' || quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF OLD.layer3_network_collection_id IS DISTINCT FROM NEW.layer3_network_collection_id THEN
_uq := array_append(_uq, 'layer3_network_collection_id = ' || quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF OLD.netblock_collection_id IS DISTINCT FROM NEW.netblock_collection_id THEN
_uq := array_append(_uq, 'netblock_collection_id = ' || quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF OLD.network_range_id IS DISTINCT FROM NEW.network_range_id THEN
_uq := array_append(_uq, 'network_range_id = ' || quote_nullable(NEW.network_range_id));
	END IF;

	IF OLD.operating_system_id IS DISTINCT FROM NEW.operating_system_id THEN
_uq := array_append(_uq, 'operating_system_id = ' || quote_nullable(NEW.operating_system_id));
	END IF;

	IF OLD.operating_system_snapshot_id IS DISTINCT FROM NEW.operating_system_snapshot_id THEN
_uq := array_append(_uq, 'operating_system_snapshot_id = ' || quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF OLD.property_collection_id IS DISTINCT FROM NEW.property_collection_id THEN
_uq := array_append(_uq, 'property_name_collection_id = ' || quote_nullable(NEW.property_collection_id));
	END IF;

	IF OLD.service_env_collection_id IS DISTINCT FROM NEW.service_env_collection_id THEN
_uq := array_append(_uq, 'service_environment_collection_id = ' || quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF OLD.site_code IS DISTINCT FROM NEW.site_code THEN
_uq := array_append(_uq, 'site_code = ' || quote_nullable(NEW.site_code));
	END IF;

	IF OLD.x509_signed_certificate_id IS DISTINCT FROM NEW.x509_signed_certificate_id THEN
_uq := array_append(_uq, 'x509_signed_certificate_id = ' || quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.property_value IS DISTINCT FROM NEW.property_value THEN
		SELECT property_data_type INTO _dt
		FROM val_property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			IF NEW.property_value = 'Y' THEN
				_uq := array_append(_uq, 'property_value_boolean = true');
			ELSIF NEW.property_value = 'N' THEN
				_uq := array_append(_uq, 'property_value_boolean = false');
			ELSE
				_uq := array_append(_uq, 'property_value = NULL');
			END IF;
		ELSE
			_uq := array_append(_uq, 'property_value = ' || quote_nullable(NEW.property_value));
			_uq := array_append(_uq, 'property_value_boolean = NULL');
		END IF;
	END IF;

	IF OLD.property_value_timestamp IS DISTINCT FROM NEW.property_value_timestamp THEN
_uq := array_append(_uq, 'property_value_timestamp = ' || quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF OLD.property_value_account_coll_id IS DISTINCT FROM NEW.property_value_account_coll_id THEN
_uq := array_append(_uq, 'property_value_account_collection_id = ' || quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF OLD.property_value_device_coll_id IS DISTINCT FROM NEW.property_value_device_coll_id THEN
_uq := array_append(_uq, 'property_value_device_collection_id = ' || quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF OLD.property_value_json IS DISTINCT FROM NEW.property_value_json THEN
_uq := array_append(_uq, 'property_value_json = ' || quote_nullable(NEW.property_value_json));
	END IF;

	IF OLD.property_value_nblk_coll_id IS DISTINCT FROM NEW.property_value_nblk_coll_id THEN
_uq := array_append(_uq, 'property_value_netblock_collection_id = ' || quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF OLD.property_value_password_type IS DISTINCT FROM NEW.property_value_password_type THEN
_uq := array_append(_uq, 'property_value_password_type = ' || quote_nullable(NEW.property_value_password_type));
	END IF;

	IF OLD.property_value_sw_package_id IS DISTINCT FROM NEW.property_value_sw_package_id THEN
		RAISE EXCEPTION 'property_value_sw_package_id can not be set'
			USING ERRCODE = invalid_parameter_value,
			HINT = 'sw_package become software_artifacts and were dropped from property in 0.91';
	END IF;

	IF OLD.property_value_token_col_id IS DISTINCT FROM NEW.property_value_token_col_id THEN
_uq := array_append(_uq, 'property_value_token_collection_id = ' || quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF OLD.property_rank IS DISTINCT FROM NEW.property_rank THEN
_uq := array_append(_uq, 'property_rank = ' || quote_nullable(NEW.property_rank));
	END IF;

	IF OLD.start_date IS DISTINCT FROM NEW.start_date THEN
_uq := array_append(_uq, 'start_date = ' || quote_nullable(NEW.start_date));
	END IF;

	IF OLD.finish_date IS DISTINCT FROM NEW.finish_date THEN
_uq := array_append(_uq, 'finish_date = ' || quote_nullable(NEW.finish_date));
	END IF;

	IF OLD.is_enabled IS DISTINCT FROM NEW.is_enabled THEN
IF NEW.is_enabled = 'Y' THEN
	_uq := array_append(_uq, 'is_enabled = true');
ELSIF NEW.is_enabled = 'N' THEN
	_uq := array_append(_uq, 'is_enabled = false');
ELSE
	_uq := array_append(_uq, 'is_enabled = NULL');
END IF;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_id = $1 RETURNING *'  USING OLD.property_id
			INTO _nr;

		NEW.property_id = _nr.property_id;
		NEW.account_collection_id = _nr.account_collection_id;
		NEW.account_id = _nr.account_id;
		NEW.account_realm_id = _nr.account_realm_id;
		NEW.company_collection_id = _nr.company_collection_id;
		NEW.company_id = _nr.company_id;
		NEW.device_collection_id = _nr.device_collection_id;
		NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
		NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
		NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
		NEW.netblock_collection_id = _nr.netblock_collection_id;
		NEW.network_range_id = _nr.network_range_id;
		NEW.operating_system_id = _nr.operating_system_id;
		NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
		NEW.property_collection_id = _nr.property_name_collection_id;
		NEW.service_env_collection_id = _nr.service_environment_collection_id;
		NEW.site_code = _nr.site_code;
		NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;

		IF _dt IS NOT DISTINCT FROM 'boolean' THEN
			NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
		ELSE
			NEW.property_value = _nr.property_value;
		END IF;

		NEW.property_value_timestamp = _nr.property_value_timestamp;
		NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
		NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
		NEW.property_value_json = _nr.property_value_json;
		NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
		NEW.property_value_password_type = _nr.property_value_password_type;
		NEW.property_value_sw_package_id = NULL;
		NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
		NEW.property_rank = _nr.property_rank;
		NEW.start_date = _nr.start_date;
		NEW.finish_date = _nr.finish_date;
		NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands_legacy.property_upd() FROM public;
-- triggers on this function (if applicable)
DROP TRIGGER IF EXISTS trigger_property_upd ON jazzhands_legacy.property;
CREATE TRIGGER trigger_property_upd INSTEAD OF UPDATE ON jazzhands_legacy.property FOR EACH ROW EXECUTE PROCEDURE jazzhands_legacy.property_upd();

-- DONE WITH proc jazzhands_legacy.property_upd -> property_upd 
--------------------------------------------------------------------

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
-- DONE: process_ancillary_schema(jazzhands_legacy)
--
-- BEGIN: Fix cache table entries.
--
-- removing old
-- adding new cache tables that are not there
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  WHERE ('jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  WHERE ('jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
--
-- DONE: Fix cache table entries.
--


-- Clean Up
--
-- Process post-schema property_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('property_utils', 'validate_property');
SELECT schema_support.save_grants_for_replay('property_utils', 'validate_property');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS property_utils.validate_property ( new jazzhands.property );
CREATE OR REPLACE FUNCTION property_utils.validate_property(new jazzhands.property)
 RETURNS jazzhands.property
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	tally				integer;
	v_prop				VAL_Property%ROWTYPE;
	v_proptype			VAL_Property_Type%ROWTYPE;
	v_account_collection		account_collection%ROWTYPE;
	v_company_collection		company_collection%ROWTYPE;
	v_device_collection		device_collection%ROWTYPE;
	v_dns_domain_collection		dns_domain_collection%ROWTYPE;
	v_layer2_network_collection	layer2_network_collection%ROWTYPE;
	v_layer3_network_collection	layer3_network_collection%ROWTYPE;
	v_netblock_collection		netblock_collection%ROWTYPE;
	v_network_range				network_range%ROWTYPE;
	v_property_name_collection		property_name_collection%ROWTYPE;
	v_service_environment_collection	service_environment_collection%ROWTYPE;
	v_service_version_collection	service_version_collection%ROWTYPE;
	v_num				integer;
	v_listvalue			Property.Property_Value%TYPE;
BEGIN
	-- Pull in the data from the property and property_type so we can
	-- figure out what is and is not valid

	BEGIN
		SELECT * INTO STRICT v_prop FROM VAL_Property WHERE
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type;

		SELECT * INTO STRICT v_proptype FROM VAL_Property_Type WHERE
			Property_Type = NEW.Property_Type;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION
				'Property name (%) or type (%) does not exist',
				NEW.property_name, NEW.property_type
				USING ERRCODE = 'foreign_key_violation';
			RETURN NULL;
	END;

	-- Check to see if the property itself is multivalue.  That is, if only
	-- one value can be set for this property for a specific property LHS
	IF (v_prop.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of type (%,%) already exists for given LHS and property is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	ELSE
		-- check for the same lhs+rhs existing, which is basically a dup row
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code AND
			property_value IS NOT DISTINCT FROM NEW.property_value AND
			property_value_json IS NOT DISTINCT FROM
				NEW.property_value_json AND
			property_value_boolean IS NOT DISTINCT FROM
				NEW.property_value_boolean AND
			property_value_timestamp IS NOT DISTINCT FROM
				NEW.property_value_timestamp AND
			property_value_account_collection_id IS NOT DISTINCT FROM
				NEW.property_value_account_collection_id AND
			property_value_device_collection_id IS NOT DISTINCT FROM
				NEW.property_value_device_collection_id AND
			property_value_netblock_collection_id IS NOT DISTINCT FROM
				NEW.property_value_netblock_collection_id AND
			property_value_service_version_collection_id IS NOT DISTINCT FROM
				NEW.property_value_service_version_collection_id AND
			property_value_password_type IS NOT DISTINCT FROM
				NEW.property_value_password_type AND
			property_value_token_collection_id IS NOT DISTINCT FROM
				NEW.property_value_token_collection_id AND
			property_value_encryption_key_id IS NOT DISTINCT FROM
				NEW.property_value_encryption_key_id AND
			property_value_private_key_id IS NOT DISTINCT FROM
				NEW.property_value_private_key_id AND
			start_date IS NOT DISTINCT FROM NEW.start_date AND
			finish_date IS NOT DISTINCT FROM NEW.finish_date
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of (n,t) (%,%) already exists for given property',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;

	END IF;

	-- Check to see if the property type is multivalue.  That is, if only
	-- one property and value can be set for any properties with this type
	-- for a specific property LHS

	IF (v_proptype.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property % of type % already exists for given LHS and property type is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	END IF;

	-- now validate the property_value columns.
	tally := 0;

	--
	-- first determine if the property_value is set properly.
	--

	-- iterate over each of fk PROPERTY_VALUE columns and if a valid
	-- value is set, increment tally, otherwise raise an exception.
	IF NEW.Property_Value_JSON IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'json' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be JSON' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Password_Type IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'password_type' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Password_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Token_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'token_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Token_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'account_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be account_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'netblock_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be netblock_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_service_version_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'service_version_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be service_version_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Timestamp IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'timestamp' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Timestamp' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'device_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Device_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_boolean IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'boolean' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be boolean' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_encryption_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'encryption_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be encryption_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_private_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'private_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be private_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- at this point, tally will be set to 1 if one of the other property
	-- values is set to something valid.  Now, check the various options for
	-- PROPERTY_VALUE itself.  If a new type is added to the val table, this
	-- trigger needs to be updated or it will be considered invalid.  If a
	-- new PROPERTY_VALUE_* column is added, then it will pass through without
	-- trigger modification.  This should be considered bad.
	IF NEW.Property_Value IS NOT NULL THEN
		tally := tally + 1;
		IF v_prop.Property_Data_Type = 'number' THEN
			BEGIN
				v_num := to_number(NEW.property_value, '9');
			EXCEPTION
				WHEN OTHERS THEN
					RAISE 'Property_Value must be numeric' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'list' THEN
			BEGIN
				SELECT Valid_Property_Value INTO STRICT v_listvalue FROM
					VAL_Property_Value WHERE
						Property_Name = NEW.Property_Name AND
						Property_Type = NEW.Property_Type AND
						Valid_Property_Value = NEW.Property_Value;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					RAISE 'Property_Value must be a valid value' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'boolean' THEN
			RAISE 'Boolean values are set in Property_Value_Boolean' USING
				ERRCODE = 'invalid_parameter_value';
		ELSIF v_prop.Property_Data_Type != 'string' THEN
			RAISE 'Property_Value may not be set for this Property_Data_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF v_prop.Property_Data_Type != 'none' AND tally = 0 THEN
		RAISE 'One of the PROPERTY_VALUE fields must be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	IF tally > 1 THEN
		RAISE 'Only one of the PROPERTY_VALUE fields may be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	-- If the LHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.account_collection_id IS NOT NULL THEN
		IF v_prop.account_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.account_collection_id;
				IF v_account_collection.account_collection_Type != v_prop.account_collection_type
				THEN
					RAISE 'account_collection_id must be of type %',
					v_prop.account_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a company_collection_ID, check to see if it must be a
	-- specific type (e.g. per-company), and verify that if so
	IF NEW.company_collection_id IS NOT NULL THEN
		IF v_prop.company_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_company_collection
					FROM company_collection WHERE
					company_collection_Id = NEW.company_collection_id;
				IF v_company_collection.company_collection_Type != v_prop.company_collection_type
				THEN
					RAISE 'company_collection_id must be of type %',
					v_prop.company_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a device_collection_ID, check to see if it must be a
	-- specific type (e.g. per-device), and verify that if so
	IF NEW.device_collection_id IS NOT NULL THEN
		IF v_prop.device_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_Id = NEW.device_collection_id;
				IF v_device_collection.device_collection_Type != v_prop.device_collection_type
				THEN
					RAISE 'device_collection_id must be of type %',
					v_prop.device_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a dns_domain_collection_ID, check to see if it must be a
	-- specific type (e.g. per-dns_domain), and verify that if so
	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		IF v_prop.dns_domain_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_dns_domain_collection
					FROM dns_domain_collection WHERE
					dns_domain_collection_Id = NEW.dns_domain_collection_id;
				IF v_dns_domain_collection.dns_domain_collection_Type != v_prop.dns_domain_collection_type
				THEN
					RAISE 'dns_domain_collection_id must be of type %',
					v_prop.dns_domain_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer2_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer2_network), and verify that if so
	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		IF v_prop.layer2_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer2_network_collection
					FROM layer2_network_collection WHERE
					layer2_network_collection_Id = NEW.layer2_network_collection_id;
				IF v_layer2_network_collection.layer2_network_collection_Type != v_prop.layer2_network_collection_type
				THEN
					RAISE 'layer2_network_collection_id must be of type %',
					v_prop.layer2_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer3_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer3_network), and verify that if so
	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		IF v_prop.layer3_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer3_network_collection
					FROM layer3_network_collection WHERE
					layer3_network_collection_Id = NEW.layer3_network_collection_id;
				IF v_layer3_network_collection.layer3_network_collection_Type != v_prop.layer3_network_collection_type
				THEN
					RAISE 'layer3_network_collection_id must be of type %',
					v_prop.layer3_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type (e.g. per-netblock), and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.netblock_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.netblock_collection_id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.netblock_collection_type
				THEN
					RAISE 'netblock_collection_id must be of type %',
					v_prop.netblock_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a network_range_id, check to see if it must
	-- be a specific type and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.network_range_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_network_range
					FROM network_range WHERE
					network_range_id = NEW.network_range_id;
				IF v_network_range.network_range_type != v_prop.network_range_type
				THEN
					RAISE 'network_range_id must be of type %',
					v_prop.network_range_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a property_name_collection_ID, check to see if it must be a
	-- specific type (e.g. per-property), and verify that if so
	IF NEW.property_name_collection_id IS NOT NULL THEN
		IF v_prop.property_name_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_property_name_collection
					FROM property_name_collection WHERE
					property_name_collection_Id = NEW.property_name_collection_id;
				IF v_property_name_collection.property_name_collection_Type != v_prop.property_name_collection_type
				THEN
					RAISE 'property_name_collection_id must be of type %',
					v_prop.property_name_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a service_environment_collection_ID, check to see if it must be a
	-- specific type (e.g. per-service_env), and verify that if so
	IF NEW.service_environment_collection_id IS NOT NULL THEN
		IF v_prop.service_environment_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_environment_collection
					FROM service_environment_collection WHERE
					service_environment_collection_Id = NEW.service_environment_collection_id;
				IF v_service_environment_collection.service_environment_collection_Type != v_prop.service_environment_collection_type
				THEN
					RAISE 'service_environment_collection_id must be of type %',
					v_prop.service_environment_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;
	IF NEW.service_version_collection_id IS NOT NULL THEN
		IF v_prop.service_version_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_version_collection
					FROM service_version_collection WHERE
					service_version_collection_Id = NEW.service_version_collection_id;
				IF v_service_version_collection.service_version_collection_Type != v_prop.service_version_collection_type
				THEN
					RAISE 'service_version_collection_id must be of type %',
					v_prop.service_version_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_account_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.Property_Value_Account_collection_Id;
				IF v_account_collection.account_collection_Type != v_prop.property_value_account_collection_type_restriction
				THEN
					RAISE 'Property_Value_Account_collection_Id must be of type %',
					v_prop.property_value_account_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_account_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.Property_Value_netblock_collection_Id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.property_value_account_collection_type_restriction
				THEN
					RAISE 'Property_Value_netblock_collection_Id must be of type %',
					v_prop.property_value_account_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a service_version_collection_id, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.property_value_service_version_collection_id IS NOT NULL THEN
		IF v_prop.property_value_service_version_collection_id IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_version_collection
					FROM service_version_collection WHERE
					service_version_collection_Id = NEW.property_value_service_version_collection_id;
				IF v_service_version_collection.service_version_collection_Type != v_prop.property_value_service_version_collection_type_restriction
				THEN
					RAISE 'Property_Value_service_version_collection_Id must be of type %',
					v_prop.property_value_service_version_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a device_collection_id, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_device_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_id = NEW.Property_Value_Device_collection_Id;
				IF v_device_collection.device_collection_type !=
					v_prop.property_value_device_collection_type_restriction
				THEN
					RAISE 'Property_Value_Device_collection_Id must be of type %',
					v_prop.property_value_device_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	--
	--
	IF v_prop.property_data_type = 'json' THEN
		IF  NOT validate_json_schema(
				v_prop.property_value_json_schema,
				NEW.property_value_json) THEN
			RAISE EXCEPTION 'JSON provided must match the json schema'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- At this point, the RHS has been checked, so now we verify data
	-- set on the LHS

	-- There needs to be a stanza here for every "lhs".  If a new column is
	-- added to the property table, a new stanza needs to be added here,
	-- otherwise it will not be validated.  This should be considered bad.

	IF v_prop.Permit_Company_Id = 'REQUIRED' THEN
			IF NEW.Company_Id IS NULL THEN
				RAISE 'Company_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Id = 'PROHIBITED' THEN
			IF NEW.Company_Id IS NOT NULL THEN
				RAISE 'Company_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Company_Collection_Id = 'REQUIRED' THEN
			IF NEW.Company_Collection_Id IS NULL THEN
				RAISE 'Company_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Company_Collection_Id IS NOT NULL THEN
				RAISE 'Company_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Device_Collection_Id = 'REQUIRED' THEN
			IF NEW.Device_Collection_Id IS NULL THEN
				RAISE 'Device_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;

	ELSIF v_prop.Permit_Device_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Device_Collection_Id IS NOT NULL THEN
				RAISE 'Device_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_service_environment_collection_id = 'REQUIRED' THEN
			IF NEW.service_environment_collection_id IS NULL THEN
				RAISE 'service_environment_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_service_environment_collection_id = 'PROHIBITED' THEN
			IF NEW.service_environment_collection_id IS NOT NULL THEN
				RAISE 'service_environment is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_service_version_collection_id = 'REQUIRED' THEN
			IF NEW.service_version_collection_id IS NULL THEN
				RAISE 'service_version_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_service_version_collection_id = 'PROHIBITED' THEN
			IF NEW.service_version_collection_id IS NOT NULL THEN
				RAISE 'service_version_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Operating_System_Id = 'REQUIRED' THEN
			IF NEW.Operating_System_Id IS NULL THEN
				RAISE 'Operating_System_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Operating_System_Id = 'PROHIBITED' THEN
			IF NEW.Operating_System_Id IS NOT NULL THEN
				RAISE 'Operating_System_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_operating_system_snapshot_id = 'REQUIRED' THEN
			IF NEW.operating_system_snapshot_id IS NULL THEN
				RAISE 'operating_system_snapshot_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_operating_system_snapshot_id = 'PROHIBITED' THEN
			IF NEW.operating_system_snapshot_id IS NOT NULL THEN
				RAISE 'operating_system_snapshot_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Site_Code = 'REQUIRED' THEN
			IF NEW.Site_Code IS NULL THEN
				RAISE 'Site_Code is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Site_Code = 'PROHIBITED' THEN
			IF NEW.Site_Code IS NOT NULL THEN
				RAISE 'Site_Code is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Id = 'REQUIRED' THEN
			IF NEW.Account_Id IS NULL THEN
				RAISE 'Account_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Id = 'PROHIBITED' THEN
			IF NEW.Account_Id IS NOT NULL THEN
				RAISE 'Account_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Realm_Id = 'REQUIRED' THEN
			IF NEW.Account_Realm_Id IS NULL THEN
				RAISE 'Account_Realm_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Realm_Id = 'PROHIBITED' THEN
			IF NEW.Account_Realm_Id IS NOT NULL THEN
				RAISE 'Account_Realm_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_account_collection_Id = 'REQUIRED' THEN
			IF NEW.account_collection_Id IS NULL THEN
				RAISE 'account_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_account_collection_Id = 'PROHIBITED' THEN
			IF NEW.account_collection_Id IS NOT NULL THEN
				RAISE 'account_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer2_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer2_network_collection_id IS NULL THEN
				RAISE 'layer2_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer2_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer2_network_collection_id IS NOT NULL THEN
				RAISE 'layer2_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer3_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer3_network_collection_id IS NULL THEN
				RAISE 'layer3_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer3_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer3_network_collection_id IS NOT NULL THEN
				RAISE 'layer3_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_netblock_collection_Id = 'REQUIRED' THEN
			IF NEW.netblock_collection_Id IS NULL THEN
				RAISE 'netblock_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_netblock_collection_Id = 'PROHIBITED' THEN
			IF NEW.netblock_collection_Id IS NOT NULL THEN
				RAISE 'netblock_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_network_range_id = 'REQUIRED' THEN
			IF NEW.network_range_id IS NULL THEN
				RAISE 'network_range_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_network_range_id = 'PROHIBITED' THEN
			IF NEW.network_range_id IS NOT NULL THEN
				RAISE 'network_range_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_property_name_collection_Id = 'REQUIRED' THEN
			IF NEW.property_name_collection_Id IS NULL THEN
				RAISE 'property_name_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_property_name_collection_Id = 'PROHIBITED' THEN
			IF NEW.property_name_collection_Id IS NOT NULL THEN
				RAISE 'property_name_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Property_Rank = 'REQUIRED' THEN
			IF NEW.property_rank IS NULL THEN
				RAISE 'property_rank is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Property_Rank = 'PROHIBITED' THEN
			IF NEW.property_rank IS NOT NULL THEN
				RAISE 'property_rank is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'property_utils' AND type = 'function' AND object IN ('validate_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc validate_property failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
-- Dropping obsoleted sequences....
DROP SEQUENCE IF EXISTS sw_package_sw_package_id_seq;


-- Dropping obsoleted jazzhands_audit sequences....
DROP SEQUENCE IF EXISTS jazzhands_audit.sw_package_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_sw_package_type_seq;


-- Processing tables with no structural changes
-- Some of these may be redundant
-- fk constraints
ALTER TABLE device_management_controller DROP CONSTRAINT IF EXISTS fk_dev_mgmt_cntrl_val_ctrl_typ;
ALTER TABLE device_management_controller
	ADD CONSTRAINT fk_dev_mgmt_cntrl_val_ctrl_typ
	FOREIGN KEY (device_management_control_type) REFERENCES jazzhands.val_device_management_controller_type(device_management_controller_type);

ALTER TABLE dns_domain DROP CONSTRAINT IF EXISTS ak_dns_domain_name;
ALTER TABLE dns_domain
	ADD CONSTRAINT ak_dns_domain_name
	UNIQUE (dns_domain_name);

-- index
-- triggers
DROP TRIGGER IF EXISTS trig_account_change_realm_aca_realm ON account;
CREATE TRIGGER trig_account_change_realm_aca_realm BEFORE UPDATE OF account_realm_id ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_change_realm_aca_realm();
DROP TRIGGER IF EXISTS trig_add_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_add_account_automated_reporting_ac AFTER INSERT OR UPDATE OF login, account_status ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_add_automated_ac_on_account ON account;
CREATE TRIGGER trig_add_automated_ac_on_account AFTER INSERT OR UPDATE OF account_type, account_role, account_status ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_rm_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_rm_account_automated_reporting_ac BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_rm_automated_ac_on_account ON account;
CREATE TRIGGER trig_rm_automated_ac_on_account BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_userlog_account ON account;
CREATE TRIGGER trig_userlog_account BEFORE INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_enforce_is_enabled ON account;
CREATE TRIGGER trigger_account_enforce_is_enabled BEFORE INSERT OR UPDATE OF account_status, is_enabled ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_enforce_is_enabled();
DROP TRIGGER IF EXISTS trigger_account_status_per_row_after_hooks ON account;
CREATE TRIGGER trigger_account_status_per_row_after_hooks AFTER UPDATE OF account_status ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_status_per_row_after_hooks();
DROP TRIGGER IF EXISTS trigger_account_validate_login ON account;
CREATE TRIGGER trigger_account_validate_login BEFORE INSERT OR UPDATE OF login ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_validate_login();
DROP TRIGGER IF EXISTS trigger_audit_account ON account;
CREATE TRIGGER trigger_audit_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account();
DROP TRIGGER IF EXISTS trigger_create_new_unix_account ON account;
CREATE TRIGGER trigger_create_new_unix_account AFTER INSERT ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.create_new_unix_account();
DROP TRIGGER IF EXISTS trigger_delete_peraccount_account_collection ON account;
CREATE TRIGGER trigger_delete_peraccount_account_collection BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.delete_peraccount_account_collection();
DROP TRIGGER IF EXISTS trigger_update_peraccount_account_collection ON account;
CREATE TRIGGER trigger_update_peraccount_account_collection AFTER INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE PROCEDURE jazzhands.update_peraccount_account_collection();
DROP TRIGGER IF EXISTS trig_userlog_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trig_userlog_account_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trigger_audit_account_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_assigned_certificate();
DROP TRIGGER IF EXISTS aaa_account_collection_base_handler ON account_collection;
CREATE TRIGGER aaa_account_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id ON jazzhands.account_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.account_collection_base_handler();
DROP TRIGGER IF EXISTS trig_account_collection_realm ON account_collection;
CREATE TRIGGER trig_account_collection_realm AFTER UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection ON account_collection;
CREATE TRIGGER trig_userlog_account_collection BEFORE INSERT OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection ON account_collection;
CREATE TRIGGER trigger_audit_account_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_collection();
DROP TRIGGER IF EXISTS trigger_validate_account_collection_type_change ON account_collection;
CREATE TRIGGER trigger_validate_account_collection_type_change BEFORE UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_account_collection_type_change();
DROP TRIGGER IF EXISTS trig_account_collection_account_realm ON account_collection_account;
CREATE TRIGGER trig_account_collection_account_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_account ON account_collection_account;
CREATE TRIGGER trig_userlog_account_collection_account BEFORE INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_coll_member_relation_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_coll_member_relation_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_coll_member_relation_enforce();
DROP TRIGGER IF EXISTS trigger_account_collection_member_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_account ON account_collection_account;
CREATE TRIGGER trigger_audit_account_collection_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_collection_account();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_collection_account_token_changes ON account_collection_account;
CREATE TRIGGER trigger_pgnotify_account_collection_account_token_changes AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE PROCEDURE jazzhands.pgnotify_account_collection_account_token_changes();
DROP TRIGGER IF EXISTS aaa_account_collection_root_handler ON account_collection_hier;
CREATE TRIGGER aaa_account_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id, child_account_collection_id ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.account_collection_root_handler();
DROP TRIGGER IF EXISTS trig_account_collection_hier_realm ON account_collection_hier;
CREATE TRIGGER trig_account_collection_hier_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_hier_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trig_userlog_account_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_collection_hier_enforce ON account_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_account_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trigger_audit_account_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_account_collection_hier_loop ON account_collection_hier;
CREATE TRIGGER trigger_check_account_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_account_colllection_hier_loop();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trig_userlog_account_collection_type_relation BEFORE INSERT OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trigger_audit_account_collection_type_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_collection_type_relation();
DROP TRIGGER IF EXISTS trig_userlog_account_password ON account_password;
CREATE TRIGGER trig_userlog_account_password BEFORE INSERT OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_password ON account_password;
CREATE TRIGGER trigger_audit_account_password AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_password();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_password_changes ON account_password;
CREATE TRIGGER trigger_pgnotify_account_password_changes AFTER INSERT OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE PROCEDURE jazzhands.pgnotify_account_password_changes();
DROP TRIGGER IF EXISTS trigger_pull_password_account_realm_from_account ON account_password;
CREATE TRIGGER trigger_pull_password_account_realm_from_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.account_password FOR EACH ROW EXECUTE PROCEDURE jazzhands.pull_password_account_realm_from_account();
DROP TRIGGER IF EXISTS trigger_unrequire_password_change ON account_password;
CREATE TRIGGER trigger_unrequire_password_change BEFORE INSERT OR UPDATE OF password ON jazzhands.account_password FOR EACH ROW EXECUTE PROCEDURE jazzhands.unrequire_password_change();
DROP TRIGGER IF EXISTS trig_userlog_account_realm ON account_realm;
CREATE TRIGGER trig_userlog_account_realm BEFORE INSERT OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm ON account_realm;
CREATE TRIGGER trigger_audit_account_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trig_userlog_account_realm_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trigger_audit_account_realm_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_realm_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_company ON account_realm_company;
CREATE TRIGGER trig_userlog_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_company ON account_realm_company;
CREATE TRIGGER trigger_audit_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trig_userlog_account_realm_password_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trigger_audit_account_realm_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_realm_password_type();
DROP TRIGGER IF EXISTS trig_userlog_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trig_userlog_account_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trigger_audit_account_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_account_token ON account_token;
CREATE TRIGGER trig_userlog_account_token BEFORE INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_token ON account_token;
CREATE TRIGGER trigger_audit_account_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_token_change ON account_token;
CREATE TRIGGER trigger_pgnotify_account_token_change AFTER INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE PROCEDURE jazzhands.pgnotify_account_token_change();
DROP TRIGGER IF EXISTS trig_userlog_account_unix_info ON account_unix_info;
CREATE TRIGGER trig_userlog_account_unix_info BEFORE INSERT OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_unix_info ON account_unix_info;
CREATE TRIGGER trigger_audit_account_unix_info AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_account_unix_info();
DROP TRIGGER IF EXISTS trig_userlog_appaal ON appaal;
CREATE TRIGGER trig_userlog_appaal BEFORE INSERT OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal ON appaal;
CREATE TRIGGER trigger_audit_appaal AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_appaal();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance ON appaal_instance;
CREATE TRIGGER trig_userlog_appaal_instance BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance ON appaal_instance;
CREATE TRIGGER trigger_audit_appaal_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_appaal_instance();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trig_userlog_appaal_instance_device_collection BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trigger_audit_appaal_instance_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_appaal_instance_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trig_userlog_appaal_instance_property BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trigger_audit_appaal_instance_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_appaal_instance_property();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance ON approval_instance;
CREATE TRIGGER trig_userlog_approval_instance BEFORE INSERT OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance ON approval_instance;
CREATE TRIGGER trigger_audit_approval_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_instance();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trig_userlog_approval_instance_item BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approval_notify ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approval_notify AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.approval_instance_item_approval_notify();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approved_immutable ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approved_immutable BEFORE UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE PROCEDURE jazzhands.approval_instance_item_approved_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_auto_complete ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_step_auto_complete AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE PROCEDURE jazzhands.approval_instance_step_auto_complete();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trigger_audit_approval_instance_item AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_instance_item();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trig_userlog_approval_instance_link BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trigger_audit_approval_instance_link AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_instance_link();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trig_userlog_approval_instance_step BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_completed_immutable ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_completed_immutable BEFORE UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE PROCEDURE jazzhands.approval_instance_step_completed_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_resolve_instance ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_resolve_instance AFTER UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE PROCEDURE jazzhands.approval_instance_step_resolve_instance();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trigger_audit_approval_instance_step AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_instance_step();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trig_userlog_approval_instance_step_notify BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trigger_audit_approval_instance_step_notify AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_instance_step_notify();
DROP TRIGGER IF EXISTS trigger_legacy_approval_instance_step_notify_account ON approval_instance_step_notify;
CREATE TRIGGER trigger_legacy_approval_instance_step_notify_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE PROCEDURE jazzhands.legacy_approval_instance_step_notify_account();
DROP TRIGGER IF EXISTS trig_userlog_approval_process ON approval_process;
CREATE TRIGGER trig_userlog_approval_process BEFORE INSERT OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_process ON approval_process;
CREATE TRIGGER trigger_audit_approval_process AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_approval_process();
DROP TRIGGER IF EXISTS trig_userlog_asset ON asset;
CREATE TRIGGER trig_userlog_asset BEFORE INSERT OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_asset ON asset;
CREATE TRIGGER trigger_audit_asset AFTER INSERT OR DELETE OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_asset();
DROP TRIGGER IF EXISTS trigger_validate_asset_component_assignment ON asset;
CREATE CONSTRAINT TRIGGER trigger_validate_asset_component_assignment AFTER INSERT OR UPDATE OF component_id ON jazzhands.asset DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_asset_component_assignment();
DROP TRIGGER IF EXISTS trig_userlog_badge ON badge;
CREATE TRIGGER trig_userlog_badge BEFORE INSERT OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge ON badge;
CREATE TRIGGER trigger_audit_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_badge();
DROP TRIGGER IF EXISTS trig_userlog_badge_type ON badge_type;
CREATE TRIGGER trig_userlog_badge_type BEFORE INSERT OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge_type ON badge_type;
CREATE TRIGGER trigger_audit_badge_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_badge_type();
DROP TRIGGER IF EXISTS trig_userlog_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trig_userlog_certificate_signing_request BEFORE INSERT OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trigger_audit_certificate_signing_request AFTER INSERT OR DELETE OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_certificate_signing_request();
DROP TRIGGER IF EXISTS trig_userlog_chassis_location ON chassis_location;
CREATE TRIGGER trig_userlog_chassis_location BEFORE INSERT OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_chassis_location ON chassis_location;
CREATE TRIGGER trigger_audit_chassis_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_chassis_location();
DROP TRIGGER IF EXISTS trig_userlog_circuit ON circuit;
CREATE TRIGGER trig_userlog_circuit BEFORE INSERT OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_circuit ON circuit;
CREATE TRIGGER trigger_audit_circuit AFTER INSERT OR DELETE OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_circuit();
DROP TRIGGER IF EXISTS trig_userlog_company ON company;
CREATE TRIGGER trig_userlog_company BEFORE INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company ON company;
CREATE TRIGGER trigger_audit_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_company();
DROP TRIGGER IF EXISTS trigger_company_insert_function_nudge ON company;
CREATE TRIGGER trigger_company_insert_function_nudge BEFORE INSERT ON jazzhands.company FOR EACH ROW EXECUTE PROCEDURE jazzhands.company_insert_function_nudge();
DROP TRIGGER IF EXISTS trigger_delete_per_company_company_collection ON company;
CREATE TRIGGER trigger_delete_per_company_company_collection BEFORE DELETE ON jazzhands.company FOR EACH ROW EXECUTE PROCEDURE jazzhands.delete_per_company_company_collection();
DROP TRIGGER IF EXISTS trigger_update_per_company_company_collection ON company;
CREATE TRIGGER trigger_update_per_company_company_collection AFTER INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE PROCEDURE jazzhands.update_per_company_company_collection();
DROP TRIGGER IF EXISTS trig_userlog_company_collection ON company_collection;
CREATE TRIGGER trig_userlog_company_collection BEFORE INSERT OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection ON company_collection;
CREATE TRIGGER trigger_audit_company_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_company_collection();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_del ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_del BEFORE DELETE ON jazzhands.company_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_insup ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_company_collection_type_change ON company_collection;
CREATE TRIGGER trigger_validate_company_collection_type_change BEFORE UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_company_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_company ON company_collection_company;
CREATE TRIGGER trig_userlog_company_collection_company BEFORE INSERT OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_company ON company_collection_company;
CREATE TRIGGER trigger_audit_company_collection_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_company_collection_company();
DROP TRIGGER IF EXISTS trigger_company_collection_member_enforce ON company_collection_company;
CREATE CONSTRAINT TRIGGER trigger_company_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_company DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.company_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trig_userlog_company_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trigger_audit_company_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_company_collection_hier();
DROP TRIGGER IF EXISTS trigger_company_collection_hier_enforce ON company_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_company_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.company_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_type ON company_type;
CREATE TRIGGER trig_userlog_company_type BEFORE INSERT OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_type ON company_type;
CREATE TRIGGER trigger_audit_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_company_type();
DROP TRIGGER IF EXISTS aaa_tg_cache_component_parent_handler ON component;
CREATE TRIGGER aaa_tg_cache_component_parent_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.cache_component_parent_handler();
DROP TRIGGER IF EXISTS aab_tg_cache_device_component_component_handler ON component;
CREATE TRIGGER aab_tg_cache_device_component_component_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.cache_device_component_component_handler();
DROP TRIGGER IF EXISTS trig_userlog_component ON component;
CREATE TRIGGER trig_userlog_component BEFORE INSERT OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component ON component;
CREATE TRIGGER trigger_audit_component AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_component();
DROP TRIGGER IF EXISTS trigger_create_component_template_slots ON component;
CREATE TRIGGER trigger_create_component_template_slots AFTER INSERT OR UPDATE OF component_type_id ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE jazzhands.create_component_slots_by_trigger();
DROP TRIGGER IF EXISTS trigger_validate_component_parent_slot_id ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_parent_slot_id AFTER INSERT OR UPDATE OF parent_slot_id, component_type_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_component_parent_slot_id();
DROP TRIGGER IF EXISTS trigger_validate_component_rack_location ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_rack_location AFTER INSERT OR UPDATE OF rack_location_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_component_rack_location();
DROP TRIGGER IF EXISTS trigger_zzz_generate_slot_names ON component;
CREATE TRIGGER trigger_zzz_generate_slot_names AFTER INSERT OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE PROCEDURE jazzhands.set_slot_names_by_trigger();
DROP TRIGGER IF EXISTS trig_userlog_component_property ON component_property;
CREATE TRIGGER trig_userlog_component_property BEFORE INSERT OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_property ON component_property;
CREATE TRIGGER trigger_audit_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_component_property();
DROP TRIGGER IF EXISTS trigger_validate_component_property ON component_property;
CREATE CONSTRAINT TRIGGER trigger_validate_component_property AFTER INSERT OR UPDATE ON jazzhands.component_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_component_property();
DROP TRIGGER IF EXISTS trig_userlog_component_type ON component_type;
CREATE TRIGGER trig_userlog_component_type BEFORE INSERT OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type ON component_type;
CREATE TRIGGER trigger_audit_component_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_component_type();
DROP TRIGGER IF EXISTS trig_userlog_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trig_userlog_component_type_component_function BEFORE INSERT OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trigger_audit_component_type_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_component_type_component_function();
DROP TRIGGER IF EXISTS trig_userlog_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trig_userlog_component_type_slot_template BEFORE INSERT OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trigger_audit_component_type_slot_template AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_component_type_slot_template();
DROP TRIGGER IF EXISTS trig_userlog_contract ON contract;
CREATE TRIGGER trig_userlog_contract BEFORE INSERT OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract ON contract;
CREATE TRIGGER trigger_audit_contract AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_contract();
DROP TRIGGER IF EXISTS trig_userlog_contract_type ON contract_type;
CREATE TRIGGER trig_userlog_contract_type BEFORE INSERT OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract_type ON contract_type;
CREATE TRIGGER trigger_audit_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_department ON department;
CREATE TRIGGER trig_userlog_department BEFORE INSERT OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_department ON department;
CREATE TRIGGER trigger_audit_department AFTER INSERT OR DELETE OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_department();
DROP TRIGGER IF EXISTS tg_cache_device_component_device_handler ON device;
CREATE TRIGGER tg_cache_device_component_device_handler AFTER INSERT OR DELETE OR UPDATE OF component_id ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.cache_device_component_device_handler();
DROP TRIGGER IF EXISTS trig_userlog_device ON device;
CREATE TRIGGER trig_userlog_device BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device ON device;
CREATE TRIGGER trigger_audit_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device();
DROP TRIGGER IF EXISTS trigger_create_device_component ON device;
CREATE TRIGGER trigger_create_device_component BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.create_device_component_by_trigger();
DROP TRIGGER IF EXISTS trigger_del_jazzhands_legacy_support ON device;
CREATE TRIGGER trigger_del_jazzhands_legacy_support BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.del_jazzhands_legacy_support();
DROP TRIGGER IF EXISTS trigger_delete_per_device_device_collection ON device;
CREATE TRIGGER trigger_delete_per_device_device_collection BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.delete_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_device_one_location_validate ON device;
CREATE TRIGGER trigger_device_one_location_validate BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_one_location_validate();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_del ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_del BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_device_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_ins ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_ins AFTER INSERT ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_device_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_upd ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_upd AFTER UPDATE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_device_upd();
DROP TRIGGER IF EXISTS trigger_update_per_device_device_collection ON device;
CREATE TRIGGER trigger_update_per_device_device_collection AFTER INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE PROCEDURE jazzhands.update_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_validate_device_component_assignment ON device;
CREATE CONSTRAINT TRIGGER trigger_validate_device_component_assignment AFTER INSERT OR UPDATE OF device_type_id, component_id ON jazzhands.device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_device_component_assignment();
DROP TRIGGER IF EXISTS aaa_device_collection_base_handler ON device_collection;
CREATE TRIGGER aaa_device_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.device_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection ON device_collection;
CREATE TRIGGER trig_userlog_device_collection BEFORE INSERT OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection ON device_collection;
CREATE TRIGGER trigger_audit_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_collection();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_del ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_del BEFORE DELETE ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_insup ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_device_collection_type_change ON device_collection;
CREATE TRIGGER trigger_validate_device_collection_type_change BEFORE UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_device_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trig_userlog_device_collection_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trigger_audit_device_collection_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_collection_assigned_certificate();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_device ON device_collection_device;
CREATE TRIGGER trig_userlog_device_collection_device BEFORE INSERT OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_device ON device_collection_device;
CREATE TRIGGER trigger_audit_device_collection_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_collection_device();
DROP TRIGGER IF EXISTS trigger_device_collection_member_enforce ON device_collection_device;
CREATE CONSTRAINT TRIGGER trigger_device_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_del ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_del BEFORE DELETE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_dcd_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_ins ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_ins AFTER INSERT ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_dcd_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_upd ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_upd AFTER UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.jazzhands_legacy_device_columns_dcd_upd();
DROP TRIGGER IF EXISTS trigger_member_device_collection_after_hooks ON device_collection_device;
CREATE TRIGGER trigger_member_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_member_device_collection_after_row_hooks ON device_collection_device;
CREATE TRIGGER trigger_member_device_collection_after_row_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_collection_device_after_row_hooks();
DROP TRIGGER IF EXISTS aaa_device_collection_root_handler ON device_collection_hier;
CREATE TRIGGER aaa_device_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id, child_device_collection_id ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.device_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trig_userlog_device_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trigger_audit_device_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_device_collection_hier_loop ON device_collection_hier;
CREATE TRIGGER trigger_check_device_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_device_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_device_collection_hier_enforce ON device_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_device_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_hier_device_collection_after_hooks ON device_collection_hier;
CREATE TRIGGER trigger_hier_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_hier_device_collection_after_row_hooks ON device_collection_hier;
CREATE TRIGGER trigger_hier_device_collection_after_row_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_collection_hier_after_row_hooks();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trig_userlog_device_collection_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trigger_audit_device_collection_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_collection_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trig_userlog_device_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trigger_audit_device_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trig_userlog_device_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trigger_audit_device_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_device_management_controller ON device_management_controller;
CREATE TRIGGER trig_userlog_device_management_controller BEFORE INSERT OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_management_controller ON device_management_controller;
CREATE TRIGGER trigger_audit_device_management_controller AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_management_controller();
DROP TRIGGER IF EXISTS trig_userlog_device_note ON device_note;
CREATE TRIGGER trig_userlog_device_note BEFORE INSERT OR UPDATE ON jazzhands.device_note FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_note ON device_note;
CREATE TRIGGER trigger_audit_device_note AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_note FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_note();
DROP TRIGGER IF EXISTS trig_userlog_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trig_userlog_device_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trigger_audit_device_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_ticket ON device_ticket;
CREATE TRIGGER trig_userlog_device_ticket BEFORE INSERT OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ticket ON device_ticket;
CREATE TRIGGER trigger_audit_device_ticket AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_ticket();
DROP TRIGGER IF EXISTS trig_userlog_device_type ON device_type;
CREATE TRIGGER trig_userlog_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type ON device_type;
CREATE TRIGGER trigger_audit_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_type();
DROP TRIGGER IF EXISTS trigger_device_type_chassis_check ON device_type;
CREATE TRIGGER trigger_device_type_chassis_check BEFORE UPDATE OF is_chassis ON jazzhands.device_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_type_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_model_to_name ON device_type;
CREATE TRIGGER trigger_device_type_model_to_name BEFORE INSERT OR UPDATE OF device_type_name, model ON jazzhands.device_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_type_model_to_name();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module ON device_type_module;
CREATE TRIGGER trig_userlog_device_type_module BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module ON device_type_module;
CREATE TRIGGER trigger_audit_device_type_module AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_type_module();
DROP TRIGGER IF EXISTS trigger_device_type_module_chassis_check ON device_type_module;
CREATE TRIGGER trigger_device_type_module_chassis_check BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device_type_module FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_type_module_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_module_sanity_set ON device_type_module;
CREATE TRIGGER trigger_device_type_module_sanity_set BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE PROCEDURE jazzhands.device_type_module_sanity_set();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trig_userlog_device_type_module_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trigger_audit_device_type_module_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_device_type_module_device_type();
DROP TRIGGER IF EXISTS trig_userlog_dns_change_record ON dns_change_record;
CREATE TRIGGER trig_userlog_dns_change_record BEFORE INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_change_record ON dns_change_record;
CREATE TRIGGER trigger_audit_dns_change_record AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_change_record();
DROP TRIGGER IF EXISTS trigger_dns_change_record_pgnotify ON dns_change_record;
CREATE TRIGGER trigger_dns_change_record_pgnotify AFTER INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.dns_change_record_pgnotify();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain ON dns_domain;
CREATE TRIGGER trig_userlog_dns_domain BEFORE INSERT OR UPDATE ON jazzhands.dns_domain FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain ON dns_domain;
CREATE TRIGGER trigger_audit_dns_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_trigger_change ON dns_domain;
CREATE TRIGGER trigger_dns_domain_trigger_change AFTER INSERT OR UPDATE OF dns_domain_name ON jazzhands.dns_domain FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_trigger_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trig_userlog_dns_domain_collection BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trigger_audit_dns_domain_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_domain_collection();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_del ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_del BEFORE DELETE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_insup ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_dns_domain_collection_type_change ON dns_domain_collection;
CREATE TRIGGER trigger_validate_dns_domain_collection_type_change BEFORE UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_dns_domain_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trig_userlog_dns_domain_collection_dns_domain BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trigger_audit_dns_domain_collection_dns_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_domain_collection_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_member_enforce ON dns_domain_collection_dns_domain;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trig_userlog_dns_domain_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trigger_audit_dns_domain_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_domain_collection_hier();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_hier_enforce ON dns_domain_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trig_userlog_dns_domain_ip_universe BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trigger_audit_dns_domain_ip_universe AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_domain_ip_universe();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_can_generate ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_can_generate AFTER INSERT OR UPDATE OF should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_ip_universe_can_generate();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_trigger_change ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_trigger_change AFTER INSERT OR UPDATE OF soa_class, soa_ttl, soa_serial, soa_refresh, soa_retry, soa_expire, soa_minimum, soa_mname, soa_rname, should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_ip_universe_trigger_change();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_trigger_del ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_trigger_del BEFORE DELETE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_ip_universe_trigger_del();
DROP TRIGGER IF EXISTS trig_userlog_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trig_userlog_dns_record_relation BEFORE INSERT OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trigger_audit_dns_record_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_dns_record_relation();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trig_userlog_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trigger_audit_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trig_userlog_encapsulation_range BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trigger_audit_encapsulation_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_encapsulation_range();
DROP TRIGGER IF EXISTS trig_userlog_encryption_key ON encryption_key;
CREATE TRIGGER trig_userlog_encryption_key BEFORE INSERT OR UPDATE ON jazzhands.encryption_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encryption_key ON encryption_key;
CREATE TRIGGER trigger_audit_encryption_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encryption_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_encryption_key();
DROP TRIGGER IF EXISTS trig_userlog_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trig_userlog_inter_component_connection BEFORE INSERT OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trigger_audit_inter_component_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_inter_component_connection();
DROP TRIGGER IF EXISTS trigger_validate_inter_component_connection ON inter_component_connection;
CREATE CONSTRAINT TRIGGER trigger_validate_inter_component_connection AFTER INSERT OR UPDATE ON jazzhands.inter_component_connection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_inter_component_connection();
DROP TRIGGER IF EXISTS trig_userlog_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trig_userlog_ip_universe_visibility BEFORE INSERT OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trigger_audit_ip_universe_visibility AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_ip_universe_visibility();
DROP TRIGGER IF EXISTS trig_userlog_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trig_userlog_kerberos_realm BEFORE INSERT OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trigger_audit_kerberos_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_kerberos_realm();
DROP TRIGGER IF EXISTS trig_userlog_klogin ON klogin;
CREATE TRIGGER trig_userlog_klogin BEFORE INSERT OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin ON klogin;
CREATE TRIGGER trigger_audit_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_klogin();
DROP TRIGGER IF EXISTS trig_userlog_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trig_userlog_klogin_mclass BEFORE INSERT OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trigger_audit_klogin_mclass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_klogin_mclass();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection ON layer2_connection;
CREATE TRIGGER trig_userlog_layer2_connection BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection ON layer2_connection;
CREATE TRIGGER trigger_audit_layer2_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_connection();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_connection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_connection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_connection_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network ON layer2_network;
CREATE TRIGGER trig_userlog_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network ON layer2_network;
CREATE TRIGGER trigger_audit_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_network();
DROP TRIGGER IF EXISTS layer2_net_collection_member_enforce_on_type_change ON layer2_network_collection;
CREATE CONSTRAINT TRIGGER layer2_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer2_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trig_userlog_layer2_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trigger_audit_layer2_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_del ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_insup ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer2_network_collection_type_change ON layer2_network_collection;
CREATE TRIGGER trigger_validate_layer2_network_collection_type_change BEFORE UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_layer2_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trig_userlog_layer2_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trigger_audit_layer2_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer2_network_collection_after_hooks ON layer2_network_collection_hier;
CREATE TRIGGER trigger_hier_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_hier_enforce ON layer2_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer2_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_network_collection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_network_collection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer2_network_collection_layer2_network();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_member_enforce ON layer2_network_collection_layer2_network;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer2_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer2_network_collection_after_hooks ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_member_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface ON layer3_interface;
CREATE TRIGGER trig_userlog_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface ON layer3_interface;
CREATE TRIGGER trigger_audit_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_interface();
DROP TRIGGER IF EXISTS trigger_net_int_device_id_upd ON layer3_interface;
CREATE TRIGGER trigger_net_int_device_id_upd AFTER UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE PROCEDURE jazzhands.net_int_device_id_upd();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_before ON layer3_interface;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_before BEFORE UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE PROCEDURE jazzhands.net_int_nb_device_id_ins_before();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_purpose ON layer3_interface_purpose;
CREATE TRIGGER trig_userlog_layer3_interface_purpose BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_purpose ON layer3_interface_purpose;
CREATE TRIGGER trigger_audit_layer3_interface_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_interface_purpose();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network ON layer3_network;
CREATE TRIGGER trig_userlog_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network ON layer3_network;
CREATE TRIGGER trigger_audit_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_validate_netblock ON layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_validate_netblock AFTER INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_network NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer3_network_validate_netblock();
DROP TRIGGER IF EXISTS layer3_net_collection_member_enforce_on_type_change ON layer3_network_collection;
CREATE CONSTRAINT TRIGGER layer3_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer3_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trig_userlog_layer3_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trigger_audit_layer3_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_del ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_insup ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer3_network_collection_type_change ON layer3_network_collection;
CREATE TRIGGER trigger_validate_layer3_network_collection_type_change BEFORE UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_layer3_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trig_userlog_layer3_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trigger_audit_layer3_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer3_network_collection_after_hooks ON layer3_network_collection_hier;
CREATE TRIGGER trigger_hier_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_hier_enforce ON layer3_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer3_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trig_userlog_layer3_network_collection_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_audit_layer3_network_collection_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_layer3_network_collection_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_member_enforce ON layer3_network_collection_layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.layer3_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer3_network_collection_after_hooks ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_member_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_logical_port ON logical_port;
CREATE TRIGGER trig_userlog_logical_port BEFORE INSERT OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port ON logical_port;
CREATE TRIGGER trigger_audit_logical_port AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_logical_port();
DROP TRIGGER IF EXISTS trig_userlog_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trig_userlog_logical_port_slot BEFORE INSERT OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trigger_audit_logical_port_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_logical_port_slot();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume ON logical_volume;
CREATE TRIGGER trig_userlog_logical_volume BEFORE INSERT OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume ON logical_volume;
CREATE TRIGGER trigger_audit_logical_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_logical_volume();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trig_userlog_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trigger_audit_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trig_userlog_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trigger_audit_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_mlag_peering ON mlag_peering;
CREATE TRIGGER trig_userlog_mlag_peering BEFORE INSERT OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_mlag_peering ON mlag_peering;
CREATE TRIGGER trigger_audit_mlag_peering AFTER INSERT OR DELETE OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_mlag_peering();
DROP TRIGGER IF EXISTS aaa_ta_manipulate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER aaa_ta_manipulate_netblock_parentage AFTER INSERT OR DELETE ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.manipulate_netblock_parentage_after();
DROP TRIGGER IF EXISTS tb_a_validate_netblock ON netblock;
CREATE TRIGGER tb_a_validate_netblock BEFORE INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_netblock();
DROP TRIGGER IF EXISTS tb_manipulate_netblock_parentage ON netblock;
CREATE TRIGGER tb_manipulate_netblock_parentage BEFORE INSERT OR UPDATE OF ip_address, netblock_type, ip_universe_id, netblock_id, can_subnet, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.manipulate_netblock_parentage_before();
DROP TRIGGER IF EXISTS trig_userlog_netblock ON netblock;
CREATE TRIGGER trig_userlog_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock ON netblock;
CREATE TRIGGER trigger_audit_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_netblock();
DROP TRIGGER IF EXISTS trigger_cache_netblock_hier_truncate ON netblock;
CREATE TRIGGER trigger_cache_netblock_hier_truncate AFTER TRUNCATE ON jazzhands.netblock FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands_cache.cache_netblock_hier_truncate_handler();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_netblock AFTER UPDATE OF netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_ip_universe_netblock();
DROP TRIGGER IF EXISTS trigger_nb_dns_a_rec_validation ON netblock;
CREATE TRIGGER trigger_nb_dns_a_rec_validation BEFORE UPDATE OF ip_address, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.nb_dns_a_rec_validation();
DROP TRIGGER IF EXISTS trigger_netblock_single_address_ni ON netblock;
CREATE TRIGGER trigger_netblock_single_address_ni BEFORE UPDATE OF is_single_address, netblock_type ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.netblock_single_address_ni();
DROP TRIGGER IF EXISTS trigger_netblock_validate_layer3_network_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_validate_layer3_network_netblock AFTER UPDATE OF can_subnet, is_single_address ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.netblock_validate_layer3_network_netblock();
DROP TRIGGER IF EXISTS trigger_validate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_parentage AFTER INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_netblock_parentage();
DROP TRIGGER IF EXISTS trigger_validate_netblock_to_range_changes ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_to_range_changes AFTER UPDATE OF ip_address, is_single_address, can_subnet, netblock_type ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_netblock_to_range_changes();
DROP TRIGGER IF EXISTS zaa_ta_cache_netblock_hier_handler ON netblock;
CREATE TRIGGER zaa_ta_cache_netblock_hier_handler AFTER INSERT OR DELETE OR UPDATE OF ip_address, parent_netblock_id ON jazzhands.netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.cache_netblock_hier_handler();
DROP TRIGGER IF EXISTS aaa_netblock_collection_base_handler ON netblock_collection;
CREATE TRIGGER aaa_netblock_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.netblock_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection ON netblock_collection;
CREATE TRIGGER trig_userlog_netblock_collection BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection ON netblock_collection;
CREATE TRIGGER trigger_audit_netblock_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_netblock_collection();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_del ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_del BEFORE DELETE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_insup ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_netblock_collection_type_change ON netblock_collection;
CREATE TRIGGER trigger_validate_netblock_collection_type_change BEFORE UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_netblock_collection_type_change();
DROP TRIGGER IF EXISTS aaa_netblock_collection_root_handler ON netblock_collection_hier;
CREATE TRIGGER aaa_netblock_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id, child_netblock_collection_id ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands_cache.netblock_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trig_userlog_netblock_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trigger_audit_netblock_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_netblock_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_netblock_collection_hier_loop ON netblock_collection_hier;
CREATE TRIGGER trigger_check_netblock_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_netblock_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_netblock_collection_hier_enforce ON netblock_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.netblock_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trig_userlog_netblock_collection_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trigger_audit_netblock_collection_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_netblock_collection_netblock();
DROP TRIGGER IF EXISTS trigger_netblock_collection_member_enforce ON netblock_collection_netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.netblock_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_network_range ON network_range;
CREATE TRIGGER trig_userlog_network_range BEFORE INSERT OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_network_range ON network_range;
CREATE TRIGGER trigger_audit_network_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_network_range();
DROP TRIGGER IF EXISTS trigger_validate_network_range_dns ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_dns AFTER INSERT OR UPDATE OF dns_domain_id ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_network_range_dns();
DROP TRIGGER IF EXISTS trigger_validate_network_range_ips ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_ips AFTER INSERT OR UPDATE OF start_netblock_id, stop_netblock_id, parent_netblock_id, network_range_type ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_network_range_ips();
DROP TRIGGER IF EXISTS trig_userlog_operating_system ON operating_system;
CREATE TRIGGER trig_userlog_operating_system BEFORE INSERT OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system ON operating_system;
CREATE TRIGGER trigger_audit_operating_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_operating_system();
DROP TRIGGER IF EXISTS trig_userlog_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trig_userlog_operating_system_snapshot BEFORE INSERT OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trigger_audit_operating_system_snapshot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_operating_system_snapshot();
DROP TRIGGER IF EXISTS trig_userlog_person ON person;
CREATE TRIGGER trig_userlog_person BEFORE INSERT OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person ON person;
CREATE TRIGGER trigger_audit_person AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person();
DROP TRIGGER IF EXISTS trig_userlog_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trig_userlog_person_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trigger_audit_person_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trig_userlog_person_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trigger_audit_person_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_person_company ON person_company;
CREATE TRIGGER trig_userlog_person_company BEFORE INSERT OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company ON person_company;
CREATE TRIGGER trigger_audit_person_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_company();
DROP TRIGGER IF EXISTS trigger_propagate_person_status_to_account ON person_company;
CREATE TRIGGER trigger_propagate_person_status_to_account AFTER UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.propagate_person_status_to_account();
DROP TRIGGER IF EXISTS trigger_z_automated_ac_on_person_company ON person_company;
CREATE TRIGGER trigger_z_automated_ac_on_person_company AFTER UPDATE OF is_management, is_exempt, is_full_time, person_id, company_id, manager_person_id ON jazzhands.person_company FOR EACH ROW EXECUTE PROCEDURE jazzhands.automated_ac_on_person_company();
DROP TRIGGER IF EXISTS trig_userlog_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trig_userlog_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_audit_person_company_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_company_attribute();
DROP TRIGGER IF EXISTS trigger_validate_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_validate_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_person_company_attribute();
DROP TRIGGER IF EXISTS trig_userlog_person_company_badge ON person_company_badge;
CREATE TRIGGER trig_userlog_person_company_badge BEFORE INSERT OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_badge ON person_company_badge;
CREATE TRIGGER trigger_audit_person_company_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_company_badge();
DROP TRIGGER IF EXISTS trig_userlog_person_contact ON person_contact;
CREATE TRIGGER trig_userlog_person_contact BEFORE INSERT OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_contact ON person_contact;
CREATE TRIGGER trigger_audit_person_contact AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_contact();
DROP TRIGGER IF EXISTS trig_userlog_person_image ON person_image;
CREATE TRIGGER trig_userlog_person_image BEFORE INSERT OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image ON person_image;
CREATE TRIGGER trigger_audit_person_image AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_image();
DROP TRIGGER IF EXISTS trigger_fix_person_image_oid_ownership ON person_image;
CREATE TRIGGER trigger_fix_person_image_oid_ownership BEFORE INSERT ON jazzhands.person_image FOR EACH ROW EXECUTE PROCEDURE jazzhands.fix_person_image_oid_ownership();
DROP TRIGGER IF EXISTS trig_userlog_person_image_usage ON person_image_usage;
CREATE TRIGGER trig_userlog_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image_usage ON person_image_usage;
CREATE TRIGGER trigger_audit_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_image_usage();
DROP TRIGGER IF EXISTS trigger_check_person_image_usage_mv ON person_image_usage;
CREATE TRIGGER trigger_check_person_image_usage_mv AFTER INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_person_image_usage_mv();
DROP TRIGGER IF EXISTS trig_automated_realm_site_ac_pl ON person_location;
CREATE TRIGGER trig_automated_realm_site_ac_pl AFTER INSERT OR DELETE OR UPDATE OF site_code, person_id ON jazzhands.person_location FOR EACH ROW EXECUTE PROCEDURE jazzhands.automated_realm_site_ac_pl();
DROP TRIGGER IF EXISTS trig_userlog_person_location ON person_location;
CREATE TRIGGER trig_userlog_person_location BEFORE INSERT OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_location ON person_location;
CREATE TRIGGER trigger_audit_person_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_location();
DROP TRIGGER IF EXISTS trig_userlog_person_note ON person_note;
CREATE TRIGGER trig_userlog_person_note BEFORE INSERT OR UPDATE ON jazzhands.person_note FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_note ON person_note;
CREATE TRIGGER trigger_audit_person_note AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_note FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_note();
DROP TRIGGER IF EXISTS trig_userlog_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trig_userlog_person_parking_pass BEFORE INSERT OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trigger_audit_person_parking_pass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_parking_pass();
DROP TRIGGER IF EXISTS trig_userlog_person_vehicle ON person_vehicle;
CREATE TRIGGER trig_userlog_person_vehicle BEFORE INSERT OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_vehicle ON person_vehicle;
CREATE TRIGGER trigger_audit_person_vehicle AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_person_vehicle();
DROP TRIGGER IF EXISTS trig_userlog_physical_address ON physical_address;
CREATE TRIGGER trig_userlog_physical_address BEFORE INSERT OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_address ON physical_address;
CREATE TRIGGER trigger_audit_physical_address AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_physical_address();
DROP TRIGGER IF EXISTS trig_userlog_physical_connection ON physical_connection;
CREATE TRIGGER trig_userlog_physical_connection BEFORE INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_connection ON physical_connection;
CREATE TRIGGER trigger_audit_physical_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_physical_connection();
DROP TRIGGER IF EXISTS trigger_verify_physical_connection ON physical_connection;
CREATE TRIGGER trigger_verify_physical_connection AFTER INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.verify_physical_connection();
DROP TRIGGER IF EXISTS trig_userlog_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trig_userlog_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_audit_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_physicalish_volume();
DROP TRIGGER IF EXISTS trigger_verify_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_verify_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE PROCEDURE jazzhands.verify_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_private_key ON private_key;
CREATE TRIGGER trig_userlog_private_key BEFORE INSERT OR UPDATE ON jazzhands.private_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_private_key ON private_key;
CREATE TRIGGER trigger_audit_private_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.private_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_private_key();
DROP TRIGGER IF EXISTS trigger_pvtkey_ski_signed_validate ON private_key;
CREATE TRIGGER trigger_pvtkey_ski_signed_validate AFTER UPDATE OF subject_key_identifier ON jazzhands.private_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.pvtkey_ski_signed_validate();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection ON property_name_collection;
CREATE TRIGGER trig_userlog_property_name_collection BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection ON property_name_collection;
CREATE TRIGGER trigger_audit_property_name_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_property_name_collection();
DROP TRIGGER IF EXISTS trigger_validate_property_name_collection_type_change ON property_name_collection;
CREATE TRIGGER trigger_validate_property_name_collection_type_change BEFORE UPDATE OF property_name_collection_type ON jazzhands.property_name_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_property_name_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trig_userlog_property_name_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trigger_audit_property_name_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_property_name_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_property_name_collection_after_hooks ON property_name_collection_hier;
CREATE TRIGGER trigger_hier_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_hier_enforce ON property_name_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.property_name_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trig_userlog_property_name_collection_property_name BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trigger_audit_property_name_collection_property_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_property_name_collection_property_name();
DROP TRIGGER IF EXISTS trigger_member_property_name_collection_after_hooks ON property_name_collection_property_name;
CREATE TRIGGER trigger_member_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH STATEMENT EXECUTE PROCEDURE jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_member_enforce ON property_name_collection_property_name;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_property_name DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.property_name_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trig_userlog_pseudo_klogin BEFORE INSERT OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trigger_audit_pseudo_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_pseudo_klogin();
DROP TRIGGER IF EXISTS trig_userlog_rack ON rack;
CREATE TRIGGER trig_userlog_rack BEFORE INSERT OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack ON rack;
CREATE TRIGGER trigger_audit_rack AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_rack();
DROP TRIGGER IF EXISTS trig_userlog_rack_location ON rack_location;
CREATE TRIGGER trig_userlog_rack_location BEFORE INSERT OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack_location ON rack_location;
CREATE TRIGGER trigger_audit_rack_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_rack_location();
DROP TRIGGER IF EXISTS trig_userlog_service_environment ON service_environment;
CREATE TRIGGER trig_userlog_service_environment BEFORE INSERT OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment ON service_environment;
CREATE TRIGGER trigger_audit_service_environment AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_service_environment();
DROP TRIGGER IF EXISTS trigger_delete_per_service_environment_service_environment_coll ON service_environment;
CREATE TRIGGER trigger_delete_per_service_environment_service_environment_coll BEFORE DELETE ON jazzhands.service_environment FOR EACH ROW EXECUTE PROCEDURE jazzhands.delete_per_service_environment_service_environment_collection();
DROP TRIGGER IF EXISTS trigger_update_per_service_environment_service_environment_coll ON service_environment;
CREATE TRIGGER trigger_update_per_service_environment_service_environment_coll AFTER INSERT OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE PROCEDURE jazzhands.update_per_service_environment_service_environment_collection();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trig_userlog_service_environment_collection BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trigger_audit_service_environment_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_service_environment_collection();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_del ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_del BEFORE DELETE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_insup ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_service_environment_collection_type_change ON service_environment_collection;
CREATE TRIGGER trigger_validate_service_environment_collection_type_change BEFORE UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_service_environment_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trig_userlog_service_environment_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trigger_audit_service_environment_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_service_environment_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_svcenv_collection_hier_loop ON service_environment_collection_hier;
CREATE TRIGGER trigger_check_svcenv_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_svcenv_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_hier_enforce ON service_environment_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_environment_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_service_environment ON service_environment_collection_service_environment;
CREATE TRIGGER trig_userlog_service_environment_collection_service_environment BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_service_environmen ON service_environment_collection_service_environment;
CREATE TRIGGER trigger_audit_service_environment_collection_service_environmen AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_service_environment_collection_service_environmen();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_member_enforce ON service_environment_collection_service_environment;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.service_environment_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trig_userlog_shared_netblock_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trigger_audit_shared_netblock_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_shared_netblock_layer3_interface();
DROP TRIGGER IF EXISTS trig_userlog_site ON site;
CREATE TRIGGER trig_userlog_site BEFORE INSERT OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_site ON site;
CREATE TRIGGER trigger_audit_site AFTER INSERT OR DELETE OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_site();
DROP TRIGGER IF EXISTS trigger_del_site_netblock_collections ON site;
CREATE TRIGGER trigger_del_site_netblock_collections BEFORE DELETE ON jazzhands.site FOR EACH ROW EXECUTE PROCEDURE jazzhands.del_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_ins_site_netblock_collections ON site;
CREATE TRIGGER trigger_ins_site_netblock_collections AFTER INSERT ON jazzhands.site FOR EACH ROW EXECUTE PROCEDURE jazzhands.ins_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_upd_site_netblock_collections ON site;
CREATE TRIGGER trigger_upd_site_netblock_collections AFTER UPDATE ON jazzhands.site FOR EACH ROW EXECUTE PROCEDURE jazzhands.upd_site_netblock_collections();
DROP TRIGGER IF EXISTS trig_userlog_slot ON slot;
CREATE TRIGGER trig_userlog_slot BEFORE INSERT OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot ON slot;
CREATE TRIGGER trigger_audit_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_slot();
DROP TRIGGER IF EXISTS trig_userlog_slot_type ON slot_type;
CREATE TRIGGER trig_userlog_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type ON slot_type;
CREATE TRIGGER trigger_audit_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_component_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_component_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_slot_type_permitted_component_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_remote_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_remote_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_slot_type_permitted_remote_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_ssh_key ON ssh_key;
CREATE TRIGGER trig_userlog_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ssh_key ON ssh_key;
CREATE TRIGGER trigger_audit_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_static_route ON static_route;
CREATE TRIGGER trig_userlog_static_route BEFORE INSERT OR UPDATE ON jazzhands.static_route FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_static_route ON static_route;
CREATE TRIGGER trigger_audit_static_route AFTER INSERT OR DELETE OR UPDATE ON jazzhands.static_route FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_static_route();
DROP TRIGGER IF EXISTS trig_userlog_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trig_userlog_sudo_account_collection_device_collection BEFORE INSERT OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trigger_audit_sudo_account_collection_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_sudo_account_collection_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_sudo_alias ON sudo_alias;
CREATE TRIGGER trig_userlog_sudo_alias BEFORE INSERT OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_alias ON sudo_alias;
CREATE TRIGGER trigger_audit_sudo_alias AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_sudo_alias();
DROP TRIGGER IF EXISTS trig_userlog_ticketing_system ON ticketing_system;
CREATE TRIGGER trig_userlog_ticketing_system BEFORE INSERT OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ticketing_system ON ticketing_system;
CREATE TRIGGER trigger_audit_ticketing_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_ticketing_system();
DROP TRIGGER IF EXISTS trig_userlog_token ON token;
CREATE TRIGGER trig_userlog_token BEFORE INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token ON token;
CREATE TRIGGER trigger_audit_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_token_change ON token;
CREATE TRIGGER trigger_pgnotify_token_change AFTER INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE PROCEDURE jazzhands.pgnotify_token_change();
DROP TRIGGER IF EXISTS trig_userlog_token_collection ON token_collection;
CREATE TRIGGER trig_userlog_token_collection BEFORE INSERT OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection ON token_collection;
CREATE TRIGGER trigger_audit_token_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_token_collection();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trig_userlog_token_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trigger_audit_token_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_token_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_token_collection_hier_loop ON token_collection_hier;
CREATE TRIGGER trigger_check_token_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE PROCEDURE jazzhands.check_token_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_token_collection_hier_enforce ON token_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_token_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.token_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_token ON token_collection_token;
CREATE TRIGGER trig_userlog_token_collection_token BEFORE INSERT OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_token ON token_collection_token;
CREATE TRIGGER trigger_audit_token_collection_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_token_collection_token();
DROP TRIGGER IF EXISTS trigger_token_collection_member_enforce ON token_collection_token;
CREATE CONSTRAINT TRIGGER trigger_token_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_token DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.token_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_unix_group ON unix_group;
CREATE TRIGGER trig_userlog_unix_group BEFORE INSERT OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_unix_group ON unix_group;
CREATE TRIGGER trigger_audit_unix_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_unix_group();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trig_userlog_val_account_collection_relation BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_preserve_direct ON val_account_collection_relation;
CREATE CONSTRAINT TRIGGER trigger_acct_coll_preserve_direct AFTER DELETE OR UPDATE ON jazzhands.val_account_collection_relation DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.acct_coll_preserve_direct();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trigger_audit_val_account_collection_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_account_collection_relation();
DROP TRIGGER IF EXISTS trig_account_collection_type_realm ON val_account_collection_type;
CREATE TRIGGER trig_account_collection_type_realm AFTER UPDATE OF account_realm_id ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.account_collection_type_realm();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trig_userlog_val_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_insert_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_insert_direct AFTER INSERT ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.acct_coll_insert_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_remove_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_remove_direct BEFORE DELETE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.acct_coll_remove_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_update_direct_before ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_update_direct_before AFTER UPDATE OF account_collection_type ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.acct_coll_update_direct_before();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trigger_audit_val_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_account_role ON val_account_role;
CREATE TRIGGER trig_userlog_val_account_role BEFORE INSERT OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_role ON val_account_role;
CREATE TRIGGER trigger_audit_val_account_role AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_account_role();
DROP TRIGGER IF EXISTS trig_userlog_val_account_type ON val_account_type;
CREATE TRIGGER trig_userlog_val_account_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_type ON val_account_type;
CREATE TRIGGER trigger_audit_val_account_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_account_type();
DROP TRIGGER IF EXISTS trig_userlog_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trig_userlog_val_appaal_group_name BEFORE INSERT OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trigger_audit_val_appaal_group_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_appaal_group_name();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key ON val_application_key;
CREATE TRIGGER trig_userlog_val_application_key BEFORE INSERT OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key ON val_application_key;
CREATE TRIGGER trigger_audit_val_application_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_application_key();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trig_userlog_val_application_key_values BEFORE INSERT OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trigger_audit_val_application_key_values AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_application_key_values();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trig_userlog_val_approval_chain_response_period BEFORE INSERT OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trigger_audit_val_approval_chain_response_period AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_approval_chain_response_period();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trig_userlog_val_approval_expiration_action BEFORE INSERT OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trigger_audit_val_approval_expiration_action AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_approval_expiration_action();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trig_userlog_val_approval_notifty_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trigger_audit_val_approval_notifty_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_approval_notifty_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trig_userlog_val_approval_process_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trigger_audit_val_approval_process_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_approval_process_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_type ON val_approval_type;
CREATE TRIGGER trig_userlog_val_approval_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_type ON val_approval_type;
CREATE TRIGGER trigger_audit_val_approval_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_approval_type();
DROP TRIGGER IF EXISTS trig_userlog_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trig_userlog_val_attestation_frequency BEFORE INSERT OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trigger_audit_val_attestation_frequency AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_attestation_frequency();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trig_userlog_val_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trigger_audit_val_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trig_userlog_val_authentication_resource BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trigger_audit_val_authentication_resource AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_authentication_resource();
DROP TRIGGER IF EXISTS trig_userlog_val_badge_status ON val_badge_status;
CREATE TRIGGER trig_userlog_val_badge_status BEFORE INSERT OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_badge_status ON val_badge_status;
CREATE TRIGGER trigger_audit_val_badge_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_badge_status();
DROP TRIGGER IF EXISTS trig_userlog_val_cable_type ON val_cable_type;
CREATE TRIGGER trig_userlog_val_cable_type BEFORE INSERT OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_cable_type ON val_cable_type;
CREATE TRIGGER trigger_audit_val_cable_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_cable_type();
DROP TRIGGER IF EXISTS trig_userlog_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trig_userlog_val_company_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trigger_audit_val_company_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_company_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_del ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_insup ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type ON val_company_type;
CREATE TRIGGER trig_userlog_val_company_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type ON val_company_type;
CREATE TRIGGER trigger_audit_val_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_company_type();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trig_userlog_val_company_type_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trigger_audit_val_company_type_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_company_type_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_component_function ON val_component_function;
CREATE TRIGGER trig_userlog_val_component_function BEFORE INSERT OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_function ON val_component_function;
CREATE TRIGGER trigger_audit_val_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_component_function();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property ON val_component_property;
CREATE TRIGGER trig_userlog_val_component_property BEFORE INSERT OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property ON val_component_property;
CREATE TRIGGER trigger_audit_val_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_component_property();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trig_userlog_val_component_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trigger_audit_val_component_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_component_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trig_userlog_val_component_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trigger_audit_val_component_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_component_property_value();
DROP TRIGGER IF EXISTS trig_userlog_val_contract_type ON val_contract_type;
CREATE TRIGGER trig_userlog_val_contract_type BEFORE INSERT OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_contract_type ON val_contract_type;
CREATE TRIGGER trigger_audit_val_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_val_country_code ON val_country_code;
CREATE TRIGGER trig_userlog_val_country_code BEFORE INSERT OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_country_code ON val_country_code;
CREATE TRIGGER trigger_audit_val_country_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_country_code();
DROP TRIGGER IF EXISTS trig_userlog_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trig_userlog_val_device_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trigger_audit_val_device_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_device_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_del ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_insup ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_device_status ON val_device_status;
CREATE TRIGGER trig_userlog_val_device_status BEFORE INSERT OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_status ON val_device_status;
CREATE TRIGGER trigger_audit_val_device_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_device_status();
DROP TRIGGER IF EXISTS trig_userlog_val_diet ON val_diet;
CREATE TRIGGER trig_userlog_val_diet BEFORE INSERT OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_diet ON val_diet;
CREATE TRIGGER trigger_audit_val_diet AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_diet();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_class ON val_dns_class;
CREATE TRIGGER trig_userlog_val_dns_class BEFORE INSERT OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_class ON val_dns_class;
CREATE TRIGGER trigger_audit_val_dns_class AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_dns_class();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trig_userlog_val_dns_domain_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_audit_val_dns_domain_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_dns_domain_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_del ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_insup ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trig_userlog_val_dns_domain_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trigger_audit_val_dns_domain_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_dns_domain_type();
DROP TRIGGER IF EXISTS trigger_dns_domain_type_should_generate ON val_dns_domain_type;
CREATE TRIGGER trigger_dns_domain_type_should_generate AFTER UPDATE OF can_generate ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.dns_domain_type_should_generate();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trig_userlog_val_dns_record_relation_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trigger_audit_val_dns_record_relation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_dns_record_relation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trig_userlog_val_dns_srv_service BEFORE INSERT OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trigger_audit_val_dns_srv_service AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_dns_srv_service();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trig_userlog_val_encapsulation_mode BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trigger_audit_val_encapsulation_mode AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_encapsulation_mode();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trig_userlog_val_encapsulation_type BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trigger_audit_val_encapsulation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_encapsulation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trig_userlog_val_encryption_key_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trigger_audit_val_encryption_key_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_encryption_key_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trig_userlog_val_encryption_method BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trigger_audit_val_encryption_method AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_encryption_method();
DROP TRIGGER IF EXISTS trig_userlog_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trig_userlog_val_filesystem_type BEFORE INSERT OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trigger_audit_val_filesystem_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_filesystem_type();
DROP TRIGGER IF EXISTS trig_userlog_val_image_type ON val_image_type;
CREATE TRIGGER trig_userlog_val_image_type BEFORE INSERT OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_image_type ON val_image_type;
CREATE TRIGGER trigger_audit_val_image_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_image_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trig_userlog_val_ip_namespace BEFORE INSERT OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trigger_audit_val_ip_namespace AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_ip_namespace();
DROP TRIGGER IF EXISTS trig_userlog_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trig_userlog_val_iso_currency_code BEFORE INSERT OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trigger_audit_val_iso_currency_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_iso_currency_code();
DROP TRIGGER IF EXISTS trig_userlog_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trig_userlog_val_key_usage_reason_for_assignment BEFORE INSERT OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trigger_audit_val_key_usage_reason_for_assignment AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_key_usage_reason_for_assignment();
DROP TRIGGER IF EXISTS trig_userlog_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer2_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer2_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_layer2_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_del ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_insup ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_interface_purpose ON val_layer3_interface_purpose;
CREATE TRIGGER trig_userlog_val_layer3_interface_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_interface_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_interface_purpose ON val_layer3_interface_purpose;
CREATE TRIGGER trigger_audit_val_layer3_interface_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_interface_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_layer3_interface_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_interface_type ON val_layer3_interface_type;
CREATE TRIGGER trig_userlog_val_layer3_interface_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_interface_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_interface_type ON val_layer3_interface_type;
CREATE TRIGGER trigger_audit_val_layer3_interface_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_interface_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_layer3_interface_type();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer3_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer3_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_layer3_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_del ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_insup ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trig_userlog_val_logical_port_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trigger_audit_val_logical_port_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_logical_port_type();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trig_userlog_val_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trigger_audit_val_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trig_userlog_val_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trigger_audit_val_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trig_userlog_val_logical_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trigger_audit_val_logical_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_logical_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trig_userlog_val_netblock_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trigger_audit_val_netblock_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_netblock_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_del ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_insup ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trig_userlog_val_netblock_status BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trigger_audit_val_netblock_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_netblock_status();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trig_userlog_val_netblock_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trigger_audit_val_netblock_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_netblock_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trig_userlog_val_network_range_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trigger_audit_val_network_range_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_network_range_type();
DROP TRIGGER IF EXISTS trigger_validate_net_range_toggle_nonoverlap ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_net_range_toggle_nonoverlap AFTER UPDATE OF can_overlap, require_cidr_boundary ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_net_range_toggle_nonoverlap();
DROP TRIGGER IF EXISTS trigger_validate_val_network_range_type ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_val_network_range_type AFTER UPDATE OF dns_domain_required, netblock_type ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_val_network_range_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trig_userlog_val_network_service_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trigger_audit_val_network_service_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_network_service_type();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trig_userlog_val_operating_system_family BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trigger_audit_val_operating_system_family AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_operating_system_family();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trig_userlog_val_operating_system_snapshot_type BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trigger_audit_val_operating_system_snapshot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_operating_system_snapshot_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trig_userlog_val_ownership_status BEFORE INSERT OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trigger_audit_val_ownership_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_ownership_status();
DROP TRIGGER IF EXISTS trig_userlog_val_package_relation_type ON val_package_relation_type;
CREATE TRIGGER trig_userlog_val_package_relation_type BEFORE INSERT OR UPDATE ON jazzhands.val_package_relation_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_package_relation_type ON val_package_relation_type;
CREATE TRIGGER trigger_audit_val_package_relation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_package_relation_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_package_relation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_password_type ON val_password_type;
CREATE TRIGGER trig_userlog_val_password_type BEFORE INSERT OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_password_type ON val_password_type;
CREATE TRIGGER trigger_audit_val_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_password_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trig_userlog_val_person_company_attribute_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trigger_audit_val_person_company_attribute_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_company_attribute_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trig_userlog_val_person_company_attribute_name BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trigger_audit_val_person_company_attribute_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_company_attribute_name();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trig_userlog_val_person_company_attribute_value BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_audit_val_person_company_attribute_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_company_attribute_value();
DROP TRIGGER IF EXISTS trigger_person_company_attribute_change_after_row_hooks ON val_person_company_attribute_value;
CREATE TRIGGER trigger_person_company_attribute_change_after_row_hooks AFTER INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE PROCEDURE jazzhands.person_company_attribute_change_after_row_hooks();
DROP TRIGGER IF EXISTS trigger_validate_pers_comp_attr_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_validate_pers_comp_attr_value BEFORE DELETE OR UPDATE OF person_company_attribute_name, person_company_attribute_value ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE PROCEDURE jazzhands.validate_pers_comp_attr_value();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trig_userlog_val_person_company_relation BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trigger_audit_val_person_company_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_company_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trig_userlog_val_person_contact_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trigger_audit_val_person_contact_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_contact_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trig_userlog_val_person_contact_technology BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trigger_audit_val_person_contact_technology AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_contact_technology();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trig_userlog_val_person_contact_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trigger_audit_val_person_contact_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_contact_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trig_userlog_val_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trigger_audit_val_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_image_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trig_userlog_val_person_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trigger_audit_val_person_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_status ON val_person_status;
CREATE TRIGGER trig_userlog_val_person_status BEFORE INSERT OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_status ON val_person_status;
CREATE TRIGGER trigger_audit_val_person_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_person_status();
DROP TRIGGER IF EXISTS trig_userlog_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trig_userlog_val_physical_address_type BEFORE INSERT OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trigger_audit_val_physical_address_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_physical_address_type();
DROP TRIGGER IF EXISTS trig_userlog_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trig_userlog_val_physicalish_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trigger_audit_val_physicalish_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_physicalish_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trig_userlog_val_private_key_encryption_type BEFORE INSERT OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trigger_audit_val_private_key_encryption_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_private_key_encryption_type();
DROP TRIGGER IF EXISTS trig_userlog_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trig_userlog_val_processor_architecture BEFORE INSERT OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trigger_audit_val_processor_architecture AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_processor_architecture();
DROP TRIGGER IF EXISTS trig_userlog_val_production_state ON val_production_state;
CREATE TRIGGER trig_userlog_val_production_state BEFORE INSERT OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_production_state ON val_production_state;
CREATE TRIGGER trigger_audit_val_production_state AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_production_state();
DROP TRIGGER IF EXISTS trig_userlog_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trig_userlog_val_property_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trigger_audit_val_property_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_property_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trig_userlog_val_property_name_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trigger_audit_val_property_name_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_property_name_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_type ON val_property_type;
CREATE TRIGGER trig_userlog_val_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_type ON val_property_type;
CREATE TRIGGER trigger_audit_val_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_value ON val_property_value;
CREATE TRIGGER trig_userlog_val_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_value ON val_property_value;
CREATE TRIGGER trigger_audit_val_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_property_value();
DROP TRIGGER IF EXISTS trigger_val_property_value_del_check ON val_property_value;
CREATE CONSTRAINT TRIGGER trigger_val_property_value_del_check AFTER DELETE ON jazzhands.val_property_value DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE jazzhands.val_property_value_del_check();
DROP TRIGGER IF EXISTS trig_userlog_val_rack_type ON val_rack_type;
CREATE TRIGGER trig_userlog_val_rack_type BEFORE INSERT OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_rack_type ON val_rack_type;
CREATE TRIGGER trigger_audit_val_rack_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_rack_type();
DROP TRIGGER IF EXISTS trig_userlog_val_raid_type ON val_raid_type;
CREATE TRIGGER trig_userlog_val_raid_type BEFORE INSERT OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_raid_type ON val_raid_type;
CREATE TRIGGER trigger_audit_val_raid_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_raid_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trig_userlog_val_service_environment_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trigger_audit_val_service_environment_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_service_environment_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_del ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_insup ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_service_environment_type ON val_service_environment_type;
CREATE TRIGGER trig_userlog_val_service_environment_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_environment_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_environment_type ON val_service_environment_type;
CREATE TRIGGER trigger_audit_val_service_environment_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_environment_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_service_environment_type();
DROP TRIGGER IF EXISTS trig_userlog_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trig_userlog_val_shared_netblock_protocol BEFORE INSERT OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trigger_audit_val_shared_netblock_protocol AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_shared_netblock_protocol();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_function ON val_slot_function;
CREATE TRIGGER trig_userlog_val_slot_function BEFORE INSERT OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_function ON val_slot_function;
CREATE TRIGGER trigger_audit_val_slot_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_slot_function();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trig_userlog_val_slot_physical_interface BEFORE INSERT OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trigger_audit_val_slot_physical_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_slot_physical_interface();
DROP TRIGGER IF EXISTS trig_userlog_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trig_userlog_val_ssh_key_type BEFORE INSERT OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trigger_audit_val_ssh_key_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_ssh_key_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trig_userlog_val_token_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trigger_audit_val_token_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_token_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_status ON val_token_status;
CREATE TRIGGER trig_userlog_val_token_status BEFORE INSERT OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_status ON val_token_status;
CREATE TRIGGER trigger_audit_val_token_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_token_status();
DROP TRIGGER IF EXISTS trig_userlog_val_token_type ON val_token_type;
CREATE TRIGGER trig_userlog_val_token_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_type ON val_token_type;
CREATE TRIGGER trigger_audit_val_token_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_token_type();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trig_userlog_val_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trigger_audit_val_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trig_userlog_val_volume_group_relation BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trigger_audit_val_volume_group_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_volume_group_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trig_userlog_val_volume_group_type BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trigger_audit_val_volume_group_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_volume_group_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trig_userlog_val_x509_certificate_file_format BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trigger_audit_val_x509_certificate_file_format AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_x509_certificate_file_format();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trig_userlog_val_x509_certificate_type BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trigger_audit_val_x509_certificate_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_x509_certificate_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trig_userlog_val_x509_key_usage BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trigger_audit_val_x509_key_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_x509_key_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trig_userlog_val_x509_key_usage_category BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trigger_audit_val_x509_key_usage_category AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_x509_key_usage_category();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trig_userlog_val_x509_revocation_reason BEFORE INSERT OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trigger_audit_val_x509_revocation_reason AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_val_x509_revocation_reason();
DROP TRIGGER IF EXISTS trig_userlog_volume_group ON volume_group;
CREATE TRIGGER trig_userlog_volume_group BEFORE INSERT OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group ON volume_group;
CREATE TRIGGER trigger_audit_volume_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_volume_group();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trig_userlog_volume_group_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trigger_audit_volume_group_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_volume_group_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trig_userlog_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trigger_audit_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trig_userlog_x509_key_usage_attribute BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trigger_audit_x509_key_usage_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_x509_key_usage_attribute();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trig_userlog_x509_key_usage_categorization BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trigger_audit_x509_key_usage_categorization AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_x509_key_usage_categorization();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trig_userlog_x509_key_usage_default BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trigger_audit_x509_key_usage_default AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_x509_key_usage_default();
DROP TRIGGER IF EXISTS trig_userlog_x509_signed_certificate ON x509_signed_certificate;
CREATE TRIGGER trig_userlog_x509_signed_certificate BEFORE INSERT OR UPDATE ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE PROCEDURE schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_signed_certificate ON x509_signed_certificate;
CREATE TRIGGER trigger_audit_x509_signed_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE PROCEDURE jazzhands.perform_audit_x509_signed_certificate();
DROP TRIGGER IF EXISTS trigger_x509_signed_ski_pvtkey_validate ON x509_signed_certificate;
CREATE TRIGGER trigger_x509_signed_ski_pvtkey_validate AFTER INSERT OR UPDATE OF subject_key_identifier, private_key_id ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE PROCEDURE jazzhands.x509_signed_ski_pvtkey_validate();

--
-- BEGIN: Procesing things saved for end
--
SAVEPOINT beforerecreate;

--
-- END: Procesing things saved for end
--

SELECT schema_support.replay_object_recreates(beverbose := true);
SELECT schema_support.replay_saved_grants(beverbose := true);

--
-- BEGIN: Running final cache table sync
SAVEPOINT beforecache;
SELECT schema_support.synchronize_cache_tables();

--
-- END: Running final cache table sync
SAVEPOINT beforereset;
SELECT schema_support.reset_all_schema_table_sequences('jazzhands');
SELECT schema_support.reset_all_schema_table_sequences('jazzhands_audit');
SAVEPOINT beforegrant;
GRANT select on all tables in schema jazzhands to ro_role;
GRANT insert,update,delete on all tables in schema jazzhands to iud_role;
GRANT insert,update,delete on all tables in schema jazzhands_legacy to iud_role;
GRANT select on all sequences in schema jazzhands to ro_role;
GRANT usage on all sequences in schema jazzhands to iud_role;
GRANT select on all tables in schema jazzhands_audit to ro_role;
GRANT select on all sequences in schema jazzhands_audit to ro_role;
GRANT select on all tables in schema audit to ro_role;
GRANT select on all sequences in schema audit to ro_role;

SELECT schema_support.set_schema_version(
	version := '0.91',
	schema := 'jazzhands'
);
SAVEPOINT maintend;
SELECT schema_support.end_maintenance();
SAVEPOINT maintfin;
select clock_timestamp(), now(), clock_timestamp() - now() AS len;
