--
-- Copyright (c) 2020 Todd Kover
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


\pset pager
/*
Invoked:

	--suffix=v89
	--reinsert-dir=i
	--pre
	../new/database/ddl/schema/pgsql/create_schema_support.sql
	--pre
	pre
	--post
	post
	--postschema=jazzhands_cache
	--postschema=jazzhands_legacy
	--scan
	--last=jazzhands_legacy.v_person_company
	--last=jazzhands_legacy.v_account_manager_map
	val_network_interface_type:val_layer3_interface_type
	val_network_interface_purpose:val_layer3_interface_purpose
	encryption_key
	account_password
	val_service_environment_type
	service_environment
*/

\set ON_ERROR_STOP
SELECT schema_support.begin_maintenance(false);
select clock_timestamp(), now(), clock_timestamp() - now() AS len;


-- BEGIN Misc that does not apply to above
/*
 * Copyright (c) 2010-2019 Todd Kover
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

\set ON_ERROR_STOP

/*
 * Copyright (c) 2010-2019 Matthew Ragan
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


--
-- $HeadURL$
-- $Id$
--


-- Create schema if it does not exist, do nothing otherwise.
DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'schema_support';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS schema_support;
		CREATE SCHEMA schema_support AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA schema_support IS 'part of jazzhands';

	END IF;
END;
$$;


-------------------------------------------------------------------
-- returns the Id tag for CM
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.id_tag()
RETURNS VARCHAR AS $$
BEGIN
    RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;
-- end of procedure id_tag
-------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence
    ( schema VARCHAR, table_name VARCHAR )
RETURNS VOID AS $$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		WITH s AS (
			SELECT	pg_get_serial_sequence(schema||'.'||table_name,
				a.attname) as seq, a.attname as column
			FROM	pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE	c.relname = table_name
			AND	n.nspname = schema
				AND	a.attnum > 0
				AND	NOT a.attisdropped
		) SELECT s.*, nextval(s.seq) as nv FROM s WHERE seq IS NOT NULL
	LOOP
		EXECUTE 'SELECT max('||quote_ident(_r.column)||')+1 FROM  '
			|| quote_ident(schema)||'.'||quote_ident(table_name)
			INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE 'ALTER SEQUENCE ' || _r.seq || ' RESTART WITH '
				|| m;
		END IF;
	END LOOP;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.reset_all_schema_table_sequences
    ( schema TEXT )
RETURNS INTEGER AS $$
DECLARE
	_r	RECORD;
	tally INTEGER;
BEGIN
	tally := 0;
	FOR _r IN

		SELECT n.nspname, c.relname, c.relkind
		FROM	pg_class c
				INNER JOIN pg_namespace n ON n.oid = c.relnamespace
		WHERE	n.nspname = schema
		AND		c.relkind = 'r'
	LOOP
		PERFORM schema_support.reset_table_sequence(_r.nspname::text, _r.relname::text);
		tally := tally + 1;
	END LOOP;
	RETURN tally;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_trigger
    ( aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR )
RETURNS VOID AS $$
BEGIN
    EXECUTE 'CREATE OR REPLACE FUNCTION ' || quote_ident(tbl_schema)
	|| '.' || quote_ident('perform_audit_' || table_name)
	|| $ZZ$() RETURNS TRIGGER AS $TQ$
	    DECLARE
		appuser VARCHAR;
	    BEGIN
		appuser := concat_ws('/', session_user,
			coalesce(
				current_setting('jazzhands.appuser', true),
				current_setting('request.header.x-remote-user', true)
			)
		);

		appuser = substr(appuser, 1, 255);

		IF TG_OP = 'DELETE' THEN
		    INSERT INTO $ZZ$ || quote_ident(aud_schema)
			|| '.' || quote_ident(table_name) || $ZZ$
		    VALUES ( OLD.*, 'DEL', now(),
			clock_timestamp(), txid_current(), appuser );
		    RETURN OLD;
		ELSIF TG_OP = 'UPDATE' THEN
			IF OLD != NEW THEN
				INSERT INTO $ZZ$ || quote_ident(aud_schema)
				|| '.' || quote_ident(table_name) || $ZZ$
				VALUES ( NEW.*, 'UPD', now(),
				clock_timestamp(), txid_current(), appuser );
			END IF;
			RETURN NEW;
		ELSIF TG_OP = 'INSERT' THEN
		    INSERT INTO $ZZ$ || quote_ident(aud_schema)
			|| '.' || quote_ident(table_name) || $ZZ$
		    VALUES ( NEW.*, 'INS', now(),
			clock_timestamp(), txid_current(), appuser );
		    RETURN NEW;
		END IF;
		RETURN NULL;
	    END;
	$TQ$ LANGUAGE plpgsql SECURITY DEFINER
    $ZZ$;

    EXECUTE 'DROP TRIGGER IF EXISTS ' || quote_ident('trigger_audit_'
	|| table_name) || ' ON ' || quote_ident(tbl_schema) || '.'
	|| quote_ident(table_name);

    EXECUTE 'CREATE TRIGGER ' || quote_ident('trigger_audit_' || table_name)
	|| ' AFTER INSERT OR UPDATE OR DELETE ON ' || quote_ident(tbl_schema)
	|| '.' || quote_ident(table_name) || ' FOR EACH ROW EXECUTE PROCEDURE '
	|| quote_ident(tbl_schema) || '.' || quote_ident('perform_audit_'
	|| table_name) || '()';
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_triggers
    ( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $$
DECLARE
    table_list RECORD;
BEGIN
    --
    -- select tables with audit tables
    --
    FOR table_list IN
	SELECT table_name::text FROM information_schema.tables
	WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
	AND table_name IN (
	    SELECT table_name FROM information_schema.tables
	    WHERE table_schema = aud_schema AND table_type = 'BASE TABLE'
	) ORDER BY table_name
    LOOP
	PERFORM schema_support.rebuild_audit_trigger
	    (aud_schema, tbl_schema, table_list.table_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table_finish(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	cols	text[];
	i	text;
BEGIN
	--
	-- get columns - XXX NOTE:  Need to remove columns not in the new
	-- table...
	--
	SELECT	array_agg(quote_ident(a.attname) ORDER BY a.attnum)
	INTO	cols
	FROM	pg_catalog.pg_attribute a
	INNER JOIN pg_catalog.pg_class c on a.attrelid = c.oid
	INNER JOIN pg_catalog.pg_namespace n on n.oid = c.relnamespace
	LEFT JOIN pg_catalog.pg_description d
			on d.objoid = a.attrelid
			and d.objsubid = a.attnum
	WHERE   n.nspname = quote_ident(aud_schema)
	  AND	c.relname = quote_ident('__old__' || table_name)
	  AND	a.attnum > 0
	  AND	NOT a.attisdropped
	;

	EXECUTE 'INSERT INTO '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' ( '
		|| array_to_string(cols, ',') || ' ) SELECT '
		|| array_to_string(cols, ',') || ' FROM '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__' || table_name)
		|| ' ORDER BY '
		|| quote_ident('aud#seq');


	EXECUTE 'DROP TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('__old__' || table_name);

	--
	-- drop audit sequence, in case it was not dropped with table.
	--
	EXECUTE 'DROP SEQUENCE IF EXISTS '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident('_old_' || table_name || '_seq');

	--
	-- drop indexes found before that did not get dropped.
	--
	FOR i IN SELECT	c2.relname
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident('__old__' || table_name)
		  AND	contype is NULL
	LOOP
		EXECUTE 'DROP INDEX '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('_' || i);
	END LOOP;
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR,
	finish_rebuild BOOLEAN DEFAULT true
)
RETURNS VOID AS $FUNC$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__' || table_name);


	--
	-- RENAME sequence
	--
	EXECUTE 'ALTER SEQUENCE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq')
		|| ' RENAME TO '
		|| quote_ident('_old_' || table_name || '_seq');

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- fix sequence primary key to have the correct next value
	--
	EXECUTE 'SELECT max("aud#seq") + 1 FROM	 '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident('__old__' || table_name) INTO seq;
	IF seq IS NOT NULL THEN
		EXECUTE 'ALTER SEQUENCE '
			|| quote_ident(aud_schema) || '.'
			|| quote_ident(table_name || '_seq')
			|| ' RESTART WITH ' || seq;
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table_pkak_indexes(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	keys	RECORD;
	count	INTEGER;
	name	TEXT;
BEGIN
	COUNT := 0;
	-- one day, I will want to construct the list of columns by hand rather
	-- than use pg_get_constraintdef.  watch me...
	FOR keys IN
		SELECT con.conname, c2.relname as index_name,
			pg_catalog.pg_get_constraintdef(con.oid, true) as condef,
				regexp_replace(
			pg_catalog.pg_get_constraintdef(con.oid, true),
					'^.*(\([^\)]+\)).*$', '\1') as cols,
			con.condeferrable,
			con.condeferred
		FROM pg_catalog.pg_class c
			INNER JOIN pg_namespace n
				ON relnamespace = n.oid
			INNER JOIN pg_catalog.pg_index i
				ON c.oid = i.indrelid
			INNER JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			INNER JOIN pg_catalog.pg_constraint con ON
				(con.conrelid = i.indrelid
				AND con.conindid = i.indexrelid )
		WHERE c.relname =  table_name
		AND	 n.nspname = tbl_schema
		AND con.contype in ('p', 'u')
		ORDER BY CASE WHEN con.contype = 'p' THEN 0 ELSE 1 END, con.conname
	LOOP
		name := 'aud_' || quote_ident( table_name || '_' || keys.conname);
		IF char_length(name) > 63 THEN
			name := 'aud_' || count || quote_ident( table_name || '_' || keys.conname);
			COUNT := COUNT + 1;
		END IF;
		EXECUTE 'CREATE INDEX ' || name
			|| ' ON ' || quote_ident(aud_schema) || '.'
			|| quote_ident(table_name) || keys.cols;
	END LOOP;

END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table_other_indexes(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR
)
RETURNS VOID AS $FUNC$
DECLARE
	_r	RECORD;
	sch	TEXT;
BEGIN
	-- one day, I will want to construct the list of columns by hand rather
	-- than use pg_get_constraintdef.  watch me...

	sch := quote_ident( aud_schema );
	FOR _r IN
		SELECT c2.relname, pg_get_indexdef(i.indexrelid) as def, con.contype
	FROM pg_catalog.pg_class c
	    INNER JOIN pg_namespace n
		ON relnamespace = n.oid
	    INNER JOIN pg_catalog.pg_index i
		ON c.oid = i.indrelid
	    INNER JOIN pg_catalog.pg_class c2
		ON i.indexrelid = c2.oid
	   LEFT JOIN pg_catalog.pg_constraint con ON
		(con.conrelid = i.indrelid
		AND con.conindid = i.indexrelid )
	WHERE c.relname =  table_name
	AND      n.nspname = tbl_schema
	AND	con.contype IS NULL

	LOOP
		_r.def := regexp_replace(_r.def, ' ON ', ' ON ' || sch || '.');
		EXECUTE _r.def;
	END LOOP;

END;
$FUNC$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(
	aud_schema VARCHAR, tbl_schema VARCHAR, table_name VARCHAR,
	first_time boolean DEFAULT true
)
RETURNS VOID AS $FUNC$
BEGIN
	BEGIN
	EXECUTE 'CREATE SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq');
	EXCEPTION WHEN duplicate_table THEN
		NULL;
	END;

	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| $$ ALTER COLUMN "aud#seq" SET NOT NULL, $$
		|| $$ ALTER COLUMN "aud#seq" SET DEFAULT nextval('$$
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name || '_seq')
		|| $$')$$;

	EXECUTE 'ALTER SEQUENCE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name || '_seq') || ' OWNED BY '
		|| quote_ident(aud_schema) || '.' || quote_ident(table_name)
		|| '.' || quote_ident('aud#seq');


	EXECUTE 'CREATE INDEX '
		|| quote_ident( table_name || '_aud#timestamp_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#timestamp")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( table_name || '_aud#realtime_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#realtime")';

	EXECUTE 'CREATE INDEX '
		|| quote_ident( table_name || '_aud#txid_idx')
		|| ' ON ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || '("aud#txid")';

	EXECUTE 'ALTER TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident( table_name )
		|| ' ADD PRIMARY KEY ("aud#seq")';

	PERFORM schema_support.build_audit_table_pkak_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.build_audit_tables
    ( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $FUNC$
DECLARE
     table_list RECORD;
BEGIN
    FOR table_list IN
	SELECT table_name::text FROM information_schema.tables
	WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
	AND NOT (
	    table_name IN (
		SELECT table_name FROM information_schema.tables
		WHERE table_schema = aud_schema
	    )
	)
	ORDER BY table_name
    LOOP
	PERFORM schema_support.build_audit_table
	    ( aud_schema, tbl_schema, table_list.table_name );
    END LOOP;

    PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
END;
$FUNC$ LANGUAGE plpgsql;

-------------------------------------------------------------------------------

--
-- rebuilds all existing audit tables.  This is used when new columns are
-- added or there's some other reason to want to do it.
--
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_tables
	( aud_schema varchar, tbl_schema varchar )
RETURNS VOID AS $FUNC$
DECLARE
	 table_list RECORD;
BEGIN
	FOR table_list IN
		SELECT b.table_name::text
		FROM information_schema.tables b
			INNER JOIN information_schema.tables a
				USING (table_name,table_type)
		WHERE table_type = 'BASE TABLE'
		AND a.table_schema = aud_schema
		AND b.table_schema = tbl_schema
		ORDER BY table_name
	LOOP
		PERFORM schema_support.save_dependent_objects_for_replay(
			schema := aud_schema::varchar,
			object := table_list.table_name::varchar,
			tags:= ARRAY['rebuild_audit_tables']);
		PERFORM schema_support.save_grants_for_replay(schema := aud_schema,
			object := table_list.table_name,
			tags := ARRAY['rebuild_audit_tables']);
		PERFORM schema_support.rebuild_audit_table
			( aud_schema, tbl_schema, table_list.table_name );
		PERFORM schema_support.replay_object_recreates();
		PERFORM schema_support.replay_saved_grants();
		END LOOP;

	PERFORM schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);
	PERFORM schema_support.replay_object_recreates(tags := ARRAY['rebuild_audit_tables
']);
	PERFORM schema_support.replay_saved_grants(tags := ARRAY['rebuild_audit_tables']);
END;
$FUNC$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.trigger_ins_upd_generic_func()
RETURNS TRIGGER AS $$
DECLARE
    appuser VARCHAR;
BEGIN
	appuser := concat_ws('/', session_user,
		coalesce(
			current_setting('jazzhands.appuser', true),
			current_setting('request.header.x-remote-user', true)
		)
	);
    appuser = substr(appuser, 1, 255);

    IF TG_OP = 'INSERT' THEN
	NEW.data_ins_user = appuser;
	NEW.data_ins_date = 'now';
    END IF;

    IF TG_OP = 'UPDATE' AND OLD != NEW THEN
	NEW.data_upd_user = appuser;
	NEW.data_upd_date = 'now';

	IF OLD.data_ins_user != NEW.data_ins_user THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_USER" cannot be modified.';
	END IF;

	IF OLD.data_ins_date != NEW.data_ins_date THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_DATE" cannot be modified.';
	END IF;
    END IF;

    RETURN NEW;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_stamp_trigger
    (tbl_schema VARCHAR, table_name VARCHAR)
RETURNS VOID AS $$
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS '
	|| quote_ident('trig_userlog_' || table_name)
	|| ' ON ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name);

    EXECUTE 'CREATE TRIGGER '
	|| quote_ident('trig_userlog_' || table_name)
	|| ' BEFORE INSERT OR UPDATE ON '
	|| quote_ident(tbl_schema) || '.' || quote_ident(table_name)
	|| ' FOR EACH ROW EXECUTE PROCEDURE'
	|| ' schema_support.trigger_ins_upd_generic_func()';
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.rebuild_stamp_triggers
    (tbl_schema VARCHAR)
RETURNS VOID AS $$
BEGIN
    DECLARE
	tab RECORD;
    BEGIN
	FOR tab IN
	    SELECT table_name::text FROM information_schema.tables
	    WHERE table_schema = tbl_schema AND table_type = 'BASE TABLE'
	    AND table_name NOT LIKE 'aud$%'
	LOOP
	    PERFORM schema_support.rebuild_stamp_trigger
		(tbl_schema, tab.table_name);
	END LOOP;
    END;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-------------------------------------------------------------------------------

-- MAINTENANCE SUPPORT FUNCTIONS

--
-- Check for ideal maintenance conditions.
-- Are we superuser? (argument turns this off if it is not necessary
-- Are we in a transaction?
--
-- Raise an exception now
--
CREATE OR REPLACE FUNCTION schema_support.begin_maintenance(
	shouldbesuper	BOOLEAN		DEFAULT true
)
RETURNS BOOLEAN AS $$
DECLARE
	issuper	boolean;
	_tally	integer;
BEGIN
	IF shouldbesuper THEN
		SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
		IF issuper IS false THEN
			PERFORM groname, rolname
			FROM (
				SELECT groname, unnest(grolist) AS oid
				FROM pg_group ) g
			JOIN pg_roles r USING (oid)
			WHERE groname = 'dba'
			AND rolname = current_user;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'User must be a super user or have the dba role';
			END IF;
		END IF;
	END IF;
	-- Not sure how reliable this is.
	-- http://www.postgresql.org/docs/9.3/static/monitoring-stats.html
	SELECT count(*)
	  INTO _tally
	  FROM	pg_stat_activity
	 WHERE	pid = pg_backend_pid()
	   AND	query_start = xact_start;
	IF _tally > 0 THEN
		RAISE EXCEPTION 'Must run maintenance in a transaction.';
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--
	CREATE TEMPORARY TABLE __owner_before_stats (
		username					TEXT,
		before_views_count			INTEGER,
		before_func_count		INTEGER,
		before_key_count	INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_before_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Revokes superuser if its set on the current user
--
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(
	minnumdiff		INTEGER		DEFAULT 0,
	minpercent		INTEGER		DEFAULT 0,
	skipchecks		BOOLEAN		DEFAULT false
) RETURNS BOOLEAN AS $$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || current_user;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;
	RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Sets up temporary tables for replaying grants if it does not exist
--
-- This is called by other functions in this module.
--
CREATE OR REPLACE FUNCTION schema_support.prepare_for_grant_replay()
RETURNS VOID AS $$
DECLARE
	_tally integer;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__regrants'
	   AND	relpersistence = 't';

	IF _tally = 0 THEN
		CREATE TEMPORARY TABLE IF NOT EXISTS __regrants (id SERIAL, schema text, object text, newname text, regrant text, tags text[]);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Collect grants for relations and saves them for future replay (if objects
-- are dropped and recreated)
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_relations(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_schema		varchar;
	_object	varchar;
	_tabs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_fullgrant		varchar;
	_role		varchar;
	_myrole		TEXT;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;

	PERFORM schema_support.prepare_for_grant_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- Handle table wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			c.relacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || ' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	-- Handle column specific wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			a.attname as col,
			a.attacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
		ON a.attrelid = c.oid
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND a.attacl IS NOT NULL
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || '(' || _tabs.col || ')'
				' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Collect grants for functions and saves them for future replay (if objects
-- are dropped and recreated)
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_functions(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_schema		varchar;
	_object		varchar;
	_procs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_role		varchar;
	_fullgrant		varchar;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;
	PERFORM schema_support.prepare_for_grant_replay();
	FOR _procs IN SELECT  n.nspname as schema, p.proname,
			pg_get_function_identity_arguments(p.oid) as args,
			proacl as privs
		FROM    pg_catalog.pg_proc  p
				inner join pg_catalog.pg_namespace n on n.oid = p.pronamespace
		WHERE   n.nspname = _schema
		 AND    p.proname = _object
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _procs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || ' on FUNCTION ' ||
				_schema || '.' ||
				newname || '(' || _procs.args || ')  to ' ||
				_role || _grant;
			-- RAISE DEBUG 'inserting % for %', _fullgrant, _perm;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- save grants for object regardless of if its a relation or function.
--
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay(
	schema varchar,
	object varchar,
	newname varchar DEFAULT NULL,
	tags text[] DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
	PERFORM schema_support.save_grants_for_replay_relations(schema, object, newname, tags);
	PERFORM schema_support.save_grants_for_replay_functions(schema, object, newname, tags);
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- replay saved grants, drop temporary tables
--
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(
	beverbose	boolean DEFAULT false,
	schema		text DEFAULT NULL,
	tags		text DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Sets up temporary tables for replaying grants if it does not exist
--
-- This is called by other functions in this module.
--
CREATE OR REPLACE FUNCTION schema_support.prepare_for_object_replay()
RETURNS VOID AS $$
DECLARE
	_tally integer;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	IF _tally = 0 THEN
		CREATE TEMPORARY TABLE IF NOT EXISTS __recreate (id SERIAL, schema text, object text, owner text, type text, ddl text, idargs text, tags text[], path text[]);
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Saves view definition for replay later.  This is to allow for dropping
-- dependent views and having a migration script recreate them.
--
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object)
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- NEED:  something to drop an object (view or function), save grants and deal with dependencies
-- probably want a restore everything function too
--

--
-- Saves relations dependent on an object for reply.
--
CREATE OR REPLACE FUNCTION schema_support.save_dependent_objects_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	doobjectdeps boolean DEFAULT false,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_myrole TEXT;
BEGIN
	RAISE DEBUG 'processing %.%', schema, object;
	path = path || concat(schema, '.', object);
	-- process stored procedures
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
			SELECT * FROM (
				-- functions that depend on relations
				SELECT  distinct np.nspname::text AS nspname,
					dependent.proname::text AS dep_object,
						n.nspname as base_namespace,
						dependee.typname as base_object
				FROM   pg_depend dep
					INNER join pg_type dependee on dependee.oid = dep.refobjid
					INNER join pg_namespace n on n.oid = dependee.typnamespace
					INNER join pg_proc dependent on dependent.oid = dep.objid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				UNION ALL
				-- relations that depend on functions
				-- note dependent and depndee are backwards

				SELECT  distinct n.nspname::text, dependee.relname::text,
					np.nspname, dependent.proname::text
				FROM   pg_depend dep
					INNER JOIN pg_rewrite ON dep.objid = pg_rewrite.oid
					INNER JOIN pg_class as dependee
						ON pg_rewrite.ev_class = dependee.oid
					INNER join pg_namespace n on n.oid = dependee.relnamespace
					INNER join pg_proc dependent on dependent.oid = dep.refobjid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				) x
	WHERE
			base_object = object
			AND base_namespace = schema
	LOOP
		-- RAISE NOTICE '1 dealing with  %.%', _r.nspname, _r.dep_object;
		PERFORM schema_support.save_constraint_for_replay(schema := _r.nspname, object := _r.dep_object, dropit := dropit, tags := tags, path := path);
		PERFORM schema_support.save_dependent_objects_for_replay(_r.nspname, _r.dep_object, dropit, doobjectdeps, tags, path);
		-- which of these to run depends on which side of the union above
		PERFORM schema_support.save_function_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
		PERFORM schema_support.save_view_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
	END LOOP;

	-- save any triggers on the view
	FOR _r in SELECT distinct n.nspname::text, dependee.relname::text, dependee.relkind
		FROM pg_depend
		JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
		JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
		JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
		JOIN pg_namespace n on n.oid = dependee.relnamespace
		JOIN pg_namespace sn on sn.oid = dependent.relnamespace
		JOIN pg_attribute ON pg_depend.refobjid = pg_attribute.attrelid
			AND pg_depend.refobjsubid = pg_attribute.attnum
		WHERE dependent.relname = object
		AND sn.nspname = schema
	LOOP
		IF _r.relkind = 'v' OR _r.relkind = 'm' THEN
			-- RAISE NOTICE '2 dealing with  %.%', _r.nspname, _r.relname;
			PERFORM * FROM save_dependent_objects_for_replay(_r.nspname, _r.relname, dropit, doobjectdeps, tags, path);
			PERFORM schema_support.save_view_for_replay(_r.nspname, _r.relname, dropit, tags, path);
		END IF;
	END LOOP;
	IF doobjectdeps THEN
		PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);
		PERFORM schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'table', tags := tags, path := path);
	END IF;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql
SECURITY INVOKER;

--
-- given schema.object, save all triggers for replay
--
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;


--
-- given schema.object, look for all constraints to it outside of schema
--
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	newobject varchar DEFAULT NULL,
	newmap jsonb DEFAULT NULL,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
		    pg_get_constraintdef(otherside.oid, true) AS def,
		    otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
		    myside.nspname as mynspname, myside.relname as myrelname,
		    myside.cols as mycols, myside.conname as myconname
		FROM
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) otherside JOIN
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) myside ON myside.conrelid = otherside.confrelid
			    AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY DEFERRED';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- Saves view definition for replay later.  This is to allow for dropping
-- dependent functions and having a migration script recreate them.
--
-- Note this will drop and recreate all functions of the name.  This sh
--
CREATE OR REPLACE FUNCTION schema_support.save_function_for_replay(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT true,
	tags text[] DEFAULT NULL,
	path text[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, owner,
			ddl, idargs, tags, path
		) VALUES (
			_r.nspname, _r.proname, 'function', _r.owner,
			_r.funcdef, _r.idargs, tags, path
		);
		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _r.nspname || '.' ||
				_r.proname || '(' || _r.idargs || ');';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- If tags is set, replays just the rows with those tags
-- If object/schema are set, further refines to replay objects
-- if path is set, include objects that have input path in path
-- with those names.
--
CREATE OR REPLACE FUNCTION schema_support.replay_object_recreates(
	beverbose	boolean DEFAULT false,
	tags		text[] DEFAULT NULL,
	schema		text DEFAULT NULL,
	object		text DEFAULT NULL,
	type		text DEFAULT NULL,
	path		text DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
	_r		RECORD;
	_tally	integer;
    _origsp TEXT;
	_myrole TEXT;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	SHOW search_path INTO _origsp;

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	IF _tally > 0 THEN
		FOR _r in SELECT * from __recreate ORDER BY id DESC FOR UPDATE
		LOOP
			IF tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			IF schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN NOT _r.schema = schema;
			END IF;
			IF type IS NOT NULL THEN
				CONTINUE WHEN _r.type IS NULL;
				CONTINUE WHEN NOT _r.type = type;
			END IF;
			IF object IS NOT NULL THEN
				CONTINUE WHEN _r.object IS NULL;
				IF object ~ '^!' THEN
					object = regexp_replace(object, '^!', '');
					CONTINUE WHEN _r.object = object;
				ELSE
					CONTINUE WHEN NOT _r.object = object;
				END IF;
			END IF;

			IF beverbose THEN
				RAISE NOTICE 'Recreate % %.%', _r.type, _r.schema, _r.object;
			END IF;
			EXECUTE _r.ddl;
			EXECUTE 'SET search_path = ' || _r.schema || ',jazzhands';
			IF _r.owner is not NULL THEN
				IF _r.type = 'view' OR _r.type = 'materialized view' THEN
					EXECUTE 'ALTER ' || _r.type || ' ' || _r.schema || '.' || _r.object ||
						' OWNER TO ' || _r.owner || ';';
				ELSIF _r.type = 'function' THEN
					EXECUTE 'ALTER FUNCTION ' || _r.schema || '.' || _r.object ||
						'(' || _r.idargs || ') OWNER TO ' || _r.owner || ';';
				ELSE
					RAISE EXCEPTION 'Unable to recreate object for % ', _r;
				END IF;
			END IF;
			DELETE from __recreate where id = _r.id;
		END LOOP;

		SELECT count(*) INTO _tally from __recreate;

		IF _tally > 0 THEN
			IF tags IS NULL AND schema IS NULL and object IS NULL THEN
				RAISE EXCEPTION '% objects still exist for recreating after a complete loop', _tally;
			END IF;
		ELSE
			DROP TABLE __recreate;
		END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_object_recreates did NOT have anything to regrant!';
		END IF;
	END IF;

	EXECUTE 'SET search_path = ' || _origsp;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

------------------------------------------------------------------------------
-- BEGIN functions to undo audit rows
--
-- schema_support.undo_audit_row is the function that does all the work here;
-- the rest just are support routines
------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION schema_support.get_pk_columns(
	_schema		text,
	_table		text
) RETURNS text[] AS $$
DECLARE
	cols		text[];
	_r			RECORD;
BEGIN
	for _r IN SELECT a.attname
			FROM pg_class c
				INNER JOIN pg_namespace n on n.oid = c.relnamespace
				INNER JOIN pg_index i ON i.indrelid = c.oid
				INNER JOIN pg_attribute  a ON   a.attrelid = c.oid AND
								a.attnum = any(i.indkey)
			WHERE	c.relname = _table
			AND		n.nspname = _schema
			AND		indisprimary
	LOOP
		SELECT array_append(cols, _r.attname::text) INTO cols;
	END LOOP;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

--
-- given two relations, returns an array columns they have in common
--
-- runs the column names through quote_ident to ensure it is usable and
-- also will append ::text to adjust mismatches where one side or the other is
-- an enum to force both to text.
--
CREATE OR REPLACE FUNCTION schema_support.get_common_columns(
    _oldschema   TEXT,
    _table1      TEXT,
    _newschema   TEXT,
    _table2      TEXT
) RETURNS text[] AS $$
DECLARE
	_q			text;
    cols	text[];
BEGIN
    _q := 'WITH cols AS (
	SELECT  n.nspname as schema, c.relname as relation, a.attname as colname, t.typoutput as type,
		a.attnum
	    FROM    pg_catalog.pg_attribute a
		INNER JOIN pg_catalog.pg_class c
		    ON a.attrelid = c.oid
		INNER JOIN pg_catalog.pg_namespace n
		    ON c.relnamespace = n.oid
				INNER JOIN pg_catalog.pg_type t
					ON  t.oid = a.atttypid
	    WHERE   a.attnum > 0
	    AND   NOT a.attisdropped
	    ORDER BY a.attnum
       ) SELECT array_agg(colname ORDER BY attnum) as cols
	FROM ( SELECT CASE WHEN ( o.type::text ~ ''enum'' OR n.type::text ~ ''enum'')  AND o.type != n.type THEN concat(quote_ident(n.colname), ''::text'')
					ELSE quote_ident(n.colname)
					END  AS colname,
				o.attnum
			FROM cols  o
	    INNER JOIN cols n USING (colname)
		WHERE
			o.schema = $1
		and o.relation = $2
		and n.schema = $3
		and n.relation = $4
		) as prett
	';
	EXECUTE _q INTO cols USING _oldschema, _table1, _newschema, _table2;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION schema_support.get_columns(
	_schema		text,
	_table		text
) RETURNS text[] AS $$
DECLARE
	cols		text[];
	_r			record;
BEGIN
	FOR _r IN SELECT  a.attname as colname,
	    pg_catalog.format_type(a.atttypid, a.atttypmod) as coltype,
	    a.attnotnull, a.attnum
	FROM    pg_catalog.pg_attribute a
				INNER JOIN pg_class c on a.attrelid = c.oid
				INNER JOIN pg_namespace n on n.oid = c.relnamespace
	WHERE   c.relname = _table
		  AND	n.nspname = _schema
	  AND   a.attnum > 0
	  AND   NOT a.attisdropped
		  AND	lower(a.attname) not like 'data_%'
	ORDER BY a.attnum
	LOOP
		SELECT array_append(cols, _r.colname::text) INTO cols;
	END LOOP;
	RETURN cols;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.quote_ident_array(
	_input		text[]
) RETURNS text[] AS $$
DECLARE
	_rv		text[];
	x		text;
BEGIN
	FOREACH x IN ARRAY _input
	LOOP
		SELECT array_append(_rv, quote_ident(x)) INTO _rv;
	END LOOP;
	RETURN _rv;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-- Given a schema and table and (and and audit schema)
-- and some audit characteristics, undo the effects of the record
-- Note that this does not consider foreign keys, so the reply may fail
--
-- note also that the values are AND'd together, not OR'd
--
CREATE OR REPLACE FUNCTION schema_support.undo_audit_row(
	in_table		text,
	in_audit_schema	text DEFAULT 'audit',
	in_schema		text DEFAULT 'jazzhands',
	in_start_time	timestamp DEFAULT NULL,
	in_end_time		timestamp DEFAULT NULL,
	in_aud_user		text DEFAULT NULL,
	in_audit_ids	integer[] DEFAULT NULL,
	in_txids		bigint[] DEFAULT NULL
) RETURNS INTEGER AS $$
DECLARE
	tally	integer;
	pks		text[];
	cols	text[];
	q		text;
	val		text;
	x		text;
	_whcl	text;
	_eq		text;
	setstr	text;
	_r		record;
	_c		record;
	_br		record;
	_vals	text[];
BEGIN
	tally := 0;
	pks := schema_support.get_pk_columns(in_schema, in_table);
	cols := schema_support.get_columns(in_schema, in_table);
	q = '';
	IF in_start_time is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#timestamp') || ' >= ' || quote_literal(in_start_time);
	END IF;
	IF in_end_time is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#timestamp') || ' <= ' || quote_literal(in_end_time);
	END IF;
	IF in_aud_user is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#user') || ' = ' || quote_literal(in_aud_user);
	END IF;
	IF in_audit_ids is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#seq') || ' = ANY (in_audit_ids)';
	END IF;
	IF in_audit_ids is not NULL THEN
		IF q = '' THEN
			q := q || 'WHERE ';
		ELSE
			q := q || 'AND ';
		END IF;
		q := q || quote_ident('aud#txid') || ' = ANY (in_txids)';
	END IF;

	-- Iterate over all the rows that need to be replayed
	q := 'SELECT * from ' || quote_ident(in_audit_schema) || '.' ||
			quote_ident(in_table) || ' ' || q || ' ORDER BY "aud#seq" desc';
	FOR _r IN EXECUTE q
	LOOP
		IF _r."aud#action" = 'DEL' THEN
			-- Build up a list of rows that need to be inserted
			_vals = NULL;
			FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
			LOOP
				IF _c.key !~ 'data|aud' THEN
					IF _c.value IS NULL THEN
						SELECT array_append(_vals, 'NULL') INTO _vals;
					ELSE
						SELECT array_append(_vals, quote_literal(_c.value)) INTO _vals;
					END IF;
				END IF;
			END LOOP;
			_eq := 'INSERT INTO ' || quote_ident(in_schema) || '.' ||
				quote_ident(in_table) || ' ( ' ||
				array_to_string(
					schema_support.quote_ident_array(cols), ',') ||
					') VALUES (' ||  array_to_string(_vals, ',', NULL) || ')';
		ELSIF _r."aud#action" in ('INS', 'UPD') THEN
			-- Build up a where clause for this table to get a unique row
			-- based on the primary key
			FOREACH x IN ARRAY pks
			LOOP
				_whcl := '';
				FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
				LOOP
					IF _c.key = x THEN
						IF _whcl != '' THEN
							_whcl := _whcl || ', ';
						END IF;
						IF _c.value IS NULL THEN
							_whcl = _whcl || quote_ident(_c.key) || ' = NULL ';
						ELSE
							_whcl = _whcl || quote_ident(_c.key) || ' =  ' ||
								quote_nullable(_c.value);
						END IF;
					END IF;
				END LOOP;
			END LOOP;

			IF _r."aud#action" = 'INS' THEN
				_eq := 'DELETE FROM ' || quote_ident(in_schema) || '.' ||
					quote_ident(in_table) || ' WHERE ' || _whcl;
			ELSIF _r."aud#action" = 'UPD' THEN
				-- figure out what rows have changed and do an update if
				-- they have.  NOTE:  This may result in no change being
				-- replayed if a row did not actually change
				setstr = '';
				FOR _c IN SELECT * FROM json_each_text( row_to_json(_r) )
				LOOP
					--
					-- Iterate over all the columns and if they have changed,
					-- then build an update statement
					--
					IF _c.key !~ 'aud#|data_(ins|upd)_(user|date)' THEN
						EXECUTE 'SELECT ' || _c.key || ' FROM ' ||
							quote_ident(in_schema) || '.' ||
								quote_ident(in_table)  ||
							' WHERE ' || _whcl
							INTO val;
						IF ( _c.value IS NULL  AND val IS NOT NULL) OR
							( _c.value IS NOT NULL AND val IS NULL) OR
							(_c.value::text NOT SIMILAR TO val::text) THEN
							IF char_length(setstr) > 0 THEN
								setstr = setstr || ',
								';
							END IF;
							IF _c.value IS NOT  NULL THEN
								setstr = setstr || _c.key || ' = ' ||
									quote_nullable(_c.value) || ' ' ;
							ELSE
								setstr = setstr || _c.key || ' = ' ||
									' NULL ' ;
							END IF;
						END IF;
					END IF;
				END LOOP;
				IF char_length(setstr) > 0 THEN
					_eq := 'UPDATE ' || quote_ident(in_schema) || '.' ||
						quote_ident(in_table) ||
						' SET ' || setstr || ' WHERE ' || _whcl;
				END IF;
			END IF;
		END IF;
		IF _eq IS NOT NULL THEN
			tally := tally + 1;
			RAISE NOTICE '%', _eq;
			EXECUTE _eq;
		END IF;
	END LOOP;
	RETURN tally;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;
------------------------------------------------------------------------------
-- DONE functions to undo audit rows
------------------------------------------------------------------------------

------------------------------------------------------------------------------
-- START  schema_support.retrieve_functions
--
-- function that returns, and optionally drops all functions of a given
-- name in a schema, regardless of arguments.  The return array can be used
-- to operate on the objects if needed (enough to uniquely id the function)
--
--
CREATE OR REPLACE FUNCTION schema_support.retrieve_functions(
	schema varchar,
	object varchar,
	dropit boolean DEFAULT false
) RETURNS TEXT[] AS $$
DECLARE
	_r		RECORD;
	_fn		TEXT;
	_cmd	TEXT;
	_rv		TEXT[];
	_myrole TEXT;
BEGIN
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		_fn = _r.nspname || '.' || _r.proname || '(' || _r.idargs || ')';
		_rv = _rv || _fn;

		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _fn || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
	RETURN _rv;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

-- DONE  schema_support.retrieve_functions
------------------------------------------------------------------------------


----------------------------------------------------------------------------
--
-- returns true if all common colloms match between two simple relations
-- (define as containing common column that can be auto-converted to text)
--
-- returns false if not.  RAISE NOTICE all problems
--
-- Can raise an exception if desired.
--
-- Usage:
-- SELECT schema_support.relation_diff(
--	schema				- schema name of both objects
--	old_rel				- old relation name
--	new_rel				- new relation name
--	key_relation		- relation to extract pks from
--							- if not set, then defaults to old_rel
--							- will eventually be set to the one that's a table
--	prikeys				- which keys should be considered pks.  can be grabbed
--							based on key_relation; this one always wins
--	raise_exception		- raise an exception on mismatch


create or replace function schema_support.relation_diff(
	schema			text,
	old_rel			text,
	new_rel		text,
	key_relation	text DEFAULT NULL,
	prikeys			text[] DEFAULT NULL,
	raise_exception boolean DEFAULT true
) returns boolean AS
$$
DECLARE
	_r		RECORD;
	_t1		integer;
	_t2		integer;
	_cnt	integer;
	_cols	TEXT[];
	_pkcol	TEXT[];
	_q		TEXT;
	_f		TEXT;
	_c		RECORD;
	_w		TEXT[];
	_ctl		TEXT[];
	_rv	boolean;
	_oj		jsonb;
	_nj		jsonb;
	_oldschema	TEXT;
	_newschema	TEXT;
BEGIN
	IF old_rel ~ '\.' THEN
		_oldschema := regexp_replace(old_rel, '\..*$', '');
		old_rel := regexp_replace(old_rel, '^[^\.]*\.', '');
	ELSE
		_oldschema:= schema;
	END IF;

	IF new_rel ~ '\.' THEN
		_newschema := regexp_replace(new_rel, '\..*$', '');
		new_rel := regexp_replace(new_rel, '^[^\.]*\.', '');
	ELSE
		_newschema:= schema;
	END IF;

	RAISE NOTICE '% % % %', _oldschema, old_rel, _newschema, new_rel;

	-- do a simple row count
	EXECUTE 'SELECT count(*) FROM ' || _oldschema || '."' || old_rel || '"' INTO _t1;
	EXECUTE 'SELECT count(*) FROM ' || _newschema || '."' || new_rel || '"' INTO _t2;

	_rv := true;

	IF _t1 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, old_rel;
		_rv := false;
	END IF;
	IF _t2 IS NULL THEN
		RAISE NOTICE 'table %.% does not seem to exist', _oldschema, new_rel;
		_rv := false;
	END IF;

	IF prikeys IS NULL THEN
		-- read into prikeys the primary key for the table
		IF key_relation IS NULL THEN
			key_relation := old_rel;
		END IF;
		prikeys := schema_support.get_pk_columns(_oldschema, key_relation);
	END IF;

	-- read into _cols the column list in common between old_rel and new_rel
	_cols := schema_support.get_common_columns(_oldschema, old_rel, _newschema, new_rel);

	_ctl := NULL;
	FOREACH _f IN ARRAY prikeys
	LOOP
		SELECT array_append(_ctl, quote_ident(_f) ) INTO _ctl;
	END LOOP;
	_pkcol := _ctl;

	--
	-- Number of rows mismatch.  Show the missing rows based on the
	-- primary key.
	--
	IF _t1 != _t2 THEN
		RAISE NOTICE 'table % has % rows; table % has % rows (%)', old_rel, _t1, new_rel, _t2, _t1 - _t2;
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InOld/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	_q := 'SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
		quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
		' WHERE (' || array_to_string(_pkcol,',') || ') IN ( ' ||
			' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel)  ||
			' EXCEPT ( '
				' SELECT ' || array_to_string(_pkcol,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel)  ||
			' )) ';

	_cnt := 0;
	FOR _r IN EXECUTE 'SELECT row_to_json(x) as r FROM (' || _q || ') x'
	LOOP
		RAISE NOTICE 'InNew/%: %', _cnt, _r;
		_cnt := _cnt + 1;
	END LOOP;

	IF _cnt > 0  THEN
		_rv := false;
	END IF;

	IF NOT _rv THEN
		IF raise_exception THEN
			RAISE EXCEPTION 'Relations do not match';
		END IF;
		RETURN false;
	END IF;

	-- At this point, the same number of rows appear in both, so need to
	-- figure out rows that are different between them.

	-- SELECT row_to_json(o) as old, row_to_json(n) as new
	-- FROM ( SELECT cols FROM old WHERE prikeys in Vv ) old,
	-- JOIN ( SELECT cols FROM new WHERE prikeys in Vv ) new
	-- USING (prikeys);
	-- WHERE (prikeys) IN
	-- ( SELECT  prikeys FROM (
	--		( SELECT cols FROM old EXCEPT ( SELECT cols FROM new ) )
	-- ))

	_q := ' SELECT row_to_json(old) as old, row_to_json(new) as new FROM ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_oldschema) || '.' || quote_ident(old_rel) || ' ) old ' ||
		' JOIN ' ||
		'( SELECT '  || array_to_string(_cols,',') || ' FROM ' ||
			quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' ) new ' ||
		' USING ( ' ||  array_to_string(_pkcol,',') ||
		' ) WHERE (' || array_to_string(_pkcol,',') || ' ) IN (' ||
		'SELECT ' || array_to_string(_pkcol,',')  || ' FROM ( ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_oldschema) || '.' || quote_ident(old_rel) ||
			' EXCEPT ' ||
			'( SELECT ' || array_to_string(_cols,',') || ' FROM ' ||
				quote_ident(_newschema) || '.' || quote_ident(new_rel) || ' )) ' ||
		' ) subq) ORDER BY ' || array_to_string(_pkcol,',')
	;

	_t1 := 0;
	FOR _r IN EXECUTE _q
	LOOP
		_t1 := _t1 + 1;
		FOR _f IN SELECT json_object_keys(_r.new)
		LOOP
			IF _f = ANY ( prikeys ) OR _r.old->>_f IS DISTINCT FROM _r.new->>_f
			THEN
				IF _oj IS NULL THEN
					_oj := jsonb_build_object(_f, _r.old->>_f);
					_nj := jsonb_build_object(_f, _r.new->>_f);
				ELSE
					_oj := _oj || jsonb_build_object(_f, _r.old->>_f);
					_nj := _nj || jsonb_build_object(_f, _r.new->>_f);
				END IF;
			END IF;
		END LOOP;
		RAISE NOTICE 'mismatched row:';
		RAISE NOTICE 'OLD: %', _oj;
		RAISE NOTICE 'NEW: %', _nj;
		_rv := false;
	END LOOP;


	IF NOT _rv AND raise_exception THEN
		RAISE EXCEPTION 'Relations do not match (% rows)', _t1;
	ELSE
		RAISE NOTICE '% rows mismatch', _t1;
	END IF;
	return _rv;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------------
-- BEGIN materialized view refresh automation support
----------------------------------------------------------------------------
--
-- These functions are used to better automate refreshing of materialized
-- views.  They are meant to be called by the schema owners and not by
-- mere mortals, which may mean writing wrapper functions
--
-- schema_support.relation_last_changed(table,schema,debug) can be used to
--	tell the last time a table, view or materialized view was updated
--	based on audit tables.  For views and materialized views, it will
--	recursively rifle through dependent tables to find the answer. Note
--	that if a dependency does not have an audit table (such as another
--	materialized view or caching/log table), the functions will just
--	assume they are current.
--
--	Also note that the recursive check is not terribly smart, so if
--	dependant tables had data changed that was not in the object that
--	called it, it will still trigger yes even if the view didn't really
--	change.
--
-- mv_last_updated()/set_mv_last_updated() are largely used internally.
--
-- schema_support.refresh_mv_if_needed(table,schema,debug) is used to
--	refresh a materialized view if tables internal to schema_support
--	reflect that it has not refreshed since the dependant objects were
--	refreshed.  There appears to be no place in the system catalog to
--	tell when a materialized view was last changed, so if the internal
--	tables are out of date, a refresh could happen.
--
--	Note that calls to this in different transactions will block, thus
--	if two things go to rebuild, they will happen serially.  In that
--	case, if there are no changes in a blocking transaction, the code
--	is arranged such that it will return immediately and not try to
--	rebuild the materialized view, so this should result in less churn.

--
-- refiles through internal tables to figure out when an mv or similar was
-- updated; runs as DEFINER to hide objects.
--
CREATE OR REPLACE FUNCTION schema_support.mv_last_updated (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	rv	timestamp;
BEGIN
	IF debug THEN
		RAISE NOTICE 'schema_support.mv_last_updated(): selecting for update...';
	END IF;

	SELECT	refresh
	INTO	rv
	FROM	schema_support.mv_refresh r
	WHERE	r.schema = mv_last_updated.schema
	AND	r.view = relation
	FOR UPDATE;

	IF debug THEN
		RAISE NOTICE 'schema_support.mv_last_updated(): returning %', rv;
	END IF;

	RETURN rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY DEFINER;

--
-- updates internal tables to set last update.
-- runs as DEFINER to hide objects.
--
CREATE OR REPLACE FUNCTION schema_support.set_mv_last_updated (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	whence timestamp DEFAULT now(),
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	rv	timestamp;
BEGIN
	INSERT INTO schema_support.mv_refresh AS r (
		schema, view, refresh
	) VALUES (
		set_mv_last_updated.schema, relation, whence
	) ON CONFLICT ON CONSTRAINT mv_refresh_pkey DO UPDATE
		SET		refresh = whence
		WHERE	r.schema = set_mv_last_updated.schema
		AND		r.view = relation
	;

	RETURN rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY DEFINER;

--
-- figures out the last time an object changed based on the audit tables
-- for the object.  This assumes that the schema -> audit mapping is found
-- in schema_support.schema_audit_map, otherwise raises an exception.
--
CREATE OR REPLACE FUNCTION schema_support.relation_last_changed (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands_legacy',
	debug boolean DEFAULT false
) RETURNS TIMESTAMP AS $$
DECLARE
	audsch	text;
	rk	char;
	rv	timestamp;
	ts	timestamp;
	obj	text;
	objaud text;
	objkind text;
	objschema text;
BEGIN
	SELECT	audit_schema
	INTO	audsch
	FROM	schema_support.schema_audit_map m
	WHERE	m.schema = relation_last_changed.schema;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Schema % not configured for this', schema;
	END IF;

	SELECT	relkind
	INTO	rk
	FROM	pg_catalog.pg_class c
		JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE	n.nspname = relation_last_changed.schema
	AND	c.relname = relation_last_changed.relation;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'No such object %.%', schema, relation;
	END IF;

	IF rk = 'r' THEN
		EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
			FROM '||quote_ident(audsch)||'.'|| quote_ident(relation)
		INTO rv;
		IF rv IS NULL THEN
			EXECUTE '
				SELECT	max("aud#timestamp")
				FROM	'||quote_ident(audsch)||'.'||quote_ident(relation)
			INTO rv;
		END IF;

		IF rv IS NULL THEN
			RETURN '-infinity'::timestamp;
		ELSE
			RETURN rv;
		END IF;
	END IF;

	IF rk = 'v' OR rk = 'm' THEN
		FOR obj,objaud,objkind, objschema IN WITH RECURSIVE recur AS (
		SELECT distinct rewrite.ev_class as root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		    JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE c.relname = relation
		AND n.nspname = relation_last_changed.schema
		AND d.refobjsubid > 0
	    UNION ALL
		SELECT recur.root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		JOIN recur ON recur.oid = rewrite.ev_class
		AND d.refobjsubid > 0
		AND c.relkind != 'm'
	    ), list AS ( select distinct m.audit_schema, c.relname, c.relkind, n.nspname as relschema, recur.*
		FROM pg_class c
		    JOIN recur on recur.oid = c.oid
		    JOIN pg_namespace n on c.relnamespace = n.oid
		    JOIN schema_support.schema_audit_map m
			ON m.schema = n.nspname
		WHERE relkind IN ('r', 'm')
		) SELECT relname, audit_schema, relkind, relschema from list
		LOOP
			-- if there is no audit table, assume its kept current.  This is
			-- likely some sort of cache table.  XXX - should probably be
			-- updated to use the materialized view update bits
			BEGIN
				IF objkind = 'r' THEN
					EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
						FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) ||'
						WHERE "aud#timestamp" > (
								SELECT max("aud#timestamp")
								FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) || '
							) - ''10 day''::interval'
						INTO ts;
					IF ts IS NULL THEN
						EXECUTE 'SELECT max("aud#timestamp")
							FROM '||quote_ident(objaud)||'.'|| quote_ident(obj)
							INTO ts;
					END IF;
				ELSIF objkind = 'm' THEN
					SELECT refresh INTO ts FROM schema_support.mv_refresh m WHERE m.schema = objschema
						AND m.view = obj;
				ELSE
					RAISE NOTICE 'Unknown object kind % for %.%', objkind, objaud, obj;
				END IF;
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): %.% -> %', objaud, obj, ts;
				END IF;
				IF rv IS NULL OR ts > rv THEN
					rv := ts;
				END IF;
			EXCEPTION WHEN undefined_table THEN
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): skipping %.%', schema, obj;
				END IF;
			END;
		END LOOP;
		RETURN rv;
	END IF;

	RAISE EXCEPTION 'Unable to process relkind %', rk;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;

CREATE OR REPLACE FUNCTION schema_support.refresh_mv_if_needed (
	relation TEXT,
	schema TEXT DEFAULT 'jazzhands',
	debug boolean DEFAULT false
) RETURNS void AS $$
DECLARE
	lastref	timestamp;
	lastdat	timestamp;
	whence	timestamp;
BEGIN
	SELECT coalesce(schema_support.mv_last_updated(relation, schema,debug),'-infinity') INTO lastref;
	SELECT coalesce(schema_support.relation_last_changed(relation, schema,debug),'-infinity') INTO lastdat;
	IF lastdat > lastref THEN
		IF debug THEN
			RAISE NOTICE 'schema_support.refresh_mv_if_needed(): refreshing %.%', schema, relation;
		END IF;
		EXECUTE 'REFRESH MATERIALIZED VIEW ' || quote_ident(schema)||'.'||quote_ident(relation);
		--  This can happen with long running transactions.
		whence := now();
		IF lastref > whence THEN
			whence := lastref;
		END IF;
		PERFORM schema_support.set_mv_last_updated(relation, schema, whence, debug);
	END IF;
	RETURN;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;


--
-- This migrates grants from one schema to another for setting up a shadow
-- schema for dealing with migrations.  It still needs to handle functions.
--
-- It also ignores sequences because those really need to move to IDENTITY
-- columns anyway. and sequences are really part of the shadow schema stuff.
--
CREATE OR REPLACE FUNCTION schema_support.migrate_grants (
	username	TEXT,
	direction	TEXT,
	old_schema	TEXT DEFAULT 'jazzhands_legacy',
	new_schema	TEXT DEFAULT 'jazzhands'
) RETURNS TEXT[] AS $$
DECLARE
	_rv	TEXT[];
	_r	RECORD;
	_q	TEXT;
BEGIN
	IF lower(direction) NOT IN ('grant','revoke') THEN
		RAISE EXCEPTION 'direction must be grant or revoke';
	END IF;

	FOR _r IN
		WITH x AS (
		SELECT *
			FROM (
		SELECT oid, schema, name,  typ,
			p->>'privilege_type' as privilege_type,
			col,
			r.usename as grantor, e.usename as grantee,
			r.usesysid as rid,  e.usesysid as eid,
			e.useconfig
		FROM (
			SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
				NULL::text as col,
			to_jsonb(pg_catalog.aclexplode(acl := c.relacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
		UNION ALL
		SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
			a.attname as col,
			to_jsonb(pg_catalog.aclexplode(a.attacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
				ON a.attrelid = c.oid
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
			AND a.attacl IS NOT NULL
		) x
		LEFT JOIN pg_user r ON r.usesysid = (p->>'grantor')::oid
		LEFT JOIN pg_user e ON e.usesysid = (p->>'grantee')::oid
		) i
		) select *
		FROM x
		WHERE ( schema = old_schema )
		AND grantee = username
		AND typ IN ('table', 'view', 'mview', 'foreign table')
		order by name, col
	LOOP
		IF _r.col IS NOT NULL THEN
			_q = concat(' (', _r.col, ') ');
		ELSE
			_q := NULL;
		END IF;
		IF lower(direction) = 'grant' THEN
			_q := concat('GRANT ', _r.privilege_type, _q, ' ON ', new_schema, '.', _r.name, ' TO ', _r.grantee);
		ELSIF lower(direction) = 'revoke' THEN
			_q := concat('REVOKE ', _r.privilege_type, _q, ' ON ', old_schema, '.', _r.name, ' FROM ', _r.grantee);
		END IF;


		_rv := array_append(_rv, _q);
		EXECUTE _q;
	END LOOP;
	RETURN _rv;
END;
$$
SET search_path=schema_support
LANGUAGE plpgsql SECURITY INVOKER;



----------------------------------------------------------------------------
-- END materialized view support
----------------------------------------------------------------------------

/**************************************************************
 *  FUNCTIONS

schema_support.begin_maintenance

	- ensures you are running in a transaction
	- ensures you are a superuser (based on argument)

schema_support.end_maintenance
	- revokes superuser from running user (based on argument)


This:
	schema_support.migrate_grants is used to deal with setting up
	shadow schemas for migrations and removing/adding permissions as
	things are moving.

These will save an object for replay, including presering grants
automatically:

SELECT schema_support.save_function_for_replay('jazzhands', 'fncname');
	- saves all function of a given name

SELECT schema_support.save_view_for_replay('jazzhands',  'mytableorview');
	- saves a view includling triggers on the view, for replay

SELECT schema_support.save_constraint_for_replay('jazzhands', 'table');
	- saves constraints pointing to an object for replay

SELECT schema_support.save_trigger_for_replay('jazzhands', 'relation');
	- save triggers poinging to an object for replay

SELECT schema_support.save_dependent_objects_for_replay(schema, object)

This will take an option (relation[table/view] or procedure) and figure
out what depends on it, and save the ddl to recreate tehm.

NOTE:  This does not always handle constraints well. (bug, needs to be fixed)
Right now you may also need to call schema_support.save_constraint_for_replay.

NOTE:  All of the aforementioned tables take an optional boolean argument
at the end.  That argument defaults to true and indicates whether or not
the object shouldbe dropped after saveing grants and other info

==== GRANTS ===

This will save grants for later relay on a relation (view, table) or proc:

select schema_support.save_grants_for_replay('jazzhands', 'physical_port');
select schema_support.save_grants_for_replay('port_support',
	'do_l1_connection_update');

NOTE:  It saves the grants of stored procedures based on the arguments
passed in, so if you change those, you need to update the definitions in
__regrants (or __recreates)  before replying them.

NOTE:  These procedures end up losing who did the grants originally

THESE:

	SELECT schema_support.replay_object_recreates();
	SELECT schema_support.replay_saved_grants();

will replay object creations and grants on them respectively.  They should
be called in that order at the end of a maintenance script

THIS:
	schema_support.undo_audit_row()

will build and execute a statement to undo changes made in an audit table
against the current state.  It executes the queries in reverse order from
execution so in theory can undo every operation on a table if called without
restriction.  It does not cascade or otherwise do anything with foreign keys.


These setup triggers for the data_{ins,upd}_{user,date} columns on tables

select schema_support.rebuild_stamp_triggers();


Building and manipulating audit tables:

	schema_support.build_audit_table_pkak_indexes (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_table_other_indexes (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_table (aud_schema, tbl_schema, table_name)
	schema_support.build_audit_tables (aud_schema, tbl_schema)

These are used to build various bits about audit tables.
schema_support.build_audit_tables() is just a wrapper that
loops through the list of tables in tbl_schema and runs
schema_support.build_audit_table().  Arguably, the system needs a method
to mark tables as exempt.

schema_support.build_audit_table() also calls table_pkak_indexes().  So
schema_support.build_audit_there is generally no reason to call that.

schema_support.build_audit_table_other_indexes() mirrors all the indexes on
the base table on the audit table and names them the same.  Note that the
rebuild commands DO NOT mirror these (yet).  This should arguably be
considered a bug...

Rebuilding audit tables:

	schema_support.rebuild_audit_trigger(aud_schema, tbl_schema table_name)
	schema_support.rebuild_audit_table(aud_schema, tbl_schema, table_name)

	schema_support.rebuild_audit_tables(aud_schema, tbl_schema)
	schema_support.rebuild_audit_triggers(aud_schema, tbl_schema);

These all work together but can be called individually.
schema_support.rebuild_audit_tables is generally the interface and will
iterate though every base table that has an audit table.
schema_support.rebuild_audit_tables() will also preserve grants and views
on top of the objects via functions in here, which the individual ones do not
do.  This should arguably be changed.

**************************************************************/


-- END Misc that does not apply to above


-- BEGIN Misc that does not apply to above

--
-- running this again to get the new one...
--
SELECT schema_support.begin_maintenance();
select clock_timestamp(), now(), clock_timestamp() - now() AS len;


-- END Misc that does not apply to above
--
-- BEGIN: process_ancillary_schema(schema_support)
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'begin_maintenance');
SELECT schema_support.save_grants_for_replay('schema_support', 'begin_maintenance');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.begin_maintenance ( boolean );
CREATE OR REPLACE FUNCTION schema_support.begin_maintenance(shouldbesuper boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper	boolean;
	_tally	integer;
BEGIN
	IF shouldbesuper THEN
		SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
		IF issuper IS false THEN
			PERFORM groname, rolname
			FROM (
				SELECT groname, unnest(grolist) AS oid
				FROM pg_group ) g
			JOIN pg_roles r USING (oid)
			WHERE groname = 'dba'
			AND rolname = current_user;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'User must be a super user or have the dba role';
			END IF;
		END IF;
	END IF;
	-- Not sure how reliable this is.
	-- http://www.postgresql.org/docs/9.3/static/monitoring-stats.html
	SELECT count(*)
	  INTO _tally
	  FROM	pg_stat_activity
	 WHERE	pid = pg_backend_pid()
	   AND	query_start = xact_start;
	IF _tally > 0 THEN
		RAISE EXCEPTION 'Must run maintenance in a transaction.';
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--
	CREATE TEMPORARY TABLE __owner_before_stats (
		username					TEXT,
		before_views_count			INTEGER,
		before_func_count		INTEGER,
		before_key_count	INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_before_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	RETURN true;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('begin_maintenance');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('begin_maintenance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc begin_maintenance failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'end_maintenance (  )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.end_maintenance (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'migrate_grants');
SELECT schema_support.save_grants_for_replay('schema_support', 'migrate_grants');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.migrate_grants ( text,text,text,text );
CREATE OR REPLACE FUNCTION schema_support.migrate_grants(username text, direction text, old_schema text DEFAULT 'jazzhands_legacy'::text, new_schema text DEFAULT 'jazzhands'::text)
 RETURNS text[]
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_rv	TEXT[];
	_r	RECORD;
	_q	TEXT;
BEGIN
	IF lower(direction) NOT IN ('grant','revoke') THEN
		RAISE EXCEPTION 'direction must be grant or revoke';
	END IF;

	FOR _r IN
		WITH x AS (
		SELECT *
			FROM (
		SELECT oid, schema, name,  typ,
			p->>'privilege_type' as privilege_type,
			col,
			r.usename as grantor, e.usename as grantee,
			r.usesysid as rid,  e.usesysid as eid,
			e.useconfig
		FROM (
			SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
				NULL::text as col,
			to_jsonb(pg_catalog.aclexplode(acl := c.relacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
		UNION ALL
		SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
			a.attname as col,
			to_jsonb(pg_catalog.aclexplode(a.attacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
				ON a.attrelid = c.oid
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
			AND a.attacl IS NOT NULL
		) x
		LEFT JOIN pg_user r ON r.usesysid = (p->>'grantor')::oid
		LEFT JOIN pg_user e ON e.usesysid = (p->>'grantee')::oid
		) i
		) select *
		FROM x
		WHERE ( schema = old_schema )
		AND grantee = username
		AND typ IN ('table', 'view', 'mview', 'foreign table')
		order by name, col
	LOOP
		IF _r.col IS NOT NULL THEN
			_q = concat(' (', _r.col, ') ');
		ELSE
			_q := NULL;
		END IF;
		IF lower(direction) = 'grant' THEN
			_q := concat('GRANT ', _r.privilege_type, _q, ' ON ', new_schema, '.', _r.name, ' TO ', _r.grantee);
		ELSIF lower(direction) = 'revoke' THEN
			_q := concat('REVOKE ', _r.privilege_type, _q, ' ON ', old_schema, '.', _r.name, ' FROM ', _r.grantee);
		END IF;


		_rv := array_append(_rv, _q);
		EXECUTE _q;
	END LOOP;
	RETURN _rv;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('migrate_grants');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('migrate_grants');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc migrate_grants failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'relation_last_changed');
SELECT schema_support.save_grants_for_replay('schema_support', 'relation_last_changed');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.relation_last_changed ( text,text,boolean );
CREATE OR REPLACE FUNCTION schema_support.relation_last_changed(relation text, schema text DEFAULT 'jazzhands_legacy'::text, debug boolean DEFAULT false)
 RETURNS timestamp without time zone
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	audsch	text;
	rk	char;
	rv	timestamp;
	ts	timestamp;
	obj	text;
	objaud text;
	objkind text;
	objschema text;
BEGIN
	SELECT	audit_schema
	INTO	audsch
	FROM	schema_support.schema_audit_map m
	WHERE	m.schema = relation_last_changed.schema;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Schema % not configured for this', schema;
	END IF;

	SELECT	relkind
	INTO	rk
	FROM	pg_catalog.pg_class c
		JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE	n.nspname = relation_last_changed.schema
	AND	c.relname = relation_last_changed.relation;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'No such object %.%', schema, relation;
	END IF;

	IF rk = 'r' THEN
		EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
			FROM '||quote_ident(audsch)||'.'|| quote_ident(relation)
		INTO rv;
		IF rv IS NULL THEN
			EXECUTE '
				SELECT	max("aud#timestamp")
				FROM	'||quote_ident(audsch)||'.'||quote_ident(relation)
			INTO rv;
		END IF;

		IF rv IS NULL THEN
			RETURN '-infinity'::timestamp;
		ELSE
			RETURN rv;
		END IF;
	END IF;

	IF rk = 'v' OR rk = 'm' THEN
		FOR obj,objaud,objkind, objschema IN WITH RECURSIVE recur AS (
		SELECT distinct rewrite.ev_class as root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		    JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE c.relname = relation
		AND n.nspname = relation_last_changed.schema
		AND d.refobjsubid > 0
	    UNION ALL
		SELECT recur.root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		JOIN recur ON recur.oid = rewrite.ev_class
		AND d.refobjsubid > 0
		AND c.relkind != 'm'
	    ), list AS ( select distinct m.audit_schema, c.relname, c.relkind, n.nspname as relschema, recur.*
		FROM pg_class c
		    JOIN recur on recur.oid = c.oid
		    JOIN pg_namespace n on c.relnamespace = n.oid
		    JOIN schema_support.schema_audit_map m
			ON m.schema = n.nspname
		WHERE relkind IN ('r', 'm')
		) SELECT relname, audit_schema, relkind, relschema from list
		LOOP
			-- if there is no audit table, assume its kept current.  This is
			-- likely some sort of cache table.  XXX - should probably be
			-- updated to use the materialized view update bits
			BEGIN
				IF objkind = 'r' THEN
					EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
						FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) ||'
						WHERE "aud#timestamp" > (
								SELECT max("aud#timestamp")
								FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) || '
							) - ''10 day''::interval'
						INTO ts;
					IF ts IS NULL THEN
						EXECUTE 'SELECT max("aud#timestamp")
							FROM '||quote_ident(objaud)||'.'|| quote_ident(obj)
							INTO ts;
					END IF;
				ELSIF objkind = 'm' THEN
					SELECT refresh INTO ts FROM schema_support.mv_refresh m WHERE m.schema = objschema
						AND m.view = obj;
				ELSE
					RAISE NOTICE 'Unknown object kind % for %.%', objkind, objaud, obj;
				END IF;
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): %.% -> %', objaud, obj, ts;
				END IF;
				IF rv IS NULL OR ts > rv THEN
					rv := ts;
				END IF;
			EXCEPTION WHEN undefined_table THEN
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): skipping %.%', schema, obj;
				END IF;
			END;
		END LOOP;
		RETURN rv;
	END IF;

	RAISE EXCEPTION 'Unable to process relkind %', rk;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('relation_last_changed');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('relation_last_changed');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc relation_last_changed failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'replay_object_recreates');
SELECT schema_support.save_grants_for_replay('schema_support', 'replay_object_recreates');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.replay_object_recreates ( boolean,text[],text,text,text,text );
CREATE OR REPLACE FUNCTION schema_support.replay_object_recreates(beverbose boolean DEFAULT false, tags text[] DEFAULT NULL::text[], schema text DEFAULT NULL::text, object text DEFAULT NULL::text, type text DEFAULT NULL::text, path text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
    _origsp TEXT;
	_myrole TEXT;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	SHOW search_path INTO _origsp;

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	IF _tally > 0 THEN
		FOR _r in SELECT * from __recreate ORDER BY id DESC FOR UPDATE
		LOOP
			IF tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			IF schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN NOT _r.schema = schema;
			END IF;
			IF type IS NOT NULL THEN
				CONTINUE WHEN _r.type IS NULL;
				CONTINUE WHEN NOT _r.type = type;
			END IF;
			IF object IS NOT NULL THEN
				CONTINUE WHEN _r.object IS NULL;
				IF object ~ '^!' THEN
					object = regexp_replace(object, '^!', '');
					CONTINUE WHEN _r.object = object;
				ELSE
					CONTINUE WHEN NOT _r.object = object;
				END IF;
			END IF;

			IF beverbose THEN
				RAISE NOTICE 'Recreate % %.%', _r.type, _r.schema, _r.object;
			END IF;
			EXECUTE _r.ddl;
			EXECUTE 'SET search_path = ' || _r.schema || ',jazzhands';
			IF _r.owner is not NULL THEN
				IF _r.type = 'view' OR _r.type = 'materialized view' THEN
					EXECUTE 'ALTER ' || _r.type || ' ' || _r.schema || '.' || _r.object ||
						' OWNER TO ' || _r.owner || ';';
				ELSIF _r.type = 'function' THEN
					EXECUTE 'ALTER FUNCTION ' || _r.schema || '.' || _r.object ||
						'(' || _r.idargs || ') OWNER TO ' || _r.owner || ';';
				ELSE
					RAISE EXCEPTION 'Unable to recreate object for % ', _r;
				END IF;
			END IF;
			DELETE from __recreate where id = _r.id;
		END LOOP;

		SELECT count(*) INTO _tally from __recreate;

		IF _tally > 0 THEN
			IF tags IS NULL AND schema IS NULL and object IS NULL THEN
				RAISE EXCEPTION '% objects still exist for recreating after a complete loop', _tally;
			END IF;
		ELSE
			DROP TABLE __recreate;
		END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_object_recreates did NOT have anything to regrant!';
		END IF;
	END IF;

	EXECUTE 'SET search_path = ' || _origsp;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('replay_object_recreates');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('replay_object_recreates');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc replay_object_recreates failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'replay_saved_grants');
SELECT schema_support.save_grants_for_replay('schema_support', 'replay_saved_grants');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.replay_saved_grants ( boolean,text,text );
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(beverbose boolean DEFAULT false, schema text DEFAULT NULL::text, tags text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('replay_saved_grants');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('replay_saved_grants');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc replay_saved_grants failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'retrieve_functions');
SELECT schema_support.save_grants_for_replay('schema_support', 'retrieve_functions');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.retrieve_functions ( character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.retrieve_functions(schema character varying, object character varying, dropit boolean DEFAULT false)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_fn		TEXT;
	_cmd	TEXT;
	_rv		TEXT[];
	_myrole TEXT;
BEGIN
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		_fn = _r.nspname || '.' || _r.proname || '(' || _r.idargs || ')';
		_rv = _rv || _fn;

		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _fn || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
	RETURN _rv;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('retrieve_functions');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('retrieve_functions');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc retrieve_functions failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_constraint_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_constraint_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_constraint_for_replay ( character varying,character varying,boolean,character varying,jsonb,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, newobject character varying DEFAULT NULL::character varying, newmap jsonb DEFAULT NULL::jsonb, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
		    pg_get_constraintdef(otherside.oid, true) AS def,
		    otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
		    myside.nspname as mynspname, myside.relname as myrelname,
		    myside.cols as mycols, myside.conname as myconname
		FROM
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) otherside JOIN
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) myside ON myside.conrelid = otherside.confrelid
			    AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY DEFERRED';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_constraint_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_constraint_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_constraint_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_dependent_objects_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_dependent_objects_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_dependent_objects_for_replay ( character varying,character varying,boolean,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_dependent_objects_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, doobjectdeps boolean DEFAULT false, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_myrole TEXT;
BEGIN
	RAISE DEBUG 'processing %.%', schema, object;
	path = path || concat(schema, '.', object);
	-- process stored procedures
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
			SELECT * FROM (
				-- functions that depend on relations
				SELECT  distinct np.nspname::text AS nspname,
					dependent.proname::text AS dep_object,
						n.nspname as base_namespace,
						dependee.typname as base_object
				FROM   pg_depend dep
					INNER join pg_type dependee on dependee.oid = dep.refobjid
					INNER join pg_namespace n on n.oid = dependee.typnamespace
					INNER join pg_proc dependent on dependent.oid = dep.objid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				UNION ALL
				-- relations that depend on functions
				-- note dependent and depndee are backwards

				SELECT  distinct n.nspname::text, dependee.relname::text,
					np.nspname, dependent.proname::text
				FROM   pg_depend dep
					INNER JOIN pg_rewrite ON dep.objid = pg_rewrite.oid
					INNER JOIN pg_class as dependee
						ON pg_rewrite.ev_class = dependee.oid
					INNER join pg_namespace n on n.oid = dependee.relnamespace
					INNER join pg_proc dependent on dependent.oid = dep.refobjid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				) x
	WHERE
			base_object = object
			AND base_namespace = schema
	LOOP
		-- RAISE NOTICE '1 dealing with  %.%', _r.nspname, _r.dep_object;
		PERFORM schema_support.save_constraint_for_replay(schema := _r.nspname, object := _r.dep_object, dropit := dropit, tags := tags, path := path);
		PERFORM schema_support.save_dependent_objects_for_replay(_r.nspname, _r.dep_object, dropit, doobjectdeps, tags, path);
		-- which of these to run depends on which side of the union above
		PERFORM schema_support.save_function_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
		PERFORM schema_support.save_view_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
	END LOOP;

	-- save any triggers on the view
	FOR _r in SELECT distinct n.nspname::text, dependee.relname::text, dependee.relkind
		FROM pg_depend
		JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
		JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
		JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
		JOIN pg_namespace n on n.oid = dependee.relnamespace
		JOIN pg_namespace sn on sn.oid = dependent.relnamespace
		JOIN pg_attribute ON pg_depend.refobjid = pg_attribute.attrelid
			AND pg_depend.refobjsubid = pg_attribute.attnum
		WHERE dependent.relname = object
		AND sn.nspname = schema
	LOOP
		IF _r.relkind = 'v' OR _r.relkind = 'm' THEN
			-- RAISE NOTICE '2 dealing with  %.%', _r.nspname, _r.relname;
			PERFORM * FROM save_dependent_objects_for_replay(_r.nspname, _r.relname, dropit, doobjectdeps, tags, path);
			PERFORM schema_support.save_view_for_replay(_r.nspname, _r.relname, dropit, tags, path);
		END IF;
	END LOOP;
	IF doobjectdeps THEN
		PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);
		PERFORM schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'table', tags := tags, path := path);
	END IF;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_dependent_objects_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_dependent_objects_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_dependent_objects_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_function_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_function_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_function_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_function_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, owner,
			ddl, idargs, tags, path
		) VALUES (
			_r.nspname, _r.proname, 'function', _r.owner,
			_r.funcdef, _r.idargs, tags, path
		);
		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _r.nspname || '.' ||
				_r.proname || '(' || _r.idargs || ');';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_function_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_function_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_function_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_grants_for_replay_relations');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_grants_for_replay_relations');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_grants_for_replay_relations ( character varying,character varying,character varying,text[] );
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_relations(schema character varying, object character varying, newname character varying DEFAULT NULL::character varying, tags text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_schema		varchar;
	_object	varchar;
	_tabs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_fullgrant		varchar;
	_role		varchar;
	_myrole		TEXT;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;

	PERFORM schema_support.prepare_for_grant_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- Handle table wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			c.relacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || ' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	-- Handle column specific wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			a.attname as col,
			a.attacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
		ON a.attrelid = c.oid
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND a.attacl IS NOT NULL
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || '(' || _tabs.col || ')'
				' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_grants_for_replay_relations');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_grants_for_replay_relations');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_grants_for_replay_relations failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_trigger_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_trigger_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_trigger_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_trigger_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_trigger_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_trigger_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_view_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_view_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_view_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object)
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_view_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_view_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_view_for_replay failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(minnumdiff integer DEFAULT 0, minpercent integer DEFAULT 0, skipchecks boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || current_user;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;
	RETURN true;
END;
$function$
;

-- DONE: process_ancillary_schema(schema_support)
--
-- Process middle (non-trigger) schema schema_support
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'begin_maintenance');
SELECT schema_support.save_grants_for_replay('schema_support', 'begin_maintenance');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.begin_maintenance ( boolean );
CREATE OR REPLACE FUNCTION schema_support.begin_maintenance(shouldbesuper boolean DEFAULT true)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper	boolean;
	_tally	integer;
BEGIN
	IF shouldbesuper THEN
		SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
		IF issuper IS false THEN
			PERFORM groname, rolname
			FROM (
				SELECT groname, unnest(grolist) AS oid
				FROM pg_group ) g
			JOIN pg_roles r USING (oid)
			WHERE groname = 'dba'
			AND rolname = current_user;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'User must be a super user or have the dba role';
			END IF;
		END IF;
	END IF;
	-- Not sure how reliable this is.
	-- http://www.postgresql.org/docs/9.3/static/monitoring-stats.html
	SELECT count(*)
	  INTO _tally
	  FROM	pg_stat_activity
	 WHERE	pid = pg_backend_pid()
	   AND	query_start = xact_start;
	IF _tally > 0 THEN
		RAISE EXCEPTION 'Must run maintenance in a transaction.';
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--
	CREATE TEMPORARY TABLE __owner_before_stats (
		username					TEXT,
		before_views_count			INTEGER,
		before_func_count		INTEGER,
		before_key_count	INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_before_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	RETURN true;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('begin_maintenance');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('begin_maintenance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc begin_maintenance failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'end_maintenance (  )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.end_maintenance (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'migrate_grants');
SELECT schema_support.save_grants_for_replay('schema_support', 'migrate_grants');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.migrate_grants ( text,text,text,text );
CREATE OR REPLACE FUNCTION schema_support.migrate_grants(username text, direction text, old_schema text DEFAULT 'jazzhands_legacy'::text, new_schema text DEFAULT 'jazzhands'::text)
 RETURNS text[]
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_rv	TEXT[];
	_r	RECORD;
	_q	TEXT;
BEGIN
	IF lower(direction) NOT IN ('grant','revoke') THEN
		RAISE EXCEPTION 'direction must be grant or revoke';
	END IF;

	FOR _r IN
		WITH x AS (
		SELECT *
			FROM (
		SELECT oid, schema, name,  typ,
			p->>'privilege_type' as privilege_type,
			col,
			r.usename as grantor, e.usename as grantee,
			r.usesysid as rid,  e.usesysid as eid,
			e.useconfig
		FROM (
			SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
				NULL::text as col,
			to_jsonb(pg_catalog.aclexplode(acl := c.relacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
		UNION ALL
		SELECT  c.oid, n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as typ,
			a.attname as col,
			to_jsonb(pg_catalog.aclexplode(a.attacl)) as p
			FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
				ON a.attrelid = c.oid
			WHERE c.relkind IN ('r', 'v', 'S', 'f')
			AND a.attacl IS NOT NULL
		) x
		LEFT JOIN pg_user r ON r.usesysid = (p->>'grantor')::oid
		LEFT JOIN pg_user e ON e.usesysid = (p->>'grantee')::oid
		) i
		) select *
		FROM x
		WHERE ( schema = old_schema )
		AND grantee = username
		AND typ IN ('table', 'view', 'mview', 'foreign table')
		order by name, col
	LOOP
		IF _r.col IS NOT NULL THEN
			_q = concat(' (', _r.col, ') ');
		ELSE
			_q := NULL;
		END IF;
		IF lower(direction) = 'grant' THEN
			_q := concat('GRANT ', _r.privilege_type, _q, ' ON ', new_schema, '.', _r.name, ' TO ', _r.grantee);
		ELSIF lower(direction) = 'revoke' THEN
			_q := concat('REVOKE ', _r.privilege_type, _q, ' ON ', old_schema, '.', _r.name, ' FROM ', _r.grantee);
		END IF;


		_rv := array_append(_rv, _q);
		EXECUTE _q;
	END LOOP;
	RETURN _rv;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('migrate_grants');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('migrate_grants');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc migrate_grants failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'relation_last_changed');
SELECT schema_support.save_grants_for_replay('schema_support', 'relation_last_changed');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.relation_last_changed ( text,text,boolean );
CREATE OR REPLACE FUNCTION schema_support.relation_last_changed(relation text, schema text DEFAULT 'jazzhands_legacy'::text, debug boolean DEFAULT false)
 RETURNS timestamp without time zone
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	audsch	text;
	rk	char;
	rv	timestamp;
	ts	timestamp;
	obj	text;
	objaud text;
	objkind text;
	objschema text;
BEGIN
	SELECT	audit_schema
	INTO	audsch
	FROM	schema_support.schema_audit_map m
	WHERE	m.schema = relation_last_changed.schema;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Schema % not configured for this', schema;
	END IF;

	SELECT	relkind
	INTO	rk
	FROM	pg_catalog.pg_class c
		JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE	n.nspname = relation_last_changed.schema
	AND	c.relname = relation_last_changed.relation;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'No such object %.%', schema, relation;
	END IF;

	IF rk = 'r' THEN
		EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
			FROM '||quote_ident(audsch)||'.'|| quote_ident(relation)
		INTO rv;
		IF rv IS NULL THEN
			EXECUTE '
				SELECT	max("aud#timestamp")
				FROM	'||quote_ident(audsch)||'.'||quote_ident(relation)
			INTO rv;
		END IF;

		IF rv IS NULL THEN
			RETURN '-infinity'::timestamp;
		ELSE
			RETURN rv;
		END IF;
	END IF;

	IF rk = 'v' OR rk = 'm' THEN
		FOR obj,objaud,objkind, objschema IN WITH RECURSIVE recur AS (
		SELECT distinct rewrite.ev_class as root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		    JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE c.relname = relation
		AND n.nspname = relation_last_changed.schema
		AND d.refobjsubid > 0
	    UNION ALL
		SELECT recur.root_oid, d.refobjid as oid
		FROM pg_depend d
		    JOIN pg_rewrite rewrite ON d.objid = rewrite.oid
		    JOIN pg_class c on rewrite.ev_class = c.oid
		JOIN recur ON recur.oid = rewrite.ev_class
		AND d.refobjsubid > 0
		AND c.relkind != 'm'
	    ), list AS ( select distinct m.audit_schema, c.relname, c.relkind, n.nspname as relschema, recur.*
		FROM pg_class c
		    JOIN recur on recur.oid = c.oid
		    JOIN pg_namespace n on c.relnamespace = n.oid
		    JOIN schema_support.schema_audit_map m
			ON m.schema = n.nspname
		WHERE relkind IN ('r', 'm')
		) SELECT relname, audit_schema, relkind, relschema from list
		LOOP
			-- if there is no audit table, assume its kept current.  This is
			-- likely some sort of cache table.  XXX - should probably be
			-- updated to use the materialized view update bits
			BEGIN
				IF objkind = 'r' THEN
					EXECUTE 'SELECT max(pg_xact_commit_timestamp(xmin))
						FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) ||'
						WHERE "aud#timestamp" > (
								SELECT max("aud#timestamp")
								FROM '||quote_ident(objaud)||'.'|| quote_ident(obj) || '
							) - ''10 day''::interval'
						INTO ts;
					IF ts IS NULL THEN
						EXECUTE 'SELECT max("aud#timestamp")
							FROM '||quote_ident(objaud)||'.'|| quote_ident(obj)
							INTO ts;
					END IF;
				ELSIF objkind = 'm' THEN
					SELECT refresh INTO ts FROM schema_support.mv_refresh m WHERE m.schema = objschema
						AND m.view = obj;
				ELSE
					RAISE NOTICE 'Unknown object kind % for %.%', objkind, objaud, obj;
				END IF;
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): %.% -> %', objaud, obj, ts;
				END IF;
				IF rv IS NULL OR ts > rv THEN
					rv := ts;
				END IF;
			EXCEPTION WHEN undefined_table THEN
				IF debug THEN
					RAISE NOTICE 'schema_support.relation_last_changed(): skipping %.%', schema, obj;
				END IF;
			END;
		END LOOP;
		RETURN rv;
	END IF;

	RAISE EXCEPTION 'Unable to process relkind %', rk;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('relation_last_changed');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('relation_last_changed');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc relation_last_changed failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'replay_object_recreates');
SELECT schema_support.save_grants_for_replay('schema_support', 'replay_object_recreates');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.replay_object_recreates ( boolean,text[],text,text,text,text );
CREATE OR REPLACE FUNCTION schema_support.replay_object_recreates(beverbose boolean DEFAULT false, tags text[] DEFAULT NULL::text[], schema text DEFAULT NULL::text, object text DEFAULT NULL::text, type text DEFAULT NULL::text, path text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
    _origsp TEXT;
	_myrole TEXT;
BEGIN
	SELECT	count(*)
	  INTO	_tally
	  FROM	pg_catalog.pg_class
	 WHERE	relname = '__recreate'
	   AND	relpersistence = 't';

	SHOW search_path INTO _origsp;

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	IF _tally > 0 THEN
		FOR _r in SELECT * from __recreate ORDER BY id DESC FOR UPDATE
		LOOP
			IF tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			IF schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN NOT _r.schema = schema;
			END IF;
			IF type IS NOT NULL THEN
				CONTINUE WHEN _r.type IS NULL;
				CONTINUE WHEN NOT _r.type = type;
			END IF;
			IF object IS NOT NULL THEN
				CONTINUE WHEN _r.object IS NULL;
				IF object ~ '^!' THEN
					object = regexp_replace(object, '^!', '');
					CONTINUE WHEN _r.object = object;
				ELSE
					CONTINUE WHEN NOT _r.object = object;
				END IF;
			END IF;

			IF beverbose THEN
				RAISE NOTICE 'Recreate % %.%', _r.type, _r.schema, _r.object;
			END IF;
			EXECUTE _r.ddl;
			EXECUTE 'SET search_path = ' || _r.schema || ',jazzhands';
			IF _r.owner is not NULL THEN
				IF _r.type = 'view' OR _r.type = 'materialized view' THEN
					EXECUTE 'ALTER ' || _r.type || ' ' || _r.schema || '.' || _r.object ||
						' OWNER TO ' || _r.owner || ';';
				ELSIF _r.type = 'function' THEN
					EXECUTE 'ALTER FUNCTION ' || _r.schema || '.' || _r.object ||
						'(' || _r.idargs || ') OWNER TO ' || _r.owner || ';';
				ELSE
					RAISE EXCEPTION 'Unable to recreate object for % ', _r;
				END IF;
			END IF;
			DELETE from __recreate where id = _r.id;
		END LOOP;

		SELECT count(*) INTO _tally from __recreate;

		IF _tally > 0 THEN
			IF tags IS NULL AND schema IS NULL and object IS NULL THEN
				RAISE EXCEPTION '% objects still exist for recreating after a complete loop', _tally;
			END IF;
		ELSE
			DROP TABLE __recreate;
		END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_object_recreates did NOT have anything to regrant!';
		END IF;
	END IF;

	EXECUTE 'SET search_path = ' || _origsp;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('replay_object_recreates');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('replay_object_recreates');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc replay_object_recreates failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'replay_saved_grants');
SELECT schema_support.save_grants_for_replay('schema_support', 'replay_saved_grants');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.replay_saved_grants ( boolean,text,text );
CREATE OR REPLACE FUNCTION schema_support.replay_saved_grants(beverbose boolean DEFAULT false, schema text DEFAULT NULL::text, tags text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_tally	integer;
	_myrole	TEXT;
BEGIN
	 SELECT  count(*)
      INTO  _tally
      FROM  pg_catalog.pg_class
     WHERE  relname = '__regrants'
       AND  relpersistence = 't';

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	IF _tally > 0 THEN
	    FOR _r in SELECT * from __regrants FOR UPDATE
	    LOOP
			if tags IS NOT NULL THEN
				CONTINUE WHEN _r.tags IS NULL;
				CONTINUE WHEN NOT _r.tags && tags;
			END IF;
			if schema IS NOT NULL THEN
				CONTINUE WHEN _r.schema IS NULL;
				CONTINUE WHEN _r.schema != schema;
			END IF;
		    IF beverbose THEN
			    RAISE NOTICE 'Regrant Executing: %', _r.regrant;
		    END IF;
		    EXECUTE _r.regrant;
		    DELETE from __regrants where id = _r.id;
	    END LOOP;

	    SELECT count(*) INTO _tally from __regrants;
	    IF _tally > 0 THEN
			IF schema IS NULL AND tags IS NULL THEN
				RAISE EXCEPTION 'Grant extractions were run while replaying grants - %.', _tally;
			END IF;
	    ELSE
		    DROP TABLE __regrants;
	    END IF;
	ELSE
		IF beverbose THEN
			RAISE NOTICE '**** WARNING: replay_saved_grants did NOT have anything to regrant!';
		END IF;
	END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('replay_saved_grants');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('replay_saved_grants');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc replay_saved_grants failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'retrieve_functions');
SELECT schema_support.save_grants_for_replay('schema_support', 'retrieve_functions');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.retrieve_functions ( character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.retrieve_functions(schema character varying, object character varying, dropit boolean DEFAULT false)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_fn		TEXT;
	_cmd	TEXT;
	_rv		TEXT[];
	_myrole TEXT;
BEGIN
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		_fn = _r.nspname || '.' || _r.proname || '(' || _r.idargs || ')';
		_rv = _rv || _fn;

		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _fn || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
	RETURN _rv;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('retrieve_functions');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('retrieve_functions');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc retrieve_functions failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_constraint_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_constraint_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_constraint_for_replay ( character varying,character varying,boolean,character varying,jsonb,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_constraint_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, newobject character varying DEFAULT NULL::character varying, newmap jsonb DEFAULT NULL::jsonb, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_def	TEXT;
	_cols	TEXT;
	_myname	TEXT;
		_myrole TEXT;
BEGIN
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- This used to be just "def" but a once this was incorporating
	-- tables and columns changing name, had to construct the definition
	-- by hand.  yay.  Most of this query is to match the two sides
	-- together.  This query took way too long to figure out.
	--
	FOR _r in
		SELECT otherside.nspname, otherside.relname, otherside.conname,
		    pg_get_constraintdef(otherside.oid, true) AS def,
		    otherside.conname, otherside.condeferrable, otherside.condeferred,
			otherside.cols as cols,
		    myside.nspname as mynspname, myside.relname as myrelname,
		    myside.cols as mycols, myside.conname as myconname
		FROM
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('f')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) otherside JOIN
		    (
			SELECT me.oid, n.oid as namespaceid, nspname, relname,
				conrelid, conindid, confrelid, conname, connamespace,
				condeferrable, condeferred,
				array_agg(attname ORDER BY attnum) as cols
			FROM (
			    SELECT con.*, a.attname, a.attnum
			    FROM
				    ( SELECT oid, conrelid, conindid, confrelid,
					contype, connamespace,
					condeferrable, condeferred, conname,
					unnest(conkey) as conkey
					FROM pg_constraint
				    ) con
				JOIN pg_attribute a ON a.attrelid = con.conrelid
					AND a.attnum = con.conkey
				WHERE contype IN ('u','p')
			) me
				JOIN pg_class c ON c.oid = me.conrelid
				JOIN pg_namespace n ON c.relnamespace = n.oid
			GROUP BY 1,2,3,4,5,6,7,8,9,10,11
		    ) myside ON myside.conrelid = otherside.confrelid
			    AND myside.conindid = otherside.conindid
		WHERE myside.namespaceid != otherside.namespaceid
		AND myside.nspname = schema
		AND myside.relname = object
	LOOP
		--
		-- if my name is changing, reflect that in the recreation
		--
		IF newobject IS NOT NULL THEN
			_myname := newobject;
		ELSE
			_myname := object;
		END IF;
		_cols := array_to_string(_r.mycols, ',');
		--
		-- If newmap is set *AMD* contains a key of the constraint name
		-- on "my" side, then replace the column list with the new names.
		--
		IF newmap IS NOT NULL AND newmap->>_r.myconname IS NOT NULL THEN
			SELECT string_agg(x::text, ',') INTO _cols
				FROM jsonb_array_elements_text(newmap->_r.myconname->'columns') x;
		END IF;
		_def := concat('FOREIGN KEY (', array_to_string(_r.cols, ','),
			') REFERENCES ',
			schema, '.', _myname, '(', _cols, ')');

		IF _r.condeferrable THEN
			_def := _def || ' DEFERRABLE';
		END IF;

		IF _r.condeferred THEN
			_def := _def || ' INITIALLY DEFERRED';
		ELSE
			_def := _def || ' INITIALLY DEFERRED';
		END IF;

		_ddl := 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
			' ADD CONSTRAINT ' || _r.conname || ' ' || _def;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define constraint for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'constraint', _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'ALTER TABLE ' || _r.nspname || '.' || _r.relname ||
				' DROP CONSTRAINT ' || _r.conname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_constraint_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_constraint_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_constraint_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_dependent_objects_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_dependent_objects_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_dependent_objects_for_replay ( character varying,character varying,boolean,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_dependent_objects_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, doobjectdeps boolean DEFAULT false, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_myrole TEXT;
BEGIN
	RAISE DEBUG 'processing %.%', schema, object;
	path = path || concat(schema, '.', object);
	-- process stored procedures
	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
			SELECT * FROM (
				-- functions that depend on relations
				SELECT  distinct np.nspname::text AS nspname,
					dependent.proname::text AS dep_object,
						n.nspname as base_namespace,
						dependee.typname as base_object
				FROM   pg_depend dep
					INNER join pg_type dependee on dependee.oid = dep.refobjid
					INNER join pg_namespace n on n.oid = dependee.typnamespace
					INNER join pg_proc dependent on dependent.oid = dep.objid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				UNION ALL
				-- relations that depend on functions
				-- note dependent and depndee are backwards

				SELECT  distinct n.nspname::text, dependee.relname::text,
					np.nspname, dependent.proname::text
				FROM   pg_depend dep
					INNER JOIN pg_rewrite ON dep.objid = pg_rewrite.oid
					INNER JOIN pg_class as dependee
						ON pg_rewrite.ev_class = dependee.oid
					INNER join pg_namespace n on n.oid = dependee.relnamespace
					INNER join pg_proc dependent on dependent.oid = dep.refobjid
					INNER join pg_namespace np on np.oid = dependent.pronamespace
				) x
	WHERE
			base_object = object
			AND base_namespace = schema
	LOOP
		-- RAISE NOTICE '1 dealing with  %.%', _r.nspname, _r.dep_object;
		PERFORM schema_support.save_constraint_for_replay(schema := _r.nspname, object := _r.dep_object, dropit := dropit, tags := tags, path := path);
		PERFORM schema_support.save_dependent_objects_for_replay(_r.nspname, _r.dep_object, dropit, doobjectdeps, tags, path);
		-- which of these to run depends on which side of the union above
		PERFORM schema_support.save_function_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
		PERFORM schema_support.save_view_for_replay(_r.nspname, _r.dep_object, dropit, tags, path);
	END LOOP;

	-- save any triggers on the view
	FOR _r in SELECT distinct n.nspname::text, dependee.relname::text, dependee.relkind
		FROM pg_depend
		JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
		JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
		JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
		JOIN pg_namespace n on n.oid = dependee.relnamespace
		JOIN pg_namespace sn on sn.oid = dependent.relnamespace
		JOIN pg_attribute ON pg_depend.refobjid = pg_attribute.attrelid
			AND pg_depend.refobjsubid = pg_attribute.attnum
		WHERE dependent.relname = object
		AND sn.nspname = schema
	LOOP
		IF _r.relkind = 'v' OR _r.relkind = 'm' THEN
			-- RAISE NOTICE '2 dealing with  %.%', _r.nspname, _r.relname;
			PERFORM * FROM save_dependent_objects_for_replay(_r.nspname, _r.relname, dropit, doobjectdeps, tags, path);
			PERFORM schema_support.save_view_for_replay(_r.nspname, _r.relname, dropit, tags, path);
		END IF;
	END LOOP;
	IF doobjectdeps THEN
		PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);
		PERFORM schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'table', tags := tags, path := path);
	END IF;
	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_dependent_objects_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_dependent_objects_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_dependent_objects_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_function_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_function_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_function_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_function_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;


	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);
	FOR _r IN SELECT n.nspname, p.proname,
				coalesce(u.usename, 'public') as owner,
				pg_get_functiondef(p.oid) as funcdef,
				pg_get_function_identity_arguments(p.oid) as idargs
		FROM    pg_catalog.pg_proc  p
				INNER JOIN pg_catalog.pg_namespace n on n.oid = p.pronamespace
				INNER JOIN pg_catalog.pg_language l on l.oid = p.prolang
				INNER JOIN pg_catalog.pg_user u on u.usesysid = p.proowner
		WHERE   n.nspname = schema
		  AND	p.proname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, owner,
			ddl, idargs, tags, path
		) VALUES (
			_r.nspname, _r.proname, 'function', _r.owner,
			_r.funcdef, _r.idargs, tags, path
		);
		IF dropit  THEN
			_cmd = 'DROP FUNCTION ' || _r.nspname || '.' ||
				_r.proname || '(' || _r.idargs || ');';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_function_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_function_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_function_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_grants_for_replay_relations');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_grants_for_replay_relations');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_grants_for_replay_relations ( character varying,character varying,character varying,text[] );
CREATE OR REPLACE FUNCTION schema_support.save_grants_for_replay_relations(schema character varying, object character varying, newname character varying DEFAULT NULL::character varying, tags text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_schema		varchar;
	_object	varchar;
	_tabs		RECORD;
	_perm		RECORD;
	_grant		varchar;
	_fullgrant		varchar;
	_role		varchar;
	_myrole		TEXT;
BEGIN
	_schema := schema;
	_object := object;
	if newname IS NULL THEN
		newname := _object;
	END IF;

	PERFORM schema_support.prepare_for_grant_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- Handle table wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'm' THEN 'view'
				WHEN 'v' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			c.relacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || ' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	-- Handle column specific wide grants
	FOR _tabs IN SELECT  n.nspname as schema,
			c.relname as name,
			CASE c.relkind
				WHEN 'r' THEN 'table'
				WHEN 'v' THEN 'view'
				WHEN 'mv' THEN 'mview'
				WHEN 'S' THEN 'sequence'
				WHEN 'f' THEN 'foreign table'
				END as "Type",
			a.attname as col,
			a.attacl as privs
		FROM    pg_catalog.pg_class c
			INNER JOIN pg_catalog.pg_namespace n
				ON n.oid = c.relnamespace
			INNER JOIN pg_attribute a
		ON a.attrelid = c.oid
		WHERE c.relkind IN ('r', 'v', 'S', 'f')
		  AND a.attacl IS NOT NULL
		  AND c.relname = _object
		  AND n.nspname = _schema
		ORDER BY 1, 2
	LOOP
		-- NOTE:  We lose who granted it.  Oh Well.
		FOR _perm IN SELECT * FROM pg_catalog.aclexplode(acl := _tabs.privs)
		LOOP
			--  grantor | grantee | privilege_type | is_grantable
			IF _perm.is_grantable THEN
				_grant = ' WITH GRANT OPTION';
			ELSE
				_grant = '';
			END IF;
			IF _perm.grantee = 0 THEN
				_role := 'PUBLIC';
			ELSE
				_role := pg_get_userbyid(_perm.grantee);
			END IF;
			_fullgrant := 'GRANT ' ||
				_perm.privilege_type || '(' || _tabs.col || ')'
				' on ' ||
				_schema || '.' ||
				newname || ' to ' ||
				_role || _grant;
			IF _fullgrant IS NULL THEN
				RAISE EXCEPTION 'built up grant for %.% (%) is NULL',
					schema, object, newname;
	    END IF;
			INSERT INTO __regrants (schema, object, newname, regrant, tags) values (schema,object, newname, _fullgrant, tags );
		END LOOP;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_grants_for_replay_relations');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_grants_for_replay_relations');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_grants_for_replay_relations failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_trigger_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_trigger_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_trigger_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_trigger_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_cmd	TEXT;
	_myrole TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	FOR _r in
		SELECT n.nspname, c.relname, trg.tgname,
				pg_get_triggerdef(trg.oid, true) as def
		FROM pg_trigger trg
			INNER JOIN pg_class c on trg.tgrelid =  c.oid
			INNER JOIN pg_namespace n on n.oid = c.relnamespace
		WHERE n.nspname = schema and c.relname = object
	LOOP
		INSERT INTO __recreate (schema, object, type, ddl, tags , path)
			VALUES (
				_r.nspname, _r.relname, 'trigger', _r.def, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP TRIGGER ' || _r.tgname || ' ON ' ||
				_r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;
	END LOOP;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_trigger_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_trigger_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_trigger_for_replay failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'save_view_for_replay');
SELECT schema_support.save_grants_for_replay('schema_support', 'save_view_for_replay');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.save_view_for_replay ( character varying,character varying,boolean,text[],text[] );
CREATE OR REPLACE FUNCTION schema_support.save_view_for_replay(schema character varying, object character varying, dropit boolean DEFAULT true, tags text[] DEFAULT NULL::text[], path text[] DEFAULT NULL::text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		RECORD;
	_c		RECORD;
	_cmd	TEXT;
	_ddl	TEXT;
	_mat	TEXT;
	_typ	TEXT;
	_myrole	TEXT;
BEGIN
	path = path || concat(schema, '.', object);
	PERFORM schema_support.prepare_for_object_replay();

	-- implicitly save regrants
	PERFORM schema_support.save_grants_for_replay(schema, object, object, tags);

	-- save any triggers on the view
	PERFORM schema_support.save_trigger_for_replay(schema, object, dropit, tags, path);

	BEGIN
		SELECT current_role INTO _myrole;
		SET ROLE = dba;
	EXCEPTION WHEN insufficient_privilege OR invalid_parameter_value THEN
		RAISE NOTICE 'Failed to raise privilege: % (%), crossing fingers', SQLERRM, SQLSTATE;
	END;

	-- now save the view
	FOR _r in SELECT c.oid, n.nspname, c.relname, 'view',
				coalesce(u.usename, 'public') as owner,
				pg_get_viewdef(c.oid, true) as viewdef, relkind
		FROM pg_class c
		INNER JOIN pg_namespace n on n.oid = c.relnamespace
		LEFT JOIN pg_user u on u.usesysid = c.relowner
		WHERE c.relname = object
		AND n.nspname = schema
	LOOP
		--
		-- iterate through all the columns on this view with comments or
		-- defaults and reserve them
		--
		FOR _c IN SELECT * FROM ( SELECT a.attname AS colname,
					pg_catalog.format_type(a.atttypid, a.atttypmod) AS coltype,
					(
						SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid)
								FOR 128)
						FROM pg_catalog.pg_attrdef d
						WHERE
							d.adrelid = a.attrelid
							AND d.adnum = a.attnum
							AND a.atthasdef) AS def, a.attnotnull, a.attnum, (
							SELECT c.collname
							FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
							WHERE
								c.oid = a.attcollation
								AND t.oid = a.atttypid
								AND a.attcollation <> t.typcollation) AS attcollation, d.description AS COMMENT
						FROM pg_catalog.pg_attribute a
						LEFT JOIN pg_catalog.pg_description d ON d.objoid = a.attrelid
							AND d.objsubid = a.attnum
					WHERE
						a.attrelid = _r.oid
						AND a.attnum > 0
						AND NOT a.attisdropped
					ORDER BY a.attnum
			) x WHERE def IS NOT NULL OR COMMENT IS NOT NULL
		LOOP
			IF _c.def IS NOT NULL THEN
				_ddl := 'ALTER VIEW ' || quote_ident(schema) || '.' ||
					quote_ident(object) || ' ALTER COLUMN ' ||
					quote_ident(_c.colname) || ' SET DEFAULT ' || _c.def;
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'default', _ddl, tags, path
					);
			END IF;
			IF _c.comment IS NOT NULL THEN
				_ddl := 'COMMENT ON COLUMN ' ||
					quote_ident(schema) || '.' || quote_ident(object)
					' IS ''' || _c.comment || '''';
				INSERT INTO __recreate (schema, object, type, ddl, tags, path )
					VALUES (
						_r.nspname, _r.relname, 'colcomment', _ddl, tags, path
					);
			END IF;

		END LOOP;

		_mat = ' VIEW ';
		_typ = 'view';
		IF _r.relkind = 'm' THEN
			_mat = ' MATERIALIZED VIEW ';
			_typ = 'materialized view';
		END IF;
		_ddl := 'CREATE ' || _mat || _r.nspname || '.' || _r.relname ||
			' AS ' || _r.viewdef;
		IF _ddl is NULL THEN
			RAISE EXCEPTION 'Unable to define view for %', _r;
		END IF;
		INSERT INTO __recreate (schema, object, owner, type, ddl, tags, path )
			VALUES (
				_r.nspname, _r.relname, _r.owner, _typ, _ddl, tags, path
			);
		IF dropit  THEN
			_cmd = 'DROP ' || _mat || _r.nspname || '.' || _r.relname || ';';
			EXECUTE _cmd;
		END IF;

	IF _myrole IS NOT NULL THEN
		EXECUTE 'SET role = ' || _myrole;
	END IF;

	END LOOP;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('save_view_for_replay');
	DELETE FROM __regrants WHERE schema = 'schema_support' AND object IN ('save_view_for_replay');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc save_view_for_replay failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.end_maintenance(minnumdiff integer DEFAULT 0, minpercent integer DEFAULT 0, skipchecks boolean DEFAULT false)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	issuper BOOLEAN;
	_r		RECORD;
	doh	boolean DEFAULT false;
	_myrole	TEXT;
BEGIN
	SELECT usesuper INTO issuper FROM pg_user where usename = current_user;
	IF issuper THEN
		EXECUTE 'ALTER USER ' || current_user || ' NOSUPERUSER';
	END IF;

	PERFORM groname, rolname
	FROM (
		SELECT groname, unnest(grolist) AS oid
		FROM pg_group ) g
	JOIN pg_roles r USING (oid)
	WHERE groname = 'dba'
	AND rolname = current_user;

	IF FOUND THEN
		SELECT current_role INTO _myrole;
		SET role=dba;
		EXECUTE 'REVOKE dba FROM ' || current_user;
		EXECUTE 'SET role =' || _myrole;
	END IF;

	--
	-- Stash counts of things that may relate to this maintenance for
	-- alter verification and statistics
	--
	-- similar code is in end_maintenance (the INSERT uqery is the same
	--

	CREATE TEMPORARY TABLE __owner_after_stats (
		username			TEXT,
		after_views_count	INTEGER,
		after_func_count	INTEGER,
		after_key_count		INTEGER,
		PRIMARY KEY (username)
	);
	INSERT INTO __owner_after_stats
		SELECT rolname, coalesce(numrels, 0) AS numrels,
		coalesce(numprocs, 0) AS numprocs,
		coalesce(numfks, 0) AS numfks
		FROM pg_roles r
			LEFT JOIN (
		SELECT relowner, count(*) AS numrels
				FROM pg_class
				WHERE relkind IN ('r','v')
				GROUP BY 1
				) c ON r.oid = c.relowner
			LEFT JOIN (SELECT proowner, count(*) AS numprocs
				FROM pg_proc
				GROUP BY 1
				) p ON r.oid = p.proowner
			LEFT JOIN (
				SELECT relowner, count(*) AS numfks
				FROM pg_class r JOIN pg_constraint fk ON fk.confrelid = r.oid
				WHERE contype = 'f'
				GROUP BY 1
			) fk ON r.oid = fk.relowner
		WHERE r.oid > 16384
	AND (numrels IS NOT NULL OR numprocs IS NOT NULL OR numfks IS NOT NULL);

	--
	-- sanity checks
	--
	IF skipchecks THEN
		RETURN true;
	END IF;

	RAISE NOTICE 'Object difference count by username:';
	FOR _r IN SELECT *,
			abs(after_views_count - before_views_count) as viewdelta,
			abs(after_func_count - before_func_count) as funcdelta,
			abs(after_key_count - before_key_count) as keydelta
		FROM __owner_before_stats JOIN __owner_after_stats USING (username)
	LOOP
		IF _r.viewdelta = 0 AND _r.funcdelta = 0 AND _r.keydelta = 0 THEN
			CONTINUE;
		END IF;
		RAISE NOTICE '%: % v % / % v % / % v %',
			_r.username,
			_r.before_views_count,
			_r.after_views_count,
			_r.before_func_count,
			_r.after_func_count,
			_r.before_key_count,
			_r.after_key_count;
		IF _r.username = current_user THEN
			CONTINUE;
		END IF;
		IF _r.viewdelta > 0 THEN
			IF _r.viewdelta  > minnumdiff OR
				(_r.viewdelta / _r.before_views_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! view changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... View changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.viewdelta,
						((_r.viewdelta::float / _r.before_views_count ))*100;
			END IF;
		END IF;
		IF _r.funcdelta > 0 THEN
			IF _r.funcdelta  > minnumdiff OR
				(_r.funcdelta / _r.before_func_count )*100 > minpercent
			THEN
				RAISE NOTICE '!!! function changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it: %/% %%',
						minnumdiff, minpercent,
						_r.funcdelta,
						((_r.funcdelta::float / _r.before_func_count ))*100;
			END IF;
		END IF;
		IF _r.keydelta > 0 THEN
			IF _r.keydelta  > minnumdiff OR
				(_r.keydelta / _r.before_key_count )*100 > 100 - minpercent
			THEN
				RAISE NOTICE '!!! fk constraint changes not within tolerence';
				doh := 1;
			ELSE
				RAISE NOTICE
					'... Function changes within tolerence (%/% %%), I will allow it, %/% %%',
						minnumdiff, minpercent,
						_r.keydelta,
						((_r.keydelta::float / _r.before_keys_count ))*100;
			END IF;
		END IF;
	END LOOP;

	IF doh THEN
		RAISE EXCEPTION 'Too many changes, abort!';
	END IF;
	RETURN true;
END;
$function$
;

--
-- Process middle (non-trigger) schema jazzhands
--
DROP TRIGGER IF EXISTS trigger_del_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'del_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.del_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_del ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_del (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_del (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_ins ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_ins (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_ins (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_upd ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_upd (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_upd (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_soa_name_retire ON jazzhands.dns_domain;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_soa_name_retire (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_soa_name_retire (  );
DROP TRIGGER IF EXISTS trigger_layer1_connection_insteadof ON jazzhands.layer1_connection;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'do_layer1_connection_trigger (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.do_layer1_connection_trigger (  );
DROP TRIGGER IF EXISTS trigger_physical_port_insteadof ON jazzhands.physical_port;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'do_physical_port_trigger (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.do_physical_port_trigger (  );
DROP TRIGGER IF EXISTS trigger_ins_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'ins_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.ins_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_upd_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'upd_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.upd_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_del ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_del (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_del (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_ins ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_ins (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_ins (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_upd ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_upd (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_upd (  );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
--
-- Process middle (non-trigger) schema net_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process middle (non-trigger) schema network_strings
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process middle (non-trigger) schema time_util
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process middle (non-trigger) schema dns_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_dns_domain');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_dns_domain');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_dns_domain ( character varying,character varying,integer[],boolean );
CREATE OR REPLACE FUNCTION dns_utils.add_dns_domain(dns_domain_name character varying, dns_domain_type character varying DEFAULT NULL::character varying, ip_universes integer[] DEFAULT NULL::integer[], add_nameservers boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	elements		text[];
	parent_zone		text;
	parent_id		dns_domain.dns_domain_id%type;
	domain_id		dns_domain.dns_domain_id%type;
	elem			text;
	sofar			text;
	rvs_nblk_id		netblock.netblock_id%type;
	univ			ip_universe.ip_universe_id%type;
BEGIN
	IF dns_domain_name IS NULL THEN
		RETURN NULL;
	END IF;
	elements := regexp_split_to_array(dns_domain_name, '\.');
	sofar := '';
	FOREACH elem in ARRAY elements
	LOOP
		IF octet_length(sofar) > 0 THEN
			sofar := sofar || '.';
		END IF;
		sofar := sofar || elem;
		parent_zone := regexp_replace(dns_domain_name, '^'||sofar||'.', '');
		EXECUTE 'SELECT dns_domain_id FROM dns_domain
			WHERE dns_domain_name = $1' INTO parent_id USING parent_zone;
		IF parent_id IS NOT NULL THEN
			EXIT;
		END IF;
	END LOOP;

	IF ip_universes IS NULL THEN
		SELECT array_agg(ip_universe_id)
		INTO	ip_universes
		FROM	ip_universe
		WHERE	ip_universe_name = 'default';
	END IF;

	IF dns_domain_type IS NULL THEN
		IF dns_domain_name ~ '^.*(in-addr|ip6)\.arpa$' THEN
			dns_domain_type := 'reverse';
		END IF;
	END IF;

	IF dns_domain_type IS NULL THEN
		RAISE EXCEPTION 'Unable to guess dns_domain_type for %',
			dns_domain_name USING ERRCODE = 'not_null_violation';
	END IF;

	EXECUTE '
		INSERT INTO dns_domain (
			dns_domain_name,
			parent_dns_domain_id,
			dns_domain_type
		) VALUES (
			$1,
			$2,
			$3
		) RETURNING dns_domain_id' INTO domain_id
		USING dns_domain_name,
			parent_id,
			dns_domain_type
	;

	FOREACH univ IN ARRAY ip_universes
	LOOP
		EXECUTE '
			INSERT INTO dns_domain_ip_universe (
				dns_domain_id,
				ip_universe_id,
				soa_class,
				soa_mname,
				soa_rname,
				should_generate
			) VALUES (
				$1,
				$2,
				$3,
				$4,
				$5,
				$6
			);'
			USING domain_id, univ,
				'IN',
				(select property_value from property
					where property_type = 'Defaults'
					and property_name = '_dnsmname' ORDER BY property_id LIMIT 1),
				(select property_value from property
					where property_type = 'Defaults'
					and property_name = '_dnsrname' ORDER BY property_id LIMIT 1),
				true
		;
	END LOOP;

	IF dns_domain_type = 'reverse' THEN
		rvs_nblk_id := dns_utils.get_or_create_inaddr_domain_netblock_link(
			dns_domain_name, domain_id);
	END IF;

	IF add_nameservers THEN
		PERFORM dns_utils.add_ns_records(domain_id);
	END IF;

	--
	-- XXX - need to reconsider how ip universes fit into this.
	IF parent_id IS NOT NULL THEN
		INSERT INTO dns_change_record (
			dns_domain_id
		) SELECT dns_domain_id
		FROM dns_domain
		WHERE dns_domain_id = parent_id
		AND dns_domain_id IN (
			SELECT dns_domain_id
			FROM dns_domain_ip_universe
			WHERE should_generate = true
		);
	END IF;

	RETURN domain_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_dns_domain');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('add_dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_dns_domain failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_domain_from_cidr');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_domain_from_cidr');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_domain_from_cidr ( inet );
CREATE OR REPLACE FUNCTION dns_utils.add_domain_from_cidr(block inet)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ipaddr		text;
	ipnodes		text[];
	domain		text;
	domain_id	dns_domain.dns_domain_id%TYPE;
	j			text;
BEGIN
	-- silently fail for ipv6
	IF family(block) != 4 THEN
		RETURN NULL;
	END IF;
	IF family(block) != 4 THEN
		j := '';
		-- this needs to be tweaked to expand ::, which postgresql does
		-- not easily do.  This requires more thinking than I was up for today.
		ipaddr := regexp_replace(host(block)::text, ':', '', 'g');
	ELSE
		j := '\.';
		ipaddr := host(block);
	END IF;

	EXECUTE 'select array_agg(member order by rn desc)
		from (
        select
			row_number() over () as rn, *
			from
			unnest(regexp_split_to_array($1, $2)) as member
		) x
	' INTO ipnodes USING ipaddr, j;

	IF family(block) = 4 THEN
		domain := array_to_string(ARRAY[ipnodes[2],ipnodes[3],ipnodes[4]], '.')
			|| '.in-addr.arpa';
	ELSE
		domain := array_to_string(ipnodes, '.')
			|| '.ip6.arpa';
	END IF;

	SELECT dns_domain_id INTO domain_id FROM dns_domain where dns_domain_name = domain;
	IF NOT FOUND THEN
		-- domain_id := dns_utils.add_dns_domain(domain);
	END IF;

	RETURN domain_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_domain_from_cidr');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('add_domain_from_cidr');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_domain_from_cidr failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'add_domains_from_netblock');
SELECT schema_support.save_grants_for_replay('dns_utils', 'add_domains_from_netblock');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.add_domains_from_netblock ( integer );
CREATE OR REPLACE FUNCTION dns_utils.add_domains_from_netblock(netblock_id integer)
 RETURNS TABLE(dns_domain_id integer, dns_domain_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	block		inet;
	domain		text;
	domain_id	dns_domain.dns_domain_id%TYPE;
	nid			ALIAS FOR netblock_id;
BEGIN
	SELECT ip_address INTO block FROM netblock n WHERE n.netblock_id = nid;

	RAISE DEBUG 'Creating inverse DNS zones for %s', block;

	RETURN QUERY SELECT
		dns_utils.add_dns_domain(
			dns_domain_name := x.dns_domain_name,
			dns_domain_type := 'reverse'
			),
		x.dns_domain_name::text
	FROM
		dns_utils.get_all_domain_rows_for_cidr(block) x LEFT JOIN
		dns_domain d USING (dns_domain_name)
	WHERE
		d.dns_domain_id IS NULL;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('add_domains_from_netblock');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('add_domains_from_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_domains_from_netblock failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'find_dns_domain');
SELECT schema_support.save_grants_for_replay('dns_utils', 'find_dns_domain');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.find_dns_domain ( text );
CREATE OR REPLACE FUNCTION dns_utils.find_dns_domain(fqdn text)
 RETURNS TABLE(dns_name text, dns_domain_name text, dns_domain_id integer)
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF fqdn !~ '^[^.][a-zA-Z0-9_.-]+[^.]$' THEN
		RAISE EXCEPTION '% is not a valid DNS name', fqdn;
	END IF;

	RETURN QUERY SELECT
		regexp_replace(fqdn, '.' || dd.dns_domain_name || '$', '')::text,
		dd.dns_domain_name::text,
		dd.dns_domain_id
	FROM
		dns_domain dd
	WHERE
		fqdn LIKE ('%.' || dd.dns_domain_name)
	ORDER BY
		length(dd.dns_domain_name) DESC
	LIMIT 1;

	RETURN;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('find_dns_domain');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('find_dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc find_dns_domain failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'get_all_domain_rows_for_cidr');
SELECT schema_support.save_grants_for_replay('dns_utils', 'get_all_domain_rows_for_cidr');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.get_all_domain_rows_for_cidr ( inet );
CREATE OR REPLACE FUNCTION dns_utils.get_all_domain_rows_for_cidr(block inet)
 RETURNS TABLE(dns_domain_name text)
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	cur			inet;
BEGIN
	IF family(block) = 4 THEN
		IF (masklen(block) >= 24) THEN
			dns_domain_name := dns_utils.get_domain_from_cidr(set_masklen(block, 24));
			RETURN NEXT;
		ELSE
			FOR cur IN
				SELECT
					set_masklen((block + o), 24)
				FROM
					generate_series(
						0,
						(256 * (2 ^ (24 - masklen(block))) - 1)::integer,
						256)
					AS x(o)
			LOOP
				dns_domain_name := dns_utils.get_domain_from_cidr(cur);
				RETURN NEXT;
			END LOOP;
		END IF;
	ELSIF family(block) = 6 THEN
			-- note sure if we should do this or not, but we are..
			cur := set_masklen(block, 64);
			dns_domain_name := dns_utils.get_domain_from_cidr(cur);
			RETURN NEXT;
	ELSE
		RAISE EXCEPTION 'Not IPv% aware.', family(block);
	END IF;
    return;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('get_all_domain_rows_for_cidr');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('get_all_domain_rows_for_cidr');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc get_all_domain_rows_for_cidr failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('dns_utils', 'get_or_create_inaddr_domain_netblock_link');
SELECT schema_support.save_grants_for_replay('dns_utils', 'get_or_create_inaddr_domain_netblock_link');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS dns_utils.get_or_create_inaddr_domain_netblock_link ( character varying,integer );
CREATE OR REPLACE FUNCTION dns_utils.get_or_create_inaddr_domain_netblock_link(dns_domain_name character varying, dns_domain_id integer)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nblk_id	netblock.netblock_id%type;
	blk text;
	root	text;
	brk	text[];
	ipmember text[];
	ip	inet;
	j text;
BEGIN
	brk := regexp_matches(dns_domain_name, '^(.+)\.(in-addr|ip6)\.arpa$');
	IF brk[2] = 'in-addr' THEN
		j := '.';
	ELSE
		j := ':';
	END IF;

	EXECUTE 'select array_agg(member order by rn desc), $2
		from (
        select
			row_number() over () as rn, *
			from
			unnest(regexp_split_to_array($1, $3)) as member
		) x
	' INTO ipmember USING brk[1], j, '\.';

	IF brk[2] = 'in-addr' THEN
		IF array_length(ipmember, 1) > 4 THEN
			RAISE EXCEPTION 'Unable to work with anything smaller than a /24';
		ELSIF array_length(ipmember, 1) != 3 THEN
			-- If this is not a /24, then do not add any rvs association
			RETURN NULL;
		END IF;
		WHILE array_length(ipmember, 1) < 4
		LOOP
			ipmember := array_append(ipmember, '0');
		END LOOP;
		ip := concat(array_to_string(ipmember, j),'/24')::inet;
	ELSE
		ip := concat(
			regexp_replace(
				array_to_string(ipmember, ''), '(....)', '\1:', 'g'),
			':/64')::inet;
	END IF;

	SELECT netblock_id
		INTO	nblk_id
		FROM	netblock
		WHERE	netblock_type = 'dns'
		AND		is_single_address = false
		AND		can_subnet = false
		AND		netblock_status = 'Allocated'
		AND		ip_universe_id = 0
		AND		ip_address = ip;

	IF NOT FOUND THEN
		INSERT INTO netblock (
			ip_address, netblock_type, is_single_address,
			can_subnet, netblock_status, ip_universe_id
		) VALUES (
			ip, 'dns', false,
			false, 'Allocated', 0
		) RETURNING netblock_id INTO nblk_id;
	END IF;

	EXECUTE '
		INSERT INTO dns_record(
			dns_domain_id, dns_class, dns_type, netblock_id
		) values (
			$1, $2, $3, $4
		)
	' USING dns_domain_id, 'IN', 'REVERSE_ZONE_BLOCK_PTR', nblk_id;

	RETURN nblk_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'dns_utils' AND type = 'function' AND object IN ('get_or_create_inaddr_domain_netblock_link');
	DELETE FROM __regrants WHERE schema = 'dns_utils' AND object IN ('get_or_create_inaddr_domain_netblock_link');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc get_or_create_inaddr_domain_netblock_link failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
--
-- Process middle (non-trigger) schema obfuscation_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process middle (non-trigger) schema person_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('person_manip', 'add_user');
SELECT schema_support.save_grants_for_replay('person_manip', 'add_user');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS person_manip.add_user ( integer,character varying,character varying,character varying,character varying,character varying,character varying,character varying,character varying,character varying,date,character varying,character varying,character varying,character varying,character varying,character varying,text,date,date,character varying,character varying,character varying,integer,character varying,integer,character varying,character varying,character varying,integer );
CREATE OR REPLACE FUNCTION person_manip.add_user(company_id integer, person_company_relation character varying, login character varying DEFAULT NULL::character varying, first_name character varying DEFAULT NULL::character varying, middle_name character varying DEFAULT NULL::character varying, last_name character varying DEFAULT NULL::character varying, name_suffix character varying DEFAULT NULL::character varying, gender character varying DEFAULT NULL::character varying, preferred_last_name character varying DEFAULT NULL::character varying, preferred_first_name character varying DEFAULT NULL::character varying, birth_date date DEFAULT NULL::date, external_hr_id character varying DEFAULT NULL::character varying, person_company_status character varying DEFAULT 'enabled'::character varying, is_management character varying DEFAULT 'N'::character varying, is_manager character varying DEFAULT NULL::character varying, is_exempt character varying DEFAULT 'Y'::character varying, is_full_time character varying DEFAULT 'Y'::character varying, employee_id text DEFAULT NULL::text, hire_date date DEFAULT NULL::date, termination_date date DEFAULT NULL::date, position_title character varying DEFAULT NULL::character varying, job_title character varying DEFAULT NULL::character varying, department_name character varying DEFAULT NULL::character varying, manager_person_id integer DEFAULT NULL::integer, site_code character varying DEFAULT NULL::character varying, physical_address_id integer DEFAULT NULL::integer, person_location_type character varying DEFAULT 'office'::character varying, description character varying DEFAULT NULL::character varying, unix_uid character varying DEFAULT NULL::character varying, INOUT person_id integer DEFAULT NULL::integer, OUT dept_account_collection_id integer, OUT account_id integer)
 RETURNS record
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
    _account_realm_id INTEGER;
    _account_type VARCHAR;
    _uid INTEGER;
    _uxaccountid INTEGER;
    _companyid INTEGER;
    _personid INTEGER;
    _accountid INTEGER;
BEGIN
	IF is_manager IS NOT NULL THEN
		is_management := is_manager;
	END IF;

	IF job_title IS NOT NULL THEN
		position_title := job_title;
	END IF;

    IF company_id is NULL THEN
        RAISE EXCEPTION 'Must specify company id';
    END IF;
    _companyid := company_id;

    SELECT arc.account_realm_id
      INTO _account_realm_id
      FROM account_realm_company arc
     WHERE arc.company_id = _companyid;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Cannot find account_realm_id with company id %', company_id;
    END IF;

    IF login is NULL THEN
        IF first_name IS NULL or last_name IS NULL THEN
            RAISE EXCEPTION 'Must specify login name or first name+last name';
        ELSE
            login := person_manip.pick_login(
                account_realm_id := _account_realm_id,
                first_name := coalesce(preferred_first_name, first_name),
                middle_name := middle_name,
                last_name := coalesce(preferred_last_name, last_name)
            );
        END IF;
    END IF;

    IF person_company_relation = 'pseudouser' THEN
        person_id := 0;
        _account_type := 'pseudouser';
    ELSE
        _account_type := 'person';
        IF person_id IS NULL THEN
            INSERT INTO person (first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date)
                VALUES (first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date)
            RETURNING person.person_id into _personid;
            person_id = _personid;
        ELSE
            INSERT INTO person (person_id, first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date)
                VALUES (person_id, first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date);
        END IF;
        INSERT INTO v_person_company
            (person_id, company_id, external_hr_id, person_company_status, is_management, is_exempt, is_full_time, employee_id, hire_date, termination_date, person_company_relation, position_title, manager_person_id)
            VALUES
            (person_id, company_id, external_hr_id, person_company_status, is_management, is_exempt, is_full_time, employee_id, hire_date, termination_date, person_company_relation, position_title, manager_person_id);
        INSERT INTO person_account_realm_company ( person_id, company_id, account_realm_id) VALUES ( person_id, company_id, _account_realm_id);
    END IF;

    INSERT INTO account ( login, person_id, company_id, account_realm_id, account_status, description, account_role, account_type)
        VALUES (login, person_id, company_id, _account_realm_id, person_company_status, description, 'primary', _account_type)
    RETURNING account.account_id INTO account_id;

    IF department_name IS NOT NULL THEN
        dept_account_collection_id = person_manip.get_account_collection_id(department_name, 'department');
        INSERT INTO account_collection_account (account_collection_id, account_id) VALUES ( dept_account_collection_id, account_id);
    END IF;

    IF site_code IS NOT NULL AND physical_address_id IS NOT NULL THEN
        RAISE EXCEPTION 'You must provide either site_code or physical_address_id NOT both';
    END IF;

    IF site_code IS NULL AND physical_address_id IS NOT NULL THEN
        site_code = person_manip.get_site_code_from_physical_address_id(physical_address_id);
    END IF;

    IF physical_address_id IS NULL AND site_code IS NOT NULL THEN
        physical_address_id = person_manip.get_physical_address_from_site_code(site_code);
    END IF;

    IF physical_address_id IS NOT NULL AND site_code IS NOT NULL THEN
        INSERT INTO person_location
            (person_id, person_location_type, site_code, physical_address_id)
        VALUES
            (person_id, person_location_type, site_code, physical_address_id);
    END IF;


    IF unix_uid IS NOT NULL THEN
        _accountid = account_id;
        SELECT  aui.account_id
          INTO  _uxaccountid
          FROM  account_unix_info aui
        WHERE  aui.account_id = _accountid;

        --
        -- This is creatd by trigger for non-pseudousers, which will
        -- eventually change, so this is here once it goes away.
        --
        IF _uxaccountid IS NULL THEN
            IF unix_uid = 'auto' THEN
                _uid :=  person_manip.get_unix_uid(_account_type);
            ELSE
                _uid := unix_uid::int;
            END IF;

            PERFORM person_manip.setup_unix_account(
                account_id := account_id,
                account_type := _account_type,
                uid := _uid
            );
        END IF;
    END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'person_manip' AND type = 'function' AND object IN ('add_user');
	DELETE FROM __regrants WHERE schema = 'person_manip' AND object IN ('add_user');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_user failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('person_manip', 'merge_accounts');
SELECT schema_support.save_grants_for_replay('person_manip', 'merge_accounts');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS person_manip.merge_accounts ( integer,integer );
CREATE OR REPLACE FUNCTION person_manip.merge_accounts(merge_from_account_id integer, merge_to_account_id integer)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	fpc		person_company%ROWTYPE;
	tpc		person_company%ROWTYPE;
	_account_realm_id INTEGER;
BEGIN
	select	*
	  into	fpc
	  from	person_company
	 where	(person_id, company_id) in
		(select person_id, company_id
		   from account where account_id = merge_from_account_id);

	select	*
	  into	tpc
	  from	person_company
	 where	(person_id, company_id) in
		(select person_id, company_id
		   from account where account_id = merge_to_account_id);

	IF (fpc.company_id != tpc.company_id) THEN
		RAISE EXCEPTION 'Accounts are in different companies';
	END IF;

	IF (fpc.person_company_relation != tpc.person_company_relation) THEN
		RAISE EXCEPTION 'People have different relationships';
	END IF;

	IF(tpc.external_hr_id is NOT NULL AND fpc.external_hr_id IS NULL) THEN
		RAISE EXCEPTION 'Destination account has an external HR ID and origin account has none';
	END IF;

	-- move any account collections over that are
	-- not infrastructure ones, and the new person is
	-- not in
	UPDATE	account_collection_account
	   SET	ACCOUNT_ID = merge_to_account_id
	 WHERE	ACCOUNT_ID = merge_from_account_id
	  AND	ACCOUNT_COLLECTION_ID IN (
			SELECT ACCOUNT_COLLECTION_ID
			  FROM	ACCOUNT_COLLECTION
				INNER JOIN VAL_ACCOUNT_COLLECTION_TYPE
					USING (ACCOUNT_COLLECTION_TYPE)
			 WHERE	IS_INFRASTRUCTURE_TYPE = false
		)
	  AND	account_collection_id not in (
			SELECT	account_collection_id
			  FROM	account_collection_account
			 WHERE	account_id = merge_to_account_id
	);


	-- Now begin removing the old account
	PERFORM person_manip.purge_account( merge_from_account_id );

	-- Switch person_ids
	DELETE FROM person_account_realm_company WHERE person_id = fpc.person_id AND company_id = tpc.company_id;
	SELECT account_realm_id INTO _account_realm_id FROM account_realm_company WHERE company_id = tpc.company_id;
	INSERT INTO person_account_realm_company (person_id, company_id, account_realm_id) VALUES ( fpc.person_id , tpc.company_id, _account_realm_id);
	UPDATE account SET account_realm_id = _account_realm_id, person_id = fpc.person_id WHERE person_id = tpc.person_id AND company_id = fpc.company_id;
	DELETE FROM person_company_attribute WHERE person_id = tpc.person_id AND company_id = tpc.company_id;
	DELETE FROM person_company WHERE person_id = tpc.person_id AND company_id = tpc.company_id;
	DELETE FROM person_account_realm_company WHERE person_id = tpc.person_id AND company_id = tpc.company_id;
	UPDATE person_image SET person_id = fpc.person_id WHERE person_id = tpc.person_id;
	-- if there are other relations that may exist, do not delete the person.
	BEGIN
		delete from person where person_id = tpc.person_id;
	EXCEPTION WHEN foreign_key_violation THEN
		NULL;
	END;

	return merge_to_account_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'person_manip' AND type = 'function' AND object IN ('merge_accounts');
	DELETE FROM __regrants WHERE schema = 'person_manip' AND object IN ('merge_accounts');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc merge_accounts failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('person_manip', 'pick_login');
SELECT schema_support.save_grants_for_replay('person_manip', 'pick_login');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS person_manip.pick_login ( integer,character varying,character varying,character varying );
CREATE OR REPLACE FUNCTION person_manip.pick_login(account_realm_id integer, first_name character varying DEFAULT NULL::character varying, middle_name character varying DEFAULT NULL::character varying, last_name character varying DEFAULT NULL::character varying)
 RETURNS character varying
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_acctrealmid	integer;
	_login			varchar;
	_trylogin		varchar;
	_trunclen		integer;
    id				account.account_id%TYPE;
	fn		text;
	ln		text;
BEGIN
	SELECT	property_value::int
	INTO	_trunclen
	FROM	property
	WHERE	property_type = 'Defaults'
	AND	 	property_name = '_max_default_login_length';

	IF NOT FOUND THEN
		_trunclen := 15;
	END IF;

	-- remove special characters
	fn = regexp_replace(lower(pick_login.first_name), '[^a-z]', '', 'g');
	ln = regexp_replace(lower(pick_login.last_name), '[^a-z]', '', 'g');
	_acctrealmid := pick_login.account_realm_id;
	-- Try first initial, last name
	_login = lpad(lower(fn), 1) || lower(ln);

	IF _trunclen IS NOT NULL AND _trunclen > 0 THEN
		_login := left(_login, _trunclen);
	END IF;

	SELECT account_id into id FROM account a where a.account_realm_id = _acctrealmid
		AND login = _login;

	IF id IS NULL THEN
		RETURN _login;
	END IF;

	-- Try first initial, middle initial, last name
	if pick_login.middle_name IS NOT NULL THEN
		_login = lpad(lower(fn), 1) || lpad(lower(pick_login.middle_name), 1) || lower(ln);

		IF _trunclen IS NOT NULL AND _trunclen > 0 THEN
			_login := left(_login, _trunclen);
		END IF;
		SELECT account_id into id FROM account a where a.account_realm_id = _acctrealmid
			AND login = _login;
		IF id IS NULL THEN
			RETURN _login;
		END IF;
	END IF;

	-- if length of first+last is <= 10 then try that.
	_login = lower(fn) || lower(ln);
	IF _trunclen IS NOT NULL AND _trunclen > 0 THEN
		_login := left(_login, _trunclen);
	END IF;
	IF char_length(_login) < 10 THEN
		SELECT account_id into id FROM account a where a.account_realm_id = _acctrealmid
			AND login = _login;
		IF id IS NULL THEN
			RETURN _login;
		END IF;
	END IF;

	-- ok, keep trying to add a number to first initial, last
	_login = lpad(lower(fn), 1) || lower(ln);
	FOR i in 1..500 LOOP
		IF _trunclen IS NOT NULL AND _trunclen > 0 THEN
			_login := left(_login, _trunclen - 2);
		END IF;
		_trylogin := _login || i;
		SELECT account_id into id FROM account a where a.account_realm_id = _acctrealmid
			AND login = _trylogin;
		IF id IS NULL THEN
			RETURN _trylogin;
		END IF;
	END LOOP;

	-- wtf. this should never happen
	RETURN NULL;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'person_manip' AND type = 'function' AND object IN ('pick_login');
	DELETE FROM __regrants WHERE schema = 'person_manip' AND object IN ('pick_login');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc pick_login failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('person_manip', 'purge_account');
SELECT schema_support.save_grants_for_replay('person_manip', 'purge_account');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS person_manip.purge_account ( integer );
CREATE OR REPLACE FUNCTION person_manip.purge_account(account_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	-- note the per-account account collection is removed in triggers

	DELETE FROM account_assigned_certificate ac
		where ac.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM account_token at where at.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM account_unix_info aui where aui.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM klogin k where k.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM property p where p.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM property p where p.account_collection_id in
		(select account_collection_id from account_collection
			where account_collection_name in
				(select login from account a where a.account_id = purge_account.account_id)
				and account_collection_type in ('per-account')
		);
	DELETE FROM account_password ap where ap.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM unix_group ug where account_collection_id in
		(select account_collection_id from account_collection
			where account_collection_name in
				(select login from account a where a.account_id = purge_account.account_id)
				and account_collection_type in ('unix-group')
		);
	DELETE FROM account_collection_account aca where aca.ACCOUNT_ID = purge_account.account_id;

	DELETE FROM account_collection where account_collection_name in
		(select login from account a where a.account_id = purge_account.account_id)
		and account_collection_type in ('per-account', 'unix-group');

	DELETE FROM account_ssh_key ssh where ssh.ACCOUNT_ID = purge_account.account_id;
	DELETE FROM account a where a.ACCOUNT_ID = purge_account.account_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'person_manip' AND type = 'function' AND object IN ('purge_account');
	DELETE FROM __regrants WHERE schema = 'person_manip' AND object IN ('purge_account');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc purge_account failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('person_manip', 'purge_person');
SELECT schema_support.save_grants_for_replay('person_manip', 'purge_person');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS person_manip.purge_person ( integer );
CREATE OR REPLACE FUNCTION person_manip.purge_person(person_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	aid	INTEGER;
BEGIN
	FOR aid IN select account_id
			FROM account a
			WHERE a.person_id = purge_person.person_id
	LOOP
		PERFORM person_manip.purge_account ( aid );
	END LOOP;

	DELETE FROM person_company_attribute pca
		WHERE pca.person_id = purge_person.person_id;
	DELETE FROM person_contact pc WHERE pc.person_id = purge_person.person_id;
	DELETE FROM person_location pl WHERE pl.person_id = purge_person.person_id;
	DELETE FROM v_person_company pc WHERE pc.person_id = purge_person.person_id;
	DELETE FROM person_account_realm_company pcrc
		WHERE pcrc.person_id = purge_person.person_id;
	DELETE FROM person p WHERE p.person_id = purge_person.person_id;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'person_manip' AND type = 'function' AND object IN ('purge_person');
	DELETE FROM __regrants WHERE schema = 'person_manip' AND object IN ('purge_person');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc purge_person failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process middle (non-trigger) schema account_password_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
--
-- Process middle (non-trigger) schema layerx_network_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process middle (non-trigger) schema auto_ac_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process middle (non-trigger) schema company_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
--
-- Process middle (non-trigger) schema component_connection_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process middle (non-trigger) schema token_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('token_utils', 'set_lock_status');
SELECT schema_support.save_grants_for_replay('token_utils', 'set_lock_status');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS token_utils.set_lock_status ( integer,boolean,timestamp with time zone,integer,timestamp with time zone );
CREATE OR REPLACE FUNCTION token_utils.set_lock_status(p_token_id integer, p_lock_status boolean, p_unlock_time timestamp with time zone, p_bad_logins integer, p_last_updated timestamp with time zone)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cur		token%ROWTYPE;
BEGIN

	IF p_token_id IS NULL THEN
		RAISE EXCEPTION 'Invalid token %', p_token_id
			USING ERRCODE = invalid_parameter_value;
	END IF;

	EXECUTE '
		SELECT *
		FROM token
		WHERE token_id = $1
	' INTO _cur USING p_token_id;

	--
	-- This used to be <= but if two clients were doing things in the
	-- same second, it became dueling syncs.  This may result in a change
	-- getting undone.  Solution may be to make last_updated more garanular
	-- as some libraries in here are no more granular than second (HOTPants
	-- or dbsyncer in jazzhands)
	IF _cur.last_updated < p_last_updated THEN
		UPDATE token SET
		is_token_locked = p_lock_status,
			token_unlock_time = p_unlock_time,
			bad_logins = p_bad_logins,
			last_updated = p_last_updated
		WHERE
			Token_ID = p_token_id;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'token_utils' AND type = 'function' AND object IN ('set_lock_status');
	DELETE FROM __regrants WHERE schema = 'token_utils' AND object IN ('set_lock_status');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_lock_status failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('token_utils', 'set_sequence');
SELECT schema_support.save_grants_for_replay('token_utils', 'set_sequence');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS token_utils.set_sequence ( integer,integer,timestamp without time zone );
CREATE OR REPLACE FUNCTION token_utils.set_sequence(p_token_id integer, p_token_sequence integer, p_reset_time timestamp without time zone DEFAULT NULL::timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cur		token_sequence%ROWTYPE;
BEGIN

	IF p_token_id IS NULL THEN
		RAISE EXCEPTION 'Invalid token %', p_token_id
			USING ERRCODE = invalid_parameter_value;
	END IF;

	EXECUTE '
		SELECT *
		FROM token_sequence
		WHERE token_id = $1
	' INTO _cur USING p_token_id;

	IF _cur.token_id IS NULL THEN
		EXECUTE '
			INSERT INTO token_sequence (
				token_id, token_sequence, last_updated
			) VALUES (
				$1, $2, $3
			);
		' USING p_token_id, p_token_sequence, p_reset_time;
	ELSE
		IF p_reset_time IS NULL THEN
			-- Using this code path, do not reset the sequence back, ever
			UPDATE Token_Sequence SET
				Token_Sequence = p_token_sequence,
				last_updated = now()
			WHERE
				Token_ID = p_token_id
				AND (token_sequence is NULL OR Token_Sequence < p_token_sequence);
		ELSE
			--
			-- Only reset the sequence back if its newer than what's in the
			-- db
			UPDATE Token_Sequence SET
				Token_Sequence = p_token_sequence,
				Last_Updated = p_reset_time
			WHERE Token_ID = p_token_id
			AND Last_Updated <= p_reset_time;
		END IF;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'token_utils' AND type = 'function' AND object IN ('set_sequence');
	DELETE FROM __regrants WHERE schema = 'token_utils' AND object IN ('set_sequence');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_sequence failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('token_utils', 'set_lock_status');
DROP FUNCTION IF EXISTS token_utils.set_lock_status ( integer,text,timestamp with time zone,integer,timestamp with time zone );
CREATE OR REPLACE FUNCTION token_utils.set_lock_status(p_token_id integer, p_lock_status text, p_unlock_time timestamp with time zone, p_bad_logins integer, p_last_updated timestamp with time zone)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ls boolean;
BEGIN
	IF p_lock_status = 'Y' THEN
		_ls := true;
	ELSE
		_ls := false;
	END IF;

	PERFORM token_utils.set_lock_status(
		p_token_id		:= p_token_id,
		p_lock_status	:= _ls,
		p_unlock_time	:= p_unlock_time,
		p_bad_logins	:= p_bad_logins,
		p_last_updated	:= p_last_updated
	);
END;
$function$
;

--
-- Process middle (non-trigger) schema port_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('port_utils', 'configure_layer1_connect');
SELECT schema_support.save_grants_for_replay('port_utils', 'configure_layer1_connect');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS port_utils.configure_layer1_connect ( integer,integer,integer,integer,integer,text,text,integer );
CREATE OR REPLACE FUNCTION port_utils.configure_layer1_connect(physportid1 integer, physportid2 integer, baud integer DEFAULT '-99'::integer, data_bits integer DEFAULT '-99'::integer, stop_bits integer DEFAULT '-99'::integer, parity text DEFAULT '__unknown__'::text, flw_cntrl text DEFAULT '__unknown__'::text, circuit_id integer DEFAULT '-99'::integer)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	tally		integer;
	l1_con_id	jazzhands_legacy.layer1_connection.layer1_connection_id%TYPE;
	l1con		jazzhands_legacy.layer1_connection%ROWTYPE;
	p1_l1_con	jazzhands_legacy.layer1_connection%ROWTYPE;
	p2_l1_con	jazzhands_legacy.layer1_connection%ROWTYPE;
	p1_port		jazzhands_legacy.physical_port%ROWTYPE;
	p2_port		jazzhands_legacy.physical_port%ROWTYPE;
	col_nams	varchar(100) [];
	col_vals	varchar(100) [];
	updateitr	integer;
	i_baud		jazzhands_legacy.layer1_connection.baud%type;
	i_data_bits	jazzhands_legacy.layer1_connection.data_bits%type;
	i_stop_bits	jazzhands_legacy.layer1_connection.stop_bits%type;
	i_parity     	jazzhands_legacy.layer1_connection.parity%type;
	i_flw_cntrl	jazzhands_legacy.layer1_connection.flow_control%type;
	i_circuit_id 	jazzhands_legacy.layer1_connection.circuit_id%type;
BEGIN
	RAISE DEBUG 'looking up % and %', physportid1, physportid2;

	RAISE DEBUG 'min args %:%:% <--', physportid1, physportid2, circuit_id;

	-- First make sure the physical ports exist
	BEGIN
		select	*
		  into	p1_port
		  from	physical_port
		 where	physical_port_id = physportid1;

		select	*
		  into	p2_port
		  from	physical_port
		 where	physical_port_id = physportid2;
	EXCEPTION WHEN no_data_found THEN
		RAISE EXCEPTION 'Two physical ports must be specified'
			USING ERRCODE = -20100;
	END;

	if p1_port.port_type <> p2_port.port_type then
		RAISE EXCEPTION 'Port Types Must match' USING ERRCODE = -20101;
	end if;

	-- see if existing layer1_connection exists
	-- [XXX] probably want to pull out into a cursor
	BEGIN
		select	*
		  into	p1_l1_con
		  from	layer1_connection
		 where	physical_port1_id = physportid1
		    or  physical_port2_id = physportid1;
	EXCEPTION WHEN no_data_found THEN
		NULL;
	END;
	BEGIN
		select	*
		  into	p2_l1_con
		  from	layer1_connection
		 where	physical_port1_id = physportid2
		    or  physical_port2_id = physportid2;

	EXCEPTION WHEN no_data_found THEN
		NULL;
	END;

	updateitr := 0;

	--		need to figure out which ports to reset in some cases
	--		need to check as many combinations as possible.
	--		need to deal with new ids.

	--
	-- If a connection already exists, figure out the right one
	-- If there are two, then remove one.  Favor ones where the left
	-- is this port.
	--
	-- Also falling out of this will be the port needs to be updated,
	-- assuming a port needs to be updated
	--
	RAISE DEBUG 'one is %, the other is %', p1_l1_con.layer1_connection_id,
		p2_l1_con.layer1_connection_id;
	if (p1_l1_con.layer1_connection_id is not NULL) then
		if (p2_l1_con.layer1_connection_id is not NULL) then
			if (p1_l1_con.physical_port1_id = physportid1) then
				--
				-- if this is not true, then the connection already
				-- exists between these two, and layer1_params need to
				-- be set later.  If they are already connected,
				-- this gets discovered here
				--
				if(p1_l1_con.physical_port2_id != physportid2) then
					--
					-- physport1 is connected to something, just not this
					--
					RAISE DEBUG 'physport1 is connected to something, just not this';
					l1_con_id := p1_l1_con.layer1_connection_id;
					--
					-- physport2 is connected to something, which needs to go away, so make it go away
					--
					if(p2_l1_con.layer1_connection_id is not NULL) then
						RAISE DEBUG 'physport2 is connected to something, just not this';
						RAISE DEBUG '>>>> removing %',
							p2_l1_con.layer1_connection_id;
						delete from layer1_connection
							where layer1_connection_id =
								p2_l1_con.layer1_connection_id;
					end if;
				else
					l1_con_id := p1_l1_con.layer1_connection_id;
					RAISE DEBUG 'they''re already connected';
				end if;
			elsif (p1_l1_con.physical_port2_id = physportid1) then
				RAISE DEBUG '>>> connection is backwards!';
				if (p1_l1_con.physical_port1_id != physportid2) then
					if (p2_l1_con.physical_port1_id = physportid1) then
						l1_con_id := p2_l1_con.layer1_connection_id;
						RAISE DEBUG '>>>>+ removing %', p1_l1_con.layer1_connection_id;
						delete from layer1_connection
							where layer1_connection_id =
								p1_l1_con.layer1_connection_id;
					else
						if (p1_l1_con.physical_port1_id = physportid1) then
							l1_con_id := p1_l1_con.layer1_connection_id;
						else
							-- p1_l1_con.physical_port2_id must be physportid1
							l1_con_id := p1_l1_con.layer1_connection_id;
						end if;
						RAISE DEBUG '>>>>- removing %', p2_l1_con.layer1_connection_id;
						delete from layer1_connection
							where layer1_connection_id =
								p2_l1_con.layer1_connection_id;
					end if;
				else
					RAISE DEBUG 'they''re already connected, but backwards';
					l1_con_id := p1_l1_con.layer1_connection_id;
				end if;
			end if;
		else
			RAISE DEBUG 'p1 is connected, bt p2 is not';
			l1_con_id := p1_l1_con.layer1_connection_id;
		end if;
	elsif(p2_l1_con.layer1_connection_id is NULL) then
		-- both are null in this case

		IF (circuit_id = -99) THEN
			i_circuit_id := NULL;
		ELSE
			i_circuit_id := circuit_id;
		END IF;
		IF (baud = -99) THEN
			i_baud := NULL;
		ELSE
			i_baud := baud;
		END IF;
		IF data_bits = -99 THEN
			i_data_bits := NULL;
		ELSE
			i_data_bits := data_bits;
		END IF;
		IF stop_bits = -99 THEN
			i_stop_bits := NULL;
		ELSE
			i_stop_bits := stop_bits;
		END IF;
		IF parity = '__unknown__' THEN
			i_parity := NULL;
		ELSE
			i_parity := parity;
		END IF;
		IF flw_cntrl = '__unknown__' THEN
			i_flw_cntrl := NULL;
		ELSE
			i_flw_cntrl := flw_cntrl;
		END IF;
		IF p1_port.port_type = 'serial' THEN
		        insert into layer1_connection (
			        PHYSICAL_PORT1_ID, PHYSICAL_PORT2_ID,
			        BAUD, DATA_BITS, STOP_BITS, PARITY, FLOW_CONTROL,
			        CIRCUIT_ID, IS_TCPSRV_ENABLED
		        ) values (
			        physportid1, physportid2,
			        i_baud, i_data_bits, i_stop_bits, i_parity, i_flw_cntrl,
			        i_circuit_id, true
		        ) RETURNING layer1_connection_id into l1_con_id;
		ELSE
		        insert into layer1_connection (
			        PHYSICAL_PORT1_ID, PHYSICAL_PORT2_ID,
			        BAUD, DATA_BITS, STOP_BITS, PARITY, FLOW_CONTROL,
			        CIRCUIT_ID
		        ) values (
			        physportid1, physportid2,
			        i_baud, i_data_bits, i_stop_bits, i_parity, i_flw_cntrl,
			        i_circuit_id
		        ) RETURNING layer1_connection_id into l1_con_id;
		END IF;
		RAISE DEBUG 'added, l1_con_id is %', l1_con_id;
		return 1;
	else
		RAISE DEBUG 'p2 is connected but p1 is not';
		l1_con_id := p2_l1_con.layer1_connection_id;
	end if;

	RAISE DEBUG 'l1_con_id is %', l1_con_id;

	-- check to see if both ends are the same type
	-- see if they're already connected.  If not, zap the connection
	--	that doesn't match this port1/port2 config (favor first port)
	-- update various variables
	select	*
	  into	l1con
	  from	layer1_connection
	 where	layer1_connection_id = l1_con_id;

	if (l1con.PHYSICAL_PORT1_ID != physportid1 OR
			l1con.PHYSICAL_PORT2_ID != physportid2) AND
			(l1con.PHYSICAL_PORT1_ID != physportid2 OR
			l1con.PHYSICAL_PORT2_ID != physportid1)  THEN
		-- this means that one end is wrong, now we need to figure out
		-- which end.
		if(l1con.PHYSICAL_PORT1_ID = physportid1) THEN
			RAISE DEBUG 'update port2 to second port';
			updateitr := updateitr + 1;
			col_nams[updateitr] := 'PHYSICAL_PORT2_ID';
			col_vals[updateitr] := physportid2;
		elsif(l1con.PHYSICAL_PORT2_ID = physportid1) THEN
			RAISE DEBUG 'update port1 to second port';
			updateitr := updateitr + 1;
			col_nams[updateitr] := 'PHYSICAL_PORT1_ID';
			col_vals[updateitr] := physportid2;
		elsif(l1con.PHYSICAL_PORT1_ID = physportid2) THEN
			RAISE DEBUG 'update port2 to first port';
			updateitr := updateitr + 1;
			col_nams[updateitr] := 'PHYSICAL_PORT2_ID';
			col_vals[updateitr] := physportid1;
		elsif(l1con.PHYSICAL_PORT2_ID = physportid2) THEN
			RAISE DEBUG 'update port1 to first port';
			updateitr := updateitr + 1;
			col_nams[updateitr] := 'PHYSICAL_PORT1_ID';
			col_vals[updateitr] := physportid1;
		end if;
	end if;

	RAISE DEBUG 'circuit_id -- % v %', circuit_id, l1con.circuit_id;
	if(circuit_id <> -99 and (l1con.circuit_id is NULL or l1con.circuit_id <> circuit_id)) THEN
		RAISE DEBUG 'updating circuit_id';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'CIRCUIT_ID';
		col_vals[updateitr] := circuit_id;
	end if;

	RAISE DEBUG  'baud: % v %', baud, l1con.baud;
	if(baud <> -99 and (l1con.baud is NULL or l1con.baud <> baud)) THEN
		RAISE DEBUG 'updating baud';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'BAUD';
		col_vals[updateitr] := baud;
	end if;

	if(data_bits <> -99 and (l1con.data_bits is NULL or l1con.data_bits <> data_bits)) THEN
		RAISE DEBUG 'updating data_bits';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'DATA_BITS';
		col_vals[updateitr] := data_bits;
	end if;

	if(stop_bits <> -99 and (l1con.stop_bits is NULL or l1con.stop_bits <> stop_bits)) THEN
		RAISE DEBUG 'updating stop bits';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'STOP_BITS';
		col_vals[updateitr] := stop_bits;
	end if;

	if(parity <> '__unknown__' and (l1con.parity is NULL or l1con.parity <> parity)) THEN
		RAISE DEBUG 'updating parity';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'PARITY';
		col_vals[updateitr] := quote_literal(parity);
	end if;

	if(flw_cntrl <> '__unknown__' and (l1con.parity is NULL or l1con.parity <> flw_cntrl)) THEN
		RAISE DEBUG 'updating flow control';
		updateitr := updateitr + 1;
		col_nams[updateitr] := 'FLOW_CONTROL';
		col_vals[updateitr] := quote_literal(flw_cntrl);
	end if;

	if(updateitr > 0) then
		RAISE DEBUG 'running do_l1_connection_update';
		PERFORM port_support.do_l1_connection_update(col_nams, col_vals, l1_con_id);
	end if;

	RAISE DEBUG 'returning %', updateitr;
	return updateitr;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'port_utils' AND type = 'function' AND object IN ('configure_layer1_connect');
	DELETE FROM __regrants WHERE schema = 'port_utils' AND object IN ('configure_layer1_connect');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc configure_layer1_connect failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('port_utils', 'configure_power_connect');
SELECT schema_support.save_grants_for_replay('port_utils', 'configure_power_connect');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS port_utils.configure_power_connect ( integer,character varying,integer,character varying );
CREATE OR REPLACE FUNCTION port_utils.configure_power_connect(in_dev1_id integer, in_port1_id character varying, in_dev2_id integer, in_port2_id character varying)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
	DECLARE
	v_p1_pc		jazzhands_legacy.device_power_connection%ROWTYPE;
	v_p2_pc		jazzhands_legacy.device_power_connection%ROWTYPE;
	v_pc		jazzhands_legacy.device_power_connection%ROWTYPE;
	v_pc_id		jazzhands_legacy.device_power_connection.device_power_connection_id%type;
BEGIN
	RAISE DEBUG 'consider %:% %:%',
		in_dev1_id, in_port1_id, in_dev2_id, in_port2_id;
	-- check to see if ports are already connected
	BEGIN
		select	*
		  into	v_p1_pc
		  from	device_power_connection
		 where	(device_Id = in_dev1_id
					and power_interface_port = in_port1_id) OR
				(rpc_device_id = in_dev1_id
					and rpc_power_interface_port = in_port1_id);
	EXCEPTION WHEN no_data_found THEN
		v_p1_pc.device_power_connection_id := NULL;
	END;

	BEGIN
		select	*
		  into	v_p2_pc
		  from	device_power_connection
		 where	(device_Id = in_dev2_id
					and power_interface_port = in_port2_id) OR
				(rpc_device_id = in_dev2_id
					and rpc_power_interface_port = in_port2_id);
	EXCEPTION WHEN no_data_found THEN
		v_p2_pc.device_power_connection_id := NULL;
	END;

	--
	-- If a connection already exists, figure out the right one
	-- If there are two, then remove one.  Favor ones where the left
	-- is this port.
	--
	-- Also falling out of this will be the port needs to be updated,
	-- assuming a port needs to be updated
	--
	RAISE DEBUG 'one is %, the other is %',
		v_p1_pc.device_power_connection_id, v_p2_pc.device_power_connection_id;
	IF (v_p1_pc.device_power_connection_id is not NULL) then
		IF (v_p2_pc.device_power_connection_id is not NULL) then
			IF (v_p1_pc.device_id = in_dev1_id AND v_p1_pc.power_interface_port = in_port1_id) then
				--
				-- if this is not true, then the connection already
				-- exists between these two.
				-- If they are already connected, this gets
				-- discovered here
				--
				RAISE DEBUG '>> one side matches: %:% %:%',
						v_p1_pc.rpc_device_id, in_dev2_id,
						v_p1_pc.rpc_power_interface_port, in_port2_id;
				IF(v_p1_pc.rpc_device_id != in_dev2_id OR v_p1_pc.rpc_power_interface_port != in_port2_id) then
					--
					-- port is connected to something, just not this
					--
					RAISE DEBUG 'port1 is connected to something, just not this';
					v_pc_id := v_p1_pc.device_power_connection_id;
					--
					-- port2 is connected to something, which needs to go away, so make it go away
					--
					IF(v_p2_pc.device_power_connection_id is not NULL) then
						RAISE DEBUG 'port2 is connectedt to something, deleting it';
						RAISE DEBUG '>>>> removing(0) %',v_p2_pc.device_power_connection_id;
						delete from device_power_connection
							where device_power_connection_id =
								v_p2_pc.device_power_connection_id;
					END IF;
				ELSE
					v_pc_id := v_p1_pc.device_power_connection_id;
					RAISE DEBUG 'they are alredy connected to each other';
					-- XXX NOTE THAT THIS SHOULD NOT RETURN FOR MORE PROPERTIES TO TWEAK
					return;
				END IF;
			ELSIF (v_p1_pc.rpc_device_id = in_dev1_id AND v_p1_pc.rpc_power_interface_port = in_port1_id) then
				RAISE DEBUG '>>> connection is backwards!';
				IF(v_p1_pc.device_id != in_dev2_id OR v_p1_pc.power_interface_port != in_port2_id) then
					IF (v_p2_pc.rpc_device_id = in_dev1_id AND v_p2_pc.rpc_power_interface_port = in_port1_id) then
						v_pc_id := v_p2_pc.device_power_connection_id;
						RAISE DEBUG '>>>> removing(1) %',
							v_p1_pc.device_power_connection_id;
						delete from device_power_connection
							where device_power_connection_id =
								v_p1_pc.device_power_connection_id;
					ELSE
						IF (v_p1_pc.device_id = in_dev1_id AND v_p1_pc.power_interface_port = in_port1_id) then
							v_pc_id := v_p1_pc.device_power_connection_id;
						ELSE
							-- v_p1_pc.device_id must be port1
							v_pc_id := v_p1_pc.device_power_connection_id;
						END IF;
						RAISE DEBUG '>>>> removing(2) %',
							v_p2_pc.device_power_connection_id;
						delete from device_power_connection
							where device_power_connection_id =
								v_p2_pc.device_power_connection_id;
					END IF;
				ELSE
					RAISE DEBUG 'already connected, but backwards.';
					v_pc_id := v_p1_pc.device_power_connection_id;
					-- XXX NOTE THAT THIS SHOULD NOT RETURN FOR MORE PROPERTIES TO TWEAK
					return;
				END IF;
			ELSE
				RAISE DEBUG 'else condition that should not have happened happened';
				return;
			END IF;
		ELSE
			RAISE DEBUG 'p1 is connected but p2 is not';
			v_pc_id := v_p1_pc.device_power_connection_id;
		END IF;
	ELSIF(v_p2_pc.device_power_connection_id is NULL) then
		-- both are null in this case, so connect 'em.
		RAISE DEBUG 'insert brand new record!';
		RAISE DEBUG 'consider %:% %:%',
			in_dev1_id, in_port1_id, in_dev2_id, in_port2_id;
		insert into device_power_connection (
			rpc_device_id,
			rpc_power_interface_port,
			power_interface_port,
			device_id
		) values (
			in_dev2_id,
			in_port2_id,
			in_port1_id,
			in_dev1_id
		);
		RAISE DEBUG 'record is totally inserted';
		return;
	ELSE
		RAISE DEBUG 'p2 is connected, bt p1 is not (else)';
		v_pc_id := v_p2_pc.device_power_connection_id;
	END IF;

	RAISE DEBUG 'salvaging power connection %', v_pc_id;
	-- this is here instead of above so that its possible to add properties
	-- to the argument list that would also get updated the same way serial
	-- port parameters do.  Otherwise, it would make more sense to do the
	-- updates in the morass above.
	--
	select	*
	  into	v_pc
	  from	device_power_connection
	 where	device_power_connection_id = v_pc_id;

	-- XXX - need to actually figure out which part to update and upate it.
	IF v_pc.device_id = in_dev1_id AND v_pc.power_interface_port = in_port1_id THEN
		update	device_power_connection
		   set	rpc_device_id = in_dev2_id,
				rpc_power_interface_port = in_port2_id
		  where	device_power_connection_id = v_pc_id;
	ELSIF v_pc.device_id = in_dev2_id AND v_pc.power_interface_port = in_port2_id THEN
		update	device_power_connection
		   set	rpc_device_id = in_dev1_id,
				rpc_power_interface_port = in_port1_id
		  where	device_power_connection_id = v_pc_id;
	ELSIF v_pc.rpc_device_id = in_dev1_id AND v_pc.rpc_power_interface_port = in_port1_id THEN
		update	device_power_connection
		   set	device_id = in_dev2_id,
				power_interface_port = in_port2_id
		  where	device_power_connection_id = v_pc_id;
	ELSIF v_pc.rpc_device_id = in_dev2_id AND v_pc.rpc_power_interface_port = in_port2_id THEN
		update	device_power_connection
		   set	device_id = in_dev1_id,
				power_interface_port = in_port1_id
		  where	device_power_connection_id = v_pc_id;
	END IF;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'port_utils' AND type = 'function' AND object IN ('configure_power_connect');
	DELETE FROM __regrants WHERE schema = 'port_utils' AND object IN ('configure_power_connect');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc configure_power_connect failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process middle (non-trigger) schema device_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('device_manip', 'monitoring_off_in_rack');
SELECT schema_support.save_grants_for_replay('device_manip', 'monitoring_off_in_rack');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS device_manip.monitoring_off_in_rack ( integer );
CREATE OR REPLACE FUNCTION device_manip.monitoring_off_in_rack(rack_id integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	rid	ALIAS FOR rack_id;
BEGIN
	BEGIN
		PERFORM local_hooks.monitoring_off_in_rack_early(
			rack_id, false
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;

	BEGIN
		PERFORM local_hooks.monitoring_off_in_rack_late(
			rack_id, false
		);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;

	RETURN true;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'device_manip' AND type = 'function' AND object IN ('monitoring_off_in_rack');
	DELETE FROM __regrants WHERE schema = 'device_manip' AND object IN ('monitoring_off_in_rack');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc monitoring_off_in_rack failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('device_manip', 'retire_devices');
SELECT schema_support.save_grants_for_replay('device_manip', 'retire_devices');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS device_manip.retire_devices ( integer[] );
CREATE OR REPLACE FUNCTION device_manip.retire_devices(device_id_list integer[])
 RETURNS TABLE(device_id integer, success boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nb_list		integer[];
	sn_list		integer[];
	sn_rec		RECORD;
	mp_rec		RECORD;
	rl_list		integer[];
	dev_id		jazzhands.device.device_id%TYPE;
	se_id		jazzhands.service_environment.service_environment_id%TYPE;
	nb_id		jazzhands.netblock.netblock_id%TYPE;
BEGIN
	BEGIN
		PERFORM local_hooks.retire_devices_early(device_id_list);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;
	--
	-- Add all of the BMCs for any retiring devices to the list in case
	-- they are not specified
	--
	device_id_list := array_cat(
		device_id_list,
		(SELECT
			array_agg(manager_device_id)
		FROM
			device_management_controller dmc
		WHERE
			dmc.device_id = ANY(device_id_list) AND
			device_management_control_type = 'bmc'
		)
	);

	--
	-- Delete layer3_interfaces
	--
	PERFORM device_manip.remove_layer3_interfaces(
		layer3_interface_id_list := ARRAY(
			SELECT
				layer3_interface_id
			FROM
				layer3_interface ni
			WHERE
				ni.device_id = ANY(device_id_list)
		)
	);

	--
	-- If device is a member of an MLAG, remove it.  This will also clean
	-- up any logical port assignments for this MLAG
	--

	FOREACH dev_id IN ARRAY device_id_list LOOP
		PERFORM logical_port_manip.remove_mlag_peer(device_id := dev_id);
	END LOOP;
	
	--
	-- Delete all layer2_connections involving these devices
	--

	WITH x AS (
		SELECT
			layer2_connection_id
		FROM
			layer2_connection l2c
		WHERE
			l2c.logical_port1_id IN (
				SELECT
					logical_port_id
				FROM
					logical_port lp
				WHERE
					lp.device_id = ANY(device_id_list)
			) OR
			l2c.logical_port2_id IN (
				SELECT
					logical_port_id
				FROM
					logical_port lp
				WHERE
					lp.device_id = ANY(device_id_list)
			)
	), z AS (
		DELETE FROM layer2_connection_layer2_network l2cl2n WHERE
			l2cl2n.layer2_connection_id IN (
				SELECT layer2_connection_id FROM x
			)
	)
	DELETE FROM layer2_connection l2c WHERE
		l2c.layer2_connection_id IN (
			SELECT layer2_connection_id FROM x
		);

	--
	-- Delete all logical ports for these devices
	--
	DELETE FROM logical_port lp WHERE lp.device_id = ANY(device_id_list);


	RAISE LOG 'Removing inter_component_connections...';

	WITH s AS (
		SELECT DISTINCT
			slot_id
		FROM
			v_device_slots ds
		WHERE
			ds.device_id = ANY(device_id_list)
	)
	DELETE FROM inter_component_connection WHERE
		slot1_id IN (SELECT slot_id FROM s) OR
		slot2_id IN (SELECT slot_id FROM s);

	RAISE LOG 'Removing device properties...';

	DELETE FROM property WHERE device_collection_id IN (
		SELECT
			dc.device_collection_id
		FROM
			device_collection dc JOIN
			device_collection_device dcd USING (device_collection_id)
		WHERE
			dc.device_collection_type = 'per-device' AND
			dcd.device_id = ANY(device_id_list)
	);

	RAISE LOG 'Removing inter_component_connections...';

	WITH s AS (
		SELECT DISTINCT
			slot_id
		FROM
			v_device_slots ds
		WHERE
			ds.device_id = ANY(device_id_list)
	)
	DELETE FROM inter_component_connection WHERE
		slot1_id IN (SELECT slot_id FROM s) OR
		slot2_id IN (SELECT slot_id FROM s);

	RAISE LOG 'Removing device properties...';

	DELETE FROM property WHERE device_collection_id IN (
		SELECT
			dc.device_collection_id
		FROM
			device_collection dc JOIN
			device_collection_device dcd USING (device_collection_id)
		WHERE
			dc.device_collection_type = 'per-device' AND
			dcd.device_id = ANY(device_id_list)
	);

	RAISE LOG 'Removing per-device device_collections...';

	DELETE FROM
		device_collection_device dcd
	WHERE
		dcd.device_id = ANY(device_id_list) AND
		device_collection_id NOT IN (
			SELECT
				device_collection_id
			FROM
				device_collection
			WHERE
				device_collection_type = 'per-device'
		);

	--
	-- Make sure all rack_location stuff has been cleared out
	--

	RAISE LOG 'Removing rack_locations...';

	SELECT array_agg(rack_location_id) INTO rl_list FROM (
		SELECT DISTINCT
			rack_location_id
		FROM
			device d
		WHERE
			d.device_id = ANY(device_id_list) AND
			rack_location_id IS NOT NULL
		UNION
		SELECT DISTINCT
			rack_location_id
		FROM
			component c JOIN
			v_device_components dc USING (component_id)
		WHERE
			dc.device_id = ANY(device_id_list) AND
			rack_location_id IS NOT NULL
	) x;

	UPDATE
		device d
	SET
		rack_location_id = NULL
	WHERE
		d.device_id = ANY(device_id_list) AND
		rack_location_id IS NOT NULL;

	UPDATE
		component
	SET
		rack_location_id = NULL
	WHERE
		component_id IN (
			SELECT
				component_id
			FROM
				v_device_components dc
			WHERE
				dc.device_id = ANY(device_id_list)
		) AND
		rack_location_id IS NOT NULL;

	--
	-- Delete any now-abandoned rack_locations
	--
	DELETE FROM
		rack_location rl
	WHERE
		rack_location_id = ANY (rl_list) AND
		rack_location_id NOT IN (
			SELECT
				rack_location_id
			FROM
				device
			WHERE
				rack_location_id IS NOT NULL
			UNION
			SELECT
				rack_location_id
			FROM
				component
			WHERE
				rack_location_id IS NOT NULL
		);

	RAISE LOG 'Removing device_management_controller links...';

	DELETE FROM device_management_controller dmc WHERE
		dmc.device_id = ANY (device_id_list) OR
		manager_device_id = ANY (device_id_list);

	RAISE LOG 'Removing device_encapsulation_domain entries...';

	DELETE FROM device_encapsulation_domain ded WHERE
		ded.device_id = ANY (device_id_list);

	--
	-- Clear out all of the logical_volume crap
	--
	RAISE LOG 'Removing logical volume hierarchies...';
	SET CONSTRAINTS ALL DEFERRED;

	DELETE FROM volume_group_physicalish_volume vgpv WHERE
		vgpv.device_id = ANY (device_id_list);
	DELETE FROM physicalish_volume pv WHERE
		pv.device_id = ANY (device_id_list);

	WITH z AS (
		DELETE FROM volume_group vg
		WHERE vg.device_id = ANY (device_id_list)
		RETURNING vg.volume_group_id
	)
	DELETE FROM volume_group_purpose WHERE
		volume_group_id IN (SELECT volume_group_id FROM z);

	WITH z AS (
		DELETE FROM logical_volume lv
		WHERE lv.device_id = ANY (device_id_list)
		RETURNING lv.logical_volume_id
	), y AS (
		DELETE FROM logical_volume_purpose WHERE
			logical_volume_id IN (SELECT logical_volume_id FROM z)
	)
	DELETE FROM logical_volume_property WHERE
		logical_volume_id IN (SELECT logical_volume_id FROM z);

	SET CONSTRAINTS ALL IMMEDIATE;

	--
	-- Attempt to delete all of the devices
	--
	SELECT service_environment_id INTO se_id FROM service_environment WHERE
		service_environment_name = 'unallocated';

	FOREACH dev_id IN ARRAY device_id_list LOOP
		RAISE LOG 'Deleting device %', dev_id;

		BEGIN
			DELETE FROM device_note dn WHERE dn.device_id = dev_id;

			DELETE FROM device d WHERE d.device_id = dev_id;
			device_id := dev_id;
			success := true;
			RETURN NEXT;
		EXCEPTION
			WHEN foreign_key_violation THEN
				UPDATE device d SET
					device_name = NULL,
					component_id = NULL,
					service_environment_id = se_id,
					device_status = 'removed',
					description = NULL
				WHERE
					d.device_id = dev_id;

				device_id := dev_id;
				success := false;
				RETURN NEXT;
		END;
	END LOOP;

	BEGIN
		PERFORM local_hooks.retire_devices_late(device_id_list);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		NULL;
	END;
	RETURN;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'device_manip' AND type = 'function' AND object IN ('retire_devices');
	DELETE FROM __regrants WHERE schema = 'device_manip' AND object IN ('retire_devices');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc retire_devices failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process middle (non-trigger) schema device_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('device_utils', 'remove_network_interface');
SELECT schema_support.save_grants_for_replay('device_utils', 'remove_network_interface');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS device_utils.remove_network_interface ( integer,integer,character varying );
CREATE OR REPLACE FUNCTION device_utils.remove_network_interface(network_interface_id integer DEFAULT NULL::integer, device_id integer DEFAULT NULL::integer, network_interface_name character varying DEFAULT NULL::character varying)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN device_manip.remove_layer3_interface(
		layer3_network_id := network_interface_id,
		device_id := device_id,
		layer3_interface_name := network_interface_name
	);
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'device_utils' AND type = 'function' AND object IN ('remove_network_interface');
	DELETE FROM __regrants WHERE schema = 'device_utils' AND object IN ('remove_network_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc remove_network_interface failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('device_utils', 'retire_devices');
SELECT schema_support.save_grants_for_replay('device_utils', 'retire_devices');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS device_utils.retire_devices ( integer[] );
CREATE OR REPLACE FUNCTION device_utils.retire_devices(device_id_list integer[])
 RETURNS TABLE(device_id integer, success boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	FOR _r IN SELECT (device_manip.retire_devices(device_id_list)).*
	LOOP
		device_id := _r.device_id;
		success := _r.success;
		RETURN NEXT;
	END LOOP;
	RETURN;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'device_utils' AND type = 'function' AND object IN ('retire_devices');
	DELETE FROM __regrants WHERE schema = 'device_utils' AND object IN ('retire_devices');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc retire_devices failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('device_utils', 'remove_network_interfaces');
DROP FUNCTION IF EXISTS device_utils.remove_network_interfaces ( integer[] );
CREATE OR REPLACE FUNCTION device_utils.remove_network_interfaces(network_interface_id_list integer[])
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN device_manip.remove_layer3_interfaces(network_interface_id_list);
END;
$function$
;

--
-- Process middle (non-trigger) schema netblock_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('netblock_utils', 'find_best_parent_id');
SELECT schema_support.save_grants_for_replay('netblock_utils', 'find_best_parent_id');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS netblock_utils.find_best_parent_id ( inet,integer,character varying,integer,text,integer,boolean,boolean,boolean );
CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_id(in_ipaddress inet, in_netmask_bits integer DEFAULT NULL::integer, in_netblock_type character varying DEFAULT 'default'::character varying, in_ip_universe_id integer DEFAULT 0, in_is_single_address text DEFAULT 'N'::text, in_netblock_id integer DEFAULT NULL::integer, in_fuzzy_can_subnet boolean DEFAULT false, can_fix_can_subnet boolean DEFAULT false, will_soon_be_dropped boolean DEFAULT true)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	p_single	BOOLEAN;
BEGIN
	IF in_is_single_address = 'Y' THEN
		p_single := true;
	ELSE
		p_single := false;
	END IF;

	RETURN netblock_utils.find_best_parent_netblock_id(
		ip_address			:= in_IpAddress,
		netmask_bits		:= in_Netmask_Bits,
		netblock_type		:= in_netblock_type,
		ip_universe_id		:= in_ip_universe_id,
		is_single_address	:= p_single,
		netblock_id			:= in_netblock_id,
		fuzzy_can_subnet	:= in_fuzzy_can_subnet
	);
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'netblock_utils' AND type = 'function' AND object IN ('find_best_parent_id');
	DELETE FROM __regrants WHERE schema = 'netblock_utils' AND object IN ('find_best_parent_id');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc find_best_parent_id failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process middle (non-trigger) schema property_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('property_utils', 'validate_property');
SELECT schema_support.save_grants_for_replay('property_utils', 'validate_property');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS property_utils.validate_property ( new jazzhands.property );
CREATE OR REPLACE FUNCTION property_utils.validate_property(new jazzhands.property)
 RETURNS jazzhands.property
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	tally				integer;
	v_prop				VAL_Property%ROWTYPE;
	v_proptype			VAL_Property_Type%ROWTYPE;
	v_account_collection		account_collection%ROWTYPE;
	v_company_collection		company_collection%ROWTYPE;
	v_device_collection		device_collection%ROWTYPE;
	v_dns_domain_collection		dns_domain_collection%ROWTYPE;
	v_layer2_network_collection	layer2_network_collection%ROWTYPE;
	v_layer3_network_collection	layer3_network_collection%ROWTYPE;
	v_netblock_collection		netblock_collection%ROWTYPE;
	v_network_range				network_range%ROWTYPE;
	v_property_name_collection		property_name_collection%ROWTYPE;
	v_service_environment_collection	service_environment_collection%ROWTYPE;
	v_num				integer;
	v_listvalue			Property.Property_Value%TYPE;
BEGIN
	-- Pull in the data from the property and property_type so we can
	-- figure out what is and is not valid

	BEGIN
		SELECT * INTO STRICT v_prop FROM VAL_Property WHERE
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type;

		SELECT * INTO STRICT v_proptype FROM VAL_Property_Type WHERE
			Property_Type = NEW.Property_Type;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION
				'Property name or type does not exist'
				USING ERRCODE = 'foreign_key_violation';
			RETURN NULL;
	END;

	-- Check to see if the property itself is multivalue.  That is, if only
	-- one value can be set for this property for a specific property LHS
	IF (v_prop.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of type (%,%) already exists for given LHS and property is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	ELSE
		-- check for the same lhs+rhs existing, which is basically a dup row
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code AND
			property_value IS NOT DISTINCT FROM NEW.property_value AND
			property_value_json IS NOT DISTINCT FROM
				NEW.property_value_json AND
			property_value_boolean IS NOT DISTINCT FROM
				NEW.property_value_boolean AND
			property_value_timestamp IS NOT DISTINCT FROM
				NEW.property_value_timestamp AND
			property_value_account_collection_id IS NOT DISTINCT FROM
				NEW.property_value_account_collection_id AND
			property_value_device_collection_id IS NOT DISTINCT FROM
				NEW.property_value_device_collection_id AND
			property_value_netblock_collection_id IS NOT DISTINCT FROM
				NEW.property_value_netblock_collection_id AND
			property_value_password_type IS NOT DISTINCT FROM
				NEW.property_value_password_type AND
			property_value_sw_package_id IS NOT DISTINCT FROM
				NEW.property_value_sw_package_id AND
			property_value_token_collection_id IS NOT DISTINCT FROM
				NEW.property_value_token_collection_id AND
			property_value_encryption_key_id IS NOT DISTINCT FROM
				NEW.property_value_encryption_key_id AND
			property_value_private_key_id IS NOT DISTINCT FROM
				NEW.property_value_private_key_id AND
			start_date IS NOT DISTINCT FROM NEW.start_date AND
			finish_date IS NOT DISTINCT FROM NEW.finish_date
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of (n,t) (%,%) already exists for given property',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;

	END IF;

	-- Check to see if the property type is multivalue.  That is, if only
	-- one property and value can be set for any properties with this type
	-- for a specific property LHS

	IF (v_proptype.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property % of type % already exists for given LHS and property type is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	END IF;

	-- now validate the property_value columns.
	tally := 0;

	--
	-- first determine if the property_value is set properly.
	--

	-- iterate over each of fk PROPERTY_VALUE columns and if a valid
	-- value is set, increment tally, otherwise raise an exception.
	IF NEW.Property_Value_JSON IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'json' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be JSON' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Password_Type IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'password_type' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Password_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Token_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'token_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Token_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_SW_Package_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'sw_package_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be SW_Package_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'account_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be account_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'netblock_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be netblock_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Timestamp IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'timestamp' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Timestamp' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'device_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Device_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_boolean IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'boolean' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be boolean' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_encryption_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'encryption_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be encryption_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_private_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'private_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be private_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- at this point, tally will be set to 1 if one of the other property
	-- values is set to something valid.  Now, check the various options for
	-- PROPERTY_VALUE itself.  If a new type is added to the val table, this
	-- trigger needs to be updated or it will be considered invalid.  If a
	-- new PROPERTY_VALUE_* column is added, then it will pass through without
	-- trigger modification.  This should be considered bad.
	IF NEW.Property_Value IS NOT NULL THEN
		tally := tally + 1;
		IF v_prop.Property_Data_Type = 'number' THEN
			BEGIN
				v_num := to_number(NEW.property_value, '9');
			EXCEPTION
				WHEN OTHERS THEN
					RAISE 'Property_Value must be numeric' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'list' THEN
			BEGIN
				SELECT Valid_Property_Value INTO STRICT v_listvalue FROM
					VAL_Property_Value WHERE
						Property_Name = NEW.Property_Name AND
						Property_Type = NEW.Property_Type AND
						Valid_Property_Value = NEW.Property_Value;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					RAISE 'Property_Value must be a valid value' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type != 'string' THEN
			RAISE 'Property_Data_Type is not a known type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF v_prop.Property_Data_Type != 'none' AND tally = 0 THEN
		RAISE 'One of the PROPERTY_VALUE fields must be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	IF tally > 1 THEN
		RAISE 'Only one of the PROPERTY_VALUE fields may be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	-- If the LHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.account_collection_id IS NOT NULL THEN
		IF v_prop.account_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.account_collection_id;
				IF v_account_collection.account_collection_Type != v_prop.account_collection_type
				THEN
					RAISE 'account_collection_id must be of type %',
					v_prop.account_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a company_collection_ID, check to see if it must be a
	-- specific type (e.g. per-company), and verify that if so
	IF NEW.company_collection_id IS NOT NULL THEN
		IF v_prop.company_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_company_collection
					FROM company_collection WHERE
					company_collection_Id = NEW.company_collection_id;
				IF v_company_collection.company_collection_Type != v_prop.company_collection_type
				THEN
					RAISE 'company_collection_id must be of type %',
					v_prop.company_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a device_collection_ID, check to see if it must be a
	-- specific type (e.g. per-device), and verify that if so
	IF NEW.device_collection_id IS NOT NULL THEN
		IF v_prop.device_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_Id = NEW.device_collection_id;
				IF v_device_collection.device_collection_Type != v_prop.device_collection_type
				THEN
					RAISE 'device_collection_id must be of type %',
					v_prop.device_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a dns_domain_collection_ID, check to see if it must be a
	-- specific type (e.g. per-dns_domain), and verify that if so
	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		IF v_prop.dns_domain_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_dns_domain_collection
					FROM dns_domain_collection WHERE
					dns_domain_collection_Id = NEW.dns_domain_collection_id;
				IF v_dns_domain_collection.dns_domain_collection_Type != v_prop.dns_domain_collection_type
				THEN
					RAISE 'dns_domain_collection_id must be of type %',
					v_prop.dns_domain_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer2_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer2_network), and verify that if so
	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		IF v_prop.layer2_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer2_network_collection
					FROM layer2_network_collection WHERE
					layer2_network_collection_Id = NEW.layer2_network_collection_id;
				IF v_layer2_network_collection.layer2_network_collection_Type != v_prop.layer2_network_collection_type
				THEN
					RAISE 'layer2_network_collection_id must be of type %',
					v_prop.layer2_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer3_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer3_network), and verify that if so
	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		IF v_prop.layer3_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer3_network_collection
					FROM layer3_network_collection WHERE
					layer3_network_collection_Id = NEW.layer3_network_collection_id;
				IF v_layer3_network_collection.layer3_network_collection_Type != v_prop.layer3_network_collection_type
				THEN
					RAISE 'layer3_network_collection_id must be of type %',
					v_prop.layer3_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type (e.g. per-netblock), and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.netblock_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.netblock_collection_id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.netblock_collection_type
				THEN
					RAISE 'netblock_collection_id must be of type %',
					v_prop.netblock_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a network_range_id, check to see if it must
	-- be a specific type and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.network_range_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_network_range
					FROM network_range WHERE
					network_range_id = NEW.network_range_id;
				IF v_network_range.network_range_type != v_prop.network_range_type
				THEN
					RAISE 'network_range_id must be of type %',
					v_prop.network_range_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a property_name_collection_ID, check to see if it must be a
	-- specific type (e.g. per-property), and verify that if so
	IF NEW.property_name_collection_id IS NOT NULL THEN
		IF v_prop.property_name_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_property_name_collection
					FROM property_name_collection WHERE
					property_name_collection_Id = NEW.property_name_collection_id;
				IF v_property_name_collection.property_name_collection_Type != v_prop.property_name_collection_type
				THEN
					RAISE 'property_name_collection_id must be of type %',
					v_prop.property_name_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a service_environment_collection_ID, check to see if it must be a
	-- specific type (e.g. per-service_env), and verify that if so
	IF NEW.service_environment_collection_id IS NOT NULL THEN
		IF v_prop.service_environment_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_environment_collection
					FROM service_environment_collection WHERE
					service_environment_collection_Id = NEW.service_environment_collection_id;
				IF v_service_environment_collection.service_environment_collection_Type != v_prop.service_environment_collection_type
				THEN
					RAISE 'service_environment_collection_id must be of type %',
					v_prop.service_environment_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_account_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.Property_Value_Account_collection_Id;
				IF v_account_collection.account_collection_Type != v_prop.property_value_account_collection_type_restriction
				THEN
					RAISE 'Property_Value_Account_collection_Id must be of type %',
					v_prop.property_value_account_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_account_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.Property_Value_netblock_collection_Id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.property_value_account_collection_type_restriction
				THEN
					RAISE 'Property_Value_netblock_collection_Id must be of type %',
					v_prop.property_value_account_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a device_collection_id, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.prop_val_dev_collection_type_rstrct IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_id = NEW.Property_Value_Device_collection_Id;
				IF v_device_collection.device_collection_type !=
					v_prop.prop_val_dev_collection_type_rstrct
				THEN
					RAISE 'Property_Value_Device_collection_Id must be of type %',
					v_prop.prop_val_dev_collection_type_rstrct
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	--
	--
	IF v_prop.property_data_type = 'json' THEN
		IF  NOT validate_json_schema(
				v_prop.property_value_json_schema,
				NEW.property_value_json) THEN
			RAISE EXCEPTION 'JSON provided must match the json schema'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- At this point, the RHS has been checked, so now we verify data
	-- set on the LHS

	-- There needs to be a stanza here for every "lhs".  If a new column is
	-- added to the property table, a new stanza needs to be added here,
	-- otherwise it will not be validated.  This should be considered bad.

	IF v_prop.Permit_Company_Id = 'REQUIRED' THEN
			IF NEW.Company_Id IS NULL THEN
				RAISE 'Company_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Id = 'PROHIBITED' THEN
			IF NEW.Company_Id IS NOT NULL THEN
				RAISE 'Company_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Company_Collection_Id = 'REQUIRED' THEN
			IF NEW.Company_Collection_Id IS NULL THEN
				RAISE 'Company_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Company_Collection_Id IS NOT NULL THEN
				RAISE 'Company_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Device_Collection_Id = 'REQUIRED' THEN
			IF NEW.Device_Collection_Id IS NULL THEN
				RAISE 'Device_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;

	ELSIF v_prop.Permit_Device_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Device_Collection_Id IS NOT NULL THEN
				RAISE 'Device_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_service_environment_collection = 'REQUIRED' THEN
			IF NEW.service_environment_collection_id IS NULL THEN
				RAISE 'service_environment_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_service_environment_collection = 'PROHIBITED' THEN
			IF NEW.service_environment_collection_id IS NOT NULL THEN
				RAISE 'service_environment is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Operating_System_Id = 'REQUIRED' THEN
			IF NEW.Operating_System_Id IS NULL THEN
				RAISE 'Operating_System_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Operating_System_Id = 'PROHIBITED' THEN
			IF NEW.Operating_System_Id IS NOT NULL THEN
				RAISE 'Operating_System_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_operating_system_snapshot_id = 'REQUIRED' THEN
			IF NEW.operating_system_snapshot_id IS NULL THEN
				RAISE 'operating_system_snapshot_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_operating_system_snapshot_id = 'PROHIBITED' THEN
			IF NEW.operating_system_snapshot_id IS NOT NULL THEN
				RAISE 'operating_system_snapshot_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Site_Code = 'REQUIRED' THEN
			IF NEW.Site_Code IS NULL THEN
				RAISE 'Site_Code is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Site_Code = 'PROHIBITED' THEN
			IF NEW.Site_Code IS NOT NULL THEN
				RAISE 'Site_Code is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Id = 'REQUIRED' THEN
			IF NEW.Account_Id IS NULL THEN
				RAISE 'Account_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Id = 'PROHIBITED' THEN
			IF NEW.Account_Id IS NOT NULL THEN
				RAISE 'Account_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Realm_Id = 'REQUIRED' THEN
			IF NEW.Account_Realm_Id IS NULL THEN
				RAISE 'Account_Realm_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Realm_Id = 'PROHIBITED' THEN
			IF NEW.Account_Realm_Id IS NOT NULL THEN
				RAISE 'Account_Realm_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_account_collection_Id = 'REQUIRED' THEN
			IF NEW.account_collection_Id IS NULL THEN
				RAISE 'account_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_account_collection_Id = 'PROHIBITED' THEN
			IF NEW.account_collection_Id IS NOT NULL THEN
				RAISE 'account_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer2_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer2_network_collection_id IS NULL THEN
				RAISE 'layer2_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer2_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer2_network_collection_id IS NOT NULL THEN
				RAISE 'layer2_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer3_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer3_network_collection_id IS NULL THEN
				RAISE 'layer3_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer3_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer3_network_collection_id IS NOT NULL THEN
				RAISE 'layer3_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_netblock_collection_Id = 'REQUIRED' THEN
			IF NEW.netblock_collection_Id IS NULL THEN
				RAISE 'netblock_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_netblock_collection_Id = 'PROHIBITED' THEN
			IF NEW.netblock_collection_Id IS NOT NULL THEN
				RAISE 'netblock_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_network_range_id = 'REQUIRED' THEN
			IF NEW.network_range_id IS NULL THEN
				RAISE 'network_range_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_network_range_id = 'PROHIBITED' THEN
			IF NEW.network_range_id IS NOT NULL THEN
				RAISE 'network_range_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_property_name_collection_Id = 'REQUIRED' THEN
			IF NEW.property_name_collection_Id IS NULL THEN
				RAISE 'property_name_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_property_name_collection_Id = 'PROHIBITED' THEN
			IF NEW.property_name_collection_Id IS NOT NULL THEN
				RAISE 'property_name_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Property_Rank = 'REQUIRED' THEN
			IF NEW.property_rank IS NULL THEN
				RAISE 'property_rank is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Property_Rank = 'PROHIBITED' THEN
			IF NEW.property_rank IS NOT NULL THEN
				RAISE 'property_rank is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'property_utils' AND type = 'function' AND object IN ('validate_property');
	DELETE FROM __regrants WHERE schema = 'property_utils' AND object IN ('validate_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc validate_property failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
--
-- Process middle (non-trigger) schema netblock_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('netblock_manip', 'set_interface_addresses');
SELECT schema_support.save_grants_for_replay('netblock_manip', 'set_interface_addresses');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS netblock_manip.set_interface_addresses ( integer,integer,text,text,jsonb,boolean,text,text );
CREATE OR REPLACE FUNCTION netblock_manip.set_interface_addresses(network_interface_id integer DEFAULT NULL::integer, device_id integer DEFAULT NULL::integer, network_interface_name text DEFAULT NULL::text, network_interface_type text DEFAULT 'broadcast'::text, ip_address_hash jsonb DEFAULT NULL::jsonb, create_layer3_networks boolean DEFAULT false, move_addresses text DEFAULT 'if_same_device'::text, address_errors text DEFAULT 'error'::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
--
-- ip_address_hash consists of the following elements
--
--		"ip_addresses" : [ (inet | netblock) ... ]
--		"shared_ip_addresses" : [ (inet | netblock) ... ]
--
-- where inet is a text string that can be legally converted to type inet
-- and netblock is a JSON object with fields:
--		"ip_address" : inet
--		"ip_universe_id" : integer (default 0)
--		"netblock_type" : text (default 'default')
--		"protocol" : text (default 'VRRP')
--
-- If either "ip_addresses" or "shared_ip_addresses" does not exist, it
-- will not be processed.  If the key is present and is an empty array or
-- null, then all IP addresses of those types will be removed from the
-- interface
--
-- 'protocol' is only valid for shared addresses, which is how the address
-- is shared.  Valid values can be found in the val_shared_netblock_protocol
-- table
--
DECLARE
    layer3_interface_id ALIAS FOR network_interface_id;
    layer3_interface_name ALIAS FOR network_interface_name;
    layer3_interface_type ALIAS FOR network_interface_type;
	ni_id			ALIAS FOR network_interface_id;
	dev_id			ALIAS FOR device_id;
	ni_name			ALIAS FOR network_interface_name;
	ni_type			ALIAS FOR network_interface_type;

	addrs_ary		jsonb;
	ipaddr			inet;
	universe		integer;
	nb_type			text;
	protocol		text;

	c				integer;
	i				integer;

	error_rec		RECORD;
	nb_rec			RECORD;
	pnb_rec			RECORD;
	layer3_rec		RECORD;
	sn_rec			RECORD;
	ni_rec			RECORD;
	nin_rec			RECORD;
	nb_id			jazzhands.netblock.netblock_id%TYPE;
	nb_id_ary		integer[];
	ni_id_ary		integer[];
	del_list		integer[];
BEGIN
	--
	-- Validate that we got enough information passed to do things
	--

	IF ip_address_hash IS NULL OR NOT
		(jsonb_typeof(ip_address_hash) = 'object')
	THEN
		RAISE 'Must pass ip_addresses to netblock_manip.set_interface_addresses';
	END IF;

	IF layer3_interface_id IS NULL THEN
		IF device_id IS NULL OR layer3_interface_name IS NULL THEN
			RAISE 'netblock_manip.assign_shared_netblock: must pass either layer3_interface_id or device_id and layer3_interface_name'
			USING ERRCODE = 'invalid_parameter_value';
		END IF;

		SELECT
			ni.layer3_interface_id INTO ni_id
		FROM
			layer3_interface ni
		WHERE
			ni.device_id = dev_id AND
			ni.layer3_interface_name = ni_name;

		IF NOT FOUND THEN
			INSERT INTO layer3_interface(
				device_id,
				layer3_interface_name,
				layer3_interface_type,
				should_monitor
			) VALUES (
				dev_id,
				ni_name,
				ni_type,
				false
			) RETURNING layer3_interface.layer3_interface_id INTO ni_id;
		END IF;
	END IF;

	SELECT * INTO ni_rec FROM layer3_interface ni WHERE 
		ni.layer3_interface_id = ni_id;

	--
	-- First, loop through ip_addresses passed and process those
	--

	IF ip_address_hash ? 'ip_addresses' AND
		jsonb_typeof(ip_address_hash->'ip_addresses') = 'array'
	THEN
		RAISE DEBUG 'Processing ip_addresses...';
		--
		-- Loop through each member of the ip_addresses array
		-- and process each address
		--
		addrs_ary := ip_address_hash->'ip_addresses';
		c := jsonb_array_length(addrs_ary);
		i := 0;
		nb_id_ary := NULL;
		WHILE (i < c) LOOP
			IF jsonb_typeof(addrs_ary->i) = 'string' THEN
				--
				-- If this is a string, use it as an inet with default
				-- universe and netblock_type
				--
				ipaddr := addrs_ary->>i;
				universe := netblock_utils.find_best_ip_universe(ipaddr);
				nb_type := 'default';
			ELSIF jsonb_typeof(addrs_ary->i) = 'object' THEN
				--
				-- If this is an object, require 'ip_address' key
				-- optionally use 'ip_universe_id' and 'netblock_type' keys
				-- to override the defaults
				--
				IF NOT addrs_ary->i ? 'ip_address' THEN
					RAISE E'Object in array element % of ip_addresses in ip_address_hash in netblock_manip.set_interface_addresses does not contain ip_address key:\n%',
						i, jsonb_pretty(addrs_ary->i);
				END IF;
				ipaddr := addrs_ary->i->>'ip_address';

				IF addrs_ary->i ? 'ip_universe_id' THEN
					universe := addrs_ary->i->'ip_universe_id';
				ELSE
					universe := netblock_utils.find_best_ip_universe(ipaddr);
				END IF;

				IF addrs_ary->i ? 'netblock_type' THEN
					nb_type := addrs_ary->i->>'netblock_type';
				ELSE
					nb_type := 'default';
				END IF;
			ELSE
				RAISE 'Invalid type in array element % of ip_addresses in ip_address_hash in netblock_manip.set_interface_addresses (%)',
					i, jsonb_typeof(addrs_ary->i);
			END IF;
			--
			-- We're done with the array, so increment the counter so
			-- we don't have to deal with it later
			--
			i := i + 1;

			RAISE DEBUG 'Address is %, universe is %, nb type is %',
				ipaddr, universe, nb_type;

			--
			-- This is a hack, because Juniper is really annoying about this.
			-- If masklen < 8, then ignore this netblock (we specifically
			-- want /8, because of 127/8 and 10/8, which someone could
			-- maybe want to not subnet.
			--
			-- This should probably be a configuration parameter, but it's not.
			--
			CONTINUE WHEN masklen(ipaddr) < 8;

			--
			-- Check to see if this is a netblock that we have been
			-- told to explicitly ignore
			--
			PERFORM
				ip_address
			FROM
				netblock n JOIN
				netblock_collection_netblock ncn USING (netblock_id) JOIN
				v_netblock_collection_expanded nce USING (netblock_collection_id)
					JOIN
				property p ON (
					property_name = 'IgnoreProbedNetblocks' AND
					property_type = 'DeviceInventory' AND
					property_value_netblock_collection_id =
						nce.root_netblock_collection_id
				)
			WHERE
				ipaddr <<= n.ip_address AND
				n.ip_universe_id = universe
			;

			--
			-- If we found this netblock in the ignore list, then just
			-- skip it
			--
			IF FOUND THEN
				RAISE DEBUG 'Skipping ignored address %', ipaddr;
				CONTINUE;
			END IF;

			--
			-- Look for an is_single_address=true, can_subnet=false netblock
			-- with the given ip_address
			--
			SELECT
				* INTO nb_rec
			FROM
				netblock n
			WHERE
				is_single_address = true AND
				can_subnet = false AND
				netblock_type = nb_type AND
				ip_universe_id = universe AND
				host(ip_address) = host(ipaddr);

			IF FOUND THEN
				RAISE DEBUG E'Located netblock:\n%',
					jsonb_pretty(to_jsonb(nb_rec));

				nb_id_ary := array_append(nb_id_ary, nb_rec.netblock_id);

				--
				-- Look to see if there's a layer3_network for the
				-- parent netblock
				--
				SELECT
					n.netblock_id,
					n.ip_address,
					layer3_network_id,
					default_gateway_netblock_id
				INTO layer3_rec
				FROM
					netblock n LEFT JOIN
					layer3_network l3 USING (netblock_id)
				WHERE
					n.netblock_id = nb_rec.parent_netblock_id;

				IF FOUND THEN
					RAISE DEBUG E'Located layer3_network:\n%',
						jsonb_pretty(to_jsonb(layer3_rec));
				ELSE
					--
					-- If we're told to create the layer3_network,
					-- then do that, otherwise go to the next address
					--
					CONTINUE WHEN NOT create_layer3_networks;
					INSERT INTO layer3_network(
						netblock_id
					) VALUES (
						layer3_rec.netblock_id
					) RETURNING layer3_network_id INTO
						layer3_rec.layer3_network_id;
				END IF;
			ELSE
				--
				-- If the parent netblock does not exist, then create it
				-- if we were passed the option to
				--
				SELECT
					n.netblock_id,
					n.ip_address,
					layer3_network_id,
					default_gateway_netblock_id
				INTO layer3_rec
				FROM
					netblock n LEFT JOIN
					layer3_network l3 USING (netblock_id)
				WHERE
					n.ip_universe_id = universe AND
					n.netblock_type = nb_type AND
					is_single_address = false AND
					can_subnet = false AND
					n.ip_address >>= ipaddr;

				IF NOT FOUND THEN
					RAISE DEBUG 'Parent netblock with ip_address %, netblock_type %, ip_universe_id % not found',
						network(ipaddr),
						nb_type,
						universe;
					CONTINUE WHEN NOT create_layer3_networks;
					--
					-- Check to see if the netblock exists, but is
					-- marked can_subnet=true.  If so, fix it
					--
					SELECT
						* INTO pnb_rec
					FROM
						netblock n
					WHERE
						n.ip_universe_id = universe AND
						n.netblock_type = nb_type AND
						n.is_single_address = false AND
						n.can_subnet = true AND
						n.ip_address = network(ipaddr);

					IF FOUND THEN
						UPDATE netblock n SET
							can_subnet = false
						WHERE
							n.netblock_id = pnb_rec.netblock_id;
						pnb_rec.can_subnet = false;
					ELSE
						INSERT INTO netblock (
							ip_address,
							netblock_type,
							is_single_address,
							can_subnet,
							ip_universe_id,
							netblock_status
						) VALUES (
							network(ipaddr),
							nb_type,
							false,
							false,
							universe,
							'Allocated'
						) RETURNING * INTO pnb_rec;
					END IF;

					WITH l3_ins AS (
						INSERT INTO layer3_network(
							netblock_id
						) VALUES (
							pnb_rec.netblock_id
						) RETURNING *
					)
					SELECT
						pnb_rec.netblock_id,
						pnb_rec.ip_address,
						l3_ins.layer3_network_id,
						NULL::inet
					INTO layer3_rec
					FROM
						l3_ins;
				ELSIF layer3_rec.layer3_network_id IS NULL THEN
					--
					-- If we're told to create the layer3_network,
					-- then do that, otherwise go to the next address
					--

					RAISE DEBUG 'layer3_network for parent netblock % not found (ip_address %, netblock_type %, ip_universe_id %)',
						layer3_rec.netblock_id,
						network(ipaddr),
						nb_type,
						universe;
					CONTINUE WHEN NOT create_layer3_networks;
					INSERT INTO layer3_network(
						netblock_id
					) VALUES (
						layer3_rec.netblock_id
					) RETURNING layer3_network_id INTO
						layer3_rec.layer3_network_id;
				END IF;
				RAISE DEBUG E'Located layer3_network:\n%',
					jsonb_pretty(to_jsonb(layer3_rec));
				--
				-- Parents should be all set up now.  Insert the netblock
				--
				INSERT INTO netblock (
					ip_address,
					netblock_type,
					ip_universe_id,
					is_single_address,
					can_subnet,
					netblock_status
				) VALUES (
					ipaddr,
					nb_type,
					universe,
					true,
					false,
					'Allocated'
				) RETURNING * INTO nb_rec;
				nb_id_ary := array_append(nb_id_ary, nb_rec.netblock_id);
			END IF;
			--
			-- Now that we have the netblock and everything, check to see
			-- if this netblock is already assigned to this layer3_interface
			--
			PERFORM * FROM
				layer3_interface_netblock nin
			WHERE
				nin.netblock_id = nb_rec.netblock_id AND
				nin.layer3_interface_id = ni_id;

			IF FOUND THEN
				RAISE DEBUG 'Netblock % already found on layer3_interface',
					nb_rec.netblock_id;
				CONTINUE;
			END IF;

			--
			-- See if this netblock is on something else, and delete it
			-- if move_addresses is set, otherwise skip it
			--
			SELECT 
				ni.layer3_interface_id,
				ni.layer3_interface_name,
				nin.netblock_id,
				d.device_id,
				COALESCE(d.device_name, d.physical_label) AS device_name
			INTO nin_rec
			FROM
				layer3_interface_netblock nin JOIN
				layer3_interface ni USING (layer3_interface_id) JOIN
				device d ON (nin.device_id = d.device_id)
			WHERE
				nin.netblock_id = nb_rec.netblock_id AND
				nin.layer3_interface_id != ni_id;

			IF FOUND THEN
				IF move_addresses = 'always' OR (
					move_addresses = 'if_same_device' AND
					nin_rec.device_id = ni_rec.device_id
				)
				THEN
					DELETE FROM
						layer3_interface_netblock
					WHERE
						netblock_id = nb_rec.netblock_id;
				ELSE
					IF address_errors = 'ignore' THEN
						RAISE DEBUG 'Netblock % is assigned to layer3_interface %',
							nb_rec.netblock_id, nin_rec.layer3_interface_id;

						CONTINUE;
					ELSIF address_errors = 'warn' THEN
						RAISE NOTICE 'Netblock % (%) is assigned to layer3_interface % (%) on device % (%)',
							nb_rec.netblock_id,
							nb_rec.ip_address,
							nin_rec.layer3_interface_id,
							nin_rec.layer3_interface_name,
							nin_rec.device_id,
							nin_rec.device_name;

						CONTINUE;
					ELSE
						RAISE 'Netblock % (%) is assigned to layer3_interface %(%) on device % (%)',
							nb_rec.netblock_id,
							nb_rec.ip_address,
							nin_rec.layer3_interface_id,
							nin_rec.layer3_interface_name,
							nin_rec.device_id,
							nin_rec.device_name;
					END IF;
				END IF;
			END IF;

			--
			-- See if this netblock is on a shared_address somewhere, and
			-- move it only if move_addresses is 'always'
			--
			SELECT * FROM
				shared_netblock sn
			INTO sn_rec
			WHERE
				sn.netblock_id = nb_rec.netblock_id;

			IF FOUND THEN
				IF move_addresses IS NULL OR move_addresses != 'always' THEN
					IF address_errors = 'ignore' THEN
						RAISE DEBUG 'Netblock % is assigned to a shared_network %, but not forcing, so skipping',
							nb_rec.netblock_id, sn.shared_netblock_id;
						CONTINUE;
					ELSIF address_errors = 'warn' THEN
						RAISE NOTICE 'Netblock % (%) is assigned to a shared_network %, but not forcing, so skipping',
							nb_rec.netblock_id, nb_rec.ip_address,
							sn.shared_netblock_id;
						CONTINUE;
					ELSE
						RAISE 'Netblock % (%) is assigned to a shared_network %, but not forcing, so skipping',
							nb_rec.netblock_id, nb_rec.ip_address,
							sn.shared_netblock_id;
						CONTINUE;
					END IF;
				END IF;

				DELETE FROM
					shared_netblock_layer3_interface snni
				WHERE
					snni.shared_netblock_id = sn_rec.shared_netblock_id;

				DELETE FROM
					shared_network sn
				WHERE
					sn.netblock_id = sn_rec.shared_netblock_id;
			END IF;

			--
			-- Insert the netblock onto the interface using the next
			-- rank
			--
			INSERT INTO layer3_interface_netblock (
				layer3_interface_id,
				netblock_id,
				network_interface_rank
			) SELECT
				ni_id,
				nb_rec.netblock_id,
				COALESCE(MAX(network_interface_rank) + 1, 0)
			FROM
				layer3_interface_netblock nin
			WHERE
				nin.layer3_interface_id = ni_id
			RETURNING * INTO nin_rec;

			RAISE DEBUG E'Inserted into:\n%',
				jsonb_pretty(to_jsonb(nin_rec));
		END LOOP;
		--
		-- Remove any netblocks that are on the interface that are not
		-- supposed to be (and that aren't ignored).
		--

		FOR nin_rec IN
			DELETE FROM
				layer3_interface_netblock nin
			WHERE
				(nin.layer3_interface_id, nin.netblock_id) IN (
				SELECT
					nin2.layer3_interface_id,
					nin2.netblock_id
				FROM
					layer3_interface_netblock nin2 JOIN
					netblock n USING (netblock_id)
				WHERE
					nin2.layer3_interface_id = ni_id AND NOT (
						nin.netblock_id = ANY(nb_id_ary) OR
						n.ip_address <<= ANY ( ARRAY (
							SELECT
								n2.ip_address
							FROM
								netblock n2 JOIN
								netblock_collection_netblock ncn USING
									(netblock_id) JOIN
								v_netblock_collection_expanded nce USING
									(netblock_collection_id) JOIN
								property p ON (
									property_name = 'IgnoreProbedNetblocks' AND
									property_type = 'DeviceInventory' AND
									property_value_netblock_collection_id =
										nce.root_netblock_collection_id
								)
						))
					)
			)
			RETURNING *
		LOOP
			RAISE DEBUG 'Removed netblock % from layer3_interface %',
				nin_rec.netblock_id,
				nin_rec.layer3_interface_id;
			--
			-- Remove any DNS records and/or netblocks that aren't used
			--
			BEGIN
				DELETE FROM dns_record WHERE netblock_id = nin_rec.netblock_id;
				DELETE FROM netblock_collection_netblock WHERE
					netblock_id = nin_rec.netblock_id;
				DELETE FROM netblock WHERE netblock_id =
					nin_rec.netblock_id;
			EXCEPTION
				WHEN foreign_key_violation THEN NULL;
			END;
		END LOOP;
	END IF;

	--
	-- Loop through shared_ip_addresses passed and process those
	--

	IF ip_address_hash ? 'shared_ip_addresses' AND
		jsonb_typeof(ip_address_hash->'shared_ip_addresses') = 'array'
	THEN
		RAISE DEBUG 'Processing shared_ip_addresses...';
		--
		-- Loop through each member of the shared_ip_addresses array
		-- and process each address
		--
		addrs_ary := ip_address_hash->'shared_ip_addresses';
		c := jsonb_array_length(addrs_ary);
		i := 0;
		nb_id_ary := NULL;
		WHILE (i < c) LOOP
			IF jsonb_typeof(addrs_ary->i) = 'string' THEN
				--
				-- If this is a string, use it as an inet with default
				-- universe and netblock_type
				--
				ipaddr := addrs_ary->>i;
				universe := netblock_utils.find_best_ip_universe(ipaddr);
				nb_type := 'default';
				protocol := 'VRRP';
			ELSIF jsonb_typeof(addrs_ary->i) = 'object' THEN
				--
				-- If this is an object, require 'ip_address' key
				-- optionally use 'ip_universe_id' and 'netblock_type' keys
				-- to override the defaults
				--
				IF NOT addrs_ary->i ? 'ip_address' THEN
					RAISE E'Object in array element % of shared_ip_addresses in ip_address_hash in netblock_manip.set_interface_addresses does not contain ip_address key:\n%',
						i, jsonb_pretty(addrs_ary->i);
				END IF;
				ipaddr := addrs_ary->i->>'ip_address';

				IF addrs_ary->i ? 'ip_universe_id' THEN
					universe := addrs_ary->i->'ip_universe_id';
				ELSE
					universe := netblock_utils.find_best_ip_universe(ipaddr);
				END IF;

				IF addrs_ary->i ? 'netblock_type' THEN
					nb_type := addrs_ary->i->>'netblock_type';
				ELSE
					nb_type := 'default';
				END IF;

				IF addrs_ary->i ? 'shared_netblock_protocol' THEN
					protocol := addrs_ary->i->>'shared_netblock_protocol';
				ELSIF addrs_ary->i ? 'protocol' THEN
					protocol := addrs_ary->i->>'protocol';
				ELSE
					protocol := 'VRRP';
				END IF;
			ELSE
				RAISE 'Invalid type in array element % of shared_ip_addresses in ip_address_hash in netblock_manip.set_interface_addresses (%)',
					i, jsonb_typeof(addrs_ary->i);
			END IF;
			--
			-- We're done with the array, so increment the counter so
			-- we don't have to deal with it later
			--
			i := i + 1;

			RAISE DEBUG 'Address is %, universe is %, nb type is %',
				ipaddr, universe, nb_type;

			--
			-- Check to see if this is a netblock that we have been
			-- told to explicitly ignore
			--
			PERFORM
				ip_address
			FROM
				netblock n JOIN
				netblock_collection_netblock ncn USING (netblock_id) JOIN
				v_netblock_collection_expanded nce USING (netblock_collection_id)
					JOIN
				property p ON (
					property_name = 'IgnoreProbedNetblocks' AND
					property_type = 'DeviceInventory' AND
					property_value_netblock_collection_id =
						nce.root_netblock_collection_id
				)
			WHERE
				ipaddr <<= n.ip_address AND
				n.ip_universe_id = universe AND
				n.netblock_type = nb_type;

			--
			-- If we found this netblock in the ignore list, then just
			-- skip it
			--
			IF FOUND THEN
				RAISE DEBUG 'Skipping ignored address %', ipaddr;
				CONTINUE;
			END IF;

			--
			-- Look for an is_single_address=true, can_subnet=false netblock
			-- with the given ip_address
			--
			SELECT
				* INTO nb_rec
			FROM
				netblock n
			WHERE
				is_single_address = true AND
				can_subnet = false AND
				netblock_type = nb_type AND
				ip_universe_id = universe AND
				host(ip_address) = host(ipaddr);

			IF FOUND THEN
				RAISE DEBUG E'Located netblock:\n%',
					jsonb_pretty(to_jsonb(nb_rec));

				nb_id_ary := array_append(nb_id_ary, nb_rec.netblock_id);

				--
				-- Look to see if there's a layer3_network for the
				-- parent netblock
				--
				SELECT
					n.netblock_id,
					n.ip_address,
					layer3_network_id,
					default_gateway_netblock_id
				INTO layer3_rec
				FROM
					netblock n LEFT JOIN
					layer3_network l3 USING (netblock_id)
				WHERE
					n.netblock_id = nb_rec.parent_netblock_id;

				IF FOUND THEN
					RAISE DEBUG E'Located layer3_network:\n%',
						jsonb_pretty(to_jsonb(layer3_rec));
				ELSE
					--
					-- If we're told to create the layer3_network,
					-- then do that, otherwise go to the next address
					--
					CONTINUE WHEN NOT create_layer3_networks;
					INSERT INTO layer3_network(
						netblock_id
					) VALUES (
						layer3_rec.netblock_id
					) RETURNING layer3_network_id INTO
						layer3_rec.layer3_network_id;
				END IF;
			ELSE
				--
				-- If the parent netblock does not exist, then create it
				-- if we were passed the option to
				--
				SELECT
					n.netblock_id,
					n.ip_address,
					layer3_network_id,
					default_gateway_netblock_id
				INTO layer3_rec
				FROM
					netblock n LEFT JOIN
					layer3_network l3 USING (netblock_id)
				WHERE
					n.ip_universe_id = universe AND
					n.netblock_type = nb_type AND
					is_single_address = false AND
					can_subnet = false AND
					n.ip_address >>= ipaddr;

				IF NOT FOUND THEN
					RAISE DEBUG 'Parent netblock with ip_address %, netblock_type %, ip_universe_id % not found',
						network(ipaddr),
						nb_type,
						universe;
					CONTINUE WHEN NOT create_layer3_networks;
					WITH nb_ins AS (
						INSERT INTO netblock (
							ip_address,
							netblock_type,
							is_single_address,
							can_subnet,
							ip_universe_id,
							netblock_status
						) VALUES (
							network(ipaddr),
							nb_type,
							false,
							false,
							universe,
							'Allocated'
						) RETURNING *
					), l3_ins AS (
						INSERT INTO layer3_network(
							netblock_id
						)
						SELECT
							netblock_id
						FROM
							nb_ins
						RETURNING *
					)
					SELECT
						nb_ins.netblock_id,
						nb_ins.ip_address,
						l3_ins.layer3_network_id,
						NULL
					INTO layer3_rec
					FROM
						nb_ins,
						l3_ins;
				ELSIF layer3_rec.layer3_network_id IS NULL THEN
					--
					-- If we're told to create the layer3_network,
					-- then do that, otherwise go to the next address
					--

					RAISE DEBUG 'layer3_network for parent netblock % not found (ip_address %, netblock_type %, ip_universe_id %)',
						layer3_rec.netblock_id,
						network(ipaddr),
						nb_type,
						universe;
					CONTINUE WHEN NOT create_layer3_networks;
					INSERT INTO layer3_network(
						netblock_id
					) VALUES (
						layer3_rec.netblock_id
					) RETURNING layer3_network_id INTO
						layer3_rec.layer3_network_id;
				END IF;
				RAISE DEBUG E'Located layer3_network:\n%',
					jsonb_pretty(to_jsonb(layer3_rec));
				--
				-- Parents should be all set up now.  Insert the netblock
				--
				INSERT INTO netblock (
					ip_address,
					netblock_type,
					ip_universe_id,
					is_single_address,
					can_subnet,
					netblock_status
				) VALUES (
					ipaddr,
					nb_type,
					universe,
					true,
					false,
					'Allocated'
				) RETURNING * INTO nb_rec;
				nb_id_ary := array_append(nb_id_ary, nb_rec.netblock_id);
			END IF;

			--
			-- See if this netblock is directly on any layer3_interface, and
			-- delete it if force is set, otherwise skip it
			--
			ni_id_ary := ARRAY[]::integer[];

			SELECT
				nin.netblock_id,
				ni.device_id
			INTO nin_rec
			FROM
				layer3_interface_netblock nin JOIN
				layer3_interface ni USING (layer3_interface_id)
			WHERE
				nin.netblock_id = nb_rec.netblock_id AND
				nin.layer3_interface_id != ni_id;

			IF FOUND THEN
				IF move_addresses = 'always' OR (
					move_addresses = 'if_same_device' AND
					nin_rec.device_id = ni_rec.device_id
				)
				THEN
					--
					-- Remove the netblocks from the layer3_interfaces,
					-- but save them for later so that we can migrate them
					-- after we make sure the shared_netblock exists.
					--
					-- Also, append the network_inteface_id that we
					-- specifically care about, and we'll add them all
					-- below
					--
					WITH z AS (
						DELETE FROM
							layer3_interface_netblock
						WHERE
							netblock_id = nb_rec.netblock_id
						RETURNING layer3_interface_id
					)
					SELECT array_agg(layer3_interface_id) FROM
						(SELECT layer3_interface_id FROM z) v
					INTO ni_id_ary;
				ELSE
					IF address_errors = 'ignore' THEN
						RAISE DEBUG 'Netblock % is assigned to layer3_interface %',
							nb_rec.netblock_id, nin_rec.layer3_interface_id;

						CONTINUE;
					ELSIF address_errors = 'warn' THEN
						RAISE NOTICE 'Netblock % is assigned to layer3_interface %',
							nb_rec.netblock_id, nin_rec.layer3_interface_id;

						CONTINUE;
					ELSE
						RAISE 'Netblock % is assigned to layer3_interface %',
							nb_rec.netblock_id, nin_rec.layer3_interface_id;
					END IF;
				END IF;

			END IF;

			IF NOT(ni_id = ANY(ni_id_ary)) THEN
				ni_id_ary := array_append(ni_id_ary, ni_id);
			END IF;

			--
			-- See if this netblock already belongs to a shared_network
			--
			SELECT * FROM
				shared_netblock sn
			INTO sn_rec
			WHERE
				sn.netblock_id = nb_rec.netblock_id;

			IF FOUND THEN
				IF sn_rec.shared_netblock_protocol != protocol THEN
					RAISE 'Netblock % (%) is assigned to shared_network %, but the shared_network_protocol does not match (% vs. %)',
						nb_rec.netblock_id,
						nb_rec.ip_address,
						sn_rec.shared_netblock_id,
						sn_rec.shared_netblock_protocol,
						protocol;
				END IF;
			ELSE
				INSERT INTO shared_netblock (
					shared_netblock_protocol,
					netblock_id
				) VALUES (
					protocol,
					nb_rec.netblock_id
				) RETURNING * INTO sn_rec;
			END IF;

			--
			-- Add this to any interfaces that we found above that
			-- need this
			--

			INSERT INTO shared_netblock_layer3_interface (
				shared_netblock_id,
				layer3_interface_id,
				priority
			) SELECT
				sn_rec.shared_netblock_id,
				x.layer3_interface_id,
				0
			FROM
				unnest(ni_id_ary) x(layer3_interface_id)
			ON CONFLICT ON CONSTRAINT pk_ip_group_network_interface DO NOTHING;

			RAISE DEBUG E'Inserted shared_netblock % onto interfaces:\n%',
				sn_rec.shared_netblock_id, jsonb_pretty(to_jsonb(ni_id_ary));
		END LOOP;
		--
		-- Remove any shared_netblocks that are on the interface that are not
		-- supposed to be (and that aren't ignored).
		--

		FOR nin_rec IN
			DELETE FROM
				shared_netblock_layer3_interface snni
			WHERE
				(snni.layer3_interface_id, snni.shared_netblock_id) IN (
				SELECT
					snni2.layer3_interface_id,
					snni2.shared_netblock_id
				FROM
					shared_netblock_layer3_interface snni2 JOIN
					shared_netblock sn USING (shared_netblock_id) JOIN
					netblock n USING (netblock_id)
				WHERE
					snni2.layer3_interface_id = ni_id AND NOT (
						sn.netblock_id = ANY(nb_id_ary) OR
						n.ip_address <<= ANY ( ARRAY (
							SELECT
								n2.ip_address
							FROM
								netblock n2 JOIN
								netblock_collection_netblock ncn USING
									(netblock_id) JOIN
								v_netblock_collection_expanded nce USING
									(netblock_collection_id) JOIN
								property p ON (
									property_name = 'IgnoreProbedNetblocks' AND
									property_type = 'DeviceInventory' AND
									property_value_netblock_collection_id =
										nce.root_netblock_collection_id
								)
						))
					)
			)
			RETURNING *
		LOOP
			RAISE DEBUG 'Removed shared_netblock % from layer3_interface %',
				nin_rec.shared_netblock_id,
				nin_rec.layer3_interface_id;

			--
			-- Remove any DNS records, netblocks and shared_netblocks
			-- that aren't used
			--
			SELECT netblock_id INTO nb_id FROM shared_netblock sn WHERE
				sn.shared_netblock_id = nin_rec.shared_netblock_id;
			BEGIN
				DELETE FROM dns_record WHERE netblock_id = nb_id;
				DELETE FROM netblock_collection_netblock ncn WHERE
					ncn.netblock_id = nb_id;
				DELETE FROM shared_netblock WHERE netblock_id = nb_id;
				DELETE FROM netblock WHERE netblock_id = nb_id;
			EXCEPTION
				WHEN foreign_key_violation THEN NULL;
			END;
		END LOOP;
	END IF;
	RETURN true;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'netblock_manip' AND type = 'function' AND object IN ('set_interface_addresses');
	DELETE FROM __regrants WHERE schema = 'netblock_manip' AND object IN ('set_interface_addresses');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc set_interface_addresses failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process middle (non-trigger) schema physical_address_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process middle (non-trigger) schema component_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('component_utils', 'insert_cpu_component');
SELECT schema_support.save_grants_for_replay('component_utils', 'insert_cpu_component');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS component_utils.insert_cpu_component ( text,bigint,bigint,text,text,text );
CREATE OR REPLACE FUNCTION component_utils.insert_cpu_component(model text, processor_speed bigint, processor_cores bigint, socket_type text, vendor_name text DEFAULT NULL::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company_id INTO cid
		FROM
			company c LEFT JOIN
			property p USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorCPUProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id)
	WHERE
		component_function = 'CPU' AND
		ct.model = m AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = socket_type AND
			slot_function = 'CPU';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type %, function % not found adding component_type',
				socket_type,
				'CPU'
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			cid,
			model,
			stid,
			true,
			model
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the CPU
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('ProcessorCores', 'CPU', ctid, processor_cores),
			('ProcessorSpeed', 'CPU', ctid, processor_speed);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['CPU']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'component_utils' AND type = 'function' AND object IN ('insert_cpu_component');
	DELETE FROM __regrants WHERE schema = 'component_utils' AND object IN ('insert_cpu_component');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc insert_cpu_component failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('component_utils', 'insert_disk_component');
SELECT schema_support.save_grants_for_replay('component_utils', 'insert_disk_component');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS component_utils.insert_disk_component ( text,bigint,text,text,text,text );
CREATE OR REPLACE FUNCTION component_utils.insert_disk_component(model text, bytes bigint, vendor_name text DEFAULT NULL::text, protocol text DEFAULT 'SATA'::text, media_type text DEFAULT 'Rotational'::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company_id INTO cid
		FROM
			company c LEFT JOIN
			property p USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorDiskProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id)
	WHERE
		component_function = 'disk' AND
		ct.model = m AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = protocol AND
			slot_function = 'disk';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function disk not found adding component_type',
				protocol
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			cid,
			model,
			stid,
			true,
			concat_ws(' ', vendor_name, model, media_type, 'disk')
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the disk
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('DiskSize', 'disk', ctid, bytes),
			('DiskProtocol', 'disk', ctid, protocol),
			('MediaType', 'disk', ctid, media_type);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['storage', 'disk']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;

END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'component_utils' AND type = 'function' AND object IN ('insert_disk_component');
	DELETE FROM __regrants WHERE schema = 'component_utils' AND object IN ('insert_disk_component');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc insert_disk_component failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('component_utils', 'insert_memory_component');
SELECT schema_support.save_grants_for_replay('component_utils', 'insert_memory_component');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS component_utils.insert_memory_component ( text,bigint,bigint,text,text,text );
CREATE OR REPLACE FUNCTION component_utils.insert_memory_component(model text, memory_size bigint, memory_speed bigint, memory_type text DEFAULT 'DDR3'::text, vendor_name text DEFAULT NULL::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	m			ALIAS FOR model;
	sn			ALIAS FOR serial_number;
	ctid		integer;
	stid		integer;
	c			RECORD;
	cid			integer;
BEGIN
	cid := NULL;

	IF vendor_name IS NOT NULL THEN	
		SELECT 
			company_id INTO cid
		FROM
			company c LEFT JOIN
			property p USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'VendorMemoryProbeString' AND
			property_value = vendor_name;
	END IF;

	--
	-- See if we have this component type in the database already.
	--
	SELECT DISTINCT
		component_type_id INTO ctid
	FROM
		component_type ct JOIN
		component_type_component_function ctcf USING (component_type_id)
	WHERE
		component_function = 'memory' AND
		ct.model = m AND
		CASE WHEN cid IS NOT NULL THEN
			(company_id = cid)
		ELSE
			true
		END;

	--
	-- If the type isn't found, then we need to insert it
	--
	IF NOT FOUND THEN
		--
		-- Fetch the slot type
		--
		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = memory_type AND
			slot_function = 'memory';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function memory not found adding component_type',
				memory_type
				USING ERRCODE = 'JH501';
		END IF;

		IF cid IS NULL THEN
			SELECT
				company_id INTO cid
			FROM
				company
			WHERE
				company_name = 'unknown';

			IF NOT FOUND THEN
				IF NOT FOUND THEN
					RAISE EXCEPTION 'company_id for unknown company not found adding component_type'
						USING ERRCODE = 'JH501';
				END IF;
			END IF;
		END IF;

		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			cid,
			model,
			stid,
			true,
			concat_ws(' ', vendor_name, model, (memory_size || 'MB'), 'memory')
		) RETURNING component_type_id INTO ctid;

		--
		-- Insert component properties for the memory
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('MemorySize', 'memory', ctid, memory_size),
			('MemorySpeed', 'memory', ctid, memory_speed);
		
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(ARRAY['memory']) x(cf);
	END IF;

	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'component_utils' AND type = 'function' AND object IN ('insert_memory_component');
	DELETE FROM __regrants WHERE schema = 'component_utils' AND object IN ('insert_memory_component');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc insert_memory_component failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('component_utils', 'insert_pci_component');
SELECT schema_support.save_grants_for_replay('component_utils', 'insert_pci_component');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS component_utils.insert_pci_component ( integer,integer,integer,integer,text,text,text,text,text[],text,text );
CREATE OR REPLACE FUNCTION component_utils.insert_pci_component(pci_vendor_id integer, pci_device_id integer, pci_sub_vendor_id integer DEFAULT NULL::integer, pci_subsystem_id integer DEFAULT NULL::integer, pci_vendor_name text DEFAULT NULL::text, pci_device_name text DEFAULT NULL::text, pci_sub_vendor_name text DEFAULT NULL::text, pci_sub_device_name text DEFAULT NULL::text, component_function_list text[] DEFAULT NULL::text[], slot_type text DEFAULT 'unknown'::text, serial_number text DEFAULT NULL::text)
 RETURNS jazzhands.component
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	sn			ALIAS FOR serial_number;
	ctid		integer;
	comp_id		integer;
	sub_comp_id	integer;
	stid		integer;
	vendor_name	text;
	sub_vendor_name	text;
	model_name	text;
	c			RECORD;
BEGIN
	IF (pci_sub_vendor_id IS NULL AND pci_subsystem_id IS NOT NULL) OR
			(pci_sub_vendor_id IS NOT NULL AND pci_subsystem_id IS NULL) THEN
		RAISE EXCEPTION
			'pci_sub_vendor_id and pci_subsystem_id must be set together';
	END IF;

	--
	-- See if we have this component type in the database already
	--
	SELECT
		vid.component_type_id INTO ctid
	FROM
		component_property vid JOIN
		component_property did ON (
			vid.component_property_name = 'PCIVendorID' AND
			vid.component_property_type = 'PCI' AND
			did.component_property_name = 'PCIDeviceID' AND
			did.component_property_type = 'PCI' AND
			vid.component_type_id = did.component_type_id ) LEFT JOIN
		component_property svid ON (
			svid.component_property_name = 'PCISubsystemVendorID' AND
			svid.component_property_type = 'PCI' AND
			svid.component_type_id = did.component_type_id ) LEFT JOIN
		component_property sid ON (
			sid.component_property_name = 'PCISubsystemID' AND
			sid.component_property_type = 'PCI' AND
			sid.component_type_id = did.component_type_id )
	WHERE
		vid.property_value = pci_vendor_id::varchar AND
		did.property_value = pci_device_id::varchar AND
		svid.property_value IS NOT DISTINCT FROM pci_sub_vendor_id::varchar AND
		sid.property_value IS NOT DISTINCT FROM pci_subsystem_id::varchar;

	--
	-- The device type doesn't exist, so attempt to insert it
	--

	IF NOT FOUND THEN	
		IF pci_device_name IS NULL OR component_function_list IS NULL THEN
			RAISE EXCEPTION 'component_id not found and pci_device_name or component_function_list was not passed' USING ERRCODE = 'JH501';
		END IF;

		--
		-- Ensure that there's a company linkage for the PCI (subsystem)vendor
		--
		SELECT
			company_id, company_name INTO comp_id, vendor_name
		FROM
			property p JOIN
			company c USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'PCIVendorID' AND
			property_value = pci_vendor_id::text;
		
		IF NOT FOUND THEN
			IF pci_vendor_name IS NULL THEN
				RAISE EXCEPTION 'PCI vendor id mapping not found and pci_vendor_name was not passed' USING ERRCODE = 'JH501';
			END IF;
			SELECT company_id INTO comp_id FROM company
			WHERE company_name = pci_vendor_name;
		
			IF NOT FOUND THEN
				SELECT company_manip.add_company(
					_company_name := pci_vendor_name,
					_company_types := ARRAY['hardware provider'],
					 _description := 'PCI vendor auto-insert'
				) INTO comp_id;
			END IF;

			INSERT INTO property (
				property_name,
				property_type,
				property_value,
				company_id
			) VALUES (
				'PCIVendorID',
				'DeviceProvisioning',
				pci_vendor_id,
				comp_id
			);
			vendor_name := pci_vendor_name;
		END IF;

		SELECT
			company_id, company_name INTO sub_comp_id, sub_vendor_name
		FROM
			property JOIN
			company c USING (company_id)
		WHERE
			property_type = 'DeviceProvisioning' AND
			property_name = 'PCIVendorID' AND
			property_value = pci_sub_vendor_id::text;
		
		IF NOT FOUND THEN
			IF pci_sub_vendor_name IS NULL THEN
				RAISE EXCEPTION 'PCI subsystem vendor id mapping not found and pci_sub_vendor_name was not passed' USING ERRCODE = 'JH501';
			END IF;
			SELECT company_id INTO sub_comp_id FROM company
			WHERE company_name = pci_sub_vendor_name;
		
			IF NOT FOUND THEN
				SELECT company_manip.add_company(
					_company_name := pci_sub_vendor_name,
					_company_types := ARRAY['hardware provider'],
					 _description := 'PCI vendor auto-insert'
				) INTO sub_comp_id;
			END IF;

			INSERT INTO property (
				property_name,
				property_type,
				property_value,
				company_id
			) VALUES (
				'PCIVendorID',
				'DeviceProvisioning',
				pci_sub_vendor_id,
				sub_comp_id
			);
			sub_vendor_name := pci_sub_vendor_name;
		END IF;

		--
		-- Fetch the slot type
		--

		SELECT 
			slot_type_id INTO stid
		FROM
			slot_type st
		WHERE
			st.slot_type = insert_pci_component.slot_type AND
			slot_function = 'PCI';

		IF NOT FOUND THEN
			RAISE EXCEPTION 'slot type % with function PCI not found adding component_type',
				insert_pci_component.slot_type
				USING ERRCODE = 'JH501';
		END IF;

		--
		-- Figure out the best name/description to insert this component with
		--
		IF pci_sub_device_name IS NOT NULL AND pci_sub_device_name != 'Device' THEN
			model_name = concat_ws(' ', 
				sub_vendor_name, pci_sub_device_name,
				'(' || vendor_name, pci_device_name || ')');
		ELSIF pci_sub_device_name = 'Device' THEN
			model_name = concat_ws(' ', 
				vendor_name, '(' || sub_vendor_name || ')', pci_device_name);
		ELSE
			model_name = concat_ws(' ', vendor_name, pci_device_name);
		END IF;
		INSERT INTO component_type (
			company_id,
			model,
			slot_type_id,
			asset_permitted,
			description
		) VALUES (
			CASE WHEN 
				sub_comp_id IS NULL OR
				pci_sub_device_name IS NULL OR
				pci_sub_device_name = 'Device'
			THEN
				comp_id
			ELSE
				sub_comp_id
			END,
			CASE WHEN
				pci_sub_device_name IS NULL OR
				pci_sub_device_name = 'Device'
			THEN
				pci_device_name
			ELSE
				pci_sub_device_name
			END,
			stid,
			true,
			model_name
		) RETURNING component_type_id INTO ctid;
		--
		-- Insert properties for the PCI vendor/device IDs
		--
		INSERT INTO component_property (
			component_property_name,
			component_property_type,
			component_type_id,
			property_value
		) VALUES 
			('PCIVendorID', 'PCI', ctid, pci_vendor_id),
			('PCIDeviceID', 'PCI', ctid, pci_device_id);
		
		IF (pci_subsystem_id IS NOT NULL) THEN
			INSERT INTO component_property (
				component_property_name,
				component_property_type,
				component_type_id,
				property_value
			) VALUES 
				('PCISubsystemVendorID', 'PCI', ctid, pci_sub_vendor_id),
				('PCISubsystemID', 'PCI', ctid, pci_subsystem_id);
		END IF;
		--
		-- Insert the component functions
		--

		INSERT INTO component_type_component_function (
			component_type_id,
			component_function
		) SELECT DISTINCT
			ctid,
			cf
		FROM
			unnest(array_append(component_function_list, 'PCI')) x(cf);
	END IF;


	--
	-- We have a component_type_id now, so look to see if this component
	-- serial number already exists
	--
	IF serial_number IS NOT NULL THEN
		SELECT 
			component.* INTO c
		FROM
			component JOIN
			asset a USING (component_id)
		WHERE
			component_type_id = ctid AND
			a.serial_number = sn;

		IF FOUND THEN
			RETURN c;
		END IF;
	END IF;

	INSERT INTO jazzhands.component (
		component_type_id
	) VALUES (
		ctid
	) RETURNING * INTO c;

	IF serial_number IS NOT NULL THEN
		INSERT INTO asset (
			component_id,
			serial_number,
			ownership_status
		) VALUES (
			c.component_id,
			serial_number,
			'unknown'
		);
	END IF;

	RETURN c;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'component_utils' AND type = 'function' AND object IN ('insert_pci_component');
	DELETE FROM __regrants WHERE schema = 'component_utils' AND object IN ('insert_pci_component');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc insert_pci_component failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process middle (non-trigger) schema snapshot_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('snapshot_manip', 'add_snapshot');
SELECT schema_support.save_grants_for_replay('snapshot_manip', 'add_snapshot');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS snapshot_manip.add_snapshot ( character varying,character varying,character varying,character varying );
CREATE OR REPLACE FUNCTION snapshot_manip.add_snapshot(os_name character varying, os_version character varying, snapshot_name character varying, snapshot_type character varying)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$

DECLARE
	major_version text;
	companyid     company.company_id%type;
	osid          operating_system.operating_system_id%type;
	snapid        operating_system_snapshot.operating_system_snapshot_id%type;
	dcid          device_collection.device_collection_id%type;

BEGIN
	SELECT company.company_id INTO companyid FROM company
		INNER JOIN company_type USING (company_id)
		WHERE lower(company_short_name) = lower(os_name)
		AND company_type = 'os provider';

	IF NOT FOUND THEN
		RAISE 'Operating system vendor not found';
	END IF;

	SELECT operating_system_id INTO osid FROM operating_system
		WHERE operating_system_name = os_name
		AND version = os_version;

	IF NOT FOUND THEN
		major_version := substring(os_version, '^[^.]+');

		INSERT INTO operating_system (
			operating_system_name,
			company_id,
			major_version,
			version,
			operating_system_family
		) VALUES (
			os_name,
			companyid,
			major_version,
			os_version,
			'linux'
		) RETURNING * INTO osid;

		INSERT INTO property (
			property_type,
			property_name,
			operating_system_id,
			property_value_boolean
		) VALUES (
			'OperatingSystem',
			'AllowOSDeploy',
			osid,
			false
		);
	END IF;

	INSERT INTO operating_system_snapshot (
		operating_system_snapshot_name,
		operating_system_snapshot_type,
		operating_system_id
	) VALUES (
		snapshot_name,
		snapshot_type,
		osid
	) RETURNING * INTO snapid;

	INSERT INTO device_collection (
		device_collection_name,
		device_collection_type,
		description
	) VALUES (
		CONCAT(os_name, '-', os_version, '-', snapshot_name),
		'os-snapshot',
		NULL
	) RETURNING * INTO dcid;

	INSERT INTO property (
		property_type,
		property_name,
		device_collection_id,
		operating_system_snapshot_id,
		property_value_boolean
	) VALUES (
		'OperatingSystem',
		'DeviceCollection',
		dcid,
		snapid,
		NULL
	), (
		'OperatingSystem',
		'AllowSnapDeploy',
		NULL,
		snapid,
		false
	);

	RETURN snapid;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'snapshot_manip' AND type = 'function' AND object IN ('add_snapshot');
	DELETE FROM __regrants WHERE schema = 'snapshot_manip' AND object IN ('add_snapshot');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_snapshot failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process middle (non-trigger) schema lv_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process middle (non-trigger) schema logical_port_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process middle (non-trigger) schema approval_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('approval_utils', 'approve');
SELECT schema_support.save_grants_for_replay('approval_utils', 'approve');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS approval_utils.approve ( integer,boolean,integer,text );
CREATE OR REPLACE FUNCTION approval_utils.approve(approval_instance_item_id integer, approved boolean, approving_account_id integer, new_value text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'approval_utils', 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
	_aii	approval_instance_item%ROWTYPE;
	_new	approval_instance_item.approval_instance_item_id%TYPE;
	_chid	approval_process_chain.approval_process_chain_id%TYPE;
	_tally	INTEGER;
BEGIN
	EXECUTE '
		SELECT 	aii.approval_instance_item_id,
			ais.approval_instance_step_id,
			ais.approval_instance_id,
			ais.approver_account_id,
			ais.approval_type,
			aii.is_approved,
			ais.is_completed,
			aic.accept_approval_process_chain_id,
			aic.reject_approval_process_chain_id
   	     FROM    approval_instance ai
   		     INNER JOIN approval_instance_step ais
   			 USING (approval_instance_id)
   		     INNER JOIN approval_instance_item aii
   			 USING (approval_instance_step_id)
   		     INNER JOIN approval_instance_link ail
   			 USING (approval_instance_link_id)
			INNER JOIN approval_process_chain aic
				USING (approval_process_chain_id)
		WHERE approval_instance_item_id = $1
	' USING approval_instance_item_id INTO 	_r;

	--
	-- Ensure that only the person or their management chain can approve
	-- others; this may want to be a property on val_approval_type rather
	-- than hard coded on account...
	IF (_r.approval_type = 'account' AND _r.approver_account_id != approving_account_id ) THEN
		EXECUTE '
			SELECT count(*)
			FROM	v_account_manager_hier
			WHERE account_id = $1
			AND manager_account_id = $2
		' INTO _tally USING _r.approver_account_id, approving_account_id;

		IF _tally = 0 THEN
			EXECUTE '
				SELECT	count(*)
				FROM	property
						INNER JOIN v_account_collection_account_expanded e
						USING (account_collection_id)
				WHERE	property_type = ''Defaults''
				AND		property_name = ''_can_approve_all''
				AND		e.account_id = $1
			' INTO _tally USING approving_account_id;

			IF _tally = 0 THEN
				RAISE EXCEPTION 'Only a person and their management chain may approve others';
			END IF;
		END IF;

	END IF;

	IF _r.approval_instance_item_id IS NULL THEN
		RAISE EXCEPTION 'Unknown approval_instance_item_id %',
			approval_instance_item_id;
	END IF;

	IF _r.is_approved IS NOT NULL THEN
		RAISE EXCEPTION 'Approval is already completed.';
	END IF;

	IF approved = false THEN
		IF _r.reject_approval_process_chain_id IS NOT NULL THEN
			_chid := _r.reject_approval_process_chain_id;
		END IF;
	ELSIF approved = true THEN
		IF _r.accept_approval_process_chain_id IS NOT NULL THEN
			_chid := _r.accept_approval_process_chain_id;
		END IF;
	ELSE
		RAISE EXCEPTION 'Approved must be Y or N';
	END IF;

	IF _chid IS NOT NULL THEN
		_new := approval_utils.build_next_approval_item(
			approval_instance_item_id, _chid,
			_r.approval_instance_id, approved,
			approving_account_id, new_value);

		EXECUTE '
			UPDATE approval_instance_item
			SET next_approval_instance_item_id = $2
			WHERE approval_instance_item_id = $1
		' USING approval_instance_item_id, _new;
	END IF;

	--
	-- This needs to happen after the next steps are created
	-- or the entire process gets marked as done on the second to last
	-- update instead of the list.

	EXECUTE '
		UPDATE approval_instance_item
		SET is_approved = $2,
		approved_account_id = $3
		WHERE approval_instance_item_id = $1
	' USING approval_instance_item_id, approved, approving_account_id;

	RETURN true;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'approval_utils' AND type = 'function' AND object IN ('approve');
	DELETE FROM __regrants WHERE schema = 'approval_utils' AND object IN ('approve');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc approve failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('approval_utils', 'approve');
DROP FUNCTION IF EXISTS approval_utils.approve ( integer,text,integer,text );
CREATE OR REPLACE FUNCTION approval_utils.approve(approval_instance_item_id integer, approved text, approving_account_id integer, new_value text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'approval_utils', 'jazzhands'
AS $function$
DECLARE
	_tf	BOOLEAN;
BEGIN
	IF approved = 'Y' THEN
		_tf = true;
	ELSIF approved = 'N' THEN
		_tf = false;
	ELSE
		RAISE NOTICE 'approved must by y/n or true/false';
	END IF;
	RETURN approval_utils.approve(
		approval_instance_item_id := approval_instance_item_id,
		approved := _tf,
		approving_account_id := approving_account_id,
		new_value := new_value
	);
END;
$function$
;

--
-- Process middle (non-trigger) schema rack_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process middle (non-trigger) schema pgcrypto
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process middle (non-trigger) schema account_collection_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process middle (non-trigger) schema audit
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Process middle (non-trigger) schema script_hooks
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process middle (non-trigger) schema backend_utils
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('backend_utils', 'relation_last_changed');
SELECT schema_support.save_grants_for_replay('backend_utils', 'relation_last_changed');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS backend_utils.relation_last_changed ( text,text );
CREATE OR REPLACE FUNCTION backend_utils.relation_last_changed(view text, schema text DEFAULT 'jazzhands_legacy'::text)
 RETURNS timestamp without time zone
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN schema_support.relation_last_changed(view, schema);
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'backend_utils' AND type = 'function' AND object IN ('relation_last_changed');
	DELETE FROM __regrants WHERE schema = 'backend_utils' AND object IN ('relation_last_changed');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc relation_last_changed failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
-- Creating new sequences....


-- Processing tables in main schema...
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_type
-- ... renaming to val_layer3_interface_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_network_interface_type', 'val_layer3_interface_type');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_network_interface_type', 'val_layer3_interface_type');

-- FOREIGN KEYS FROM
ALTER TABLE layer3_interface DROP CONSTRAINT IF EXISTS fk_netint_netinttyp_id;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_network_interface_type', newobject := 'val_layer3_interface_type', newmap := '{"pk_network_int_type":{"columns":["layer3_interface_type"],"def":"PRIMARY KEY (layer3_interface_type)","deferrable":false,"deferred":false,"name":"pk_network_int_type","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_network_interface_type DROP CONSTRAINT IF EXISTS pk_network_int_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_network_interface_type ON jazzhands.val_network_interface_type;
DROP TRIGGER IF EXISTS trigger_audit_val_network_interface_type ON jazzhands.val_network_interface_type;
DROP FUNCTION IF EXISTS perform_audit_val_network_interface_type();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_network_interface_type', tags := ARRAY['table_val_layer3_interface_type']);
---- BEGIN jazzhands_audit.val_network_interface_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_network_interface_type', tags := ARRAY['table_val_layer3_interface_type']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_network_interface_type', 'val_layer3_interface_type');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_network_interface_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_network_interface_type DROP CONSTRAINT IF EXISTS val_network_interface_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_network_interface_type_pk_network_int_type";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_network_interface_type TEARDOWN


ALTER TABLE val_network_interface_type RENAME TO val_network_interface_type_v89;
ALTER TABLE jazzhands_audit.val_network_interface_type RENAME TO val_network_interface_type_v89;

CREATE TABLE jazzhands.val_layer3_interface_type
(
	layer3_interface_type	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
ALTER SEQUENCE jazzhands_audit.val_network_interface_type_seq  RENAME TO val_layer3_interface_type_seq;
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_layer3_interface_type', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_layer3_interface_type');


-- BEGIN Manually written insert function
INSERT INTO val_layer3_interface_type (
        layer3_interface_type,          -- new column (layer3_interface_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        network_interface_type,           -- new column (layer3_interface_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM val_network_interface_type_v89;


INSERT INTO jazzhands_audit.val_layer3_interface_type (
        layer3_interface_type,          -- new column (layer3_interface_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        network_interface_type,           -- new column (layer3_interface_type)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.val_network_interface_type_v89;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_layer3_interface_type ADD CONSTRAINT pk_network_int_type PRIMARY KEY (layer3_interface_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_layer3_interface_type and jazzhands.layer3_interface
ALTER TABLE jazzhands.layer3_interface
	ADD CONSTRAINT fk_netint_netinttyp_id
	FOREIGN KEY (layer3_interface_type) REFERENCES jazzhands.val_layer3_interface_type(layer3_interface_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_layer3_interface_type');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('val_layer3_interface_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_layer3_interface_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_layer3_interface_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_layer3_interface_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_layer3_interface_type');
DROP TABLE IF EXISTS val_network_interface_type_v89;
DROP TABLE IF EXISTS jazzhands_audit.val_network_interface_type_v89;
-- DONE DEALING WITH TABLE val_layer3_interface_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_network_interface_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_interface_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_layer3_interface_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_purpose
-- ... renaming to val_layer3_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_network_interface_purpose', 'val_layer3_interface_purpose');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_network_interface_purpose', 'val_layer3_interface_purpose');

-- FOREIGN KEYS FROM
ALTER TABLE layer3_interface_purpose DROP CONSTRAINT IF EXISTS fk_netint_purpose_val_netint_purp;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_network_interface_purpose', newobject := 'val_layer3_interface_purpose', newmap := '{"pk_val_network_int_purpose":{"columns":["layer3_interface_purpose"],"def":"PRIMARY KEY (layer3_interface_purpose)","deferrable":false,"deferred":false,"name":"pk_val_network_int_purpose","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_network_interface_purpose DROP CONSTRAINT IF EXISTS pk_val_network_int_purpose;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_network_interface_purpose ON jazzhands.val_network_interface_purpose;
DROP TRIGGER IF EXISTS trigger_audit_val_network_interface_purpose ON jazzhands.val_network_interface_purpose;
DROP FUNCTION IF EXISTS perform_audit_val_network_interface_purpose();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_network_interface_purpose', tags := ARRAY['table_val_layer3_interface_purpose']);
---- BEGIN jazzhands_audit.val_network_interface_purpose TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_network_interface_purpose', tags := ARRAY['table_val_layer3_interface_purpose']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_network_interface_purpose', 'val_layer3_interface_purpose');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_network_interface_purpose');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_network_interface_purpose DROP CONSTRAINT IF EXISTS val_network_interface_purpose_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_network_interface_purpose_pk_val_network_int_purpose";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_purpose_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_purpose_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_network_interface_purpose_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_network_interface_purpose TEARDOWN


ALTER TABLE val_network_interface_purpose RENAME TO val_network_interface_purpose_v89;
ALTER TABLE jazzhands_audit.val_network_interface_purpose RENAME TO val_network_interface_purpose_v89;

CREATE TABLE jazzhands.val_layer3_interface_purpose
(
	layer3_interface_purpose	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
ALTER SEQUENCE jazzhands_audit.val_network_interface_purpose_seq  RENAME TO val_layer3_interface_purpose_seq;
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_layer3_interface_purpose', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_layer3_interface_purpose');


-- BEGIN Manually written insert function
INSERT INTO val_layer3_interface_purpose (
        layer3_interface_purpose,               -- new column (layer3_interface_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        network_interface_purpose,           -- new column (layer3_interface_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM val_network_interface_purpose_v89;


INSERT INTO jazzhands_audit.val_layer3_interface_purpose (
        layer3_interface_purpose,               -- new column (layer3_interface_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        network_interface_purpose,           -- new column (layer3_interface_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.val_network_interface_purpose_v89;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_layer3_interface_purpose ADD CONSTRAINT pk_val_network_int_purpose PRIMARY KEY (layer3_interface_purpose);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_layer3_interface_purpose and jazzhands.layer3_interface_purpose
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_interface_purpose
--	ADD CONSTRAINT fk_netint_purpose_val_netint_purp
--	FOREIGN KEY (layer3_interface_purpose) REFERENCES jazzhands.val_layer3_interface_purpose(layer3_interface_purpose);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_layer3_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('val_layer3_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_layer3_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_layer3_interface_purpose');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_layer3_interface_purpose');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_layer3_interface_purpose');
DROP TABLE IF EXISTS val_network_interface_purpose_v89;
DROP TABLE IF EXISTS jazzhands_audit.val_network_interface_purpose_v89;
-- DONE DEALING WITH TABLE val_layer3_interface_purpose (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_layer3_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_layer3_interface_purpose failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE encryption_key
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'encryption_key', 'encryption_key');

-- FOREIGN KEYS FROM
ALTER TABLE appaal_instance_property DROP CONSTRAINT IF EXISTS fk_apalinstprp_enc_id_id;
ALTER TABLE private_key DROP CONSTRAINT IF EXISTS fk_pvtkey_enckey_id;
ALTER TABLE ssh_key DROP CONSTRAINT IF EXISTS fk_ssh_key_enc_key_id;
ALTER TABLE token DROP CONSTRAINT IF EXISTS fk_token_enc_id_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.encryption_key DROP CONSTRAINT IF EXISTS fk_enckey_enckeypurpose_val;
ALTER TABLE jazzhands.encryption_key DROP CONSTRAINT IF EXISTS fk_enckey_encmethod_val;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'encryption_key', newobject := 'encryption_key', newmap := '{"pk_encryption_key":{"columns":["encryption_key_id"],"def":"PRIMARY KEY (encryption_key_id)","deferrable":false,"deferred":false,"name":"pk_encryption_key","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.encryption_key DROP CONSTRAINT IF EXISTS pk_encryption_key;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_encryption_key ON jazzhands.encryption_key;
DROP TRIGGER IF EXISTS trigger_audit_encryption_key ON jazzhands.encryption_key;
DROP FUNCTION IF EXISTS perform_audit_encryption_key();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'encryption_key', tags := ARRAY['table_encryption_key']);
---- BEGIN jazzhands_audit.encryption_key TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'encryption_key', tags := ARRAY['table_encryption_key']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'encryption_key', 'encryption_key');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'encryption_key');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.encryption_key DROP CONSTRAINT IF EXISTS encryption_key_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_encryption_key_pk_encryption_key";
DROP INDEX IF EXISTS "jazzhands_audit"."encryption_key_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."encryption_key_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."encryption_key_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.encryption_key TEARDOWN


ALTER TABLE encryption_key RENAME TO encryption_key_v89;
ALTER TABLE jazzhands_audit.encryption_key RENAME TO encryption_key_v89;

CREATE TABLE jazzhands.encryption_key
(
	encryption_key_id	integer NOT NULL,
	encryption_key_db_value	varchar(255) NOT NULL,
	encryption_key_purpose	varchar(50) NOT NULL,
	encryption_key_purpose_version	integer NOT NULL,
	encryption_method	varchar(50) NOT NULL,
	external_id	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'encryption_key', false);
ALTER TABLE encryption_key
	ALTER encryption_key_id
	SET DEFAULT nextval('jazzhands.encryption_key_encryption_key_id_seq'::regclass);

INSERT INTO encryption_key (
	encryption_key_id,
	encryption_key_db_value,
	encryption_key_purpose,
	encryption_key_purpose_version,
	encryption_method,
	external_id,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	encryption_key_id,
	encryption_key_db_value,
	encryption_key_purpose,
	encryption_key_purpose_version,
	encryption_method,
	NULL,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM encryption_key_v89;


INSERT INTO jazzhands_audit.encryption_key (
	encryption_key_id,
	encryption_key_db_value,
	encryption_key_purpose,
	encryption_key_purpose_version,
	encryption_method,
	external_id,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	encryption_key_id,
	encryption_key_db_value,
	encryption_key_purpose,
	encryption_key_purpose_version,
	encryption_method,
	NULL,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.encryption_key_v89;

ALTER TABLE jazzhands.encryption_key
	ALTER encryption_key_id
	SET DEFAULT nextval('jazzhands.encryption_key_encryption_key_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.encryption_key ADD CONSTRAINT pk_encryption_key PRIMARY KEY (encryption_key_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.encryption_key IS 'Keep information on keys used to encrypt sensitive data in the schema';
COMMENT ON COLUMN jazzhands.encryption_key.encryption_key_db_value IS 'part of 3-tuple that is the key used to encrypt.  The other portions are provided by a user and stored in the key_crypto package';
COMMENT ON COLUMN jazzhands.encryption_key.encryption_key_purpose IS 'indicates the purpose of infrastructure providing the key.  Used externally by applications to manage their portion of the key';
COMMENT ON COLUMN jazzhands.encryption_key.encryption_key_purpose_version IS 'indicates the version of the application portion of the key.  Used externally by applications to manage their portion of the key';
COMMENT ON COLUMN jazzhands.encryption_key.encryption_method IS 'Text representation of the method of encryption.  Format is the same as Kerberos uses such as in rfc3962';
COMMENT ON COLUMN jazzhands.encryption_key.external_id IS 'pointer to where to find the encrypted material in an external system.';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between encryption_key and jazzhands.account_password
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.account_password
--	ADD CONSTRAINT fk_account_passwd_enc_key
--	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- consider FK between encryption_key and jazzhands.appaal_instance_property
ALTER TABLE jazzhands.appaal_instance_property
	ADD CONSTRAINT fk_apalinstprp_enc_id_id
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);
-- consider FK between encryption_key and jazzhands.property
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.property
--	ADD CONSTRAINT fk_property_val_enc_key
--	FOREIGN KEY (property_value_encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- consider FK between encryption_key and jazzhands.private_key
ALTER TABLE jazzhands.private_key
	ADD CONSTRAINT fk_pvtkey_enckey_id
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);
-- consider FK between encryption_key and jazzhands.ssh_key
ALTER TABLE jazzhands.ssh_key
	ADD CONSTRAINT fk_ssh_key_enc_key_id
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);
-- consider FK between encryption_key and jazzhands.token
ALTER TABLE jazzhands.token
	ADD CONSTRAINT fk_token_enc_id_id
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- FOREIGN KEYS TO
-- consider FK encryption_key and val_encryption_key_purpose
ALTER TABLE jazzhands.encryption_key
	ADD CONSTRAINT fk_enckey_enckeypurpose_val
	FOREIGN KEY (encryption_key_purpose, encryption_key_purpose_version) REFERENCES jazzhands.val_encryption_key_purpose(encryption_key_purpose, encryption_key_purpose_version);
-- consider FK encryption_key and val_encryption_method
ALTER TABLE jazzhands.encryption_key
	ADD CONSTRAINT fk_enckey_encmethod_val
	FOREIGN KEY (encryption_method) REFERENCES jazzhands.val_encryption_method(encryption_method);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('encryption_key');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('encryption_key');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for encryption_key  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'encryption_key');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'encryption_key');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'encryption_key');
ALTER SEQUENCE jazzhands.encryption_key_encryption_key_id_seq
	 OWNED BY encryption_key.encryption_key_id;
DROP TABLE IF EXISTS encryption_key_v89;
DROP TABLE IF EXISTS jazzhands_audit.encryption_key_v89;
-- DONE DEALING WITH TABLE encryption_key (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('encryption_key');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('encryption_key');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old encryption_key failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('encryption_key');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('encryption_key');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new encryption_key failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE account_password
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'account_password', 'account_password');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.account_password DROP CONSTRAINT IF EXISTS fk_acct_pass_ref_vpasstype;
ALTER TABLE jazzhands.account_password DROP CONSTRAINT IF EXISTS fk_acct_pwd_acct_realm;
ALTER TABLE jazzhands.account_password DROP CONSTRAINT IF EXISTS fk_acct_pwd_realm_type;
ALTER TABLE jazzhands.account_password DROP CONSTRAINT IF EXISTS fk_acctpwd_acct_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'account_password', newobject := 'account_password', newmap := '{"pk_accunt_password":{"columns":["account_id","account_realm_id","password_type"],"def":"PRIMARY KEY (account_id, account_realm_id, password_type)","deferrable":false,"deferred":false,"name":"pk_accunt_password","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.account_password DROP CONSTRAINT IF EXISTS pk_accunt_password;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif_acct_pwd_acct_realm";
DROP INDEX IF EXISTS "jazzhands"."xif_acct_pwd_relm_type";
DROP INDEX IF EXISTS "jazzhands"."xif_acctpwd_acct_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_account_password ON jazzhands.account_password;
DROP TRIGGER IF EXISTS trigger_audit_account_password ON jazzhands.account_password;
DROP FUNCTION IF EXISTS perform_audit_account_password();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_password_changes ON jazzhands.account_password;
DROP TRIGGER IF EXISTS trigger_pull_password_account_realm_from_account ON jazzhands.account_password;
DROP TRIGGER IF EXISTS trigger_unrequire_password_change ON jazzhands.account_password;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'account_password', tags := ARRAY['table_account_password']);
---- BEGIN jazzhands_audit.account_password TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'account_password', tags := ARRAY['table_account_password']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'account_password', 'account_password');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'account_password');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.account_password DROP CONSTRAINT IF EXISTS account_password_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."account_password_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."account_password_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."account_password_aud#txid_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_account_password_pk_accunt_password";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.account_password TEARDOWN


ALTER TABLE account_password RENAME TO account_password_v89;
ALTER TABLE jazzhands_audit.account_password RENAME TO account_password_v89;

CREATE TABLE jazzhands.account_password
(
	account_id	integer NOT NULL,
	account_realm_id	integer NOT NULL,
	password_type	varchar(50) NOT NULL,
	password	varchar(255) NOT NULL,
	change_time	timestamp with time zone  NULL,
	expire_time	timestamp with time zone  NULL,
	unlock_time	timestamp with time zone  NULL,
	encryption_key_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'account_password', false);

INSERT INTO account_password (
	account_id,
	account_realm_id,
	password_type,
	password,
	change_time,
	expire_time,
	unlock_time,
	encryption_key_id,		-- new column (encryption_key_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	account_id,
	account_realm_id,
	password_type,
	password,
	change_time,
	expire_time,
	unlock_time,
	NULL,		-- new column (encryption_key_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM account_password_v89;


INSERT INTO jazzhands_audit.account_password (
	account_id,
	account_realm_id,
	password_type,
	password,
	change_time,
	expire_time,
	unlock_time,
	encryption_key_id,		-- new column (encryption_key_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	account_id,
	account_realm_id,
	password_type,
	password,
	change_time,
	expire_time,
	unlock_time,
	NULL,		-- new column (encryption_key_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.account_password_v89;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.account_password ADD CONSTRAINT pk_accunt_password PRIMARY KEY (account_id, account_realm_id, password_type);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.account_password.account_realm_id IS 'Set to allow enforcement of password type/account_realm_id.   Largely managed in the background by trigger';
COMMENT ON COLUMN jazzhands.account_password.change_time IS 'The last thie this password was changed';
COMMENT ON COLUMN jazzhands.account_password.expire_time IS 'The time this password expires, if different from the default';
COMMENT ON COLUMN jazzhands.account_password.unlock_time IS 'indicates the time that the password is unlocked and can thus be changed; NULL means the password can be changed.  This is application enforced.';
COMMENT ON COLUMN jazzhands.account_password.encryption_key_id IS 'If the plaintext version of this password is stashed somewhere, this indicates where to find it.';
-- INDEXES
CREATE INDEX xif_acct_pass_enc_key_id ON jazzhands.account_password USING btree (encryption_key_id);
CREATE INDEX xif_acct_pwd_acct_realm ON jazzhands.account_password USING btree (account_realm_id);
CREATE INDEX xif_acct_pwd_relm_type ON jazzhands.account_password USING btree (password_type, account_realm_id);
CREATE INDEX xif_acctpwd_acct_id ON jazzhands.account_password USING btree (account_id, account_realm_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK account_password and encryption_key
ALTER TABLE jazzhands.account_password
	ADD CONSTRAINT fk_account_passwd_enc_key
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);
-- consider FK account_password and val_password_type
ALTER TABLE jazzhands.account_password
	ADD CONSTRAINT fk_acct_pass_ref_vpasstype
	FOREIGN KEY (password_type) REFERENCES jazzhands.val_password_type(password_type);
-- consider FK account_password and account_realm
ALTER TABLE jazzhands.account_password
	ADD CONSTRAINT fk_acct_pwd_acct_realm
	FOREIGN KEY (account_realm_id) REFERENCES jazzhands.account_realm(account_realm_id);
-- consider FK account_password and account_realm_password_type
ALTER TABLE jazzhands.account_password
	ADD CONSTRAINT fk_acct_pwd_realm_type
	FOREIGN KEY (password_type, account_realm_id) REFERENCES jazzhands.account_realm_password_type(password_type, account_realm_id);
-- consider FK account_password and account
ALTER TABLE jazzhands.account_password
	ADD CONSTRAINT fk_acctpwd_acct_id
	FOREIGN KEY (account_id, account_realm_id) REFERENCES jazzhands.account(account_id, account_realm_id);

-- TRIGGERS
-- considering NEW jazzhands.pgnotify_account_password_changes
CREATE OR REPLACE FUNCTION jazzhands.pgnotify_account_password_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM pg_notify ('account_password_change', 'account_id=' || NEW.account_id);
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_pgnotify_account_password_changes AFTER INSERT OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_password_changes();

-- considering NEW jazzhands.pull_password_account_realm_from_account
CREATE OR REPLACE FUNCTION jazzhands.pull_password_account_realm_from_account()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		IF NEW.account_realm_id IS NULL THEN
			SELECT account_realm_id
			INTO	NEW.account_realm_id
			FROM	account
			WHERE	account_id = NEW.account_id;
		END IF;
	ELSIF NEW.account_realm_id = OLD.account_realm_id THEN
		IF NEW.account_realm_id IS NULL THEN
			SELECT account_realm_id
			INTO	NEW.account_realm_id
			FROM	account
			WHERE	account_id = NEW.account_id;
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_pull_password_account_realm_from_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.pull_password_account_realm_from_account();

-- considering NEW jazzhands.unrequire_password_change
CREATE OR REPLACE FUNCTION jazzhands.unrequire_password_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	DELETE FROM account_collection_account
	WHERE (account_collection_id, account_id)
	IN (
		SELECT	a.account_collection_id, a.account_id
		FROM	v_account_collection_account_expanded a
				JOIN account_collection ac USING (account_collection_id)
				JOIN property p USING (account_collection_id)
		WHERE	p.property_type = 'UserMgmt'
		AND		p.property_name = 'NeedsPasswdChange'
		AND	 	a.account_id = NEW.account_id
	);
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_unrequire_password_change BEFORE INSERT OR UPDATE OF password ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.unrequire_password_change();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('account_password');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('account_password');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for account_password  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'account_password');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'account_password');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'account_password');
DROP TABLE IF EXISTS account_password_v89;
DROP TABLE IF EXISTS jazzhands_audit.account_password_v89;
-- DONE DEALING WITH TABLE account_password (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_password');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_password');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old account_password failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_password');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('account_password');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new account_password failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_environment_type (jazzhands)
CREATE TABLE jazzhands.val_service_environment_type
(
	service_environment_type	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_environment_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_environment_type (
service_environment_type,description
) VALUES
	('default','universalish concepts')
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_environment_type ADD CONSTRAINT pk_val_service_environment_type PRIMARY KEY (service_environment_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_environment_type and jazzhands.service_environment
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_environment
--	ADD CONSTRAINT fk_svcenv_svctype
--	FOREIGN KEY (service_environment_type) REFERENCES jazzhands.val_service_environment_type(service_environment_type);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_environment_type');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('val_service_environment_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_environment_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_environment_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_environment_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_environment_type');
-- DONE DEALING WITH TABLE val_service_environment_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_environment_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_environment_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_environment_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_environment_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_environment_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_environment_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE service_environment
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_environment', 'service_environment');

-- FOREIGN KEYS FROM
ALTER TABLE appaal_instance DROP CONSTRAINT IF EXISTS fk_appaal_i_fk_applic_svcenv;
ALTER TABLE device DROP CONSTRAINT IF EXISTS fk_device_dev_v_svcenv;
ALTER TABLE network_service DROP CONSTRAINT IF EXISTS fk_netsvc_csvcenv;
ALTER TABLE service_environment_collection_service_environment DROP CONSTRAINT IF EXISTS fk_svc_env_col_svc_env;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_environment DROP CONSTRAINT IF EXISTS fk_val_svcenv_prodstate;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_environment', newobject := 'service_environment', newmap := '{"ak_service_env_name_type":{"columns":["service_environment_name","service_environment_type"],"def":"UNIQUE (service_environment_name, service_environment_type)","deferrable":false,"deferred":false,"name":"ak_service_env_name_type","type":"u"},"pk_service_environment":{"columns":["service_environment_id"],"def":"PRIMARY KEY (service_environment_id)","deferrable":false,"deferred":false,"name":"pk_service_environment","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_environment DROP CONSTRAINT IF EXISTS pk_service_environment;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1service_environment";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_environment ON jazzhands.service_environment;
DROP TRIGGER IF EXISTS trigger_audit_service_environment ON jazzhands.service_environment;
DROP FUNCTION IF EXISTS perform_audit_service_environment();
DROP TRIGGER IF EXISTS trigger_delete_per_service_environment_service_environment_coll ON jazzhands.service_environment;
DROP TRIGGER IF EXISTS trigger_update_per_service_environment_service_environment_coll ON jazzhands.service_environment;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_environment', tags := ARRAY['table_service_environment']);
---- BEGIN jazzhands_audit.service_environment TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_environment', tags := ARRAY['table_service_environment']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_environment', 'service_environment');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_environment');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_environment DROP CONSTRAINT IF EXISTS service_environment_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_environment_pk_service_environment";
DROP INDEX IF EXISTS "jazzhands_audit"."service_environment_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_environment_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_environment_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.service_environment TEARDOWN


ALTER TABLE service_environment RENAME TO service_environment_v89;
ALTER TABLE jazzhands_audit.service_environment RENAME TO service_environment_v89;

CREATE TABLE jazzhands.service_environment
(
	service_environment_id	integer NOT NULL,
	service_environment_name	varchar(50) NOT NULL,
	service_environment_type	varchar(50) NOT NULL,
	production_state	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	external_id	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_environment', false);
ALTER TABLE service_environment
	ALTER service_environment_id
	SET DEFAULT nextval('jazzhands.service_environment_service_environment_id_seq'::regclass);


-- BEGIN Manually written insert function
INSERT INTO service_environment (
        service_environment_id,
        service_environment_name,
        service_environment_type,               -- new column (service_environment_type)
        production_state,
        description,
        external_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        service_environment_id,
        service_environment_name,
        'default',           -- new column (service_environment_type)
        production_state,
        description,
        external_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM service_environment_v89;


INSERT INTO jazzhands_audit.service_environment (
        service_environment_id,
        service_environment_name,
        service_environment_type,               -- new column (service_environment_type)
        production_state,
        description,
        external_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        service_environment_id,
        service_environment_name,
        'default',           -- new column (service_environment_type)
        production_state,
        description,
        external_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.service_environment_v89;


-- END Manually written insert function
ALTER TABLE jazzhands.service_environment
	ALTER service_environment_id
	SET DEFAULT nextval('jazzhands.service_environment_service_environment_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_environment ADD CONSTRAINT ak_service_env_name_type UNIQUE (service_environment_name, service_environment_type);
ALTER TABLE jazzhands.service_environment ADD CONSTRAINT pk_service_environment PRIMARY KEY (service_environment_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.service_environment.external_id IS 'opaque id used in remote system to identifty this object.  Used for syncing an authoritative copy.';
-- INDEXES
CREATE INDEX xifsvcenv_production_state ON jazzhands.service_environment USING btree (production_state);
CREATE INDEX xifsvcenv_type ON jazzhands.service_environment USING btree (service_environment_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_environment and jazzhands.appaal_instance
ALTER TABLE jazzhands.appaal_instance
	ADD CONSTRAINT fk_appaal_i_fk_applic_svcenv
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK between service_environment and jazzhands.device
ALTER TABLE jazzhands.device
	ADD CONSTRAINT fk_device_dev_v_svcenv
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK between service_environment and jazzhands.network_service
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_csvcenv
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK between service_environment and jazzhands.service_environment_collection_service_environment
ALTER TABLE jazzhands.service_environment_collection_service_environment
	ADD CONSTRAINT fk_svc_env_col_svc_env
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);

-- FOREIGN KEYS TO
-- consider FK service_environment and val_service_environment_type
ALTER TABLE jazzhands.service_environment
	ADD CONSTRAINT fk_svcenv_svctype
	FOREIGN KEY (service_environment_type) REFERENCES jazzhands.val_service_environment_type(service_environment_type);
-- consider FK service_environment and val_production_state
ALTER TABLE jazzhands.service_environment
	ADD CONSTRAINT fk_val_svcenv_prodstate
	FOREIGN KEY (production_state) REFERENCES jazzhands.val_production_state(production_state);

-- TRIGGERS
-- considering NEW jazzhands.delete_per_service_environment_service_environment_collection
CREATE OR REPLACE FUNCTION jazzhands.delete_per_service_environment_service_environment_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	secid	service_environment_collection.service_environment_collection_id%TYPE;
BEGIN
	SELECT	service_environment_collection_id
	  FROM  service_environment_collection
	  INTO	secid
	 WHERE	service_environment_collection_type = 'per-environment'
	   AND	service_environment_collection_id in
		(select service_environment_collection_id
		 from service_environment_collection_service_environment
		where service_environment_id = OLD.service_environment_id
		)
	ORDER BY service_environment_collection_id
	LIMIT 1;

	IF secid IS NOT NULL THEN
		DELETE FROM service_environment_collection_service_environment
		WHERE service_environment_collection_id = secid;

		DELETE from service_environment_collection
		WHERE service_environment_collection_id = secid;
	END IF;

	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_delete_per_service_environment_service_environment_coll BEFORE DELETE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_service_environment_service_environment_collection();

-- considering NEW jazzhands.update_per_service_environment_service_environment_collection
CREATE OR REPLACE FUNCTION jazzhands.update_per_service_environment_service_environment_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	secid		service_environment_collection.service_environment_collection_id%TYPE;
BEGIN
	IF TG_OP = 'INSERT' THEN
		insert into service_environment_collection
			(service_environment_collection_name, service_environment_collection_type)
		values
			(NEW.service_environment_name, 'per-environment')
		RETURNING service_environment_collection_id INTO secid;
		insert into service_environment_collection_service_environment
			(service_environment_collection_id, service_environment_id)
		VALUES
			(secid, NEW.service_environment_id);
	ELSIF TG_OP = 'UPDATE'  AND OLD.service_environment_id != NEW.service_environment_id THEN
		UPDATE	service_environment_collection
		   SET	service_environment_collection_name = NEW.service_environment_name
		 WHERE	service_environment_collection_name != NEW.service_environment_name
		   AND	service_environment_collection_type = 'per-environment'
		   AND	service_environment_collection_id in (
			SELECT	service_environment_collection_id
			  FROM	service_environment_collection_service_environment
			 WHERE	service_environment_id =
				NEW.service_environment_id
			);
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_update_per_service_environment_service_environment_coll AFTER INSERT OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_service_environment_service_environment_collection();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_environment');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('service_environment');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_environment  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_environment');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_environment');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_environment');
ALTER SEQUENCE jazzhands.service_environment_service_environment_id_seq
	 OWNED BY service_environment.service_environment_id;
DROP TABLE IF EXISTS service_environment_v89;
DROP TABLE IF EXISTS jazzhands_audit.service_environment_v89;
-- DONE DEALING WITH TABLE service_environment (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_environment');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_environment');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_environment failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_environment');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_environment');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_environment failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_property', 'val_property');

-- FOREIGN KEYS FROM
ALTER TABLE property_name_collection_property_name DROP CONSTRAINT IF EXISTS fk_prop_col_propnamtyp;
ALTER TABLE property DROP CONSTRAINT IF EXISTS fk_property_nmtyp;
ALTER TABLE val_property_value DROP CONSTRAINT IF EXISTS fk_valproval_namtyp;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_svcemvcoll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_val_devcol_typ_rstr_dc;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_prop_val_devcoll_id;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_acct_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_comp_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_l2netype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_l3netwok_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_prop_nblk_coll_type;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_property_dnsdomcolltype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_val_property_netblkcolltype;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valnetrng_val_prop;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_propdttyp;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_proptyp;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_valprop_pv_actyp_rst;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS fk_vla_property_val_propcolltype;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_property', newobject := 'val_property', newmap := '{"pk_val_property":{"columns":["property_name","property_type"],"def":"PRIMARY KEY (property_name, property_type)","deferrable":false,"deferred":false,"name":"pk_val_property","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS pk_val_property;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif10val_property";
DROP INDEX IF EXISTS "jazzhands"."xif11val_property";
DROP INDEX IF EXISTS "jazzhands"."xif12val_property";
DROP INDEX IF EXISTS "jazzhands"."xif13val_property";
DROP INDEX IF EXISTS "jazzhands"."xif14val_property";
DROP INDEX IF EXISTS "jazzhands"."xif15val_property";
DROP INDEX IF EXISTS "jazzhands"."xif1val_property";
DROP INDEX IF EXISTS "jazzhands"."xif2val_property";
DROP INDEX IF EXISTS "jazzhands"."xif3val_property";
DROP INDEX IF EXISTS "jazzhands"."xif4val_property";
DROP INDEX IF EXISTS "jazzhands"."xif5val_property";
DROP INDEX IF EXISTS "jazzhands"."xif6val_property";
DROP INDEX IF EXISTS "jazzhands"."xif7val_property";
DROP INDEX IF EXISTS "jazzhands"."xif8val_property";
DROP INDEX IF EXISTS "jazzhands"."xif9val_property";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1034200204;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1063245312;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1162061453;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1315394496;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1338302111;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1430936437;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1430936438;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_151657048;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1581934381;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1987241427;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_1994384843;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_2002842082;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_2070965452;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_439888051;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_504174938;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_618591244;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_733000589;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS check_prp_prmt_842506143;
ALTER TABLE jazzhands.val_property DROP CONSTRAINT IF EXISTS ckc_val_prop_osid;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_property ON jazzhands.val_property;
DROP TRIGGER IF EXISTS trigger_audit_val_property ON jazzhands.val_property;
DROP FUNCTION IF EXISTS perform_audit_val_property();
DROP TRIGGER IF EXISTS trigger_validate_val_property ON jazzhands.val_property;
DROP TRIGGER IF EXISTS trigger_validate_val_property_after ON jazzhands.val_property;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_property', tags := ARRAY['table_val_property']);
---- BEGIN jazzhands_audit.val_property TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_property', tags := ARRAY['table_val_property']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_property', 'val_property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_property');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_property DROP CONSTRAINT IF EXISTS val_property_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_property_pk_val_property";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_property_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.val_property TEARDOWN


ALTER TABLE val_property RENAME TO val_property_v89;
ALTER TABLE jazzhands_audit.val_property RENAME TO val_property_v89;

CREATE TABLE jazzhands.val_property
(
	property_name	varchar(255) NOT NULL,
	property_type	varchar(50) NOT NULL,
	description	varchar(255)  NULL,
	account_collection_type	varchar(50)  NULL,
	company_collection_type	varchar(50)  NULL,
	device_collection_type	varchar(50)  NULL,
	dns_domain_collection_type	varchar(50)  NULL,
	layer2_network_collection_type	varchar(50)  NULL,
	layer3_network_collection_type	varchar(50)  NULL,
	netblock_collection_type	varchar(50)  NULL,
	network_range_type	varchar(50)  NULL,
	property_name_collection_type	varchar(50)  NULL,
	service_environment_collection_type	varchar(50)  NULL,
	is_multivalue	boolean NOT NULL,
	property_value_account_collection_type_restriction	varchar(50)  NULL,
	property_value_device_collection_type_restriction	varchar(50)  NULL,
	property_value_netblock_collection_type_restriction	varchar(50)  NULL,
	property_data_type	varchar(50) NOT NULL,
	property_value_json_schema	jsonb  NULL,
	permit_account_collection_id	character(10) NOT NULL,
	permit_account_id	character(10) NOT NULL,
	permit_account_realm_id	character(10) NOT NULL,
	permit_company_id	character(10) NOT NULL,
	permit_company_collection_id	character(10) NOT NULL,
	permit_device_collection_id	character(10) NOT NULL,
	permit_dns_domain_collection_id	character(10) NOT NULL,
	permit_layer2_network_collection_id	character(10) NOT NULL,
	permit_layer3_network_collection_id	character(10) NOT NULL,
	permit_netblock_collection_id	character(10) NOT NULL,
	permit_network_range_id	character(10) NOT NULL,
	permit_operating_system_id	character(10) NOT NULL,
	permit_operating_system_snapshot_id	character(10) NOT NULL,
	permit_property_name_collection_id	character(10) NOT NULL,
	permit_service_environment_collection	character(10) NOT NULL,
	permit_site_code	character(10) NOT NULL,
	permit_x509_signed_certificate_id	character(10) NOT NULL,
	permit_property_rank	character(10) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_property', false);
ALTER TABLE val_property
	ALTER is_multivalue
	SET DEFAULT false;
ALTER TABLE val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_dns_domain_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_layer2_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_layer3_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_operating_system_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_property_name_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_service_environment_collection
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_x509_signed_certificate_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

INSERT INTO val_property (
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection,
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection,
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_property_v89;


INSERT INTO jazzhands_audit.val_property (
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection,
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	property_name,
	property_type,
	description,
	account_collection_type,
	company_collection_type,
	device_collection_type,
	dns_domain_collection_type,
	layer2_network_collection_type,
	layer3_network_collection_type,
	netblock_collection_type,
	network_range_type,
	property_name_collection_type,
	service_environment_collection_type,
	is_multivalue,
	property_value_account_collection_type_restriction,
	property_value_device_collection_type_restriction,
	property_value_netblock_collection_type_restriction,
	property_data_type,
	property_value_json_schema,
	permit_account_collection_id,
	permit_account_id,
	permit_account_realm_id,
	permit_company_id,
	permit_company_collection_id,
	permit_device_collection_id,
	permit_dns_domain_collection_id,
	permit_layer2_network_collection_id,
	permit_layer3_network_collection_id,
	permit_netblock_collection_id,
	permit_network_range_id,
	permit_operating_system_id,
	permit_operating_system_snapshot_id,
	permit_property_name_collection_id,
	permit_service_environment_collection,
	permit_site_code,
	permit_x509_signed_certificate_id,
	permit_property_rank,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_property_v89;

ALTER TABLE jazzhands.val_property
	ALTER is_multivalue
	SET DEFAULT false;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_dns_domain_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_layer2_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_layer3_network_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_operating_system_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_property_name_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_service_environment_collection
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_x509_signed_certificate_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands.val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_property ADD CONSTRAINT pk_val_property PRIMARY KEY (property_name, property_type);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_property IS 'valid values and attributes for (name,type) pairs in the property table.  This defines how triggers enforce aspects of the property table';
COMMENT ON COLUMN jazzhands.val_property.property_name IS 'property name for validation purposes';
COMMENT ON COLUMN jazzhands.val_property.property_type IS 'property type for validation purposes';
COMMENT ON COLUMN jazzhands.val_property.account_collection_type IS 'type restriction of the account_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.company_collection_type IS 'type restriction of company_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.device_collection_type IS 'type restriction of device_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.dns_domain_collection_type IS 'type restriction of dns_domain_collection_id restriction on LHS';
COMMENT ON COLUMN jazzhands.val_property.netblock_collection_type IS 'type restriction of netblock_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.property_name_collection_type IS 'type restriction of property_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.service_environment_collection_type IS 'type restriction of service_enviornment_collection_id on LHS';
COMMENT ON COLUMN jazzhands.val_property.is_multivalue IS 'If N, acts like an alternate key on property.(lhs,property_name,property_type)';
COMMENT ON COLUMN jazzhands.val_property.property_value_account_collection_type_restriction IS 'if property_value is account_collection_Id, this limits the account_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_value_device_collection_type_restriction IS 'if property_value is devicet_collection_Id, this limits the devicet_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_value_netblock_collection_type_restriction IS 'if property_value isnetblockt_collection_Id, this limits the netblockt_collection_types that can be used in that column.';
COMMENT ON COLUMN jazzhands.val_property.property_data_type IS 'which, if any, of the property_table_* columns should be used for this value.   May turn more complex enforcement via trigger';
COMMENT ON COLUMN jazzhands.val_property.permit_account_collection_id IS 'defines permissibility/requirement of account_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_account_id IS 'defines permissibility/requirement of account_idon LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_account_realm_id IS 'defines permissibility/requirement of account_realm_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_company_id IS 'defines permissibility/requirement of company_id on LHS of property.  *NOTE*  THIS COLUMN WILL BE REMOVED IN >0.65';
COMMENT ON COLUMN jazzhands.val_property.permit_company_collection_id IS 'defines permissibility/requirement of company_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_device_collection_id IS 'defines permissibility/requirement of device_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_dns_domain_collection_id IS 'defines permissibility/requirement of dns_domain_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_layer2_network_collection_id IS 'defines permissibility/requirement of layer2_network_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_layer3_network_collection_id IS 'defines permissibility/requirement of layer3_network_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_netblock_collection_id IS 'defines permissibility/requirement of netblock_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_operating_system_id IS 'defines permissibility/requirement of operating_system_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_operating_system_snapshot_id IS 'defines permissibility/requirement of operating_system_snapshot_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_property_name_collection_id IS 'defines permissibility/requirement of property_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_service_environment_collection IS 'defines permissibility/requirement of service_env_collection_id on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_site_code IS 'defines permissibility/requirement of site_code on LHS of property';
COMMENT ON COLUMN jazzhands.val_property.permit_property_rank IS 'defines permissibility of property_rank, and if it should be part of the "lhs" of the given property';
-- INDEXES
CREATE INDEX xif10val_property ON jazzhands.val_property USING btree (netblock_collection_type);
CREATE INDEX xif11val_property ON jazzhands.val_property USING btree (property_name_collection_type);
CREATE INDEX xif12val_property ON jazzhands.val_property USING btree (service_environment_collection_type);
CREATE INDEX xif13val_property ON jazzhands.val_property USING btree (layer3_network_collection_type);
CREATE INDEX xif14val_property ON jazzhands.val_property USING btree (layer2_network_collection_type);
CREATE INDEX xif15val_property ON jazzhands.val_property USING btree (network_range_type);
CREATE INDEX xif1val_property ON jazzhands.val_property USING btree (property_data_type);
CREATE INDEX xif2val_property ON jazzhands.val_property USING btree (property_type);
CREATE INDEX xif3val_property ON jazzhands.val_property USING btree (property_value_account_collection_type_restriction);
CREATE INDEX xif4val_property ON jazzhands.val_property USING btree (property_value_netblock_collection_type_restriction);
CREATE INDEX xif5val_property ON jazzhands.val_property USING btree (property_value_device_collection_type_restriction);
CREATE INDEX xif6val_property ON jazzhands.val_property USING btree (account_collection_type);
CREATE INDEX xif7val_property ON jazzhands.val_property USING btree (company_collection_type);
CREATE INDEX xif8val_property ON jazzhands.val_property USING btree (device_collection_type);
CREATE INDEX xif9val_property ON jazzhands.val_property USING btree (dns_domain_collection_type);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1034200204
	CHECK ((permit_account_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1063245312
	CHECK ((permit_property_rank = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1315394496
	CHECK ((permit_operating_system_snapshot_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1338302111
	CHECK ((permit_service_environment_collection = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1430936437
	CHECK ((permit_layer2_network_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1430936438
	CHECK ((permit_layer3_network_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_151657048
	CHECK ((permit_account_realm_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1581934381
	CHECK ((permit_property_name_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1987241427
	CHECK ((permit_account_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_1994384843
	CHECK ((permit_netblock_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_2002842082
	CHECK ((permit_company_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_2070965452
	CHECK ((permit_device_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_439888051
	CHECK ((permit_dns_domain_collection_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_504174938
	CHECK ((permit_network_range_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_618591244
	CHECK ((permit_x509_signed_certificate_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_733000589
	CHECK ((permit_company_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT check_prp_prmt_842506143
	CHECK ((permit_site_code = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));
ALTER TABLE jazzhands.val_property ADD CONSTRAINT ckc_val_prop_osid
	CHECK ((permit_operating_system_id = ANY (ARRAY['REQUIRED'::bpchar, 'PROHIBITED'::bpchar, 'ALLOWED'::bpchar])));

-- FOREIGN KEYS FROM
-- consider FK between val_property and jazzhands.property_name_collection_property_name
ALTER TABLE jazzhands.property_name_collection_property_name
	ADD CONSTRAINT fk_prop_col_propnamtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK between val_property and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nmtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK between val_property and jazzhands.val_property_value
ALTER TABLE jazzhands.val_property_value
	ADD CONSTRAINT fk_valproval_namtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);

-- FOREIGN KEYS TO
-- consider FK val_property and val_service_environment_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_svcemvcoll_type
	FOREIGN KEY (service_environment_collection_type) REFERENCES jazzhands.val_service_environment_collection_type(service_environment_collection_type);
-- consider FK val_property and val_device_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_val_devcol_typ_rstr_dc
	FOREIGN KEY (property_value_device_collection_type_restriction) REFERENCES jazzhands.val_device_collection_type(device_collection_type);
-- consider FK val_property and val_device_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_prop_val_devcoll_id
	FOREIGN KEY (device_collection_type) REFERENCES jazzhands.val_device_collection_type(device_collection_type);
-- consider FK val_property and val_account_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_acct_coll_type
	FOREIGN KEY (account_collection_type) REFERENCES jazzhands.val_account_collection_type(account_collection_type);
-- consider FK val_property and val_company_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_comp_coll_type
	FOREIGN KEY (company_collection_type) REFERENCES jazzhands.val_company_collection_type(company_collection_type);
-- consider FK val_property and val_layer2_network_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_l2netype
	FOREIGN KEY (layer2_network_collection_type) REFERENCES jazzhands.val_layer2_network_collection_type(layer2_network_collection_type);
-- consider FK val_property and val_layer3_network_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_l3netwok_type
	FOREIGN KEY (layer3_network_collection_type) REFERENCES jazzhands.val_layer3_network_collection_type(layer3_network_collection_type);
-- consider FK val_property and val_netblock_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_prop_nblk_coll_type
	FOREIGN KEY (property_value_netblock_collection_type_restriction) REFERENCES jazzhands.val_netblock_collection_type(netblock_collection_type);
-- consider FK val_property and val_dns_domain_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_property_dnsdomcolltype
	FOREIGN KEY (dns_domain_collection_type) REFERENCES jazzhands.val_dns_domain_collection_type(dns_domain_collection_type);
-- consider FK val_property and val_netblock_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_val_property_netblkcolltype
	FOREIGN KEY (netblock_collection_type) REFERENCES jazzhands.val_netblock_collection_type(netblock_collection_type);
-- consider FK val_property and val_network_range_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valnetrng_val_prop
	FOREIGN KEY (network_range_type) REFERENCES jazzhands.val_network_range_type(network_range_type);
-- consider FK val_property and val_property_data_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_propdttyp
	FOREIGN KEY (property_data_type) REFERENCES jazzhands.val_property_data_type(property_data_type);
-- consider FK val_property and val_property_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_proptyp
	FOREIGN KEY (property_type) REFERENCES jazzhands.val_property_type(property_type);
-- consider FK val_property and val_account_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_valprop_pv_actyp_rst
	FOREIGN KEY (property_value_account_collection_type_restriction) REFERENCES jazzhands.val_account_collection_type(account_collection_type);
-- consider FK val_property and val_property_name_collection_type
ALTER TABLE jazzhands.val_property
	ADD CONSTRAINT fk_vla_property_val_propcolltype
	FOREIGN KEY (property_name_collection_type) REFERENCES jazzhands.val_property_name_collection_type(property_name_collection_type);

-- TRIGGERS
-- considering NEW jazzhands.validate_val_property
CREATE OR REPLACE FUNCTION jazzhands.validate_val_property()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	IF NEW.property_data_type = 'json' AND NEW.property_value_json_schema IS NULL THEN
		RAISE 'property_data_type json requires a schema to be set'
			USING ERRCODE = 'invalid_parameter_value';
	ELSIF NEW.property_data_type != 'json' AND NEW.property_value_json_schema IS NOT NULL THEN
		RAISE 'property_data_type % may not have a json schema set',
			NEW.property_data_type
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF TG_OP = 'UPDATE' AND OLD.property_data_type != NEW.property_data_type THEN
		SELECT	count(*)
		INTO	_tally
		WHERE	property_name = NEW.property_name
		AND		property_type = NEW.property_type;

		IF _tally > 0  THEN
			RAISE 'May not change property type if there are existing proeprties'
				USING ERRCODE = 'foreign_key_violation';

		END IF;
	END IF;

	IF TG_OP = 'INSERT' AND NEW.permit_company_id != 'PROHIBITED' OR
		( TG_OP = 'UPDATE' AND NEW.permit_company_id != 'PROHIBITED' AND
			OLD.permit_company_id IS DISTINCT FROM NEW.permit_company_id )
	THEN
		RAISE 'property.company_id is being retired.  Please use per-company collections'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_validate_val_property BEFORE INSERT OR UPDATE OF property_data_type, property_value_json_schema, permit_company_id ON jazzhands.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_property();

-- considering NEW jazzhands.validate_val_property_after
CREATE OR REPLACE FUNCTION jazzhands.validate_val_property_after()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	property%ROWTYPE;
BEGIN
	FOR _r IN SELECT * FROM property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type
	LOOP
		PERFORM property_utils.validate_property(_r);
	END LOOP;
	RETURN NEW;
END;
$function$
;
CREATE CONSTRAINT TRIGGER trigger_validate_val_property_after AFTER UPDATE ON jazzhands.val_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_property_after();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_property');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_property');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_property');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_property');
DROP TABLE IF EXISTS val_property_v89;
DROP TABLE IF EXISTS jazzhands_audit.val_property_v89;
-- DONE DEALING WITH TABLE val_property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE approval_process_chain
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'approval_process_chain', 'approval_process_chain');

-- FOREIGN KEYS FROM
ALTER TABLE approval_process DROP CONSTRAINT IF EXISTS fk_app_proc_1st_app_proc_chnid;
ALTER TABLE approval_instance_step DROP CONSTRAINT IF EXISTS fk_appinststep_app_prcchnid;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_appproc_chn_resp_period;
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_apprchn_app_proc_chn;
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS fk_apprchn_rej_proc_chn;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'approval_process_chain', newobject := 'approval_process_chain', newmap := '{"pk_approval_process_chain":{"columns":["approval_process_chain_id"],"def":"PRIMARY KEY (approval_process_chain_id)","deferrable":false,"deferred":false,"name":"pk_approval_process_chain","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.approval_process_chain DROP CONSTRAINT IF EXISTS pk_approval_process_chain;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1approval_process_chain";
DROP INDEX IF EXISTS "jazzhands"."xif2approval_process_chain";
DROP INDEX IF EXISTS "jazzhands"."xif3approval_process_chain";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_approval_process_chain ON jazzhands.approval_process_chain;
DROP TRIGGER IF EXISTS trigger_audit_approval_process_chain ON jazzhands.approval_process_chain;
DROP FUNCTION IF EXISTS perform_audit_approval_process_chain();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'approval_process_chain', tags := ARRAY['table_approval_process_chain']);
---- BEGIN jazzhands_audit.approval_process_chain TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'approval_process_chain', tags := ARRAY['table_approval_process_chain']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'approval_process_chain', 'approval_process_chain');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'approval_process_chain');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.approval_process_chain DROP CONSTRAINT IF EXISTS approval_process_chain_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."approval_process_chain_aud#txid_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_approval_process_chain_pk_approval_process_chain";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.approval_process_chain TEARDOWN


ALTER TABLE approval_process_chain RENAME TO approval_process_chain_v89;
ALTER TABLE jazzhands_audit.approval_process_chain RENAME TO approval_process_chain_v89;

CREATE TABLE jazzhands.approval_process_chain
(
	approval_process_chain_id	integer NOT NULL,
	approval_process_chain_name	varchar(50) NOT NULL,
	approval_chain_response_period	varchar(50)  NULL,
	description	varchar(255)  NULL,
	message	varchar(4096)  NULL,
	email_message	varchar(4096)  NULL,
	email_subject_prefix	varchar(50)  NULL,
	email_subject_suffix	varchar(50)  NULL,
	max_escalation_level	integer  NULL,
	escalation_delay	integer  NULL,
	escalation_reminder_gap	integer  NULL,
	approving_entity	varchar(50)  NULL,
	refresh_all_data	boolean NOT NULL,
	accept_approval_process_chain_id	integer  NULL,
	reject_approval_process_chain_id	integer  NULL,
	permit_immediate_resolution	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'approval_process_chain', false);
ALTER TABLE approval_process_chain
	ALTER approval_process_chain_id
	SET DEFAULT nextval('jazzhands.approval_process_chain_approval_process_chain_id_seq'::regclass);
ALTER TABLE approval_process_chain
	ALTER approval_chain_response_period
	SET DEFAULT '1 week'::character varying;
ALTER TABLE approval_process_chain
	ALTER refresh_all_data
	SET DEFAULT false;
ALTER TABLE approval_process_chain
	ALTER permit_immediate_resolution
	SET DEFAULT false;

INSERT INTO approval_process_chain (
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,		-- new column (permit_immediate_resolution)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	false,		-- new column (permit_immediate_resolution)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM approval_process_chain_v89;


INSERT INTO jazzhands_audit.approval_process_chain (
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	permit_immediate_resolution,		-- new column (permit_immediate_resolution)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	approval_process_chain_id,
	approval_process_chain_name,
	approval_chain_response_period,
	description,
	message,
	email_message,
	email_subject_prefix,
	email_subject_suffix,
	max_escalation_level,
	escalation_delay,
	escalation_reminder_gap,
	approving_entity,
	refresh_all_data,
	accept_approval_process_chain_id,
	reject_approval_process_chain_id,
	NULL,		-- new column (permit_immediate_resolution)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.approval_process_chain_v89;

ALTER TABLE jazzhands.approval_process_chain
	ALTER approval_process_chain_id
	SET DEFAULT nextval('jazzhands.approval_process_chain_approval_process_chain_id_seq'::regclass);
ALTER TABLE jazzhands.approval_process_chain
	ALTER approval_chain_response_period
	SET DEFAULT '1 week'::character varying;
ALTER TABLE jazzhands.approval_process_chain
	ALTER refresh_all_data
	SET DEFAULT false;
ALTER TABLE jazzhands.approval_process_chain
	ALTER permit_immediate_resolution
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.approval_process_chain ADD CONSTRAINT pk_approval_process_chain PRIMARY KEY (approval_process_chain_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.approval_process_chain.permit_immediate_resolution IS ' Approval functions are permitted toshort circuit to completed regardless of the existnace of an accept or reject.  Used for situations where the approval/request chagne process are in a stalemate.';
-- INDEXES
CREATE INDEX xif1approval_process_chain ON jazzhands.approval_process_chain USING btree (approval_chain_response_period);
CREATE INDEX xif2approval_process_chain ON jazzhands.approval_process_chain USING btree (accept_approval_process_chain_id);
CREATE INDEX xif3approval_process_chain ON jazzhands.approval_process_chain USING btree (accept_approval_process_chain_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between approval_process_chain and jazzhands.approval_process
ALTER TABLE jazzhands.approval_process
	ADD CONSTRAINT fk_app_proc_1st_app_proc_chnid
	FOREIGN KEY (first_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);
-- consider FK between approval_process_chain and jazzhands.approval_instance_step
ALTER TABLE jazzhands.approval_instance_step
	ADD CONSTRAINT fk_appinststep_app_prcchnid
	FOREIGN KEY (approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);

-- FOREIGN KEYS TO
-- consider FK approval_process_chain and val_approval_chain_response_period
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_appproc_chn_resp_period
	FOREIGN KEY (approval_chain_response_period) REFERENCES jazzhands.val_approval_chain_response_period(approval_chain_response_period);
-- consider FK approval_process_chain and approval_process_chain
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_apprchn_app_proc_chn
	FOREIGN KEY (accept_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);
-- consider FK approval_process_chain and approval_process_chain
ALTER TABLE jazzhands.approval_process_chain
	ADD CONSTRAINT fk_apprchn_rej_proc_chn
	FOREIGN KEY (accept_approval_process_chain_id) REFERENCES jazzhands.approval_process_chain(approval_process_chain_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('approval_process_chain');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('approval_process_chain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for approval_process_chain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'approval_process_chain');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'approval_process_chain');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'approval_process_chain');
ALTER SEQUENCE jazzhands.approval_process_chain_approval_process_chain_id_seq
	 OWNED BY approval_process_chain.approval_process_chain_id;
DROP TABLE IF EXISTS approval_process_chain_v89;
DROP TABLE IF EXISTS jazzhands_audit.approval_process_chain_v89;
-- DONE DEALING WITH TABLE approval_process_chain (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old approval_process_chain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('approval_process_chain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new approval_process_chain failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE dns_domain
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'dns_domain', 'dns_domain');

-- FOREIGN KEYS FROM
ALTER TABLE dns_change_record DROP CONSTRAINT IF EXISTS fk_dns_chg_dns_domain;
ALTER TABLE dns_domain_collection_dns_domain DROP CONSTRAINT IF EXISTS fk_dns_dom_coll_dns_domid;
ALTER TABLE dns_domain_ip_universe DROP CONSTRAINT IF EXISTS fk_dnsdom_ipu_dnsdomid;
ALTER TABLE dns_record DROP CONSTRAINT IF EXISTS fk_dnsid_dnsdom_id;
ALTER TABLE network_range DROP CONSTRAINT IF EXISTS fk_net_range_dns_domain_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.dns_domain DROP CONSTRAINT IF EXISTS fk_dns_dom_dns_dom_typ;
ALTER TABLE jazzhands.dns_domain DROP CONSTRAINT IF EXISTS fk_dnsdom_dnsdom_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'dns_domain', newobject := 'dns_domain', newmap := '{"ak_dns_domain_name_type":{"columns":["dns_domain_name","dns_domain_type"],"def":"UNIQUE (dns_domain_name, dns_domain_type)","deferrable":false,"deferred":false,"name":"ak_dns_domain_name_type","type":"u"},"pk_dns_domain":{"columns":["dns_domain_id"],"def":"PRIMARY KEY (dns_domain_id)","deferrable":false,"deferred":false,"name":"pk_dns_domain","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.dns_domain DROP CONSTRAINT IF EXISTS ak_dns_domain_name_type;
ALTER TABLE jazzhands.dns_domain DROP CONSTRAINT IF EXISTS pk_dns_domain;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_dnsdomain_parentdnsdomain";
DROP INDEX IF EXISTS "jazzhands"."xifdns_dom_dns_dom_type";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_dns_domain ON jazzhands.dns_domain;
DROP TRIGGER IF EXISTS trigger_audit_dns_domain ON jazzhands.dns_domain;
DROP FUNCTION IF EXISTS perform_audit_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_soa_name_retire ON jazzhands.dns_domain;
DROP TRIGGER IF EXISTS trigger_dns_domain_trigger_change ON jazzhands.dns_domain;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'dns_domain', tags := ARRAY['table_dns_domain']);
---- BEGIN jazzhands_audit.dns_domain TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'dns_domain', tags := ARRAY['table_dns_domain']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'dns_domain', 'dns_domain');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'dns_domain');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.dns_domain DROP CONSTRAINT IF EXISTS dns_domain_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_domain_ak_dns_domain_name_type";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_domain_pk_dns_domain";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_domain_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_domain_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_domain_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.dns_domain TEARDOWN


ALTER TABLE dns_domain RENAME TO dns_domain_v89;
ALTER TABLE jazzhands_audit.dns_domain RENAME TO dns_domain_v89;

CREATE TABLE jazzhands.dns_domain
(
	dns_domain_id	integer NOT NULL,
	dns_domain_name	varchar(255) NOT NULL,
	dns_domain_type	varchar(50) NOT NULL,
	parent_dns_domain_id	integer  NULL,
	description	varchar(255)  NULL,
	external_id	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'dns_domain', false);
ALTER TABLE dns_domain
	ALTER dns_domain_id
	SET DEFAULT nextval('jazzhands.dns_domain_dns_domain_id_seq'::regclass);

INSERT INTO dns_domain (
	dns_domain_id,
	dns_domain_name,
	dns_domain_type,
	parent_dns_domain_id,
	description,
	external_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	dns_domain_id,
	dns_domain_name,
	dns_domain_type,
	parent_dns_domain_id,
	description,
	external_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM dns_domain_v89;


INSERT INTO jazzhands_audit.dns_domain (
	dns_domain_id,
	dns_domain_name,
	dns_domain_type,
	parent_dns_domain_id,
	description,
	external_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	dns_domain_id,
	dns_domain_name,
	dns_domain_type,
	parent_dns_domain_id,
	description,
	external_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.dns_domain_v89;

ALTER TABLE jazzhands.dns_domain
	ALTER dns_domain_id
	SET DEFAULT nextval('jazzhands.dns_domain_dns_domain_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.dns_domain ADD CONSTRAINT ak_dns_domain_name_type UNIQUE (dns_domain_name, dns_domain_type);
ALTER TABLE jazzhands.dns_domain ADD CONSTRAINT pk_dns_domain PRIMARY KEY (dns_domain_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.dns_domain.external_id IS 'opaque id used in remote system to identifty this object.  Used for syncing an authoritative copy.';
-- INDEXES
CREATE INDEX idx_dnsdomain_parentdnsdomain ON jazzhands.dns_domain USING btree (parent_dns_domain_id);
CREATE INDEX xifdns_dom_dns_dom_type ON jazzhands.dns_domain USING btree (dns_domain_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between dns_domain and jazzhands.dns_change_record
ALTER TABLE jazzhands.dns_change_record
	ADD CONSTRAINT fk_dns_chg_dns_domain
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK between dns_domain and jazzhands.dns_domain_collection_dns_domain
ALTER TABLE jazzhands.dns_domain_collection_dns_domain
	ADD CONSTRAINT fk_dns_dom_coll_dns_domid
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK between dns_domain and jazzhands.dns_domain_ip_universe
ALTER TABLE jazzhands.dns_domain_ip_universe
	ADD CONSTRAINT fk_dnsdom_ipu_dnsdomid
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK between dns_domain and jazzhands.dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsid_dnsdom_id
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK between dns_domain and jazzhands.network_range
ALTER TABLE jazzhands.network_range
	ADD CONSTRAINT fk_net_range_dns_domain_id
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);

-- FOREIGN KEYS TO
-- consider FK dns_domain and val_dns_domain_type
ALTER TABLE jazzhands.dns_domain
	ADD CONSTRAINT fk_dns_dom_dns_dom_typ
	FOREIGN KEY (dns_domain_type) REFERENCES jazzhands.val_dns_domain_type(dns_domain_type);
-- consider FK dns_domain and dns_domain
ALTER TABLE jazzhands.dns_domain
	ADD CONSTRAINT fk_dnsdom_dnsdom_id
	FOREIGN KEY (parent_dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);

-- TRIGGERS
-- considering NEW jazzhands.dns_domain_trigger_change
CREATE OR REPLACE FUNCTION jazzhands.dns_domain_trigger_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM dns_domain_ip_universe
	WHERE dns_domain_id = NEW.dns_domain_id
	AND SHOULD_GENERATE = true;
	IF FOUND THEN
		INSERT INTO dns_change_record
			(dns_domain_id) VALUES (NEW.dns_domain_id);
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_domain_trigger_change AFTER INSERT OR UPDATE OF dns_domain_name ON jazzhands.dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_trigger_change();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('dns_domain');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('dns_domain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for dns_domain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'dns_domain');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'dns_domain');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'dns_domain');
ALTER SEQUENCE jazzhands.dns_domain_dns_domain_id_seq
	 OWNED BY dns_domain.dns_domain_id;
DROP TABLE IF EXISTS dns_domain_v89;
DROP TABLE IF EXISTS jazzhands_audit.dns_domain_v89;
-- DONE DEALING WITH TABLE dns_domain (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old dns_domain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new dns_domain failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE dns_record
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'dns_record', 'dns_record');

-- FOREIGN KEYS FROM
ALTER TABLE device DROP CONSTRAINT IF EXISTS fk_device_id_dnsrecord;
ALTER TABLE dns_record_relation DROP CONSTRAINT IF EXISTS fk_dns_rec_ref_dns_rec_rltn;
ALTER TABLE dns_record_relation DROP CONSTRAINT IF EXISTS fk_dnsrec_ref_dnsrecrltn_rl_id;
ALTER TABLE network_service DROP CONSTRAINT IF EXISTS fk_netsvc_dnsid_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dns_rec_ip_universe;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dns_record_vdnsclass;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsid_dnsdom_id;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsid_nblk_id;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsrec_vdnssrvsrvc;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsrecord_vdnstype;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_dnsvalref_dns_recid;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS fk_ref_dnsrec_dnserc;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'dns_record', newobject := 'dns_record', newmap := '{"ak_dns_record_dnsrec_domainid":{"columns":["dns_record_id","dns_domain_id"],"def":"UNIQUE (dns_record_id, dns_domain_id)","deferrable":false,"deferred":false,"name":"ak_dns_record_dnsrec_domainid","type":"u"},"pk_dns_record":{"columns":["dns_record_id"],"def":"PRIMARY KEY (dns_record_id)","deferrable":false,"deferred":false,"name":"pk_dns_record","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS ak_dns_record_dnsrec_domainid;
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS pk_dns_record;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_dns_record_lower_dns_name";
DROP INDEX IF EXISTS "jazzhands"."idx_dnsrec_dnsclass";
DROP INDEX IF EXISTS "jazzhands"."idx_dnsrec_dnssrvservice";
DROP INDEX IF EXISTS "jazzhands"."xif_dns_rec_ip_universe";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsid_dnsdom_id";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsid_nblk_id";
DROP INDEX IF EXISTS "jazzhands"."xif_dnsrecord_vdnstype";
DROP INDEX IF EXISTS "jazzhands"."xif_ref_dnsrec_dnserc";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.dns_record DROP CONSTRAINT IF EXISTS ckc_dns_srv_protocol_dns_reco;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_dns_record ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_audit_dns_record ON jazzhands.dns_record;
DROP FUNCTION IF EXISTS perform_audit_dns_record();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_dns_record ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_a_rec_validation ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_non_a_rec_validation ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_rec_prevent_dups ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_check_name ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_cname_checker ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_enabled_check ON jazzhands.dns_record;
DROP TRIGGER IF EXISTS trigger_dns_record_update_nontime ON jazzhands.dns_record;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'dns_record', tags := ARRAY['table_dns_record']);
---- BEGIN jazzhands_audit.dns_record TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'dns_record', tags := ARRAY['table_dns_record']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'dns_record', 'dns_record');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'dns_record');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.dns_record DROP CONSTRAINT IF EXISTS dns_record_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_record_ak_dns_record_dnsrec_domainid";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_dns_record_pk_dns_record";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."dns_record_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.dns_record TEARDOWN


ALTER TABLE dns_record RENAME TO dns_record_v89;
ALTER TABLE jazzhands_audit.dns_record RENAME TO dns_record_v89;

CREATE TABLE jazzhands.dns_record
(
	dns_record_id	integer NOT NULL,
	dns_name	varchar(255)  NULL,
	dns_domain_id	integer NOT NULL,
	dns_ttl	integer  NULL,
	dns_class	varchar(50) NOT NULL,
	dns_type	varchar(50) NOT NULL,
	dns_value	varchar(512)  NULL,
	dns_priority	integer  NULL,
	dns_srv_service	varchar(50)  NULL,
	dns_srv_protocol	varchar(4)  NULL,
	dns_srv_weight	integer  NULL,
	dns_srv_port	integer  NULL,
	netblock_id	integer  NULL,
	ip_universe_id	integer NOT NULL,
	reference_dns_record_id	integer  NULL,
	dns_value_record_id	integer  NULL,
	should_generate_ptr	boolean NOT NULL,
	external_id	varchar(255)  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'dns_record', false);
ALTER TABLE dns_record
	ALTER dns_record_id
	SET DEFAULT nextval('jazzhands.dns_record_dns_record_id_seq'::regclass);
ALTER TABLE dns_record
	ALTER dns_class
	SET DEFAULT 'IN'::character varying;
ALTER TABLE dns_record
	ALTER should_generate_ptr
	SET DEFAULT true;
ALTER TABLE dns_record
	ALTER is_enabled
	SET DEFAULT true;

INSERT INTO dns_record (
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,		-- new column (external_id)
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	NULL,		-- new column (external_id)
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM dns_record_v89;


INSERT INTO jazzhands_audit.dns_record (
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	external_id,		-- new column (external_id)
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	dns_record_id,
	dns_name,
	dns_domain_id,
	dns_ttl,
	dns_class,
	dns_type,
	dns_value,
	dns_priority,
	dns_srv_service,
	dns_srv_protocol,
	dns_srv_weight,
	dns_srv_port,
	netblock_id,
	ip_universe_id,
	reference_dns_record_id,
	dns_value_record_id,
	should_generate_ptr,
	NULL,		-- new column (external_id)
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.dns_record_v89;

ALTER TABLE jazzhands.dns_record
	ALTER dns_record_id
	SET DEFAULT nextval('jazzhands.dns_record_dns_record_id_seq'::regclass);
ALTER TABLE jazzhands.dns_record
	ALTER dns_class
	SET DEFAULT 'IN'::character varying;
ALTER TABLE jazzhands.dns_record
	ALTER should_generate_ptr
	SET DEFAULT true;
ALTER TABLE jazzhands.dns_record
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT ak_dns_record_dnsrec_domainid UNIQUE (dns_record_id, dns_domain_id);
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT pk_dns_record PRIMARY KEY (dns_record_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX idx_dns_record_lower_dns_name ON jazzhands.dns_record USING btree (lower(dns_name::text));
CREATE INDEX idx_dnsrec_dnsclass ON jazzhands.dns_record USING btree (dns_class);
CREATE INDEX idx_dnsrec_dnssrvservice ON jazzhands.dns_record USING btree (dns_srv_service);
CREATE INDEX xif_dns_rec_ip_universe ON jazzhands.dns_record USING btree (ip_universe_id);
CREATE INDEX xif_dnsid_dnsdom_id ON jazzhands.dns_record USING btree (dns_domain_id);
CREATE INDEX xif_dnsid_nblk_id ON jazzhands.dns_record USING btree (netblock_id);
CREATE INDEX xif_dnsrecord_vdnstype ON jazzhands.dns_record USING btree (dns_type);
CREATE INDEX xif_ref_dnsrec_dnserc ON jazzhands.dns_record USING btree (reference_dns_record_id, dns_domain_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.dns_record ADD CONSTRAINT ckc_dns_srv_protocol_dns_reco
	CHECK (((dns_srv_protocol IS NULL) OR (((dns_srv_protocol)::text = ANY ((ARRAY['tcp'::character varying, 'udp'::character varying])::text[])) AND ((dns_srv_protocol)::text = lower((dns_srv_protocol)::text)))));

-- FOREIGN KEYS FROM
-- consider FK between dns_record and jazzhands.device
ALTER TABLE jazzhands.device
	ADD CONSTRAINT fk_device_id_dnsrecord
	FOREIGN KEY (identifying_dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;
-- consider FK between dns_record and jazzhands.dns_record_relation
ALTER TABLE jazzhands.dns_record_relation
	ADD CONSTRAINT fk_dns_rec_ref_dns_rec_rltn
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK between dns_record and jazzhands.dns_record_relation
ALTER TABLE jazzhands.dns_record_relation
	ADD CONSTRAINT fk_dnsrec_ref_dnsrecrltn_rl_id
	FOREIGN KEY (related_dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK between dns_record and jazzhands.network_service
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_dnsid_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);

-- FOREIGN KEYS TO
-- consider FK dns_record and ip_universe
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dns_rec_ip_universe
	FOREIGN KEY (ip_universe_id) REFERENCES jazzhands.ip_universe(ip_universe_id);
-- consider FK dns_record and val_dns_class
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dns_record_vdnsclass
	FOREIGN KEY (dns_class) REFERENCES jazzhands.val_dns_class(dns_class);
-- consider FK dns_record and dns_domain
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsid_dnsdom_id
	FOREIGN KEY (dns_domain_id) REFERENCES jazzhands.dns_domain(dns_domain_id);
-- consider FK dns_record and netblock
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsid_nblk_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK dns_record and val_dns_srv_service
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsrec_vdnssrvsrvc
	FOREIGN KEY (dns_srv_service) REFERENCES jazzhands.val_dns_srv_service(dns_srv_service);
-- consider FK dns_record and val_dns_type
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsrecord_vdnstype
	FOREIGN KEY (dns_type) REFERENCES jazzhands.val_dns_type(dns_type);
-- consider FK dns_record and dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_dnsvalref_dns_recid
	FOREIGN KEY (dns_value_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK dns_record and dns_record
ALTER TABLE jazzhands.dns_record
	ADD CONSTRAINT fk_ref_dnsrec_dnserc
	FOREIGN KEY (reference_dns_record_id, dns_domain_id) REFERENCES jazzhands.dns_record(dns_record_id, dns_domain_id);

-- TRIGGERS
-- considering NEW jazzhands.check_ip_universe_dns_record
CREATE OR REPLACE FUNCTION jazzhands.check_ip_universe_dns_record()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	nb	integer[];
BEGIN
	IF TG_OP = 'UPDATE' THEN
		IF NEW.netblock_id != OLD.netblock_id THEN
			nb = ARRAY[OLD.netblock_id, NEW.netblock_id];
		ELSE
			nb = ARRAY[NEW.netblock_id];
		END IF;
	ELSE
		nb = ARRAY[NEW.netblock_id];
	END IF;

	PERFORM *
	FROM netblock
	WHERE netblock_id = ANY(nb)
	AND ip_universe_id != NEW.ip_universe_id;

	IF FOUND THEN
		RAISE EXCEPTION
			'IP Universes for dns_records must match dns records and netblocks'
			USING ERRCODE = 'foreign_key_violation';
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_dns_record AFTER INSERT OR UPDATE OF dns_record_id, ip_universe_id ON jazzhands.dns_record DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_ip_universe_dns_record();

-- considering NEW jazzhands.dns_a_rec_validation
CREATE OR REPLACE FUNCTION jazzhands.dns_a_rec_validation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ip		netblock.ip_address%type;
	_sing	netblock.is_single_address%type;
BEGIN
	--
	-- arguably, this belongs elsewhere in a non-"validation" trigger,
	-- but that only matters if this wants to be a constraint trigger.
	--
	IF NEW.ip_universe_id IS NULL THEN
		IF NEW.netblock_id IS NOT NULL THEN
			SELECT ip_universe_id INTO NEW.ip_universe_id
			FROM netblock
			WHERE netblock_id = NEW.netblock_id;
		ELSIF NEW.dns_value_record_id IS NOT NULL THEN
			SELECT ip_universe_id INTO NEW.ip_universe_id
			FROM dns_record
			WHERE dns_record_id = NEW.dns_value_record_id;
		ELSE
			-- old default.
			NEW.ip_universe_id = 0;
		END IF;
	END IF;

	IF NEW.dns_type in ('A', 'AAAA') THEN
		IF ( NEW.netblock_id IS NULL AND NEW.dns_value_record_id IS NULL ) THEN
			RAISE EXCEPTION 'Attempt to set % record without netblocks',
				NEW.dns_type
				USING ERRCODE = 'not_null_violation';
		ELSIF NEW.dns_value_record_id IS NOT NULL THEN
			PERFORM *
			FROM dns_record d
			WHERE d.dns_record_id = NEW.dns_value_record_id
			AND d.dns_type = NEW.dns_type
			AND d.dns_class = NEW.dns_class;

			IF NOT FOUND THEN
				RAISE EXCEPTION 'Attempt to set % value record without the correct netblock',
					NEW.dns_type
					USING ERRCODE = 'not_null_violation';
			END IF;
		END IF;

		IF ( NEW.should_generate_ptr = true AND NEW.dns_value_record_id IS NOT NULL ) THEN
			RAISE EXCEPTION 'It is not permitted to set should_generate_ptr and use a dns_value_record_id'
				USING ERRCODE = 'foreign_key_violation';
		END IF;
	END IF;

	IF NEW.netblock_Id is not NULL and
			( NEW.dns_value IS NOT NULL OR NEW.dns_value_record_id IS NOT NULL ) THEN
		RAISE EXCEPTION 'Both dns_value and netblock_id may not be set'
			USING ERRCODE = 'JH001';
	END IF;

	IF NEW.dns_value IS NOT NULL AND NEW.dns_value_record_id IS NOT NULL THEN
		RAISE EXCEPTION 'Both dns_value and dns_value_record_id may not be set'
			USING ERRCODE = 'JH001';
	END IF;

	-- XXX need to deal with changing a netblock type and breaking dns_record..
	IF NEW.netblock_id IS NOT NULL THEN
		SELECT ip_address, is_single_address
		  INTO _ip, _sing
		  FROM netblock
		 WHERE netblock_id = NEW.netblock_id;

		IF NEW.dns_type = 'A' AND family(_ip) != '4' THEN
			RAISE EXCEPTION 'A records must be assigned to non-IPv4 records'
				USING ERRCODE = 'JH200';
		END IF;

		IF NEW.dns_type = 'AAAA' AND family(_ip) != '6' THEN
			RAISE EXCEPTION 'AAAA records must be assigned to non-IPv6 records'
				USING ERRCODE = 'JH200';
		END IF;

		IF _sing = false AND NEW.dns_type IN ('A','AAAA') THEN
			RAISE EXCEPTION 'Non-single addresses may not have % records', NEW.dns_type
				USING ERRCODE = 'foreign_key_violation';
		END IF;

	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_a_rec_validation();

-- considering NEW jazzhands.dns_non_a_rec_validation
CREATE OR REPLACE FUNCTION jazzhands.dns_non_a_rec_validation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ip		netblock.ip_address%type;
BEGIN
	IF NEW.dns_type NOT in ('A', 'AAAA', 'REVERSE_ZONE_BLOCK_PTR') AND
			( NEW.dns_value IS NULL AND NEW.dns_value_record_id IS NULL ) THEN
		RAISE EXCEPTION 'Attempt to set % record without a value',
			NEW.dns_type
			USING ERRCODE = 'not_null_violation';
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_non_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_non_a_rec_validation();

-- considering NEW jazzhands.dns_rec_prevent_dups
CREATE OR REPLACE FUNCTION jazzhands.dns_rec_prevent_dups()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	-- should not be able to insert the same record(s) twice
	WITH newref AS (
		SELECT * FROM dns_record
			WHERE NEW.reference_dns_record_id IS NOT NULL
			AND NEW.reference_dns_record_id = dns_record_id
			ORDER BY dns_record_id LIMIT 1
	), dns AS ( SELECT
			db.dns_record_id,
			coalesce(ref.dns_name, db.dns_name) as dns_name,
			db.dns_domain_id, db.dns_ttl,
			db.dns_class, db.dns_type,
			coalesce(val.dns_value, db.dns_value) AS dns_value,
			db.dns_priority, db.dns_srv_service, db.dns_srv_protocol,
			db.dns_srv_weight, db.dns_srv_port, db.ip_universe_id,
			coalesce(val.netblock_id, db.netblock_id) AS netblock_id,
			db.reference_dns_record_id, db.dns_value_record_id,
			db.should_generate_ptr, db.is_enabled
		FROM dns_record db
			LEFT JOIN dns_record ref
				ON ( db.reference_dns_record_id = ref.dns_record_id)
			LEFT JOIN dns_record val
				ON ( db.dns_value_record_id = val.dns_record_id )
			LEFT JOIN newref
				ON newref.dns_record_id = NEW.reference_dns_record_id
		WHERE db.dns_record_id != NEW.dns_record_id
		AND (lower(coalesce(ref.dns_name, db.dns_name))
					IS NOT DISTINCT FROM
				lower(coalesce(newref.dns_name, NEW.dns_name)) )
		AND ( db.dns_domain_id = NEW.dns_domain_id )
		AND ( db.dns_class = NEW.dns_class )
		AND ( db.dns_type = NEW.dns_type )
    	AND db.dns_record_id != NEW.dns_record_id
		AND db.dns_srv_service IS NOT DISTINCT FROM NEW.dns_srv_service
		AND db.dns_srv_protocol IS NOT DISTINCT FROM NEW.dns_srv_protocol
		AND db.dns_srv_port IS NOT DISTINCT FROM NEW.dns_srv_port
		AND db.ip_universe_id IS NOT DISTINCT FROM NEW.ip_universe_id
		AND db.is_enabled = true
	) SELECT	count(*)
		INTO	_tally
		FROM dns
			LEFT JOIN dns_record val
				ON ( NEW.dns_value_record_id = val.dns_record_id )
		WHERE
			dns.dns_value IS NOT DISTINCT FROM
				coalesce(val.dns_value, NEW.dns_value)
		AND
			dns.netblock_id IS NOT DISTINCT FROM
				coalesce(val.netblock_id, NEW.netblock_id)
	;

	IF _tally != 0 THEN
		RAISE EXCEPTION 'Attempt to insert the same dns record - % %', _tally,
			NEW USING ERRCODE = 'unique_violation';
	END IF;

	IF NEW.DNS_TYPE = 'A' OR NEW.DNS_TYPE = 'AAAA' THEN
		IF NEW.SHOULD_GENERATE_PTR = true THEN
			SELECT	count(*)
			 INTO	_tally
			 FROM	dns_record
			WHERE dns_class = 'IN'
			AND dns_type = 'A'
			AND should_generate_ptr = true
			AND is_enabled = true
			AND netblock_id = NEW.NETBLOCK_ID
			AND dns_record_id != NEW.DNS_RECORD_ID;

			IF _tally != 0 THEN
				RAISE EXCEPTION 'May not have more than one SHOULD_GENERATE_PTR record on the same IP on netblock_id %', NEW.netblock_id
					USING ERRCODE = 'JH201';
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_rec_prevent_dups BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_rec_prevent_dups();

-- considering NEW jazzhands.dns_record_check_name
CREATE OR REPLACE FUNCTION jazzhands.dns_record_check_name()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.DNS_NAME IS NOT NULL THEN
		-- rfc rfc952
		IF NEW.DNS_NAME ~ '[^-a-zA-Z0-9\._\*]+' THEN
			RAISE EXCEPTION 'Invalid DNS NAME %',
				NEW.DNS_NAME
				USING ERRCODE = 'integrity_constraint_violation';
		END IF;

		-- PTRs on wildcard records break thing and make no sense.
		IF NEW.DNS_NAME ~ '\*' AND NEW.SHOULD_GENERATE_PTR = true THEN
			RAISE EXCEPTION 'Wildcard DNS Record % can not have auto-set PTR',
				NEW.DNS_NAME
				USING ERRCODE = 'integrity_constraint_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_record_check_name BEFORE INSERT OR UPDATE OF dns_name, should_generate_ptr ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_check_name();

-- considering NEW jazzhands.dns_record_cname_checker
CREATE OR REPLACE FUNCTION jazzhands.dns_record_cname_checker()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
	_dom	TEXT;
BEGIN
	--- XXX - need to seriously think about ip_universes here.
	_tally := 0;
	IF TG_OP = 'INSERT' OR NEW.DNS_TYPE != OLD.DNS_TYPE THEN
		IF NEW.DNS_TYPE = 'CNAME' THEN
			IF TG_OP = 'UPDATE' THEN
			SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE
						NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	OLD.dns_record_id != x.dns_record_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			ELSE
				-- only difference between above and this is the use of OLD
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE
						NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			END IF;
		-- this clause is basically the same as above except = 'CNAME'
		ELSIF NEW.DNS_TYPE != 'CNAME' THEN
			IF TG_OP = 'UPDATE' THEN
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE	x.dns_type = 'CNAME'
				 AND	NEW.dns_domain_id = x.dns_domain_id
				 AND	OLD.dns_record_id != x.dns_record_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			ELSE
				-- only difference between above and this is the use of OLD
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE	x.dns_type = 'CNAME'
				 AND	NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			END IF;
		END IF;
	END IF;

	IF _tally > 0 THEN
		SELECT dns_domain_name INTO _dom FROM dns_domain
		WHERE dns_domain_id = NEW.dns_domain_id ;

		if NEW.dns_name IS NULL THEN
			RAISE EXCEPTION '% may not have CNAME and other records (%)',
				_dom, _tally
				USING ERRCODE = 'unique_violation';
		ELSE
			RAISE EXCEPTION '%.% may not have CNAME and other records (%)',
				NEW.dns_name, _dom, _tally
				USING ERRCODE = 'unique_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_record_cname_checker BEFORE INSERT OR UPDATE OF dns_type ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_cname_checker();

-- considering NEW jazzhands.dns_record_enabled_check
CREATE OR REPLACE FUNCTION jazzhands.dns_record_enabled_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF new.IS_ENABLED = false THEN
		PERFORM *
		FROM dns_record
		WHERE dns_value_record_id = NEW.dns_record_id
		OR reference_dns_record_id = NEW.dns_record_id;

		IF FOUND THEN
			RAISE EXCEPTION 'Can not disabled records referred to by other enabled records.'
				USING ERRCODE = 'JH001';
		END IF;
	END IF;

	IF new.IS_ENABLED = true THEN
		PERFORM *
		FROM dns_record
		WHERE ( NEW.dns_value_record_id = dns_record_id
				OR NEW.reference_dns_record_id = dns_record_id
		) AND is_enabled = false;

		IF FOUND THEN
			RAISE EXCEPTION 'Can not enable records referencing disabled records.'
				USING ERRCODE = 'JH001';
		END IF;
	END IF;


	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_record_enabled_check BEFORE INSERT OR UPDATE OF is_enabled ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_enabled_check();

-- considering NEW jazzhands.dns_record_update_nontime
CREATE OR REPLACE FUNCTION jazzhands.dns_record_update_nontime()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_dnsdomainid	DNS_DOMAIN.DNS_DOMAIN_ID%type;
	_ipaddr			NETBLOCK.IP_ADDRESS%type;
	_mkold			boolean;
	_mknew			boolean;
	_mkdom			boolean;
	_mkip			boolean;
BEGIN
	_mkold = false;
	_mkold = false;
	_mknew = true;

	IF TG_OP = 'DELETE' THEN
		_mknew := false;
		_mkold := true;
		_mkdom := true;
		if  OLD.netblock_id is not null  THEN
			_mkip := true;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		_mkold := false;
		_mkdom := true;
		if  NEW.netblock_id is not null  THEN
			_mkip := true;
		END IF;
	ELSIF TG_OP = 'UPDATE' THEN
		IF OLD.DNS_DOMAIN_ID != NEW.DNS_DOMAIN_ID THEN
			_mkold := true;
			_mkip := true;
		END IF;
		_mkdom := true;

		IF OLD.dns_name IS DISTINCT FROM NEW.dns_name THEN
			_mknew := true;
			IF NEW.DNS_TYPE = 'A' OR NEW.DNS_TYPE = 'AAAA' THEN
				IF NEW.SHOULD_GENERATE_PTR = true THEN
					_mkip := true;
				END IF;
			END IF;
		END IF;

		IF OLD.SHOULD_GENERATE_PTR != NEW.SHOULD_GENERATE_PTR THEN
			_mkold := true;
			_mkip := true;
		END IF;

		IF (OLD.netblock_id IS DISTINCT FROM NEW.netblock_id) THEN
			_mkold := true;
			_mknew := true;
			_mkip := true;
		END IF;
	END IF;

	if _mkold THEN
		IF _mkdom THEN
			_dnsdomainid := OLD.dns_domain_id;
		ELSE
			_dnsdomainid := NULL;
		END IF;
		if _mkip and OLD.netblock_id is not NULL THEN
			SELECT	ip_address
			  INTO	_ipaddr
			  FROM	netblock
			 WHERE	netblock_id  = OLD.netblock_id;
		ELSE
			_ipaddr := NULL;
		END IF;
		insert into DNS_CHANGE_RECORD
			(dns_domain_id, ip_address) VALUES (_dnsdomainid, _ipaddr);
	END IF;
	if _mknew THEN
		if _mkdom THEN
			_dnsdomainid := NEW.dns_domain_id;
		ELSE
			_dnsdomainid := NULL;
		END IF;
		if _mkip and NEW.netblock_id is not NULL THEN
			SELECT	ip_address
			  INTO	_ipaddr
			  FROM	netblock
			 WHERE	netblock_id  = NEW.netblock_id;
		ELSE
			_ipaddr := NULL;
		END IF;
		insert into DNS_CHANGE_RECORD
			(dns_domain_id, ip_address) VALUES (_dnsdomainid, _ipaddr);
	END IF;

	--
	-- deal with records pointing to this one.  only values are done because
	-- references are forced by ak to be in the same zone.
	IF TG_OP = 'INSERT' THEN
		INSERT INTO dns_change_record (dns_domain_id)
			SELECT DISTINCT dns_domain_id
			FROM dns_record
			WHERE dns_value_record_id = NEW.dns_record_id
			AND dns_domain_id != NEW.dns_domain_id;
	ELSIF TG_OP = 'UPDATE' THEN
		INSERT INTO dns_change_record (dns_domain_id)
			SELECT DISTINCT dns_domain_id
			FROM dns_record
			WHERE dns_value_record_id = NEW.dns_record_id
			AND dns_domain_id NOT IN (OLD.dns_domain_id, NEW.dns_domain_id);
	END IF;

	IF TG_OP = 'DELETE' THEN
		return OLD;
	END IF;
	return NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_record_update_nontime AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_update_nontime();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('dns_record');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('dns_record');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for dns_record  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'dns_record');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'dns_record');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'dns_record');
ALTER SEQUENCE jazzhands.dns_record_dns_record_id_seq
	 OWNED BY dns_record.dns_record_id;
DROP TABLE IF EXISTS dns_record_v89;
DROP TABLE IF EXISTS jazzhands_audit.dns_record_v89;
-- DONE DEALING WITH TABLE dns_record (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old dns_record failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('dns_record');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new dns_record failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE layer3_interface_netblock
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'layer3_interface_netblock', 'layer3_interface_netblock');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS fk_netint_nb_nblk_id;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS fk_netint_nb_netint_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'layer3_interface_netblock', newobject := 'layer3_interface_netblock', newmap := '{"ak_netint_nblk_nblk_id":{"columns":["netblock_id"],"def":"UNIQUE (netblock_id)","deferrable":false,"deferred":false,"name":"ak_netint_nblk_nblk_id","type":"u"},"ak_network_interface_nblk_ni_rank":{"columns":["layer3_interface_id","layer3_interface_rank"],"def":"UNIQUE (layer3_interface_id, layer3_interface_rank) DEFERRABLE","deferrable":true,"deferred":false,"name":"ak_network_interface_nblk_ni_rank","type":"u"},"pk_network_interface_netblock":{"columns":["netblock_id","layer3_interface_id","device_id"],"def":"PRIMARY KEY (netblock_id, layer3_interface_id, device_id)","deferrable":false,"deferred":false,"name":"pk_network_interface_netblock","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS ak_netint_nblk_nblk_id;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS ak_network_interface_nblk_ni_rank;
ALTER TABLE jazzhands.layer3_interface_netblock DROP CONSTRAINT IF EXISTS pk_network_interface_netblock;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif_netint_nb_nblk_id";
DROP INDEX IF EXISTS "jazzhands"."xif_netint_nb_netint_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_netblock ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_netblock ON jazzhands.layer3_interface_netblock;
DROP FUNCTION IF EXISTS perform_audit_layer3_interface_netblock();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_after ON jazzhands.layer3_interface_netblock;
DROP TRIGGER IF EXISTS trigger_net_int_nb_single_address ON jazzhands.layer3_interface_netblock;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'layer3_interface_netblock', tags := ARRAY['table_layer3_interface_netblock']);
---- BEGIN jazzhands_audit.layer3_interface_netblock TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'layer3_interface_netblock', tags := ARRAY['table_layer3_interface_netblock']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'layer3_interface_netblock', 'layer3_interface_netblock');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'layer3_interface_netblock');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.layer3_interface_netblock DROP CONSTRAINT IF EXISTS layer3_interface_netblock_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_ak_netint_nblk_nblk_id";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_ak_network_interface_nblk_ni_rank";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_netblock_pk_network_interface_netblock";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_netblock_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.layer3_interface_netblock TEARDOWN


ALTER TABLE layer3_interface_netblock RENAME TO layer3_interface_netblock_v89;
ALTER TABLE jazzhands_audit.layer3_interface_netblock RENAME TO layer3_interface_netblock_v89;

CREATE TABLE jazzhands.layer3_interface_netblock
(
	netblock_id	integer NOT NULL,
	layer3_interface_id	integer NOT NULL,
	device_id	integer NOT NULL,
	layer3_interface_rank	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock', false);
ALTER TABLE layer3_interface_netblock
	ALTER layer3_interface_rank
	SET DEFAULT 0;


-- BEGIN Manually written insert function
INSERT INTO layer3_interface_netblock (
        netblock_id,
        layer3_interface_id,
        device_id,
        layer3_interface_rank,          -- new column (layer3_interface_rank)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        netblock_id,
        layer3_interface_id,
        device_id,
        network_interface_rank,              -- new column (layer3_interface_rank)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM layer3_interface_netblock_v89;


INSERT INTO jazzhands_audit.layer3_interface_netblock (
        netblock_id,
        layer3_interface_id,
        device_id,
        layer3_interface_rank,          -- new column (layer3_interface_rank)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        netblock_id,
        layer3_interface_id,
        device_id,
        network_interface_rank,           -- new column (layer3_interface_rank)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.layer3_interface_netblock_v89;


-- END Manually written insert function
ALTER TABLE jazzhands.layer3_interface_netblock
	ALTER layer3_interface_rank
	SET DEFAULT 0;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT ak_netint_nblk_nblk_id UNIQUE (netblock_id);
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT ak_network_interface_nblk_ni_rank UNIQUE (layer3_interface_id, layer3_interface_rank) DEFERRABLE;
ALTER TABLE jazzhands.layer3_interface_netblock ADD CONSTRAINT pk_network_interface_netblock PRIMARY KEY (netblock_id, layer3_interface_id, device_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.layer3_interface_netblock.layer3_interface_rank IS 'specifies the order of priority for the ip address.  generally only the highest priority matters (or highest priority v4 and v6) and is the "primary" if the underlying device supports it.';
-- INDEXES
CREATE INDEX xif_netint_nb_nblk_id ON jazzhands.layer3_interface_netblock USING btree (layer3_interface_id, device_id);
CREATE UNIQUE INDEX xif_netint_nb_netint_id ON jazzhands.layer3_interface_netblock USING btree (netblock_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK layer3_interface_netblock and layer3_interface
ALTER TABLE jazzhands.layer3_interface_netblock
	ADD CONSTRAINT fk_netint_nb_nblk_id
	FOREIGN KEY (layer3_interface_id, device_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id, device_id) DEFERRABLE;
-- consider FK layer3_interface_netblock and netblock
ALTER TABLE jazzhands.layer3_interface_netblock
	ADD CONSTRAINT fk_netint_nb_netint_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.net_int_nb_device_id_ins
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_device_id_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	SET CONSTRAINTS fk_netint_nb_nblk_id DEFERRED;
	IF NEW.device_id IS NULL OR TG_OP = 'UPDATE' THEN
		SELECT device_id
		INTO	NEW.device_id
		FROM	layer3_interface
		WHERE	layer3_interface_id = NEW.layer3_interface_id;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_net_int_nb_device_id_ins BEFORE INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins();

-- considering NEW jazzhands.net_int_nb_device_id_ins_after
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_device_id_ins_after()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	SET CONSTRAINTS fk_netint_nb_nblk_id IMMEDIATE;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_after AFTER INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins_after();

-- considering NEW jazzhands.net_int_nb_single_address
CREATE OR REPLACE FUNCTION jazzhands.net_int_nb_single_address()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	IF NEW.netblock_id IS NOT NULL THEN
		select count(*)
		INTO _tally
		FROM netblock
		WHERE netblock_id = NEW.netblock_id
		AND is_single_address = true
		AND netblock_type = 'default';

		IF _tally = 0 THEN
			RAISE EXCEPTION 'network interfaces must refer to single ip addresses of type default (%,%)', NEW.layer3_interface_id, NEW.netblock_id
				USING errcode = 'foreign_key_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_net_int_nb_single_address BEFORE INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_single_address();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_interface_netblock');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('layer3_interface_netblock');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_interface_netblock  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_interface_netblock');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_interface_netblock');
DROP TABLE IF EXISTS layer3_interface_netblock_v89;
DROP TABLE IF EXISTS jazzhands_audit.layer3_interface_netblock_v89;
-- DONE DEALING WITH TABLE layer3_interface_netblock (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_interface_netblock failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_interface_netblock failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE layer3_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'layer3_interface_purpose', 'layer3_interface_purpose');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.layer3_interface_purpose DROP CONSTRAINT IF EXISTS fk_netint_purp_dev_ni_id;
ALTER TABLE jazzhands.layer3_interface_purpose DROP CONSTRAINT IF EXISTS fk_netint_purpose_device_id;
ALTER TABLE jazzhands.layer3_interface_purpose DROP CONSTRAINT IF EXISTS fk_netint_purpose_val_netint_purp;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'layer3_interface_purpose', newobject := 'layer3_interface_purpose', newmap := '{"pk_network_int_purpose":{"columns":["device_id","layer3_interface_purpose"],"def":"PRIMARY KEY (device_id, layer3_interface_purpose)","deferrable":false,"deferred":false,"name":"pk_network_int_purpose","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_purpose DROP CONSTRAINT IF EXISTS pk_network_int_purpose;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifnetint_purp_dev_ni_id";
DROP INDEX IF EXISTS "jazzhands"."xifnetint_purpose_device_id";
DROP INDEX IF EXISTS "jazzhands"."xifnetint_purpose_val_netint_p";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_purpose ON jazzhands.layer3_interface_purpose;
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_purpose ON jazzhands.layer3_interface_purpose;
DROP FUNCTION IF EXISTS perform_audit_layer3_interface_purpose();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'layer3_interface_purpose', tags := ARRAY['table_layer3_interface_purpose']);
---- BEGIN jazzhands_audit.layer3_interface_purpose TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'layer3_interface_purpose', tags := ARRAY['table_layer3_interface_purpose']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'layer3_interface_purpose', 'layer3_interface_purpose');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'layer3_interface_purpose');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.layer3_interface_purpose DROP CONSTRAINT IF EXISTS layer3_interface_purpose_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_interface_purpose_pk_network_int_purpose";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_purpose_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_purpose_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_interface_purpose_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.layer3_interface_purpose TEARDOWN


ALTER TABLE layer3_interface_purpose RENAME TO layer3_interface_purpose_v89;
ALTER TABLE jazzhands_audit.layer3_interface_purpose RENAME TO layer3_interface_purpose_v89;

CREATE TABLE jazzhands.layer3_interface_purpose
(
	device_id	integer NOT NULL,
	layer3_interface_purpose	varchar(50) NOT NULL,
	layer3_interface_id	integer  NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_interface_purpose', false);


-- BEGIN Manually written insert function
INSERT INTO layer3_interface_purpose (
        device_id,
        layer3_interface_purpose,               -- new column (layer3_interface_purpose)
        layer3_interface_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        device_id,
        network_interface_purpose,           -- new column (layer3_interface_purpose)
        layer3_interface_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM layer3_interface_purpose_v89;


INSERT INTO jazzhands_audit.layer3_interface_purpose (
        device_id,
        layer3_interface_purpose,               -- new column (layer3_interface_purpose)
        layer3_interface_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        device_id,
        network_interface_purpose,           -- new column (layer3_interface_purpose)
        layer3_interface_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.layer3_interface_purpose_v89;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_interface_purpose ADD CONSTRAINT pk_network_int_purpose PRIMARY KEY (device_id, layer3_interface_purpose);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifnetint_purp_dev_ni_id ON jazzhands.layer3_interface_purpose USING btree (layer3_interface_id, device_id);
CREATE INDEX xifnetint_purpose_device_id ON jazzhands.layer3_interface_purpose USING btree (device_id);
CREATE INDEX xifnetint_purpose_val_netint_p ON jazzhands.layer3_interface_purpose USING btree (layer3_interface_purpose);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK layer3_interface_purpose and layer3_interface
ALTER TABLE jazzhands.layer3_interface_purpose
	ADD CONSTRAINT fk_netint_purp_dev_ni_id
	FOREIGN KEY (layer3_interface_id, device_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id, device_id) DEFERRABLE;
-- consider FK layer3_interface_purpose and device
ALTER TABLE jazzhands.layer3_interface_purpose
	ADD CONSTRAINT fk_netint_purpose_device_id
	FOREIGN KEY (device_id) REFERENCES jazzhands.device(device_id) DEFERRABLE;
-- consider FK layer3_interface_purpose and val_layer3_interface_purpose
ALTER TABLE jazzhands.layer3_interface_purpose
	ADD CONSTRAINT fk_netint_purpose_val_netint_purp
	FOREIGN KEY (layer3_interface_purpose) REFERENCES jazzhands.val_layer3_interface_purpose(layer3_interface_purpose);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('layer3_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_interface_purpose');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_interface_purpose');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_interface_purpose');
DROP TABLE IF EXISTS layer3_interface_purpose_v89;
DROP TABLE IF EXISTS jazzhands_audit.layer3_interface_purpose_v89;
-- DONE DEALING WITH TABLE layer3_interface_purpose (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_interface_purpose failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE network_service
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'network_service', 'network_service');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_csvcenv;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_device_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_dnsid_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_netint_id;
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS fk_netsvc_netsvctyp_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'network_service', newobject := 'network_service', newmap := '{"pk_service":{"columns":["network_service_id"],"def":"PRIMARY KEY (network_service_id)","deferrable":false,"deferred":false,"name":"pk_service","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.network_service DROP CONSTRAINT IF EXISTS pk_service;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_ismonitored";
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_netsvctype";
DROP INDEX IF EXISTS "jazzhands"."idx_netsvc_svcenv";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_dnsidrecid";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_netdevid";
DROP INDEX IF EXISTS "jazzhands"."ix_netsvc_netintid";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_network_service ON jazzhands.network_service;
DROP TRIGGER IF EXISTS trigger_audit_network_service ON jazzhands.network_service;
DROP FUNCTION IF EXISTS perform_audit_network_service();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'network_service', tags := ARRAY['table_network_service']);
---- BEGIN jazzhands_audit.network_service TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'network_service', tags := ARRAY['table_network_service']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'network_service', 'network_service');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'network_service');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.network_service DROP CONSTRAINT IF EXISTS network_service_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_network_service_pk_service";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."network_service_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.network_service TEARDOWN


ALTER TABLE network_service RENAME TO network_service_v89;
ALTER TABLE jazzhands_audit.network_service RENAME TO network_service_v89;

CREATE TABLE jazzhands.network_service
(
	network_service_id	integer NOT NULL,
	name	varchar(255)  NULL,
	description	varchar(255)  NULL,
	network_service_type	varchar(50) NOT NULL,
	is_monitored	boolean NOT NULL,
	device_id	integer  NULL,
	layer3_interface_id	integer  NULL,
	dns_record_id	integer  NULL,
	service_environment_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'network_service', false);
ALTER TABLE network_service
	ALTER network_service_id
	SET DEFAULT nextval('jazzhands.network_service_network_service_id_seq'::regclass);


-- BEGIN Manually written insert function
INSERT INTO network_service (
        network_service_id,
        name,
        description,
        network_service_type,
        is_monitored,
        device_id,
        layer3_interface_id,            -- new column (layer3_interface_id)
        dns_record_id,
        service_environment_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        network_service_id,
        name,
        description,
        network_service_type,
        is_monitored,
        device_id,
        network_interface_id,           -- new column (layer3_interface_id)
        dns_record_id,
        service_environment_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM network_service_v89;


INSERT INTO jazzhands_audit.network_service (
        network_service_id,
        name,
        description,
        network_service_type,
        is_monitored,
        device_id,
        layer3_interface_id,            -- new column (layer3_interface_id)
        dns_record_id,
        service_environment_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        network_service_id,
        name,
        description,
        network_service_type,
        is_monitored,
        device_id,
        network_interface_id,           -- new column (layer3_interface_id)
        dns_record_id,
        service_environment_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.network_service_v89;


-- END Manually written insert function
ALTER TABLE jazzhands.network_service
	ALTER network_service_id
	SET DEFAULT nextval('jazzhands.network_service_network_service_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.network_service ADD CONSTRAINT pk_service PRIMARY KEY (network_service_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX idx_netsvc_ismonitored ON jazzhands.network_service USING btree (is_monitored);
CREATE INDEX idx_netsvc_netsvctype ON jazzhands.network_service USING btree (network_service_type);
CREATE INDEX idx_netsvc_svcenv ON jazzhands.network_service USING btree (service_environment_id);
CREATE INDEX ix_netsvc_dnsidrecid ON jazzhands.network_service USING btree (dns_record_id);
CREATE INDEX ix_netsvc_netdevid ON jazzhands.network_service USING btree (device_id);
CREATE INDEX ix_netsvc_netintid ON jazzhands.network_service USING btree (layer3_interface_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK network_service and service_environment
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_csvcenv
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK network_service and device
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_device_id
	FOREIGN KEY (device_id) REFERENCES jazzhands.device(device_id);
-- consider FK network_service and dns_record
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_dnsid_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id);
-- consider FK network_service and layer3_interface
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_netint_id
	FOREIGN KEY (layer3_interface_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id);
-- consider FK network_service and val_network_service_type
ALTER TABLE jazzhands.network_service
	ADD CONSTRAINT fk_netsvc_netsvctyp_id
	FOREIGN KEY (network_service_type) REFERENCES jazzhands.val_network_service_type(network_service_type);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('network_service');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('network_service');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_service  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'network_service');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'network_service');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'network_service');
ALTER SEQUENCE jazzhands.network_service_network_service_id_seq
	 OWNED BY network_service.network_service_id;
DROP TABLE IF EXISTS network_service_v89;
DROP TABLE IF EXISTS jazzhands_audit.network_service_v89;
-- DONE DEALING WITH TABLE network_service (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_service failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_service failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'property', 'property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_compcoll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_l2_netcollid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_l3_netcoll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_net_range_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_os_snapshot;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_pv_devcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_svc_env_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_prop_x509_crt_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acct_col;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acctid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_acctrealmid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_compid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_devcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_dns_dom_collect;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_nblk_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_nmtyp;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_osid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_person_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_prop_coll_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pv_nblkcol_id;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_acct_colid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_pwdtyp;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_swpkgid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_pval_tokcolid;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_site_code;
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS fk_property_val_prsnid;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'property', newobject := 'property', newmap := '{"pk_property":{"columns":["property_id"],"def":"PRIMARY KEY (property_id)","deferrable":false,"deferred":false,"name":"pk_property","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.property DROP CONSTRAINT IF EXISTS pk_property;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif30property";
DROP INDEX IF EXISTS "jazzhands"."xif31property";
DROP INDEX IF EXISTS "jazzhands"."xif32property";
DROP INDEX IF EXISTS "jazzhands"."xif33property";
DROP INDEX IF EXISTS "jazzhands"."xif34property";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_compcoll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_os_snapshot";
DROP INDEX IF EXISTS "jazzhands"."xif_prop_pv_devcolid";
DROP INDEX IF EXISTS "jazzhands"."xif_property_acctrealmid";
DROP INDEX IF EXISTS "jazzhands"."xif_property_dns_dom_collect";
DROP INDEX IF EXISTS "jazzhands"."xif_property_nblk_coll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_person_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_prop_coll_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_pv_nblkcol_id";
DROP INDEX IF EXISTS "jazzhands"."xif_property_val_prsnid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_account_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_acctcol_id";
DROP INDEX IF EXISTS "jazzhands"."xifprop_compid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_devcolid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_nmtyp";
DROP INDEX IF EXISTS "jazzhands"."xifprop_osid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_acct_colid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_pwdtyp";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_swpkgid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_pval_tokcolid";
DROP INDEX IF EXISTS "jazzhands"."xifprop_site_code";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_property ON jazzhands.property;
DROP TRIGGER IF EXISTS trigger_audit_property ON jazzhands.property;
DROP FUNCTION IF EXISTS perform_audit_property();
DROP TRIGGER IF EXISTS trigger_validate_property ON jazzhands.property;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'property', tags := ARRAY['table_property']);
---- BEGIN jazzhands_audit.property TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'property', tags := ARRAY['table_property']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'property', 'property');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'property');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.property DROP CONSTRAINT IF EXISTS property_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_property_pk_property";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."property_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.property TEARDOWN


ALTER TABLE property RENAME TO property_v89;
ALTER TABLE jazzhands_audit.property RENAME TO property_v89;

CREATE TABLE jazzhands.property
(
	property_id	integer NOT NULL,
	account_collection_id	integer  NULL,
	account_id	integer  NULL,
	account_realm_id	integer  NULL,
	company_collection_id	integer  NULL,
	company_id	integer  NULL,
	device_collection_id	integer  NULL,
	dns_domain_collection_id	integer  NULL,
	layer2_network_collection_id	integer  NULL,
	layer3_network_collection_id	integer  NULL,
	netblock_collection_id	integer  NULL,
	network_range_id	integer  NULL,
	operating_system_id	integer  NULL,
	operating_system_snapshot_id	integer  NULL,
	property_name_collection_id	integer  NULL,
	service_environment_collection_id	integer  NULL,
	site_code	varchar(50)  NULL,
	x509_signed_certificate_id	integer  NULL,
	property_name	varchar(255) NOT NULL,
	property_type	varchar(50) NOT NULL,
	property_value	varchar(1024)  NULL,
	property_value_account_collection_id	integer  NULL,
	property_value_boolean	boolean  NULL,
	property_value_device_collection_id	integer  NULL,
	property_value_encryption_key_id	integer  NULL,
	property_value_json	jsonb  NULL,
	property_value_netblock_collection_id	integer  NULL,
	property_value_password_type	varchar(50)  NULL,
	property_value_private_key_id	integer  NULL,
	property_value_sw_package_id	integer  NULL,
	property_value_timestamp	timestamp without time zone  NULL,
	property_value_token_collection_id	integer  NULL,
	property_rank	integer  NULL,
	start_date	timestamp without time zone  NULL,
	finish_date	timestamp without time zone  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'property', false);
ALTER TABLE property
	ALTER property_id
	SET DEFAULT nextval('jazzhands.property_property_id_seq'::regclass);
ALTER TABLE property
	ALTER is_enabled
	SET DEFAULT true;


-- BEGIN Manually written insert function
INSERT INTO property (
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,		-- new column (property_value_encryption_key_id)
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,		-- new column (property_value_private_key_id)
	property_value_sw_package_id,
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	p.property_id,
	p.account_collection_id,
	p.account_id,
	p.account_realm_id,
	p.company_collection_id,
	p.company_id,
	p.device_collection_id,
	p.dns_domain_collection_id,
	p.layer2_network_collection_id,
	p.layer3_network_collection_id,
	p.netblock_collection_id,
	p.network_range_id,
	p.operating_system_id,
	p.operating_system_snapshot_id,
	p.property_name_collection_id,
	p.service_environment_collection_id,
	p.site_code,
	p.x509_signed_certificate_id,
	p.property_name,
	p.property_type,
	CASE WHEN vp.property_data_type = 'boolean' THEN NULL
		ELSE p.property_value END,
	p.property_value_account_collection_id,
	coalesce(p.property_value_boolean,
		CASE WHEN vp.property_data_type = 'boolean' THEN
			CASE WHEN p.property_value = 'Y' THEN true
			ELSE false 
			END
		ELSE p.property_value_boolean END
	),
	p.property_value_device_collection_id,
	NULL,		-- new column (property_value_encryption_key_id)
	p.property_value_json,
	p.property_value_netblock_collection_id,
	p.property_value_password_type,
	NULL,		-- new column (property_value_private_key_id)
	p.property_value_sw_package_id,
	p.property_value_timestamp,
	p.property_value_token_collection_id,
	p.property_rank,
	p.start_date,
	p.finish_date,
	p.is_enabled,
	p.data_ins_user,
	p.data_ins_date,
	p.data_upd_user,
	p.data_upd_date
FROM property_v89 p
	LEFT JOIN val_property vp USING (property_name, property_type);


INSERT INTO jazzhands_audit.property (
	property_id,
	account_collection_id,
	account_id,
	account_realm_id,
	company_collection_id,
	company_id,
	device_collection_id,
	dns_domain_collection_id,
	layer2_network_collection_id,
	layer3_network_collection_id,
	netblock_collection_id,
	network_range_id,
	operating_system_id,
	operating_system_snapshot_id,
	property_name_collection_id,
	service_environment_collection_id,
	site_code,
	x509_signed_certificate_id,
	property_name,
	property_type,
	property_value,
	property_value_account_collection_id,
	property_value_boolean,
	property_value_device_collection_id,
	property_value_encryption_key_id,		-- new column (property_value_encryption_key_id)
	property_value_json,
	property_value_netblock_collection_id,
	property_value_password_type,
	property_value_private_key_id,		-- new column (property_value_private_key_id)
	property_value_sw_package_id,
	property_value_timestamp,
	property_value_token_collection_id,
	property_rank,
	start_date,
	finish_date,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	p.property_id,
	p.account_collection_id,
	p.account_id,
	p.account_realm_id,
	p.company_collection_id,
	p.company_id,
	p.device_collection_id,
	p.dns_domain_collection_id,
	p.layer2_network_collection_id,
	p.layer3_network_collection_id,
	p.netblock_collection_id,
	p.network_range_id,
	p.operating_system_id,
	p.operating_system_snapshot_id,
	p.property_name_collection_id,
	p.service_environment_collection_id,
	p.site_code,
	p.x509_signed_certificate_id,
	p.property_name,
	p.property_type,
	CASE WHEN vp.property_data_type = 'boolean' THEN NULL
		ELSE p.property_value END,
	p.property_value_account_collection_id,
	coalesce(p.property_value_boolean,
		CASE WHEN vp.property_data_type = 'boolean' THEN
			CASE WHEN p.property_value = 'Y' THEN true
			ELSE false 
			END
		ELSE p.property_value_boolean END
	),
	p.property_value_device_collection_id,
	NULL,		-- new column (property_value_encryption_key_id)
	p.property_value_json,
	p.property_value_netblock_collection_id,
	p.property_value_password_type,
	NULL,		-- new column (property_value_private_key_id)
	p.property_value_sw_package_id,
	p.property_value_timestamp,
	p.property_value_token_collection_id,
	p.property_rank,
	p.start_date,
	p.finish_date,
	p.is_enabled,
	p.data_ins_user,
	p.data_ins_date,
	p.data_upd_user,
	p.data_upd_date,
	p."aud#action",
	p."aud#timestamp",
	p."aud#realtime",
	p."aud#txid",
	p."aud#user",
	p."aud#seq"
FROM jazzhands_audit.property_v89 p
	LEFT JOIN val_property vp USING (property_name, property_type);


-- END Manually written insert function
ALTER TABLE jazzhands.property
	ALTER property_id
	SET DEFAULT nextval('jazzhands.property_property_id_seq'::regclass);
ALTER TABLE jazzhands.property
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.property ADD CONSTRAINT pk_property PRIMARY KEY (property_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.property IS 'generic mechanism to create arbitrary associations between lhs database objects and assign them to zero or one other database objects/strings/lists/etc.  They are trigger enforced based on characteristics in val_property and val_property_value where foreign key enforcement does not work.';
COMMENT ON COLUMN jazzhands.property.property_id IS 'primary key for table to uniquely identify rows.';
COMMENT ON COLUMN jazzhands.property.account_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.account_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.account_realm_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.company_id IS 'LHS settable based on val_property.  THIS COLUMN IS DEPRECATED AND WILL BE REMOVED >= 0.66';
COMMENT ON COLUMN jazzhands.property.device_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.dns_domain_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.netblock_collection_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.operating_system_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.operating_system_snapshot_id IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.property_name_collection_id IS 'LHS settable based on val_property.  NOTE, this is actually collections of property_name,property_type';
COMMENT ON COLUMN jazzhands.property.site_code IS 'LHS settable based on val_property';
COMMENT ON COLUMN jazzhands.property.x509_signed_certificate_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.property.property_name IS 'textual name of a property';
COMMENT ON COLUMN jazzhands.property.property_type IS 'textual type of a department';
COMMENT ON COLUMN jazzhands.property.property_value IS 'RHS - general purpose column for value of property not defined by other types.  This may be enforced by fk (trigger) if val_property.property_data_type is list (fk is to val_property_value).   permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_account_collection_id IS 'RHS, fk to account_collection,    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_device_collection_id IS 'RHS - fk to device_collection.    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_netblock_collection_id IS 'RHS - fk to network_collection.    permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_password_type IS 'RHS - fk to val_password_type.     permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_private_key_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.property.property_value_sw_package_id IS 'RHS - fk to sw_package.  possibly will be deprecated.     permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_timestamp IS 'RHS - value is a timestamp , permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_value_token_collection_id IS 'RHS - fk to token_collection_id.     permitted based on val_property.property_data_type.';
COMMENT ON COLUMN jazzhands.property.property_rank IS 'for multivalues, specifies the order.  If set, this basically becomes part of the "ak" for the lhs.';
COMMENT ON COLUMN jazzhands.property.start_date IS 'date/time that the assignment takes effect or NULL.  .  The view v_property filters this out.';
COMMENT ON COLUMN jazzhands.property.finish_date IS 'date/time that the assignment ceases taking effect or NULL.  .  The view v_property filters this out.';
COMMENT ON COLUMN jazzhands.property.is_enabled IS 'indiciates if the property is temporarily disabled or not.  The view v_property filters this out.';
-- INDEXES
CREATE INDEX ufprop_network_range_id ON jazzhands.property USING btree (network_range_id);
CREATE INDEX xif_prop_compcoll_id ON jazzhands.property USING btree (company_collection_id);
CREATE INDEX xif_prop_os_snapshot ON jazzhands.property USING btree (operating_system_snapshot_id);
CREATE INDEX xif_prop_pv_devcolid ON jazzhands.property USING btree (property_value_device_collection_id);
CREATE INDEX xif_property_acctrealmid ON jazzhands.property USING btree (account_realm_id);
CREATE INDEX xif_property_dns_dom_collect ON jazzhands.property USING btree (dns_domain_collection_id);
CREATE INDEX xif_property_nblk_coll_id ON jazzhands.property USING btree (netblock_collection_id);
CREATE INDEX xif_property_prop_coll_id ON jazzhands.property USING btree (property_name_collection_id);
CREATE INDEX xif_property_pv_nblkcol_id ON jazzhands.property USING btree (property_value_netblock_collection_id);
CREATE INDEX xifprop_account_id ON jazzhands.property USING btree (account_id);
CREATE INDEX xifprop_acctcol_id ON jazzhands.property USING btree (account_collection_id);
CREATE INDEX xifprop_compid ON jazzhands.property USING btree (company_id);
CREATE INDEX xifprop_devcolid ON jazzhands.property USING btree (device_collection_id);
CREATE INDEX xifprop_l2_netcoll_id ON jazzhands.property USING btree (layer2_network_collection_id);
CREATE INDEX xifprop_l3_netcoll_id ON jazzhands.property USING btree (layer3_network_collection_id);
CREATE INDEX xifprop_nmtyp ON jazzhands.property USING btree (property_name, property_type);
CREATE INDEX xifprop_osid ON jazzhands.property USING btree (operating_system_id);
CREATE INDEX xifprop_pval_acct_colid ON jazzhands.property USING btree (property_value_account_collection_id);
CREATE INDEX xifprop_pval_enc_key_id ON jazzhands.property USING btree (property_value_encryption_key_id);
CREATE INDEX xifprop_pval_private_key_id ON jazzhands.property USING btree (property_value_private_key_id);
CREATE INDEX xifprop_pval_pwdtyp ON jazzhands.property USING btree (property_value_password_type);
CREATE INDEX xifprop_pval_swpkgid ON jazzhands.property USING btree (property_value_sw_package_id);
CREATE INDEX xifprop_pval_tokcolid ON jazzhands.property USING btree (property_value_token_collection_id);
CREATE INDEX xifprop_site_code ON jazzhands.property USING btree (site_code);
CREATE INDEX xifprop_svcenv ON jazzhands.property USING btree (service_environment_collection_id);
CREATE INDEX xifprop_x509_signed_cert_id ON jazzhands.property USING btree (x509_signed_certificate_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK property and company_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_compcoll_id
	FOREIGN KEY (company_collection_id) REFERENCES jazzhands.company_collection(company_collection_id);
-- consider FK property and layer2_network_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_l2_netcollid
	FOREIGN KEY (layer2_network_collection_id) REFERENCES jazzhands.layer2_network_collection(layer2_network_collection_id);
-- consider FK property and layer3_network_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_l3_netcoll_id
	FOREIGN KEY (layer3_network_collection_id) REFERENCES jazzhands.layer3_network_collection(layer3_network_collection_id);
-- consider FK property and network_range
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_net_range_id
	FOREIGN KEY (network_range_id) REFERENCES jazzhands.network_range(network_range_id);
-- consider FK property and operating_system_snapshot
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_os_snapshot
	FOREIGN KEY (operating_system_snapshot_id) REFERENCES jazzhands.operating_system_snapshot(operating_system_snapshot_id);
-- consider FK property and device_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_pv_devcolid
	FOREIGN KEY (property_value_device_collection_id) REFERENCES jazzhands.device_collection(device_collection_id);
-- consider FK property and service_environment_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_svc_env_coll_id
	FOREIGN KEY (service_environment_collection_id) REFERENCES jazzhands.service_environment_collection(service_environment_collection_id);
-- consider FK property and x509_signed_certificate
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_x509_crt_id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK property and account_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acct_col
	FOREIGN KEY (account_collection_id) REFERENCES jazzhands.account_collection(account_collection_id);
-- consider FK property and account
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acctid
	FOREIGN KEY (account_id) REFERENCES jazzhands.account(account_id);
-- consider FK property and account_realm
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_acctrealmid
	FOREIGN KEY (account_realm_id) REFERENCES jazzhands.account_realm(account_realm_id);
-- consider FK property and company
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_compid
	FOREIGN KEY (company_id) REFERENCES jazzhands.company(company_id) DEFERRABLE;
-- consider FK property and device_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_devcolid
	FOREIGN KEY (device_collection_id) REFERENCES jazzhands.device_collection(device_collection_id);
-- consider FK property and dns_domain_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_dns_dom_collect
	FOREIGN KEY (dns_domain_collection_id) REFERENCES jazzhands.dns_domain_collection(dns_domain_collection_id);
-- consider FK property and netblock_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nblk_coll_id
	FOREIGN KEY (netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id);
-- consider FK property and val_property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_nmtyp
	FOREIGN KEY (property_name, property_type) REFERENCES jazzhands.val_property(property_name, property_type);
-- consider FK property and operating_system
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_osid
	FOREIGN KEY (operating_system_id) REFERENCES jazzhands.operating_system(operating_system_id);
-- consider FK property and property_name_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_prop_coll_id
	FOREIGN KEY (property_name_collection_id) REFERENCES jazzhands.property_name_collection(property_name_collection_id);
-- consider FK property and netblock_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pv_nblkcol_id
	FOREIGN KEY (property_value_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id);
-- consider FK property and account_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_acct_colid
	FOREIGN KEY (property_value_account_collection_id) REFERENCES jazzhands.account_collection(account_collection_id);
-- consider FK property and private_key
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_private_key_id
	FOREIGN KEY (property_value_private_key_id) REFERENCES jazzhands.private_key(private_key_id);
-- consider FK property and val_password_type
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_pwdtyp
	FOREIGN KEY (property_value_password_type) REFERENCES jazzhands.val_password_type(password_type);
-- consider FK property and sw_package
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_swpkgid
	FOREIGN KEY (property_value_sw_package_id) REFERENCES jazzhands.sw_package(sw_package_id);
-- consider FK property and token_collection
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_tokcolid
	FOREIGN KEY (property_value_token_collection_id) REFERENCES jazzhands.token_collection(token_collection_id);
-- consider FK property and site
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_site_code
	FOREIGN KEY (site_code) REFERENCES jazzhands.site(site_code);
-- consider FK property and encryption_key
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_val_enc_key
	FOREIGN KEY (property_value_encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- TRIGGERS
-- considering NEW jazzhands.validate_property
CREATE OR REPLACE FUNCTION jazzhands.validate_property()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	RETURN property_utils.validate_property(NEW);
END;
$function$
;
CREATE TRIGGER trigger_validate_property BEFORE INSERT OR UPDATE ON jazzhands.property FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_property();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('property');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'property');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'property');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'property');
ALTER SEQUENCE jazzhands.property_property_id_seq
	 OWNED BY property.property_id;
DROP TABLE IF EXISTS property_v89;
DROP TABLE IF EXISTS jazzhands_audit.property_v89;
-- DONE DEALING WITH TABLE property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE static_route
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'static_route', 'static_route');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.static_route DROP CONSTRAINT IF EXISTS fk_statrt_devsrc_id;
ALTER TABLE jazzhands.static_route DROP CONSTRAINT IF EXISTS fk_statrt_nblk_id;
ALTER TABLE jazzhands.static_route DROP CONSTRAINT IF EXISTS fk_statrt_netintdst_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'static_route', newobject := 'static_route', newmap := '{"pk_static_route_id":{"columns":["static_route_id"],"def":"PRIMARY KEY (static_route_id)","deferrable":false,"deferred":false,"name":"pk_static_route_id","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.static_route DROP CONSTRAINT IF EXISTS pk_static_route_id;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_staticrt_devsrcid";
DROP INDEX IF EXISTS "jazzhands"."idx_staticrt_netblockid";
DROP INDEX IF EXISTS "jazzhands"."idx_staticrt_netintdstid";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_static_route ON jazzhands.static_route;
DROP TRIGGER IF EXISTS trigger_audit_static_route ON jazzhands.static_route;
DROP FUNCTION IF EXISTS perform_audit_static_route();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'static_route', tags := ARRAY['table_static_route']);
---- BEGIN jazzhands_audit.static_route TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'static_route', tags := ARRAY['table_static_route']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'static_route', 'static_route');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'static_route');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.static_route DROP CONSTRAINT IF EXISTS static_route_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_static_route_pk_static_route_id";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.static_route TEARDOWN


ALTER TABLE static_route RENAME TO static_route_v89;
ALTER TABLE jazzhands_audit.static_route RENAME TO static_route_v89;

CREATE TABLE jazzhands.static_route
(
	static_route_id	integer NOT NULL,
	device_source_id	integer NOT NULL,
	layer3_interface_destination_id	integer NOT NULL,
	netblock_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'static_route', false);
ALTER TABLE static_route
	ALTER static_route_id
	SET DEFAULT nextval('jazzhands.static_route_static_route_id_seq'::regclass);


-- BEGIN Manually written insert function
INSERT INTO static_route (
        static_route_id,
        device_source_id,
        layer3_interface_destination_id,                -- new column (layer3_interface_destination_id)
        netblock_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        static_route_id,
        device_source_id,
        network_interface_destination_id,           -- new column (layer3_interface_destination_id)
        netblock_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM static_route_v89;


INSERT INTO jazzhands_audit.static_route (
        static_route_id,
        device_source_id,
        layer3_interface_destination_id,                -- new column (layer3_interface_destination_id)
        netblock_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        static_route_id,
        device_source_id,
        network_interface_destination_id,           -- new column (layer3_interface_destination_id)
        netblock_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.static_route_v89;


-- END Manually written insert function
ALTER TABLE jazzhands.static_route
	ALTER static_route_id
	SET DEFAULT nextval('jazzhands.static_route_static_route_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.static_route ADD CONSTRAINT pk_static_route_id PRIMARY KEY (static_route_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX idx_staticrt_devsrcid ON jazzhands.static_route USING btree (device_source_id);
CREATE INDEX idx_staticrt_netblockid ON jazzhands.static_route USING btree (netblock_id);
CREATE INDEX idx_staticrt_netintdstid ON jazzhands.static_route USING btree (layer3_interface_destination_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK static_route and device
ALTER TABLE jazzhands.static_route
	ADD CONSTRAINT fk_statrt_devsrc_id
	FOREIGN KEY (device_source_id) REFERENCES jazzhands.device(device_id);
-- consider FK static_route and netblock
ALTER TABLE jazzhands.static_route
	ADD CONSTRAINT fk_statrt_nblk_id
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK static_route and layer3_interface
ALTER TABLE jazzhands.static_route
	ADD CONSTRAINT fk_statrt_netintdst_id
	FOREIGN KEY (layer3_interface_destination_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('static_route');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('static_route');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'static_route');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'static_route');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'static_route');
ALTER SEQUENCE jazzhands.static_route_static_route_id_seq
	 OWNED BY static_route.static_route_id;
DROP TABLE IF EXISTS static_route_v89;
DROP TABLE IF EXISTS jazzhands_audit.static_route_v89;
-- DONE DEALING WITH TABLE static_route (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE static_route_template
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'static_route_template', 'static_route_template');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_netblock_st_rt_dst_net;
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_netblock_st_rt_src_net;
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS fk_static_rt_net_interface;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'static_route_template', newobject := 'static_route_template', newmap := '{"pk_static_route_template":{"columns":["static_route_template_id"],"def":"PRIMARY KEY (static_route_template_id)","deferrable":false,"deferred":false,"name":"pk_static_route_template","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.static_route_template DROP CONSTRAINT IF EXISTS pk_static_route_template;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_static_route_template ON jazzhands.static_route_template;
DROP TRIGGER IF EXISTS trigger_audit_static_route_template ON jazzhands.static_route_template;
DROP FUNCTION IF EXISTS perform_audit_static_route_template();
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'static_route_template', tags := ARRAY['table_static_route_template']);
---- BEGIN jazzhands_audit.static_route_template TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'static_route_template', tags := ARRAY['table_static_route_template']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'static_route_template', 'static_route_template');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'static_route_template');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.static_route_template DROP CONSTRAINT IF EXISTS static_route_template_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_static_route_template_pk_static_route_template";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."static_route_template_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
---- DONE jazzhands_audit.static_route_template TEARDOWN


ALTER TABLE static_route_template RENAME TO static_route_template_v89;
ALTER TABLE jazzhands_audit.static_route_template RENAME TO static_route_template_v89;

CREATE TABLE jazzhands.static_route_template
(
	static_route_template_id	integer NOT NULL,
	netblock_source_id	integer NOT NULL,
	layer3_interface_destination_id	integer NOT NULL,
	netblock_id	integer NOT NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'static_route_template', false);
ALTER TABLE static_route_template
	ALTER static_route_template_id
	SET DEFAULT nextval('jazzhands.static_route_template_static_route_template_id_seq'::regclass);


-- BEGIN Manually written insert function
INSERT INTO static_route_template (
        static_route_template_id,
        netblock_source_id,
        layer3_interface_destination_id,                -- new column (layer3_interface_destination_id)
        netblock_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        static_route_template_id,
        netblock_source_id,
        network_interface_destination_id,           -- new column (layer3_interface_destination_id)
        netblock_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM static_route_template_v89;


INSERT INTO jazzhands_audit.static_route_template (
        static_route_template_id,
        netblock_source_id,
        layer3_interface_destination_id,                -- new column (layer3_interface_destination_id)
        netblock_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        static_route_template_id,
        netblock_source_id,
        network_interface_destination_id,           -- new column (layer3_interface_destination_id)
        netblock_id,
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.static_route_template_v89;


-- END Manually written insert function
ALTER TABLE jazzhands.static_route_template
	ALTER static_route_template_id
	SET DEFAULT nextval('jazzhands.static_route_template_static_route_template_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.static_route_template ADD CONSTRAINT pk_static_route_template PRIMARY KEY (static_route_template_id);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK static_route_template and netblock
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_netblock_st_rt_dst_net
	FOREIGN KEY (netblock_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK static_route_template and netblock
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_netblock_st_rt_src_net
	FOREIGN KEY (netblock_source_id) REFERENCES jazzhands.netblock(netblock_id);
-- consider FK static_route_template and layer3_interface
ALTER TABLE jazzhands.static_route_template
	ADD CONSTRAINT fk_static_rt_net_interface
	FOREIGN KEY (layer3_interface_destination_id) REFERENCES jazzhands.layer3_interface(layer3_interface_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('static_route_template');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('static_route_template');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route_template  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'static_route_template');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'static_route_template');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'static_route_template');
ALTER SEQUENCE jazzhands.static_route_template_static_route_template_id_seq
	 OWNED BY static_route_template.static_route_template_id;
DROP TABLE IF EXISTS static_route_template_v89;
DROP TABLE IF EXISTS jazzhands_audit.static_route_template_v89;
-- DONE DEALING WITH TABLE static_route_template (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route_template failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route_template failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE layer1_connection
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'layer1_connection', tags := ARRAY['view_layer1_connection']);
DROP VIEW IF EXISTS jazzhands.layer1_connection;
-- DONE DEALING WITH OLD TABLE layer1_connection (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer1_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer1_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer1_connection failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_changes_pending
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_dns_changes_pending', 'v_dns_changes_pending');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_dns_changes_pending', tags := ARRAY['view_v_dns_changes_pending']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_dns_changes_pending;
CREATE VIEW jazzhands.v_dns_changes_pending AS
 WITH chg AS (
         SELECT dns_change_record.dns_change_record_id,
            dns_change_record.dns_domain_id,
                CASE
                    WHEN family(dns_change_record.ip_address) = 4 THEN set_masklen(dns_change_record.ip_address, 24)
                    ELSE set_masklen(dns_change_record.ip_address, 64)
                END AS ip_address,
            dns_utils.get_domain_from_cidr(dns_change_record.ip_address) AS cidrdns
           FROM jazzhands.dns_change_record
          WHERE dns_change_record.ip_address IS NOT NULL
        )
 SELECT x.dns_change_record_id,
    x.dns_domain_id,
    x.ip_universe_id,
    x.should_generate,
    x.last_generated,
    x.dns_domain_name,
    x.ip_address
   FROM ( SELECT chg.dns_change_record_id,
            n.dns_domain_id,
            du.ip_universe_id,
            du.should_generate,
            du.last_generated,
            n.dns_domain_name,
            chg.ip_address
           FROM chg
             JOIN jazzhands.dns_domain n ON chg.cidrdns = n.dns_domain_name::text
             JOIN jazzhands.dns_domain_ip_universe du ON du.dns_domain_id = n.dns_domain_id
        UNION ALL
         SELECT chg.dns_change_record_id,
            d.dns_domain_id,
            du.ip_universe_id,
            du.should_generate,
            du.last_generated,
            d.dns_domain_name,
            NULL::inet
           FROM jazzhands.dns_change_record chg
             JOIN jazzhands.dns_domain d USING (dns_domain_id)
             JOIN jazzhands.dns_domain_ip_universe du USING (dns_domain_id)
          WHERE chg.dns_domain_id IS NOT NULL AND chg.ip_universe_id IS NULL
        UNION ALL
         SELECT chg.dns_change_record_id,
            d.dns_domain_id,
            chg.ip_universe_id,
            du.should_generate,
            du.last_generated,
            d.dns_domain_name,
            NULL::inet
           FROM jazzhands.dns_change_record chg
             JOIN jazzhands.dns_domain d USING (dns_domain_id)
             JOIN jazzhands.dns_domain_ip_universe du USING (dns_domain_id, ip_universe_id)
          WHERE chg.dns_domain_id IS NOT NULL AND chg.ip_universe_id IS NOT NULL
        UNION ALL
         SELECT chg.dns_change_record_id,
            d.dns_domain_id,
            iv.visible_ip_universe_id,
            du.should_generate,
            du.last_generated,
            d.dns_domain_name,
            NULL::inet
           FROM jazzhands.dns_change_record chg
             JOIN jazzhands.ip_universe_visibility iv USING (ip_universe_id)
             JOIN jazzhands.dns_domain d USING (dns_domain_id)
             JOIN jazzhands.dns_domain_ip_universe du USING (dns_domain_id)
          WHERE chg.dns_domain_id IS NOT NULL AND chg.ip_universe_id IS NOT NULL) x;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_dns_changes_pending','v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_changes_pending','v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_dns_changes_pending');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_changes_pending');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_dns_changes_pending  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_dns_changes_pending (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_domain_nouniverse
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_dns_domain_nouniverse', tags := ARRAY['view_v_dns_domain_nouniverse']);
DROP VIEW IF EXISTS jazzhands.v_dns_domain_nouniverse;
-- DONE DEALING WITH OLD TABLE v_dns_domain_nouniverse (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_domain_nouniverse failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_fwd
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_dns_fwd', 'v_dns_fwd');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_dns_fwd', tags := ARRAY['view_v_dns_fwd']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_dns_fwd;
CREATE VIEW jazzhands.v_dns_fwd AS
 SELECT u.dns_record_id,
    u.network_range_id,
    u.dns_domain_id,
    u.dns_name,
    u.dns_ttl,
    u.dns_class,
    u.dns_type,
    u.dns_value,
    u.dns_priority,
    u.ip,
    u.netblock_id,
    u.ip_universe_id,
    u.ref_record_id,
    u.dns_srv_service,
    u.dns_srv_protocol,
    u.dns_srv_weight,
    u.dns_srv_port,
    u.is_enabled,
    u.should_generate_ptr,
    u.dns_value_record_id
   FROM ( SELECT d.dns_record_id,
            NULL::integer AS network_range_id,
            d.dns_domain_id,
            COALESCE(rdns.dns_name, d.dns_name) AS dns_name,
            d.dns_ttl,
            d.dns_class,
            d.dns_type,
                CASE
                    WHEN d.dns_value IS NOT NULL THEN d.dns_value::text
                    WHEN (d.dns_type::text = ANY (ARRAY['A'::character varying, 'AAAA'::character varying]::text[])) AND d.netblock_id IS NULL AND d.dns_value_record_id IS NOT NULL THEN NULL::text
                    WHEN d.dns_value_record_id IS NULL THEN d.dns_value::text
                    WHEN dv.dns_domain_id = d.dns_domain_id THEN dv.dns_name::text
                    ELSE concat(dv.dns_name, '.', dv.dns_domain_name, '.')
                END AS dns_value,
            d.dns_priority,
                CASE
                    WHEN d.dns_value_record_id IS NOT NULL AND (d.dns_type::text = ANY (ARRAY['A'::character varying, 'AAAA'::character varying]::text[])) THEN dv.ip_address
                    ELSE ni.ip_address
                END AS ip,
                CASE
                    WHEN d.dns_value_record_id IS NOT NULL AND (d.dns_type::text = ANY (ARRAY['A'::character varying, 'AAAA'::character varying]::text[])) THEN dv.netblock_id
                    ELSE ni.netblock_id
                END AS netblock_id,
            d.ip_universe_id,
            rdns.reference_dns_record_id AS ref_record_id,
            d.dns_srv_service,
            d.dns_srv_protocol,
            d.dns_srv_weight,
            d.dns_srv_port,
            d.is_enabled,
            d.should_generate_ptr,
            d.dns_value_record_id
           FROM jazzhands.dns_record d
             LEFT JOIN jazzhands.netblock ni USING (netblock_id)
             LEFT JOIN ( SELECT dns_record.dns_record_id AS reference_dns_record_id,
                    dns_record.dns_name,
                    dns_record.netblock_id,
                    netblock.ip_address
                   FROM jazzhands.dns_record
                     LEFT JOIN jazzhands.netblock USING (netblock_id)) rdns USING (reference_dns_record_id)
             LEFT JOIN ( SELECT dr.dns_record_id,
                    dr.dns_name,
                    dom.dns_domain_id,
                    dom.dns_domain_name,
                    dr.dns_value,
                    dnb.ip_address AS ip,
                    dnb.ip_address,
                    dnb.netblock_id
                   FROM jazzhands.dns_record dr
                     JOIN jazzhands.dns_domain dom USING (dns_domain_id)
                     LEFT JOIN jazzhands.netblock dnb USING (netblock_id)) dv ON d.dns_value_record_id = dv.dns_record_id
        UNION ALL
         SELECT NULL::integer AS dns_record_id,
            range.network_range_id,
            range.dns_domain_id,
            concat(COALESCE(range.dns_prefix, 'pool'::character varying), '-', replace(host(range.ip), '.'::text, '-'::text)) AS dns_name,
            NULL::integer AS dns_ttl,
            'IN'::character varying AS dns_class,
                CASE
                    WHEN family(range.ip) = 4 THEN 'A'::text
                    ELSE 'AAAA'::text
                END AS dns_type,
            NULL::text AS dns_value,
            NULL::integer AS dns_prority,
            range.ip,
            NULL::integer AS netblock_id,
            range.ip_universe_id,
            NULL::integer AS ref_dns_record_id,
            NULL::character varying AS dns_srv_service,
            NULL::character varying AS dns_srv_protocol,
            NULL::integer AS dns_srv_weight,
            NULL::integer AS dns_srv_port,
            true AS is_enabled,
            false AS should_generate_ptr,
            NULL::integer AS dns_value_record_id
           FROM ( SELECT dr.network_range_id,
                    dr.dns_domain_id,
                    nbstart.ip_universe_id,
                    dr.dns_prefix,
                    nbstart.ip_address + generate_series(0::bigint, nbstop.ip_address - nbstart.ip_address) AS ip
                   FROM jazzhands.network_range dr
                     JOIN jazzhands.netblock nbstart ON dr.start_netblock_id = nbstart.netblock_id
                     JOIN jazzhands.netblock nbstop ON dr.stop_netblock_id = nbstop.netblock_id
                  WHERE dr.dns_domain_id IS NOT NULL) range) u
  WHERE u.dns_type::text <> 'REVERSE_ZONE_BLOCK_PTR'::text
UNION ALL
 SELECT NULL::integer AS dns_record_id,
    NULL::integer AS network_range_id,
    dns_domain.parent_dns_domain_id AS dns_domain_id,
    regexp_replace(dns_domain.dns_domain_name::text, ('\.'::text || pdom.parent_dns_domain_name::text) || '$'::text, ''::text) AS dns_name,
    dns_record.dns_ttl,
    dns_record.dns_class,
    dns_record.dns_type,
        CASE
            WHEN dns_record.dns_value::text ~ '\.$'::text THEN dns_record.dns_value::text
            ELSE concat(dns_record.dns_value, '.', dns_domain.dns_domain_name, '.')
        END AS dns_value,
    dns_record.dns_priority,
    NULL::inet AS ip,
    NULL::integer AS netblock_id,
    dns_record.ip_universe_id,
    NULL::integer AS ref_record_id,
    NULL::text AS dns_srv_service,
    NULL::text AS dns_srv_protocol,
    NULL::integer AS dns_srv_weight,
    NULL::integer AS dns_srv_port,
    dns_record.is_enabled,
    false AS should_generate_ptr,
    NULL::integer AS dns_value_record_id
   FROM jazzhands.dns_record
     JOIN jazzhands.dns_domain USING (dns_domain_id)
     JOIN ( SELECT dns_domain_1.dns_domain_id AS parent_dns_domain_id,
            dns_domain_1.dns_domain_name AS parent_dns_domain_name
           FROM jazzhands.dns_domain dns_domain_1) pdom USING (parent_dns_domain_id)
  WHERE dns_record.dns_class::text = 'IN'::text AND dns_record.dns_type::text = 'NS'::text AND dns_record.dns_name IS NULL AND dns_domain.parent_dns_domain_id IS NOT NULL;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_dns_fwd','v_dns_fwd');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_fwd','v_dns_fwd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_dns_fwd failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_dns_fwd');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_fwd');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_dns_fwd  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_dns_fwd (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_fwd');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_fwd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_fwd failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_fwd');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_fwd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_dns_fwd failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_rvs
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_dns_rvs', 'v_dns_rvs');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_dns_rvs', tags := ARRAY['view_v_dns_rvs']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_dns_rvs;
CREATE VIEW jazzhands.v_dns_rvs AS
 SELECT NULL::integer AS dns_record_id,
    combo.network_range_id,
    rootd.dns_domain_id,
        CASE
            WHEN family(combo.ip) = 4 THEN regexp_replace(host(combo.ip), '^.*[.](\d+)$'::text, '\1'::text, 'i'::text)
            ELSE regexp_replace(dns_utils.v6_inaddr(combo.ip), ('.'::text || replace(dd.dns_domain_name::text, '.ip6.arpa'::text, ''::text)) || '$'::text, ''::text, 'i'::text)
        END AS dns_name,
    combo.dns_ttl,
    'IN'::text AS dns_class,
    'PTR'::text AS dns_type,
        CASE
            WHEN combo.dns_name IS NULL THEN concat(combo.dns_domain_name, '.')
            ELSE concat(combo.dns_name, '.', combo.dns_domain_name, '.')
        END AS dns_value,
    NULL::integer AS dns_priority,
    combo.ip,
    combo.netblock_id,
    combo.ip_universe_id,
    NULL::integer AS rdns_record_id,
    NULL::text AS dns_srv_service,
    NULL::text AS dns_srv_protocol,
    NULL::integer AS dns_srv_weight,
    NULL::integer AS dns_srv_srv_port,
    combo.is_enabled,
    false AS should_generate_ptr,
    NULL::integer AS dns_value_record_id
   FROM ( SELECT host(nb.ip_address)::inet AS ip,
            NULL::integer AS network_range_id,
            COALESCE(rdns.dns_name, dns.dns_name) AS dns_name,
            dom.dns_domain_name,
            dns.dns_ttl,
            network(nb.ip_address) AS ip_base,
            nb.ip_universe_id,
            dns.is_enabled,
            false AS should_generate_ptr,
            nb.netblock_id
           FROM jazzhands.netblock nb
             JOIN jazzhands.dns_record dns ON nb.netblock_id = dns.netblock_id
             JOIN jazzhands.dns_domain dom ON dns.dns_domain_id = dom.dns_domain_id
             LEFT JOIN jazzhands.dns_record rdns ON rdns.dns_record_id = dns.reference_dns_record_id
          WHERE dns.should_generate_ptr AND dns.dns_class::text = 'IN'::text AND (dns.dns_type::text = 'A'::text OR dns.dns_type::text = 'AAAA'::text) AND nb.is_single_address
        UNION ALL
         SELECT host(range.ip)::inet AS ip,
            range.network_range_id,
            concat(COALESCE(range.dns_prefix, 'pool'::character varying), '-', replace(host(range.ip), '.'::text, '-'::text)) AS dns_name,
            dom.dns_domain_name,
            NULL::integer AS dns_ttl,
            network(range.ip) AS ip_base,
            range.ip_universe_id,
            true AS is_enabled,
            false AS should_generate_ptr,
            NULL::integer AS netblock_id
           FROM ( SELECT dr.network_range_id,
                    nbstart.ip_universe_id,
                    dr.dns_domain_id,
                    dr.dns_prefix,
                    nbstart.ip_address + generate_series(0::bigint, nbstop.ip_address - nbstart.ip_address) AS ip
                   FROM jazzhands.network_range dr
                     JOIN jazzhands.netblock nbstart ON dr.start_netblock_id = nbstart.netblock_id
                     JOIN jazzhands.netblock nbstop ON dr.stop_netblock_id = nbstop.netblock_id
                  WHERE dr.dns_domain_id IS NOT NULL) range
             JOIN jazzhands.dns_domain dom ON range.dns_domain_id = dom.dns_domain_id) combo,
    jazzhands.netblock root
     JOIN jazzhands.dns_record rootd ON rootd.netblock_id = root.netblock_id AND rootd.dns_type::text = 'REVERSE_ZONE_BLOCK_PTR'::text
     JOIN jazzhands.dns_domain dd USING (dns_domain_id)
  WHERE family(root.ip_address) = family(combo.ip) AND set_masklen(combo.ip, masklen(root.ip_address)) <<= root.ip_address;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_dns_rvs','v_dns_rvs');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_rvs','v_dns_rvs');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_dns_rvs failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_dns_rvs');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_dns_rvs');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_dns_rvs  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_dns_rvs (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_rvs');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_rvs');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_rvs failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_rvs');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_dns_rvs');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_dns_rvs failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_network_range_expanded
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_network_range_expanded', 'v_network_range_expanded');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_network_range_expanded', tags := ARRAY['view_v_network_range_expanded']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_network_range_expanded;
CREATE VIEW jazzhands.v_network_range_expanded AS
 SELECT nr.network_range_id,
    nr.network_range_type,
    nr.description,
    nr.parent_netblock_id,
    p.ip_address,
    p.netblock_type,
    p.ip_universe_id,
    nr.start_netblock_id,
    start.ip_address AS start_ip_address,
    start.netblock_type AS start_netblock_type,
    start.ip_universe_id AS start_ip_universe_id,
    nr.stop_netblock_id,
    stop.ip_address AS stop_ip_address,
    stop.netblock_type AS stop_netblock_type,
    stop.ip_universe_id AS stop_ip_universe_id,
    nr.dns_prefix,
    nr.dns_domain_id,
    dd.dns_domain_name
   FROM jazzhands.network_range nr
     JOIN jazzhands.netblock p ON nr.parent_netblock_id = p.netblock_id
     JOIN jazzhands.netblock start ON nr.start_netblock_id = start.netblock_id
     JOIN jazzhands.netblock stop ON nr.stop_netblock_id = stop.netblock_id
     LEFT JOIN jazzhands.dns_domain dd USING (dns_domain_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_network_range_expanded','v_network_range_expanded');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_network_range_expanded','v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_network_range_expanded');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_network_range_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_network_range_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_network_range_expanded (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_person_company
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_person_company', tags := ARRAY['view_v_person_company']);
DROP VIEW IF EXISTS jazzhands.v_person_company;
-- DONE DEALING WITH OLD TABLE v_person_company (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_person_company');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_person_company');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_person_company failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_property', 'v_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_property', tags := ARRAY['view_v_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_property;
CREATE VIEW jazzhands.v_property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id,
    property.service_environment_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
    property.property_value,
    property.property_value_account_collection_id,
    property.property_value_boolean,
    property.property_value_device_collection_id,
    property.property_value_encryption_key_id,
    property.property_value_json,
    property.property_value_netblock_collection_id,
    property.property_value_password_type,
    property.property_value_private_key_id,
    property.property_value_sw_package_id,
    property.property_value_timestamp,
    property.property_value_token_collection_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
    property.is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date
   FROM jazzhands.property
  WHERE property.is_enabled = true AND (property.start_date IS NULL AND property.finish_date IS NULL OR property.start_date IS NULL AND now() <= property.finish_date OR property.start_date <= now() AND property.finish_date IS NULL OR property.start_date <= now() AND now() <= property.finish_date);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_property','v_property');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_property','v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_property');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_property (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_site_netblock_expanded_assigned
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_site_netblock_expanded_assigned', 'v_site_netblock_expanded_assigned');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_site_netblock_expanded_assigned', tags := ARRAY['view_v_site_netblock_expanded_assigned']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_site_netblock_expanded_assigned;
CREATE VIEW jazzhands.v_site_netblock_expanded_assigned AS
 SELECT meat.site_code,
    meat.netblock_id
   FROM ( SELECT p.site_code,
            n.netblock_id,
            rank() OVER (PARTITION BY n.netblock_id ORDER BY (array_length(hc.path, 1)), (array_length(n.path, 1))) AS tier
           FROM jazzhands.netblock_collection_netblock ncn
             JOIN jazzhands_cache.ct_netblock_collection_hier_from_ancestor hc USING (netblock_collection_id)
             JOIN jazzhands_cache.ct_netblock_hier n ON ncn.netblock_id = n.root_netblock_id
             JOIN ( SELECT property.property_id,
                    property.account_collection_id,
                    property.account_id,
                    property.account_realm_id,
                    property.company_collection_id,
                    property.company_id,
                    property.device_collection_id,
                    property.dns_domain_collection_id,
                    property.layer2_network_collection_id,
                    property.layer3_network_collection_id,
                    property.netblock_collection_id,
                    property.network_range_id,
                    property.operating_system_id,
                    property.operating_system_snapshot_id,
                    property.property_name_collection_id,
                    property.service_environment_collection_id,
                    property.site_code,
                    property.x509_signed_certificate_id,
                    property.property_name,
                    property.property_type,
                    property.property_value,
                    property.property_value_account_collection_id,
                    property.property_value_boolean,
                    property.property_value_device_collection_id,
                    property.property_value_encryption_key_id,
                    property.property_value_json,
                    property.property_value_netblock_collection_id,
                    property.property_value_password_type,
                    property.property_value_private_key_id,
                    property.property_value_sw_package_id,
                    property.property_value_timestamp,
                    property.property_value_token_collection_id,
                    property.property_rank,
                    property.start_date,
                    property.finish_date,
                    property.is_enabled,
                    property.data_ins_user,
                    property.data_ins_date,
                    property.data_upd_user,
                    property.data_upd_date
                   FROM jazzhands.property
                  WHERE property.property_name::text = 'per-site-netblock_collection'::text AND property.property_type::text = 'automated'::text) p USING (netblock_collection_id)) meat
  WHERE meat.tier = 1;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_site_netblock_expanded_assigned','v_site_netblock_expanded_assigned');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_site_netblock_expanded_assigned','v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_site_netblock_expanded_assigned');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_site_netblock_expanded_assigned');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_site_netblock_expanded_assigned  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_site_netblock_expanded_assigned (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_site_netblock_expanded_assigned');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_site_netblock_expanded_assigned failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE x509_certificate
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'x509_certificate', tags := ARRAY['view_x509_certificate']);
DROP VIEW IF EXISTS jazzhands.x509_certificate;
-- DONE DEALING WITH OLD TABLE x509_certificate (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_certificate');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old x509_certificate failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE device_power_connection
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'device_power_connection', tags := ARRAY['view_device_power_connection']);
DROP VIEW IF EXISTS jazzhands.device_power_connection;
-- DONE DEALING WITH OLD TABLE device_power_connection (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_power_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_power_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_power_connection failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE device_power_interface
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'device_power_interface', tags := ARRAY['view_device_power_interface']);
DROP VIEW IF EXISTS jazzhands.device_power_interface;
-- DONE DEALING WITH OLD TABLE device_power_interface (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_power_interface');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_power_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_power_interface failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE physical_port
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'physical_port', tags := ARRAY['view_physical_port']);
DROP VIEW IF EXISTS jazzhands.physical_port;
-- DONE DEALING WITH OLD TABLE physical_port (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('physical_port');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('physical_port');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old physical_port failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_manager_map
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_account_manager_map', 'v_account_manager_map');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_account_manager_map', tags := ARRAY['view_v_account_manager_map']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_account_manager_map;
CREATE VIEW jazzhands.v_account_manager_map AS
 WITH dude_base AS (
         SELECT a_1.login,
            a_1.account_id,
            a_1.person_id,
            a_1.company_id,
            a_1.account_realm_id,
            COALESCE(p.preferred_first_name, p.first_name) AS first_name,
            COALESCE(p.preferred_last_name, p.last_name) AS last_name,
            p.middle_name,
            pc.manager_person_id
           FROM jazzhands.account a_1
             JOIN jazzhands.person_company pc USING (company_id, person_id)
             JOIN jazzhands.person p USING (person_id)
          WHERE a_1.is_enabled = true AND pc.person_company_relation::text = 'employee'::text AND a_1.account_role::text = 'primary'::text AND a_1.account_type::text = 'person'::text
        ), dude AS (
         SELECT dude_base.login,
            dude_base.account_id,
            dude_base.person_id,
            dude_base.company_id,
            dude_base.account_realm_id,
            dude_base.first_name,
            dude_base.last_name,
            dude_base.middle_name,
            dude_base.manager_person_id,
            concat(dude_base.first_name, ' ', dude_base.last_name, ' (', dude_base.login, ')') AS human_readable
           FROM dude_base
        )
 SELECT a.login,
    a.account_id,
    a.person_id,
    a.company_id,
    a.account_realm_id,
    a.first_name,
    a.last_name,
    a.middle_name,
    a.manager_person_id,
    a.human_readable,
    mp.account_id AS manager_account_id,
    mp.login AS manager_login,
    concat(mp.first_name, ' ', mp.last_name, ' (', mp.login, ')') AS manager_human_readable,
    mp.last_name AS manager_last_name,
    mp.middle_name AS manager_middle_name,
    mp.first_name AS manger_first_name,
    mp.company_id AS manager_company_id
   FROM dude a
     JOIN dude mp ON mp.person_id = a.manager_person_id AND mp.account_realm_id = a.account_realm_id;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_account_manager_map','v_account_manager_map');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_manager_map','v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_account_manager_map');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_manager_map');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_manager_map  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_manager_map (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_map');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_map');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_l1_all_physical_ports
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_l1_all_physical_ports', tags := ARRAY['view_v_l1_all_physical_ports']);
DROP VIEW IF EXISTS jazzhands.v_l1_all_physical_ports;
-- DONE DEALING WITH OLD TABLE v_l1_all_physical_ports (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_l1_all_physical_ports failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_collection_property_expanded
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_account_collection_property_expanded', 'v_account_collection_property_expanded');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_account_collection_property_expanded', tags := ARRAY['view_v_account_collection_property_expanded']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_property', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_collection_expanded_detail', type := 'view');
DROP VIEW IF EXISTS jazzhands.v_account_collection_property_expanded;
CREATE VIEW jazzhands.v_account_collection_property_expanded AS
 SELECT v_account_collection_expanded_detail.root_account_collection_id AS account_collection_id,
    v_property.property_id,
    v_property.property_name,
    v_property.property_type,
    v_property.property_value,
    v_property.property_value_timestamp,
    v_property.property_value_account_collection_id,
    v_property.property_value_netblock_collection_id,
    v_property.property_value_password_type,
    v_property.property_value_token_collection_id,
    v_property.property_rank,
        CASE val_property.is_multivalue
            WHEN false THEN false
            WHEN true THEN true
            ELSE NULL::boolean
        END AS is_multivalue,
        CASE ac.account_collection_type
            WHEN 'per-account'::text THEN 0
            ELSE
            CASE v_account_collection_expanded_detail.assignment_method
                WHEN 'DirectAccountCollectionAssignment'::text THEN 10
                WHEN 'DirectDepartmentAssignment'::text THEN 200
                WHEN 'DepartmentAssignedToAccountCollection'::text THEN 300 + v_account_collection_expanded_detail.department_level + v_account_collection_expanded_detail.account_collection_level
                WHEN 'AccountAssignedToChildDepartment'::text THEN 400 + v_account_collection_expanded_detail.department_level
                WHEN 'AccountAssignedToChildAccountCollection'::text THEN 500 + v_account_collection_expanded_detail.account_collection_level
                WHEN 'DepartmentAssignedToChildAccountCollection'::text THEN 600 + v_account_collection_expanded_detail.department_level + v_account_collection_expanded_detail.account_collection_level
                WHEN 'ChildDepartmentAssignedToAccountCollection'::text THEN 700 + v_account_collection_expanded_detail.department_level + v_account_collection_expanded_detail.account_collection_level
                WHEN 'ChildDepartmentAssignedToChildAccountCollection'::text THEN 800 + v_account_collection_expanded_detail.department_level + v_account_collection_expanded_detail.account_collection_level
                ELSE 999
            END
        END AS assignment_rank
   FROM jazzhands.v_account_collection_expanded_detail
     JOIN jazzhands.account_collection ac USING (account_collection_id)
     JOIN jazzhands.v_property USING (account_collection_id)
     JOIN jazzhands.val_property USING (property_name, property_type);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_account_collection_property_expanded','v_account_collection_property_expanded');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_collection_property_expanded','v_account_collection_property_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_collection_property_expanded failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_account_collection_property_expanded');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_collection_property_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_collection_property_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_collection_property_expanded (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_collection_property_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_collection_property_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_collection_property_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_collection_property_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_collection_property_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_collection_property_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_manager_hier
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'v_account_manager_hier', 'v_account_manager_hier');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'v_account_manager_hier', tags := ARRAY['view_v_account_manager_hier']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_person', type := 'view');
DROP VIEW IF EXISTS jazzhands.v_account_manager_hier;
CREATE VIEW jazzhands.v_account_manager_hier AS
 WITH RECURSIVE phier(level, person_id, company_id, intermediate_manager_person_id, manager_person_id) AS (
         SELECT 0 AS level,
            person_company.person_id,
            person_company.company_id,
            person_company.manager_person_id AS intermediate_manager_person_id,
            person_company.manager_person_id,
            ARRAY[person_company.person_id] AS array_path,
            false AS cycle
           FROM jazzhands.person_company
        UNION
         SELECT x.level + 1 AS level,
            x.person_id,
            x.company_id,
            m_1.manager_person_id AS intermediate_manager_person_id,
            m_1.manager_person_id,
            x.array_path || m_1.manager_person_id AS array_path,
            m_1.manager_person_id = ANY (x.array_path) AS cycle
           FROM jazzhands.person_company m_1
             JOIN phier x ON x.intermediate_manager_person_id = m_1.person_id
          WHERE NOT x.cycle AND m_1.manager_person_id IS NOT NULL
        )
 SELECT h.level,
    a.account_id,
    a.person_id,
    a.company_id,
    a.login,
    concat(p.first_name, ' ', p.last_name, ' (', a.login, ')') AS human_readable,
    a.account_realm_id,
    m.manager_account_id,
    m.manager_login,
    h.manager_person_id,
    m.manager_company_id,
    m.manager_human_readable,
    h.array_path
   FROM jazzhands.account a
     JOIN phier h USING (person_id, company_id)
     JOIN jazzhands.v_person p USING (person_id)
     LEFT JOIN ( SELECT a_1.person_id AS manager_person_id,
            a_1.account_id AS manager_account_id,
            concat(p_1.first_name, ' ', p_1.last_name, ' (', a_1.login, ')') AS manager_human_readable,
            p_1.first_name AS manager_first_name,
            p_1.last_name AS manager_last_name,
            a_1.account_role,
            a_1.company_id AS manager_company_id,
            a_1.account_realm_id,
            a_1.login AS manager_login
           FROM jazzhands.account a_1
             JOIN jazzhands.v_person p_1 USING (person_id)
          WHERE a_1.account_role::text = 'primary'::text AND a_1.account_type::text = 'person'::text) m USING (manager_person_id, account_realm_id, account_role)
  WHERE a.account_role::text = 'primary'::text AND a.account_type::text = 'person'::text;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_account_manager_hier','v_account_manager_hier');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_manager_hier','v_account_manager_hier');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_manager_hier failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_account_manager_hier');
		DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('v_account_manager_hier');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_manager_hier  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_manager_hier (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_hier');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_hier');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_manager_hier failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_hier');
	DELETE FROM __regrants WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_account_manager_hier');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_manager_hier failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_collection_audit_results
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('approval_utils', 'v_account_collection_audit_results', 'v_account_collection_audit_results');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'approval_utils', object := 'v_account_collection_audit_results', tags := ARRAY['view_v_account_collection_audit_results']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_manager_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'approval_utils', object := 'v_account_collection_account_audit_map', type := 'view');
DROP VIEW IF EXISTS approval_utils.v_account_collection_audit_results;
CREATE VIEW approval_utils.v_account_collection_audit_results AS
 WITH membermap AS (
         SELECT aca.audit_seq_id,
            ac.account_collection_id,
            ac.account_collection_name,
            ac.account_collection_type,
            a.login,
            a.account_id,
            a.person_id,
            a.company_id,
            a.account_realm_id,
            a.first_name,
            a.last_name,
            a.middle_name,
            a.manager_person_id,
            a.human_readable,
            a.manager_account_id,
            a.manager_login,
            a.manager_human_readable,
            a.manager_last_name,
            a.manager_middle_name,
            a.manger_first_name,
            a.manager_company_id
           FROM jazzhands.v_account_manager_map a
             JOIN approval_utils.v_account_collection_account_audit_map aca USING (account_id)
             JOIN jazzhands.account_collection ac USING (account_collection_id)
          WHERE a.account_id <> a.manager_account_id
          ORDER BY a.manager_login, a.last_name, a.first_name, a.account_id
        )
 SELECT membermap.audit_seq_id,
    membermap.account_collection_id,
    membermap.account_collection_name,
    membermap.account_collection_type,
    membermap.login,
    membermap.account_id,
    membermap.person_id,
    membermap.company_id,
    membermap.account_realm_id,
    membermap.first_name,
    membermap.last_name,
    membermap.middle_name,
    membermap.manager_person_id,
    membermap.human_readable,
    membermap.manager_account_id,
    membermap.manager_login,
    membermap.manager_human_readable,
    membermap.manager_last_name,
    membermap.manager_middle_name,
    membermap.manger_first_name,
    membermap.manager_company_id
   FROM membermap;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'approval_utils' AND type = 'view' AND object IN ('v_account_collection_audit_results','v_account_collection_audit_results');
	DELETE FROM __regrants WHERE schema = 'approval_utils' AND object IN ('v_account_collection_audit_results','v_account_collection_audit_results');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_collection_audit_results failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'approval_utils' AND object IN ('v_account_collection_audit_results');
		DELETE FROM __regrants WHERE schema = 'approval_utils' AND object IN ('v_account_collection_audit_results');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_collection_audit_results  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_collection_audit_results (approval_utils)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_audit_results');
	DELETE FROM __regrants WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_audit_results');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_collection_audit_results failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_audit_results');
	DELETE FROM __regrants WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_audit_results');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_collection_audit_results failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_collection_approval_process
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('approval_utils', 'v_account_collection_approval_process', 'v_account_collection_approval_process');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'approval_utils', object := 'v_account_collection_approval_process', tags := ARRAY['view_v_account_collection_approval_process']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_manager_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'approval_utils', object := 'v_account_collection_account_audit_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_manager_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'approval_utils', object := 'v_approval_matrix', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'approval_utils', object := 'v_person_company_audit_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'approval_utils', object := 'v_account_collection_audit_results', type := 'view');
DROP VIEW IF EXISTS approval_utils.v_account_collection_approval_process;
CREATE VIEW approval_utils.v_account_collection_approval_process AS
 WITH combo AS (
         WITH foo AS (
                 SELECT mm.audit_seq_id,
                    mm.account_collection_id,
                    mm.account_collection_name,
                    mm.account_collection_type,
                    mm.login,
                    mm.account_id,
                    mm.person_id,
                    mm.company_id,
                    mm.account_realm_id,
                    mm.first_name,
                    mm.last_name,
                    mm.middle_name,
                    mm.manager_person_id,
                    mm.human_readable,
                    mm.manager_account_id,
                    mm.manager_login,
                    mm.manager_human_readable,
                    mm.manager_last_name,
                    mm.manager_middle_name,
                    mm.manger_first_name,
                    mm.manager_company_id,
                    mx.approval_process_id,
                    mx.first_approval_process_chain_id,
                    mx.approval_process_name,
                    mx.approval_response_period,
                    mx.approval_expiration_action,
                    mx.attestation_frequency,
                    mx.attestation_offset,
                    mx.current_attestation_name,
                    mx.current_attestation_begins,
                    mx.property_id,
                    mx.property_name,
                    mx.property_type,
                    mx.property_value,
                    mx.property_val_lhs,
                    mx.property_val_rhs,
                    mx.approval_process_chain_id,
                    mx.approving_entity,
                    mx.approval_process_chain_name,
                    mx.approval_process_description,
                    mx.approval_chain_description
                   FROM approval_utils.v_account_collection_audit_results mm
                     JOIN approval_utils.v_approval_matrix mx ON mx.property_val_lhs = mm.account_collection_type::text
                  ORDER BY mm.manager_account_id, mm.account_id
                )
         SELECT foo.login,
            foo.account_id,
            foo.person_id,
            foo.company_id,
            foo.manager_account_id,
            foo.manager_login,
            'account_collection_account'::text AS audit_table,
            foo.audit_seq_id,
            foo.approval_process_id,
            foo.approval_process_chain_id,
            foo.approving_entity,
            foo.approval_process_description,
            foo.approval_chain_description,
            foo.approval_response_period,
            foo.approval_expiration_action,
            foo.attestation_frequency,
            foo.current_attestation_name,
            foo.current_attestation_begins,
            foo.attestation_offset,
            foo.approval_process_chain_name,
            foo.account_collection_type AS approval_category,
            concat('Verify ', foo.account_collection_type) AS approval_label,
            foo.human_readable AS approval_lhs,
            foo.account_collection_name AS approval_rhs
           FROM foo
        UNION
         SELECT mm.login,
            mm.account_id,
            mm.person_id,
            mm.company_id,
            mm.manager_account_id,
            mm.manager_login,
            'account_collection_account'::text AS audit_table,
            mm.audit_seq_id,
            mx.approval_process_id,
            mx.approval_process_chain_id,
            mx.approving_entity,
            mx.approval_process_description,
            mx.approval_chain_description,
            mx.approval_response_period,
            mx.approval_expiration_action,
            mx.attestation_frequency,
            mx.current_attestation_name,
            mx.current_attestation_begins,
            mx.attestation_offset,
            mx.approval_process_chain_name,
            mx.approval_process_name AS approval_category,
            'Verify Manager'::text AS approval_label,
            mm.human_readable AS approval_lhs,
            concat('Reports to ', mm.manager_human_readable) AS approval_rhs
           FROM approval_utils.v_approval_matrix mx
             JOIN jazzhands.property p ON p.property_name::text = mx.property_val_rhs AND p.property_type::text = mx.property_val_lhs
             JOIN approval_utils.v_account_collection_audit_results mm ON mm.account_collection_id = p.property_value_account_collection_id
          WHERE p.account_id <> mm.account_id
        UNION
         SELECT mm.login,
            mm.account_id,
            mm.person_id,
            mm.company_id,
            mm.manager_account_id,
            mm.manager_login,
            'person_company'::text AS audit_table,
            pcm.audit_seq_id,
            am.approval_process_id,
            am.approval_process_chain_id,
            am.approving_entity,
            am.approval_process_description,
            am.approval_chain_description,
            am.approval_response_period,
            am.approval_expiration_action,
            am.attestation_frequency,
            am.current_attestation_name,
            am.current_attestation_begins,
            am.attestation_offset,
            am.approval_process_chain_name,
            am.property_val_rhs AS approval_category,
                CASE
                    WHEN am.property_val_rhs = 'position_title'::text THEN 'Verify Position Title'::text
                    ELSE NULL::text
                END AS aproval_label,
            mm.human_readable AS approval_lhs,
                CASE
                    WHEN am.property_val_rhs = 'position_title'::text THEN pcm.position_title
                    ELSE NULL::character varying
                END AS approval_rhs
           FROM jazzhands.v_account_manager_map mm
             JOIN approval_utils.v_person_company_audit_map pcm USING (person_id, company_id)
             JOIN approval_utils.v_approval_matrix am ON am.property_val_lhs = 'person_company'::text AND am.property_val_rhs = 'position_title'::text
        )
 SELECT combo.login,
    combo.account_id,
    combo.person_id,
    combo.company_id,
    combo.manager_account_id,
    combo.manager_login,
    combo.audit_table,
    combo.audit_seq_id,
    combo.approval_process_id,
    combo.approval_process_chain_id,
    combo.approving_entity,
    combo.approval_process_description,
    combo.approval_chain_description,
    combo.approval_response_period,
    combo.approval_expiration_action,
    combo.attestation_frequency,
    combo.current_attestation_name,
    combo.current_attestation_begins,
    combo.attestation_offset,
    combo.approval_process_chain_name,
    combo.approval_category,
    combo.approval_label,
    combo.approval_lhs,
    combo.approval_rhs
   FROM combo
  WHERE combo.manager_account_id <> combo.account_id
  ORDER BY combo.manager_login, combo.account_id, combo.approval_label;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'approval_utils' AND type = 'view' AND object IN ('v_account_collection_approval_process','v_account_collection_approval_process');
	DELETE FROM __regrants WHERE schema = 'approval_utils' AND object IN ('v_account_collection_approval_process','v_account_collection_approval_process');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_collection_approval_process failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'approval_utils' AND object IN ('v_account_collection_approval_process');
		DELETE FROM __regrants WHERE schema = 'approval_utils' AND object IN ('v_account_collection_approval_process');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_collection_approval_process  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_collection_approval_process (approval_utils)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_approval_process');
	DELETE FROM __regrants WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_approval_process');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_collection_approval_process failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_approval_process');
	DELETE FROM __regrants WHERE schema IN ('approval_utils', 'jazzhands_audit') AND object IN ('v_account_collection_approval_process');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_collection_approval_process failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH TABLE dns_domain
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'dns_domain', 'dns_domain');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'dns_domain', tags := ARRAY['view_dns_domain']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.dns_domain;
CREATE VIEW audit.dns_domain AS
 SELECT dns_domain.dns_domain_id,
    dns_domain.dns_domain_name AS soa_name,
    dns_domain.dns_domain_name,
    dns_domain.dns_domain_type,
    dns_domain.parent_dns_domain_id,
    dns_domain.description,
    dns_domain.external_id,
    dns_domain.data_ins_user,
    dns_domain.data_ins_date,
    dns_domain.data_upd_user,
    dns_domain.data_upd_date,
    dns_domain."aud#action",
    dns_domain."aud#timestamp",
    dns_domain."aud#realtime",
    dns_domain."aud#txid",
    dns_domain."aud#user",
    dns_domain."aud#seq"
   FROM jazzhands_audit.dns_domain;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('dns_domain','dns_domain');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('dns_domain','dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of dns_domain failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('dns_domain');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('dns_domain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for dns_domain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE dns_domain (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old dns_domain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new dns_domain failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_interface_netblock
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'network_interface_netblock', 'network_interface_netblock');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'network_interface_netblock', tags := ARRAY['view_network_interface_netblock']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.network_interface_netblock;
CREATE VIEW audit.network_interface_netblock AS
 SELECT layer3_interface_netblock.netblock_id,
    layer3_interface_netblock.layer3_interface_id AS network_interface_id,
    layer3_interface_netblock.device_id,
    layer3_interface_netblock.layer3_interface_rank,
    layer3_interface_netblock.data_ins_user,
    layer3_interface_netblock.data_ins_date,
    layer3_interface_netblock.data_upd_user,
    layer3_interface_netblock.data_upd_date,
    layer3_interface_netblock."aud#action",
    layer3_interface_netblock."aud#timestamp",
    layer3_interface_netblock."aud#realtime",
    layer3_interface_netblock."aud#txid",
    layer3_interface_netblock."aud#user",
    layer3_interface_netblock."aud#seq"
   FROM jazzhands_audit.layer3_interface_netblock;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('network_interface_netblock','network_interface_netblock');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_interface_netblock','network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('network_interface_netblock');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_interface_netblock');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_interface_netblock  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_interface_netblock (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'network_interface_purpose', 'network_interface_purpose');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'network_interface_purpose', tags := ARRAY['view_network_interface_purpose']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.network_interface_purpose;
CREATE VIEW audit.network_interface_purpose AS
 SELECT layer3_interface_purpose.device_id,
    layer3_interface_purpose.layer3_interface_purpose,
    layer3_interface_purpose.layer3_interface_id AS network_interface_id,
    layer3_interface_purpose.description,
    layer3_interface_purpose.data_ins_user,
    layer3_interface_purpose.data_ins_date,
    layer3_interface_purpose.data_upd_user,
    layer3_interface_purpose.data_upd_date,
    layer3_interface_purpose."aud#action",
    layer3_interface_purpose."aud#timestamp",
    layer3_interface_purpose."aud#realtime",
    layer3_interface_purpose."aud#txid",
    layer3_interface_purpose."aud#user",
    layer3_interface_purpose."aud#seq"
   FROM jazzhands_audit.layer3_interface_purpose;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('network_interface_purpose','network_interface_purpose');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_interface_purpose','network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('network_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_interface_purpose (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_service
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'network_service', 'network_service');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'network_service', tags := ARRAY['view_network_service']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.network_service;
CREATE VIEW audit.network_service AS
 SELECT network_service.network_service_id,
    network_service.name,
    network_service.description,
    network_service.network_service_type,
        CASE
            WHEN network_service.is_monitored IS NULL THEN NULL::text
            WHEN network_service.is_monitored = true THEN 'Y'::text
            WHEN network_service.is_monitored = false THEN 'N'::text
            ELSE NULL::text
        END AS is_monitored,
    network_service.device_id,
    network_service.layer3_interface_id,
    network_service.dns_record_id,
    network_service.service_environment_id,
    network_service.data_ins_user,
    network_service.data_ins_date,
    network_service.data_upd_user,
    network_service.data_upd_date,
    network_service."aud#action",
    network_service."aud#timestamp",
    network_service."aud#realtime",
    network_service."aud#txid",
    network_service."aud#user",
    network_service."aud#seq"
   FROM jazzhands_audit.network_service;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('network_service','network_service');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_service','network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_service failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('network_service');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('network_service');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_service  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_service (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_service failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_service failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'property', 'property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'property', tags := ARRAY['view_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.property;
CREATE VIEW audit.property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id AS property_collection_id,
    property.service_environment_collection_id AS service_env_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
    property.property_value,
    property.property_value_timestamp,
    property.property_value_account_collection_id AS property_value_account_coll_id,
    property.property_value_device_collection_id AS property_value_device_coll_id,
    property.property_value_json,
    property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    property.property_value_password_type,
    property.property_value_sw_package_id,
    property.property_value_token_collection_id AS property_value_token_col_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
        CASE
            WHEN property.is_enabled IS NULL THEN NULL::text
            WHEN property.is_enabled = true THEN 'Y'::text
            WHEN property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date,
    property."aud#action",
    property."aud#timestamp",
    property."aud#realtime",
    property."aud#txid",
    property."aud#user",
    property."aud#seq"
   FROM jazzhands_audit.property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('property','property');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('property','property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('property');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE property (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE static_route
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'static_route', 'static_route');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'static_route', tags := ARRAY['view_static_route']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.static_route;
CREATE VIEW audit.static_route AS
 SELECT static_route.static_route_id,
    static_route.device_source_id AS device_src_id,
    static_route.layer3_interface_destination_id AS network_interface_dst_id,
    static_route.netblock_id,
    static_route.data_ins_user,
    static_route.data_ins_date,
    static_route.data_upd_user,
    static_route.data_upd_date,
    static_route."aud#action",
    static_route."aud#timestamp",
    static_route."aud#realtime",
    static_route."aud#txid",
    static_route."aud#user",
    static_route."aud#seq"
   FROM jazzhands_audit.static_route;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('static_route','static_route');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('static_route','static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of static_route failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('static_route');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('static_route');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE static_route (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE static_route_template
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'static_route_template', 'static_route_template');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'static_route_template', tags := ARRAY['view_static_route_template']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.static_route_template;
CREATE VIEW audit.static_route_template AS
 SELECT static_route_template.static_route_template_id,
    static_route_template.netblock_source_id AS netblock_src_id,
    static_route_template.layer3_interface_destination_id AS network_interface_dst_id,
    static_route_template.netblock_id,
    static_route_template.description,
    static_route_template.data_ins_user,
    static_route_template.data_ins_date,
    static_route_template.data_upd_user,
    static_route_template.data_upd_date,
    static_route_template."aud#action",
    static_route_template."aud#timestamp",
    static_route_template."aud#realtime",
    static_route_template."aud#txid",
    static_route_template."aud#user",
    static_route_template."aud#seq"
   FROM jazzhands_audit.static_route_template;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('static_route_template','static_route_template');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('static_route_template','static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of static_route_template failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('static_route_template');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('static_route_template');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route_template  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE static_route_template (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route_template failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route_template failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_network_interface_purpose', 'val_network_interface_purpose');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_network_interface_purpose', tags := ARRAY['view_val_network_interface_purpose']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_network_interface_purpose;
CREATE VIEW audit.val_network_interface_purpose AS
 SELECT val_layer3_interface_purpose.layer3_interface_purpose AS network_interface_purpose,
    val_layer3_interface_purpose.description,
    val_layer3_interface_purpose.data_ins_user,
    val_layer3_interface_purpose.data_ins_date,
    val_layer3_interface_purpose.data_upd_user,
    val_layer3_interface_purpose.data_upd_date,
    val_layer3_interface_purpose."aud#action",
    val_layer3_interface_purpose."aud#timestamp",
    val_layer3_interface_purpose."aud#realtime",
    val_layer3_interface_purpose."aud#txid",
    val_layer3_interface_purpose."aud#user",
    val_layer3_interface_purpose."aud#seq"
   FROM jazzhands_audit.val_layer3_interface_purpose;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_network_interface_purpose','val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_network_interface_purpose','val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_network_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_network_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_network_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_network_interface_purpose (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_network_interface_type', 'val_network_interface_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_network_interface_type', tags := ARRAY['view_val_network_interface_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_network_interface_type;
CREATE VIEW audit.val_network_interface_type AS
 SELECT val_layer3_interface_type.layer3_interface_type AS network_interface_type,
    val_layer3_interface_type.description,
    val_layer3_interface_type.data_ins_user,
    val_layer3_interface_type.data_ins_date,
    val_layer3_interface_type.data_upd_user,
    val_layer3_interface_type.data_upd_date AS "aud#action",
    val_layer3_interface_type."aud#timestamp",
    val_layer3_interface_type."aud#realtime",
    val_layer3_interface_type."aud#txid",
    val_layer3_interface_type."aud#user",
    val_layer3_interface_type."aud#seq"
   FROM jazzhands_audit.val_layer3_interface_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_network_interface_type','val_network_interface_type');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_network_interface_type','val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_network_interface_type');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_network_interface_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_network_interface_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_network_interface_type (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_type');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_type');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'val_property', 'val_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_property', tags := ARRAY['view_val_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.val_property;
CREATE VIEW audit.val_property AS
 SELECT val_property.property_name,
    val_property.property_type,
    val_property.description,
    val_property.account_collection_type,
    val_property.company_collection_type,
    val_property.device_collection_type,
    val_property.dns_domain_collection_type,
    val_property.layer2_network_collection_type,
    val_property.layer3_network_collection_type,
    val_property.netblock_collection_type,
    val_property.network_range_type,
    val_property.property_name_collection_type AS property_collection_type,
    val_property.service_environment_collection_type AS service_env_collection_type,
        CASE
            WHEN val_property.is_multivalue IS NULL THEN NULL::text
            WHEN val_property.is_multivalue = true THEN 'Y'::text
            WHEN val_property.is_multivalue = false THEN 'N'::text
            ELSE NULL::text
        END AS is_multivalue,
    val_property.property_value_account_collection_type_restriction AS prop_val_acct_coll_type_rstrct,
    val_property.property_value_device_collection_type_restriction AS prop_val_dev_coll_type_rstrct,
    val_property.property_value_netblock_collection_type_restriction AS prop_val_nblk_coll_type_rstrct,
    val_property.property_data_type,
    val_property.property_value_json_schema,
    val_property.permit_account_collection_id,
    val_property.permit_account_id,
    val_property.permit_account_realm_id,
    val_property.permit_company_id,
    val_property.permit_company_collection_id,
    val_property.permit_device_collection_id,
    val_property.permit_dns_domain_collection_id AS permit_dns_domain_coll_id,
    val_property.permit_layer2_network_collection_id AS permit_layer2_network_coll_id,
    val_property.permit_layer3_network_collection_id AS permit_layer3_network_coll_id,
    val_property.permit_netblock_collection_id,
    val_property.permit_network_range_id,
    val_property.permit_operating_system_id,
    val_property.permit_operating_system_snapshot_id AS permit_os_snapshot_id,
    val_property.permit_property_name_collection_id AS permit_property_collection_id,
    val_property.permit_service_environment_collection AS permit_service_env_collection,
    val_property.permit_site_code,
    val_property.permit_x509_signed_certificate_id AS permit_x509_signed_cert_id,
    val_property.permit_property_rank,
    val_property.data_ins_user,
    val_property.data_ins_date,
    val_property.data_upd_user,
    val_property.data_upd_date,
    val_property."aud#action",
    val_property."aud#timestamp",
    val_property."aud#realtime",
    val_property."aud#txid",
    val_property."aud#user",
    val_property."aud#seq"
   FROM jazzhands_audit.val_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('val_property','val_property');
	DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_property','val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('val_property');
		DELETE FROM __regrants WHERE schema = 'audit' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_property (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

--
-- Process proc drops in schema_support
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'schema_support'::text, object := 'end_maintenance (  )'::text, tags := ARRAY['process_all_procs_in_schema_schema_support'::text]);
DROP FUNCTION IF EXISTS schema_support.end_maintenance (  );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
--
-- Process proc drops in jazzhands
--
select clock_timestamp(), clock_timestamp() - now() AS len;
DROP TRIGGER IF EXISTS trigger_del_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'del_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.del_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_del ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_del (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_del (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_ins ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_ins (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_ins (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_nouniverse_upd ON jazzhands.v_dns_domain_nouniverse;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_nouniverse_upd (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_nouniverse_upd (  );
DROP TRIGGER IF EXISTS trigger_dns_domain_soa_name_retire ON jazzhands.dns_domain;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'dns_domain_soa_name_retire (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.dns_domain_soa_name_retire (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'dns_record_cname_checker');
SELECT schema_support.save_grants_for_replay('jazzhands', 'dns_record_cname_checker');
CREATE OR REPLACE FUNCTION jazzhands.dns_record_cname_checker()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
	_dom	TEXT;
BEGIN
	--- XXX - need to seriously think about ip_universes here.
	_tally := 0;
	IF TG_OP = 'INSERT' OR NEW.DNS_TYPE != OLD.DNS_TYPE THEN
		IF NEW.DNS_TYPE = 'CNAME' THEN
			IF TG_OP = 'UPDATE' THEN
			SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE
						NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	OLD.dns_record_id != x.dns_record_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			ELSE
				-- only difference between above and this is the use of OLD
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE
						NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			END IF;
		-- this clause is basically the same as above except = 'CNAME'
		ELSIF NEW.DNS_TYPE != 'CNAME' THEN
			IF TG_OP = 'UPDATE' THEN
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE	x.dns_type = 'CNAME'
				 AND	NEW.dns_domain_id = x.dns_domain_id
				 AND	OLD.dns_record_id != x.dns_record_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			ELSE
				-- only difference between above and this is the use of OLD
				SELECT	COUNT(*)
				  INTO	_tally
				  FROM	v_dns x
				 WHERE	x.dns_type = 'CNAME'
				 AND	NEW.dns_domain_id = x.dns_domain_id
				 AND	NEW.ip_universe_id IS NOT DISTINCT FROM x.ip_universe_id
				 AND	(
							NEW.dns_name IS NULL and x.dns_name is NULL
							or
							lower(NEW.dns_name) = lower(x.dns_name)
						)
				;
			END IF;
		END IF;
	END IF;

	IF _tally > 0 THEN
		SELECT dns_domain_name INTO _dom FROM dns_domain
		WHERE dns_domain_id = NEW.dns_domain_id ;

		if NEW.dns_name IS NULL THEN
			RAISE EXCEPTION '% may not have CNAME and other records (%)',
				_dom, _tally
				USING ERRCODE = 'unique_violation';
		ELSE
			RAISE EXCEPTION '%.% may not have CNAME and other records (%)',
				NEW.dns_name, _dom, _tally
				USING ERRCODE = 'unique_violation';
		END IF;
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('dns_record_cname_checker');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('dns_record_cname_checker');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc dns_record_cname_checker failed but that is ok';
	NULL;
END;
$$;

DROP TRIGGER IF EXISTS trigger_layer1_connection_insteadof ON jazzhands.layer1_connection;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'do_layer1_connection_trigger (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.do_layer1_connection_trigger (  );
DROP TRIGGER IF EXISTS trigger_physical_port_insteadof ON jazzhands.physical_port;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'do_physical_port_trigger (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.do_physical_port_trigger (  );
DROP TRIGGER IF EXISTS trigger_ins_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'ins_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.ins_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_upd_x509_certificate ON jazzhands.x509_certificate;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'upd_x509_certificate (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.upd_x509_certificate (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_del ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_del (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_del (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_ins ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_ins (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_ins (  );
DROP TRIGGER IF EXISTS trigger_v_person_company_upd ON jazzhands.v_person_company;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'v_person_company_upd (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.v_person_company_upd (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'validate_component_parent_slot_id');
SELECT schema_support.save_grants_for_replay('jazzhands', 'validate_component_parent_slot_id');
CREATE OR REPLACE FUNCTION jazzhands.validate_component_parent_slot_id()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	stid	integer;
BEGIN
	IF NEW.parent_slot_id IS NULL THEN
		RETURN NEW;
	END IF;

	PERFORM
		*
	FROM
		slot s JOIN
		slot_type_permitted_component_slot_type stpcst USING (slot_type_id) JOIN
		component_type ct ON (stpcst.component_slot_type_id = ct.slot_type_id)
	WHERE
		ct.component_type_id = NEW.component_type_id AND
		s.slot_id = NEW.parent_slot_id;

	IF NOT FOUND THEN
		SELECT slot_type_id INTO stid FROM slot WHERE slot_id = NEW.parent_slot_id;
		RAISE EXCEPTION 'Component type % is not permitted in slot % (slot type %)',
			NEW.component_type_id, NEW.parent_slot_id, stid
			USING ERRCODE = 'foreign_key_violation';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('validate_component_parent_slot_id');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('validate_component_parent_slot_id');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc validate_component_parent_slot_id failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'validate_inter_component_connection');
SELECT schema_support.save_grants_for_replay('jazzhands', 'validate_inter_component_connection');
CREATE OR REPLACE FUNCTION jazzhands.validate_inter_component_connection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	slot_type_info	RECORD;
	csid_rec	RECORD;
BEGIN
	IF NEW.slot1_id = NEW.slot2_id THEN
		RAISE EXCEPTION 'A slot may not be connected to itself'
			USING ERRCODE = 'check_violation';
	END IF;

	--
	-- Validate that slot_ids are not already connected
	-- to something else
	--

	SELECT
		slot1_id,
		slot2_id
	INTO
		csid_rec
	FROM
		inter_component_connection icc
	WHERE
		icc.inter_component_connection_id != NEW.inter_component_connection_id
			AND
		(icc.slot1_id = NEW.slot1_id OR
		 icc.slot1_id = NEW.slot2_id OR
		 icc.slot2_id = NEW.slot1_id OR
		 icc.slot2_id = NEW.slot2_id )
	LIMIT 1;

	IF FOUND THEN
		IF csid_rec.slot1_id = NEW.slot1_id THEN
			RAISE EXCEPTION
				'slot_id % is already attached to slot_id %',
				NEW.slot1_id, csid_rec.slot2_id
				USING ERRCODE = 'unique_violation';
		ELSIF csid_rec.slot1_id = NEW.slot2_id THEN
			RAISE EXCEPTION
				'slot_id % is already attached to slot_id %',
				NEW.slot1_id, csid_rec.slot1_id
				USING ERRCODE = 'unique_violation';
		ELSIF csid_rec.slot2_id = NEW.slot1_id THEN
			RAISE EXCEPTION
				'slot_id % is already attached to slot_id %',
				NEW.slot2_id, csid_rec.slot2_id
				USING ERRCODE = 'unique_violation';
		ELSIF csid_rec.slot2_id = NEW.slot2_id THEN
			RAISE EXCEPTION
				'slot_id % is already attached to slot_id %',
				NEW.slot2_id, csid_rec.slot1_id
				USING ERRCODE = 'unique_violation';
		END IF;
	END IF;

	PERFORM
		*
	FROM
		(slot cs1 JOIN slot_type st1 USING (slot_type_id)) slot1,
		(slot cs2 JOIN slot_type st2 USING (slot_type_id)) slot2,
		slot_type_permitted_remote_slot_type pst
	WHERE
		slot1.slot_id = NEW.slot1_id AND
		slot2.slot_id = NEW.slot2_id AND
		-- Remove next line if we ever decide to allow cross-function
		-- connections
		slot1.slot_function = slot2.slot_function AND
		((slot1.slot_type_id = pst.slot_type_id AND
				slot2.slot_type_id = pst.remote_slot_type_id) OR
			(slot2.slot_type_id = pst.slot_type_id AND
				slot1.slot_type_id = pst.remote_slot_type_id));

	IF NOT FOUND THEN
		SELECT
			slot1.slot_type_id AS slot1_slot_type_id,
			slot1.slot_id AS slot1_slot_id,
			slot1.component_id AS slot1_component_id,
			slot1.slot_function AS slot1_slot_function,
			slot2.slot_type_id AS slot2_slot_type_id,
			slot2.slot_id AS slot2_slot_id,
			slot2.component_id AS slot2_component_id,
			slot2.slot_function AS slot2_slot_function
		INTO slot_type_info
		FROM
			(slot cs1 JOIN slot_type st1 USING (slot_type_id)) slot1,
			(slot cs2 JOIN slot_type st2 USING (slot_type_id)) slot2
		WHERE
			slot1.slot_id = NEW.slot1_id AND
			slot2.slot_id = NEW.slot2_id;

		RAISE EXCEPTION E'Slot types are not allowed to be connected:\nSlot %, component_id %, slot_type %, slot_function %\nSlot %, component_id %, slot_type %, slot_function %',
			slot_type_info.slot1_slot_id,
			slot_type_info.slot1_component_id,
			slot_type_info.slot1_slot_type_id,
			slot_type_info.slot1_slot_function,
			slot_type_info.slot2_slot_id,
			slot_type_info.slot2_component_id,
			slot_type_info.slot2_slot_type_id,
			slot_type_info.slot2_slot_function
			USING ERRCODE = 'check_violation';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('validate_inter_component_connection');
	DELETE FROM __regrants WHERE schema = 'jazzhands' AND object IN ('validate_inter_component_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc validate_inter_component_connection failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_environment_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_se		service_environment%ROWTYPE;
BEGIN
	DELETE FROM service_environment_id
	WHERE service_environment_id = OLD.service_environment_id;
	RETURN OLD;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_environment_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_se	service_environment%ROWTYPE;
BEGIN
	IF NEW.service_environment_id IS NOT NULL THEN
		INSERT INTO service_environment (
				service_environment_id,
        		service_environment_name,
        		service_environment_type,
        		production_state,
        		description,
        		external_id
		) VALUES (
				NEW.service_environment_id,
        		NEW.service_environment_name,
        		'default',
        		NEW.production_state,
        		NEW.description,
        		NEW.external_id
		) RETURNING * INTO _se;
	ELSE
		INSERT INTO service_environment (
        		service_environment_name,
        		service_environment_type,
        		production_state,
        		description,
        		external_id
		) VALUES (
        		NEW.service_environment_name,
        		'default',
        		NEW.production_state,
        		NEW.description,
        		NEW.external_id
		) RETURNING * INTO _se;

	END IF;

	NEW.service_environment_id		:= _se.service_environment_id;
	NEW.service_environment_name	:= _se.service_environment_name;
	NEW.production_state			:= _se.production_state;
	NEW.description					:= _se.description;
	NEW.external_id					:= _se.external_id;
	NEW.data_ins_user 				:= _se.data_ins_user;
	NEW.data_ins_date 				:= _se.data_ins_date;
	NEW.data_upd_user 				:= _se.data_upd_user;
	NEW.data_upd_date 				:= _se.data_upd_date;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_environment_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	upd_query		TEXT[];
	_se			service_environment%ROWTYPE;
BEGIN
	IF OLD.service_environment_id IS DISTINCT FROM NEW.service_environment_id THEN
		RAISE EXCEPTION 'May not update service_environment_id'
		USING ERRCODE = 'invalid_parameter_value';
	END IF;

	upd_query := NULL;
	IF NEW.service_environment_name IS DISTINCT FROM OLD.service_environment_name THEN
		upd_query := array_append(upd_query,
			'service_environment_name = ' || quote_nullable(NEW.service_environment_name));
	END IF;
	IF NEW.production_state IS DISTINCT FROM OLD.production_state THEN
		upd_query := array_append(upd_query,
			'production_state = ' || quote_nullable(NEW.production_state));
	END IF;
	IF NEW.description IS DISTINCT FROM OLD.description THEN
		upd_query := array_append(upd_query,
			'description = ' || quote_nullable(NEW.description));
	END IF;
	IF NEW.external_id IS DISTINCT FROM OLD.external_id THEN
		upd_query := array_append(upd_query,
			'external_id = ' || quote_nullable(NEW.external_id));
	END IF;

	IF upd_query IS NOT NULL THEN
		EXECUTE 'UPDATE service_environment SET ' ||
			array_to_string(upd_query, ', ') ||
			' WHERE service_environment_id = $1 RETURNING *'
		USING OLD.service_environment_id
		INTO _se;

		NEW.service_environment_id		:= _se.service_environment_id;
		NEW.service_environment_name	:= _se.service_environment_name;
		NEW.production_state			:= _se.production_state;
		NEW.description					:= _se.description;
		NEW.external_id					:= _se.external_id;
		NEW.data_ins_user 				:= _se.data_ins_user;
		NEW.data_ins_date 				:= _se.data_ins_date;
		NEW.data_upd_user 				:= _se.data_upd_user;
		NEW.data_upd_date 				:= _se.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	_ni		network_interface%ROWTYPE;
BEGIN
	IF OLD.netblock_id IS NOT NULL THEN
		DELETE FROM network_interface_netblock
		WHERE network_interface_id = OLD.network_interface_id
		AND netblock_id = OLD.netblock_id;
	END IF;

	DELETE FROM network_interface
	WHERE network_interface_id = OLD.network_interface_id;

	RETURN OLD;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	_ni	network_interface%ROWTYPE;
BEGIN
	INSERT INTO network_interface (
		device_id,
		network_interface_name, description,
		parent_network_interface_id,
		parent_relation_type, physical_port_id,
		slot_id, logical_port_id,
		network_interface_type, is_interface_up,
		mac_addr, should_monitor,
		should_manage
	) VALUES (
		NEW.device_id,
		NEW.network_interface_name, NEW.description,
		NEW.parent_network_interface_id,
		NEW.parent_relation_type, NEW.physical_port_id,
		NEW.slot_id, NEW.logical_port_id,
		NEW.network_interface_type, NEW.is_interface_up,
		NEW.mac_addr, NEW.should_monitor,
		NEW.should_manage
	) RETURNING * INTO _ni;

	IF NEW.netblock_id IS NOT NULL THEN
		INSERT INTO network_interface_netblock (
			network_interface_id, netblock_id
		) VALUES (
			_ni.network_interface_id, NEW.netblock_id
		);
	END IF;

	NEW.network_interface_id := _ni.network_interface_id;
	NEW.device_id := _ni.device_id;
	NEW.network_interface_name := _ni.network_interface_name;
	NEW.description := _ni.description;
	NEW.parent_network_interface_id := _ni.parent_network_interface_id;
	NEW.parent_relation_type := _ni.parent_relation_type;
	NEW.physical_port_id := _ni.physical_port_id;
	NEW.slot_id := _ni.slot_id;
	NEW.logical_port_id := _ni.logical_port_id;
	NEW.network_interface_type := _ni.network_interface_type;
	NEW.is_interface_up := _ni.is_interface_up;
	NEW.mac_addr := _ni.mac_addr;
	NEW.should_monitor := _ni.should_monitor;
	NEW.should_manage := _ni.should_manage;
	NEW.data_ins_user :=_ni.data_ins_user;
	NEW.data_ins_date := _ni.data_ins_date;
	NEW.data_upd_user := _ni.data_upd_user;
	NEW.data_upd_date := _ni.data_upd_date;


	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	upd_query		TEXT[];
	_ni				network_interface%ROWTYPE;
BEGIN
	IF OLD.network_interface_id IS DISTINCT FROM NEW.network_interface_id THEN
		RAISE EXCEPTION 'May not update network_interface_id'
		USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.netblock_id IS DISTINCT FROM NEW.netblock_id THEN
		IF OLD.netblock_id IS NULL THEN
			INSERT INTO network_interface_netblock (
				network_interface_id, netblock_id
			) VALUES (
				NEW.network_interface_id, NEW.netblock_id
			);
		ELSIF NEW.netblock_id IS NULL THEN
			DELETE FROM network_interface_netblock
			WHERE network_interface_id = OLD.network_interface_id
			AND netblock_id = OLD.netblock_id;

			WITH x AS (
				SELECT *,
				rank() OVER (PARTITION BY
					network_interface_id ORDER BY
					network_interface_rank) AS rnk
				FROM network_interface_netblock
				WHERE network_interface_id = NEW.network_interface_id
			) SELECT netblock_id
			INTO NEW.netblock_id
				FROM x
				WHERE x.rnk = 1;
		ELSE
			UPDATE network_interface_netblock
			SET netblock_id = NEW.netblock_id
			WHERE netblock_id = OLD.netblock_id
			AND network_interface_id = NEW.network_interface_id;
		END IF;
	END IF;

	upd_query := NULL;
		IF NEW.device_id IS DISTINCT FROM OLD.device_id THEN
			upd_query := array_append(upd_query,
				'device_id = ' || quote_nullable(NEW.device_id));
		END IF;
		IF NEW.network_interface_name IS DISTINCT FROM OLD.network_interface_name THEN
			upd_query := array_append(upd_query,
				'network_interface_name = ' || quote_nullable(NEW.network_interface_name));
		END IF;
		IF NEW.description IS DISTINCT FROM OLD.description THEN
			upd_query := array_append(upd_query,
				'description = ' || quote_nullable(NEW.description));
		END IF;
		IF NEW.parent_network_interface_id IS DISTINCT FROM OLD.parent_network_interface_id THEN
			upd_query := array_append(upd_query,
				'parent_network_interface_id = ' || quote_nullable(NEW.parent_network_interface_id));
		END IF;
		IF NEW.parent_relation_type IS DISTINCT FROM OLD.parent_relation_type THEN
			upd_query := array_append(upd_query,
				'parent_relation_type = ' || quote_nullable(NEW.parent_relation_type));
		END IF;
		IF NEW.physical_port_id IS DISTINCT FROM OLD.physical_port_id THEN
			upd_query := array_append(upd_query,
				'physical_port_id = ' || quote_nullable(NEW.physical_port_id));
		END IF;
		IF NEW.slot_id IS DISTINCT FROM OLD.slot_id THEN
			upd_query := array_append(upd_query,
				'slot_id = ' || quote_nullable(NEW.slot_id));
		END IF;
		IF NEW.logical_port_id IS DISTINCT FROM OLD.logical_port_id THEN
			upd_query := array_append(upd_query,
				'logical_port_id = ' || quote_nullable(NEW.logical_port_id));
		END IF;
		IF NEW.network_interface_type IS DISTINCT FROM OLD.network_interface_type THEN
			upd_query := array_append(upd_query,
				'network_interface_type = ' || quote_nullable(NEW.network_interface_type));
		END IF;
		IF NEW.is_interface_up IS DISTINCT FROM OLD.is_interface_up THEN
			upd_query := array_append(upd_query,
				'is_interface_up = ' || quote_nullable(NEW.is_interface_Up));
		END IF;
		IF NEW.mac_addr IS DISTINCT FROM OLD.mac_addr THEN
			upd_query := array_append(upd_query,
				'mac_addr = ' || quote_nullable(NEW.mac_addr));
		END IF;
		IF NEW.should_monitor IS DISTINCT FROM OLD.should_monitor THEN
			upd_query := array_append(upd_query,
				'should_monitor = ' || quote_nullable(NEW.should_monitor));
		END IF;
		IF NEW.should_manage IS DISTINCT FROM OLD.should_manage THEN
			upd_query := array_append(upd_query,
				'should_manage = ' || quote_nullable(NEW.should_manage));
		END IF;

		IF upd_query IS NOT NULL THEN
			EXECUTE 'UPDATE network_interface SET ' ||
				array_to_string(upd_query, ', ') ||
				' WHERE network_interface_id = $1 RETURNING *'
			USING OLD.network_interface_id
			INTO _ni;

			NEW.device_id := _ni.device_id;
			NEW.network_interface_name := _ni.network_interface_name;
			NEW.description := _ni.description;
			NEW.parent_network_interface_id := _ni.parent_network_interface_id;
			NEW.parent_relation_type := _ni.parent_relation_type;
			NEW.physical_port_id := _ni.physical_port_id;
			NEW.slot_id := _ni.slot_id;
			NEW.logical_port_id := _ni.logical_port_id;
			NEW.network_interface_type := _ni.network_interface_type;
			NEW.is_interface_up := _ni.is_interface_up;
			NEW.mac_addr := _ni.mac_addr;
			NEW.should_monitor := _ni.should_monitor;
			NEW.should_manage := _ni.should_manage;
			NEW.data_ins_user := _ni.data_ins_user;
			NEW.data_ins_date := _ni.data_ins_date;
			NEW.data_upd_user := _ni.data_upd_user;
			NEW.data_upd_date := _ni.data_upd_date;
		END IF;
	RETURN NEW;
END;
$function$
;

--
-- Process proc drops in net_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process proc drops in network_strings
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process proc drops in time_util
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process proc drops in dns_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
--
-- Process proc drops in obfuscation_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process proc drops in person_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process proc drops in account_password_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
--
-- Process proc drops in auto_ac_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process proc drops in company_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
--
-- Process proc drops in token_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
--
-- Process proc drops in device_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process proc drops in device_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
--
-- Process proc drops in netblock_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process proc drops in property_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
--
-- Process proc drops in netblock_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process proc drops in physical_address_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process proc drops in component_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process proc drops in snapshot_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process proc drops in lv_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process proc drops in approval_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
--
-- Process proc drops in account_collection_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process proc drops in script_hooks
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process proc drops in backend_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
--
-- Process proc drops in rack_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process proc drops in layerx_network_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process proc drops in component_connection_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process proc drops in logical_port_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process proc drops in port_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process proc drops in pgcrypto
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process proc drops in audit
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Recreate the saved views in the base schema
--
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', type := 'view');


-- BEGIN Misc that does not apply to above
INSERT INTO val_encryption_key_purpose (
        encryption_key_purpose, encryption_key_purpose_version, description
) VALUES (
        'external', 1, 'Key is stored  outside the database'
);

INSERT INTO val_property_data_type ( PROPERTY_DATA_TYPE )
VALUES
        ('encryption_key_id'),
        ('private_key_id');

DELETE FROM val_property_data_type
WHERE PROPERTY_DATA_TYPE NOT IN
	('list', 'number', 'string', 'account_collection_id',
	'boolean', 'device_collection_id', 'encryption_key_id',
	'json', 'netblock_collection_id', 'password_type',
	'private_key_id', 'sw_package_id', 'timestamp',
	'token_collection_id', 'none');


-- END Misc that does not apply to above
--
-- BEGIN: process_ancillary_schema(jazzhands_legacy)
--
--------------------------------------------------------------------
-- DEALING WITH TABLE device_power_connection
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'device_power_connection', 'device_power_connection');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'device_power_connection', tags := ARRAY['view_device_power_connection']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_device_slots', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.device_power_connection;
CREATE VIEW jazzhands_legacy.device_power_connection AS
 WITH slotdev AS (
         SELECT slot.slot_id,
            slot.slot_name,
            v_device_slots.device_id
           FROM jazzhands.slot
             JOIN jazzhands.v_device_slots USING (slot_id)
             JOIN jazzhands.slot_type st USING (slot_type_id)
          WHERE st.slot_function::text = 'power'::text
        )
 SELECT icc.inter_component_connection_id AS device_power_connection_id,
    icc.inter_component_connection_id,
    s1.device_id AS rpc_device_id,
    s1.slot_name AS rpc_power_interface_port,
    s2.slot_name AS power_interface_port,
    s2.device_id,
    icc.data_ins_user,
    icc.data_ins_date,
    icc.data_upd_user,
    icc.data_upd_date
   FROM jazzhands.inter_component_connection icc
     JOIN slotdev s1 ON icc.slot1_id = s1.slot_id
     JOIN slotdev s2 ON icc.slot2_id = s2.slot_id;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('device_power_connection','device_power_connection');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_connection','device_power_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of device_power_connection failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_connection');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_connection');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for device_power_connection  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE device_power_connection (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_power_connection failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new device_power_connection failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE device_power_interface
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'device_power_interface', 'device_power_interface');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'device_power_interface', tags := ARRAY['view_device_power_interface']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_device_slots', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.device_power_interface;
CREATE VIEW jazzhands_legacy.device_power_interface AS
 WITH pdu AS (
         SELECT component_property.slot_type_id,
            component_property.property_value::integer AS property_value
           FROM jazzhands.component_property
          WHERE component_property.component_property_type::text = 'PDU'::text
        ), provides AS (
         SELECT component_property.slot_type_id,
            component_property.property_value
           FROM jazzhands.component_property
          WHERE component_property.component_property_type::text = 'power_supply'::text AND component_property.component_property_name::text = 'Provides'::text
        )
 SELECT d.device_id,
    s.slot_name AS power_interface_port,
    st.slot_physical_interface_type AS power_plug_style,
    vlt.property_value AS voltage,
    amp.property_value AS max_amperage,
    p.property_value::text AS provides_power,
    s.data_ins_user,
    s.data_ins_date,
    s.data_upd_user,
    s.data_upd_date
   FROM jazzhands.slot s
     JOIN jazzhands.slot_type st USING (slot_type_id)
     JOIN provides p USING (slot_type_id)
     JOIN pdu vlt USING (slot_type_id)
     JOIN pdu amp USING (slot_type_id)
     JOIN jazzhands.v_device_slots d USING (slot_id)
  WHERE st.slot_function::text = 'power'::text;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('device_power_interface','device_power_interface');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_interface','device_power_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of device_power_interface failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_interface');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('device_power_interface');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for device_power_interface  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE device_power_interface (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_interface');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_power_interface failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_interface');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_power_interface');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new device_power_interface failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE dns_domain
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'dns_domain', 'dns_domain');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'dns_domain', tags := ARRAY['view_dns_domain']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.dns_domain;
CREATE VIEW jazzhands_legacy.dns_domain AS
 SELECT dns_domain.dns_domain_id,
    dns_domain.dns_domain_name AS soa_name,
    dns_domain.dns_domain_name,
    dns_domain.dns_domain_type,
    dns_domain.parent_dns_domain_id,
    dns_domain.description,
    dns_domain.external_id,
    dns_domain.data_ins_user,
    dns_domain.data_ins_date,
    dns_domain.data_upd_user,
    dns_domain.data_upd_date
   FROM jazzhands.dns_domain;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('dns_domain','dns_domain');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('dns_domain','dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of dns_domain failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.dns_domain_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.dns_domain_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%ROWTYPE;
BEGIN
	IF NEW.dns_domain_name IS NOT NULL and NEW.soa_name IS NOT NULL THEN
		RAISE EXCEPTION 'Must only set dns_domain_name, not soa_name'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF NEW.dns_domain_id IS NULL THEN
		INSERT INTO jazzhands.dns_domain (
			dns_domain_name,
			dns_domain_type,
			parent_dns_domain_id,
			description,
			external_id,
			data_ins_user,
			data_ins_date,
			data_upd_user,
			data_upd_date
		) VALUES (
			coalesce(NEW.dns_domain_name, NEW.soa_name),
			NEW.dns_domain_type,
			NEW.parent_dns_domain_id,
			NEW.description,
			NEW.external_id,
			NEW.data_ins_user,
			NEW.data_ins_date,
			NEW.data_upd_user,
			NEW.data_upd_date
		) RETURNING * INTO _d;
	ELSE
		INSERT INTO jazzhands.dns_domain (
			dns_domain_id,
			dns_domain_name,
			dns_domain_type,
			parent_dns_domain_id,
			description,
			external_id,
			data_ins_user,
			data_ins_date,
			data_upd_user,
			data_upd_date
		) VALUES (
			NEW.dns_domain_id,
			coalesce(NEW.dns_domain_name, NEW.soa_name),
			NEW.dns_domain_type,
			NEW.parent_dns_domain_id,
			NEW.description,
			NEW.external_id,
			NEW.data_ins_user,
			NEW.data_ins_date,
			NEW.data_upd_user,
			NEW.data_upd_date
		) RETURNING * INTO _d;
	END IF;

	NEW.dns_domain_id			= _d.dns_domain_id;
	NEW.soa_name				= _d.dns_domain_name;
	NEW.dns_domain_name			= _d.dns_domain_name;
	NEW.dns_domain_type			= _d.dns_domain_type;
	NEW.parent_dns_domain_id	= _d.parent_dns_domain_id;
	NEW.description				= _d.description;
	NEW.external_id				= _d.external_id;
	NEW.data_ins_user			= _d.data_ins_user;
	NEW.data_ins_date			= _d.data_ins_date;
	NEW.data_upd_user			= _d.data_upd_user;
	NEW.data_upd_date			= _d.data_upd_date;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_domain_ins INSTEAD OF INSERT ON jazzhands_legacy.dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.dns_domain_ins();

-- considering NEW jazzhands_legacy.dns_domain_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.dns_domain_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%ROWTYPE;
	_uq	TEXT[];
BEGIN
	IF OLD.dns_domain_name IS DISTINCT FROM NEW.dns_domain_name
		AND OLD.soa_name IS DISTINCT FROM NEW.soa_name
	 THEN
		RAISE EXCEPTION 'Must only change dns_domain_name OR soa_name'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.dns_domain_id IS DISTINCT FROM NEW.dns_domain_id THEN
		_uq := array_append(_uq, 'dns_domain_id = ' || quote_nullable(NEW.dns_domain_id));
	END IF;

	IF OLD.dns_domain_name IS DISTINCT FROM NEW.dns_domain_name THEN
		_uq := array_append(_uq, 'dns_domain_name = ' || quote_nullable(NEW.dns_domain_name));
	END IF;

	IF OLD.soa_name IS DISTINCT FROM NEW.soa_name THEN
		_uq := array_append(_uq, 'dns_domain_name = ' || quote_nullable(NEW.soa_name));
	END IF;

	IF OLD.dns_domain_type IS DISTINCT FROM NEW.dns_domain_type THEN
		_uq := array_append(_uq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	IF OLD.parent_dns_domain_id IS DISTINCT FROM NEW.parent_dns_domain_id THEN
		_uq := array_append(_uq, 'parent_dns_domain_id = ' || quote_nullable(NEW.parent_dns_domain_id));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
		_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.external_id IS DISTINCT FROM NEW.external_id THEN
		_uq := array_append(_uq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  dns_domain_id = $1 RETURNING *'
			USING OLD.dns_domain_id
			INTO _d;

		NEW.dns_domain_id			= _d.dns_domain_id;
		NEW.soa_name				= _d.dns_domain_name;
		NEW.dns_domain_name			= _d.dns_domain_name;
		NEW.dns_domain_type			= _d.dns_domain_type;
		NEW.parent_dns_domain_id	= _d.parent_dns_domain_id;
		NEW.description				= _d.description;
		NEW.external_id				= _d.external_id;
		NEW.data_ins_user			= _d.data_ins_user;
		NEW.data_ins_date			= _d.data_ins_date;
		NEW.data_upd_user			= _d.data_upd_user;
		NEW.data_upd_date			= _d.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_dns_domain_upd INSTEAD OF UPDATE ON jazzhands_legacy.dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.dns_domain_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('dns_domain');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('dns_domain');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for dns_domain  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE dns_domain (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old dns_domain failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('dns_domain');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('dns_domain');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new dns_domain failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE layer1_connection
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'layer1_connection', 'layer1_connection');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'layer1_connection', tags := ARRAY['view_layer1_connection']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.layer1_connection;
CREATE VIEW jazzhands_legacy.layer1_connection AS
 WITH conn_props AS (
         SELECT component_property.inter_component_connection_id,
            component_property.component_property_name,
            component_property.component_property_type,
            component_property.property_value
           FROM jazzhands.component_property
          WHERE component_property.component_property_type::text = 'serial-connection'::text
        ), tcpsrv_device_id AS (
         SELECT component_property.inter_component_connection_id,
            device.device_id
           FROM jazzhands.component_property
             JOIN jazzhands.device USING (component_id)
          WHERE component_property.component_property_type::text = 'tcpsrv-connections'::text AND component_property.component_property_name::text = 'tcpsrv_device_id'::text
        ), tcpsrv_enabled AS (
         SELECT component_property.inter_component_connection_id,
            component_property.property_value
           FROM jazzhands.component_property
          WHERE component_property.component_property_type::text = 'tcpsrv-connections'::text AND component_property.component_property_name::text = 'tcpsrv_enabled'::text
        )
 SELECT icc.inter_component_connection_id AS layer1_connection_id,
    icc.slot1_id AS physical_port1_id,
    icc.slot2_id AS physical_port2_id,
    icc.circuit_id,
    baud.property_value::integer AS baud,
    dbits.property_value::integer AS data_bits,
    sbits.property_value::integer AS stop_bits,
    parity.property_value AS parity,
    flow.property_value AS flow_control,
    tcpsrv.device_id AS tcpsrv_device_id,
    COALESCE(tcpsrvon.property_value, 'N'::character varying)::character(1) AS is_tcpsrv_enabled,
    icc.data_ins_user,
    icc.data_ins_date,
    icc.data_upd_user,
    icc.data_upd_date
   FROM jazzhands.inter_component_connection icc
     JOIN jazzhands.slot s1 ON icc.slot1_id = s1.slot_id
     JOIN jazzhands.slot_type st1 ON st1.slot_type_id = s1.slot_type_id
     JOIN jazzhands.slot s2 ON icc.slot2_id = s2.slot_id
     JOIN jazzhands.slot_type st2 ON st2.slot_type_id = s2.slot_type_id
     LEFT JOIN tcpsrv_device_id tcpsrv USING (inter_component_connection_id)
     LEFT JOIN tcpsrv_enabled tcpsrvon USING (inter_component_connection_id)
     LEFT JOIN conn_props baud ON baud.inter_component_connection_id = icc.inter_component_connection_id AND baud.component_property_name::text = 'baud'::text
     LEFT JOIN conn_props dbits ON dbits.inter_component_connection_id = icc.inter_component_connection_id AND dbits.component_property_name::text = 'data-bits'::text
     LEFT JOIN conn_props sbits ON sbits.inter_component_connection_id = icc.inter_component_connection_id AND sbits.component_property_name::text = 'stop-bits'::text
     LEFT JOIN conn_props parity ON parity.inter_component_connection_id = icc.inter_component_connection_id AND parity.component_property_name::text = 'parity'::text
     LEFT JOIN conn_props flow ON flow.inter_component_connection_id = icc.inter_component_connection_id AND flow.component_property_name::text = 'flow-control'::text
  WHERE (st1.slot_function::text = ANY (ARRAY['network'::character varying, 'serial'::character varying, 'patchpanel'::character varying]::text[])) OR (st1.slot_function::text = ANY (ARRAY['network'::character varying, 'serial'::character varying, 'patchpanel'::character varying]::text[]));

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('layer1_connection','layer1_connection');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('layer1_connection','layer1_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of layer1_connection failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.do_layer1_connection_trigger
CREATE OR REPLACE FUNCTION jazzhands_legacy.do_layer1_connection_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO inter_component_connection (
			slot1_id,
			slot2_id,
			circuit_id
		) VALUES (
			NEW.physical_port1_id,
			NEW.physical_port2_id,
			NEW.circuit_id
		) RETURNING inter_component_connection_id INTO NEW.layer1_connection_id;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
		IF (NEW.layer1_connection_id IS DISTINCT FROM
				OLD.layer1_connection_id) OR
			(NEW.physical_port1_id IS DISTINCT FROM OLD.physical_port1_id) OR
			(NEW.physical_port2_id IS DISTINCT FROM OLD.physical_port2_id) OR
			(NEW.circuit_id IS DISTINCT FROM OLD.circuit_id)
		THEN
			UPDATE inter_component_connection
			SET
				inter_component_connection_id = NEW.layer1_connection_id,
				slot1_id = NEW.physical_port1_id,
				slot2_id = NEW.physical_port2_id,
				circuit_id = NEW.circuit_id
			WHERE
				inter_component_connection_id = OLD.layer1_connection_id;
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM inter_component_connection WHERE
			inter_component_connection_id = OLD.layer1_connection_id;
		RETURN OLD;
	END IF;
END; $function$
;
CREATE TRIGGER trigger_layer1_connection_insteadof INSTEAD OF INSERT OR DELETE OR UPDATE ON jazzhands_legacy.layer1_connection FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.do_layer1_connection_trigger();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('layer1_connection');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('layer1_connection');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer1_connection  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE layer1_connection (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('layer1_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('layer1_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer1_connection failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('layer1_connection');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('layer1_connection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer1_connection failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_interface_netblock
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'network_interface_netblock', 'network_interface_netblock');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'network_interface_netblock', tags := ARRAY['view_network_interface_netblock']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.network_interface_netblock;
CREATE VIEW jazzhands_legacy.network_interface_netblock AS
 SELECT layer3_interface_netblock.netblock_id,
    layer3_interface_netblock.layer3_interface_id AS network_interface_id,
    layer3_interface_netblock.device_id,
    layer3_interface_netblock.layer3_interface_rank AS network_interface_rank,
    layer3_interface_netblock.data_ins_user,
    layer3_interface_netblock.data_ins_date,
    layer3_interface_netblock.data_upd_user,
    layer3_interface_netblock.data_upd_date
   FROM jazzhands.layer3_interface_netblock;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('network_interface_netblock','network_interface_netblock');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_netblock','network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_netblock');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_netblock');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_interface_netblock  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_interface_netblock (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_netblock');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_netblock');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_interface_netblock failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'network_interface_purpose', 'network_interface_purpose');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'network_interface_purpose', tags := ARRAY['view_network_interface_purpose']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.network_interface_purpose;
CREATE VIEW jazzhands_legacy.network_interface_purpose AS
 SELECT layer3_interface_purpose.device_id,
    layer3_interface_purpose.layer3_interface_purpose AS network_interface_purpose,
    layer3_interface_purpose.layer3_interface_id AS network_interface_id,
    layer3_interface_purpose.description,
    layer3_interface_purpose.data_ins_user,
    layer3_interface_purpose.data_ins_date,
    layer3_interface_purpose.data_upd_user,
    layer3_interface_purpose.data_upd_date
   FROM jazzhands.layer3_interface_purpose;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('network_interface_purpose','network_interface_purpose');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_purpose','network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_interface_purpose (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE network_service
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'network_service', 'network_service');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'network_service', tags := ARRAY['view_network_service']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.network_service;
CREATE VIEW jazzhands_legacy.network_service AS
 SELECT network_service.network_service_id,
    network_service.name,
    network_service.description,
    network_service.network_service_type,
        CASE
            WHEN network_service.is_monitored IS NULL THEN NULL::text
            WHEN network_service.is_monitored = true THEN 'Y'::text
            WHEN network_service.is_monitored = false THEN 'N'::text
            ELSE NULL::text
        END AS is_monitored,
    network_service.device_id,
    network_service.layer3_interface_id AS network_interface_id,
    network_service.dns_record_id,
    network_service.service_environment_id,
    network_service.data_ins_user,
    network_service.data_ins_date,
    network_service.data_upd_user,
    network_service.data_upd_date
   FROM jazzhands.network_service;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('network_service','network_service');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_service','network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of network_service failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.network_service_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.network_service_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.network_service%rowtype;
BEGIN
	DELETE FROM jazzhands.network_service
	WHERE  network_service_id = OLD.network_service_id  RETURNING *
	INTO _or;
	OLD.network_service_id = _or.network_service_id;
	OLD.name = _or.name;
	OLD.description = _or.description;
	OLD.network_service_type = _or.network_service_type;
	OLD.is_monitored = CASE WHEN _or.is_monitored = true THEN 'Y' WHEN _or.is_monitored = false THEN 'N' ELSE NULL END;
	OLD.device_id = _or.device_id;
	OLD.network_interface_id = _or.network_interface_id;
	OLD.dns_record_id = _or.dns_record_id;
	OLD.service_environment_id = _or.service_environment_id;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_network_service_del INSTEAD OF DELETE ON jazzhands_legacy.network_service FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.network_service_del();

-- considering NEW jazzhands_legacy.network_service_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.network_service_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.network_service%rowtype;
BEGIN

	IF NEW.network_service_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_service_id'));
		_vq := array_append(_vq, quote_nullable(NEW.network_service_id));
	END IF;

	IF NEW.name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('name'));
		_vq := array_append(_vq, quote_nullable(NEW.name));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.network_service_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_service_type'));
		_vq := array_append(_vq, quote_nullable(NEW.network_service_type));
	END IF;

	IF NEW.is_monitored IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_monitored'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_monitored = 'Y' THEN true WHEN NEW.is_monitored = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.device_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_id'));
		_vq := array_append(_vq, quote_nullable(NEW.device_id));
	END IF;

	IF NEW.network_interface_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_interface_id'));
		_vq := array_append(_vq, quote_nullable(NEW.network_interface_id));
	END IF;

	IF NEW.dns_record_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_record_id'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_record_id));
	END IF;

	IF NEW.service_environment_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_id'));
		_vq := array_append(_vq, quote_nullable(NEW.service_environment_id));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.network_service (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.network_service_id = _nr.network_service_id;
	NEW.name = _nr.name;
	NEW.description = _nr.description;
	NEW.network_service_type = _nr.network_service_type;
	NEW.is_monitored = CASE WHEN _nr.is_monitored = true THEN 'Y' WHEN _nr.is_monitored = false THEN 'N' ELSE NULL END;
	NEW.device_id = _nr.device_id;
	NEW.network_interface_id = _nr.network_interface_id;
	NEW.dns_record_id = _nr.dns_record_id;
	NEW.service_environment_id = _nr.service_environment_id;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_network_service_ins INSTEAD OF INSERT ON jazzhands_legacy.network_service FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.network_service_ins();

-- considering NEW jazzhands_legacy.network_service_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.network_service_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.network_service%rowtype;
	_nr	jazzhands.network_service%rowtype;
	_uq	text[];
BEGIN

	IF OLD.network_service_id IS DISTINCT FROM NEW.network_service_id THEN
_uq := array_append(_uq, 'network_service_id = ' || quote_nullable(NEW.network_service_id));
	END IF;

	IF OLD.name IS DISTINCT FROM NEW.name THEN
_uq := array_append(_uq, 'name = ' || quote_nullable(NEW.name));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.network_service_type IS DISTINCT FROM NEW.network_service_type THEN
_uq := array_append(_uq, 'network_service_type = ' || quote_nullable(NEW.network_service_type));
	END IF;

	IF OLD.is_monitored IS DISTINCT FROM NEW.is_monitored THEN
IF NEW.is_monitored = 'Y' THEN
	_uq := array_append(_uq, 'is_monitored = true');
ELSIF NEW.is_monitored = 'N' THEN
	_uq := array_append(_uq, 'is_monitored = false');
ELSE
	_uq := array_append(_uq, 'is_monitored = NULL');
END IF;
	END IF;

	IF OLD.device_id IS DISTINCT FROM NEW.device_id THEN
_uq := array_append(_uq, 'device_id = ' || quote_nullable(NEW.device_id));
	END IF;

	IF OLD.network_interface_id IS DISTINCT FROM NEW.network_interface_id THEN
_uq := array_append(_uq, 'network_interface_id = ' || quote_nullable(NEW.network_interface_id));
	END IF;

	IF OLD.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
_uq := array_append(_uq, 'dns_record_id = ' || quote_nullable(NEW.dns_record_id));
	END IF;

	IF OLD.service_environment_id IS DISTINCT FROM NEW.service_environment_id THEN
_uq := array_append(_uq, 'service_environment_id = ' || quote_nullable(NEW.service_environment_id));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.network_service SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  network_service_id = $1 RETURNING *'  USING OLD.network_service_id
			INTO _nr;

		NEW.network_service_id = _nr.network_service_id;
		NEW.name = _nr.name;
		NEW.description = _nr.description;
		NEW.network_service_type = _nr.network_service_type;
		NEW.is_monitored = CASE WHEN _nr.is_monitored = true THEN 'Y' WHEN _nr.is_monitored = false THEN 'N' ELSE NULL END;
		NEW.device_id = _nr.device_id;
		NEW.network_interface_id = _nr.network_interface_id;
		NEW.dns_record_id = _nr.dns_record_id;
		NEW.service_environment_id = _nr.service_environment_id;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_network_service_upd INSTEAD OF UPDATE ON jazzhands_legacy.network_service FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.network_service_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('network_service');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('network_service');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for network_service  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE network_service (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old network_service failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_service');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('network_service');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new network_service failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE physical_port
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'physical_port', 'physical_port');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'physical_port', tags := ARRAY['view_physical_port']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_device_slots', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.physical_port;
CREATE VIEW jazzhands_legacy.physical_port AS
 SELECT sl.slot_id AS physical_port_id,
    d.device_id,
    sl.slot_name AS port_name,
    st.slot_function AS port_type,
    sl.description,
    st.slot_physical_interface_type AS port_plug_style,
    NULL::text AS port_medium,
    NULL::text AS port_protocol,
    NULL::text AS port_speed,
    sl.physical_label,
    NULL::text AS port_purpose,
    NULL::integer AS logical_port_id,
    NULL::integer AS tcp_port,
        CASE
            WHEN ct.is_removable = true THEN 'N'::text
            ELSE 'Y'::text
        END AS is_hardwired,
    sl.data_ins_user,
    sl.data_ins_date,
    sl.data_upd_user,
    sl.data_upd_date
   FROM jazzhands.slot sl
     JOIN jazzhands.slot_type st USING (slot_type_id)
     JOIN jazzhands.v_device_slots d USING (slot_id)
     JOIN jazzhands.component c ON sl.component_id = c.component_id
     JOIN jazzhands.component_type ct USING (component_type_id)
  WHERE st.slot_function::text = ANY (ARRAY['network'::character varying, 'serial'::character varying, 'patchpanel'::character varying]::text[]);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('physical_port','physical_port');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('physical_port','physical_port');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of physical_port failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.do_physical_port_trigger
CREATE OR REPLACE FUNCTION jazzhands_legacy.do_physical_port_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		RAISE EXCEPTION 'Physical ports must be inserted as component slots';
	ELSIF TG_OP = 'UPDATE' THEN
		IF (NEW.physical_port_id IS DISTINCT FROM OLD.physical_port_id) OR
			(NEW.device_id IS DISTINCT FROM OLD.device_id) OR
			(NEW.port_type IS DISTINCT FROM OLD.port_type) OR
			(NEW.port_plug_style IS DISTINCT FROM OLD.port_plug_style) OR
			(NEW.port_medium IS DISTINCT FROM OLD.port_medium) OR
			(NEW.port_protocol IS DISTINCT FROM OLD.port_protocol) OR
			(NEW.port_speed IS DISTINCT FROM OLD.port_speed) OR
			(NEW.port_purpose IS DISTINCT FROM OLD.port_purpose) OR
			(NEW.logical_port_id IS DISTINCT FROM OLD.logical_port_id) OR
			(NEW.tcp_port IS DISTINCT FROM OLD.tcp_port) OR
			(NEW.is_hardwired IS DISTINCT FROM OLD.is_hardwired)
		THEN
			RAISE EXCEPTION 'Attempted to update a deprecated physical_port attribute that must be changed on the slot now';
		END IF;
		IF (NEW.port_name IS DISTINCT FROM OLD.port_name) OR
			(NEW.description IS DISTINCT FROM OLD.description) OR
			(NEW.physical_label IS DISTINCT FROM OLD.physical_label)
		THEN
			UPDATE slot
			SET
				slot_name = NEW.port_name,
				description = NEW.description,
				physical_label = NEW.physical_label
			WHERE
				slot_id = NEW.physical_port_id;
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM slot WHERE
			slot_id = OLD.physical_port_id;
		RETURN OLD;
	END IF;
END; $function$
;
CREATE TRIGGER trigger_physical_port_insteadof INSTEAD OF INSERT OR DELETE OR UPDATE ON jazzhands_legacy.physical_port FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.do_physical_port_trigger();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('physical_port');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('physical_port');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for physical_port  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE physical_port (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('physical_port');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('physical_port');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old physical_port failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('physical_port');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('physical_port');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new physical_port failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property', 'property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'property', tags := ARRAY['view_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.property;
CREATE VIEW jazzhands_legacy.property AS
 SELECT property.property_id,
    property.account_collection_id,
    property.account_id,
    property.account_realm_id,
    property.company_collection_id,
    property.company_id,
    property.device_collection_id,
    property.dns_domain_collection_id,
    property.layer2_network_collection_id,
    property.layer3_network_collection_id,
    property.netblock_collection_id,
    property.network_range_id,
    property.operating_system_id,
    property.operating_system_snapshot_id,
    property.property_name_collection_id AS property_collection_id,
    property.service_environment_collection_id AS service_env_collection_id,
    property.site_code,
    property.x509_signed_certificate_id,
    property.property_name,
    property.property_type,
        CASE
            WHEN property.property_value_boolean = true THEN 'Y'::character varying
            WHEN property.property_value_boolean = false THEN 'N'::character varying
            ELSE property.property_value
        END AS property_value,
    property.property_value_timestamp,
    property.property_value_account_collection_id AS property_value_account_coll_id,
    property.property_value_device_collection_id AS property_value_device_coll_id,
    property.property_value_json,
    property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    property.property_value_password_type,
    property.property_value_sw_package_id,
    property.property_value_token_collection_id AS property_value_token_col_id,
    property.property_rank,
    property.start_date,
    property.finish_date,
        CASE
            WHEN property.is_enabled IS NULL THEN NULL::text
            WHEN property.is_enabled = true THEN 'Y'::text
            WHEN property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    property.data_ins_user,
    property.data_ins_date,
    property.data_upd_user,
    property.data_upd_date
   FROM jazzhands.property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('property','property');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('property','property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.property_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN
	DELETE FROM jazzhands.property
	WHERE  property_id = OLD.property_id  RETURNING *
	INTO _or;

	SELECT property_data_type INTO _dt
	FROM val_property
	WHERE property_name = OLD.property_name
	AND property_type = OLD.property_type;

	OLD.property_id = _or.property_id;
	OLD.account_collection_id = _or.account_collection_id;
	OLD.account_id = _or.account_id;
	OLD.account_realm_id = _or.account_realm_id;
	OLD.company_collection_id = _or.company_collection_id;
	OLD.company_id = _or.company_id;
	OLD.device_collection_id = _or.device_collection_id;
	OLD.dns_domain_collection_id = _or.dns_domain_collection_id;
	OLD.layer2_network_collection_id = _or.layer2_network_collection_id;
	OLD.layer3_network_collection_id = _or.layer3_network_collection_id;
	OLD.netblock_collection_id = _or.netblock_collection_id;
	OLD.network_range_id = _or.network_range_id;
	OLD.operating_system_id = _or.operating_system_id;
	OLD.operating_system_snapshot_id = _or.operating_system_snapshot_id;
	OLD.property_collection_id = _or.property_name_collection_id;
	OLD.service_env_collection_id = _or.service_environment_collection_id;
	OLD.site_code = _or.site_code;
	OLD.x509_signed_certificate_id = _or.x509_signed_certificate_id;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		OLD.property_value = CASE
			WHEN _or.property_value_boolean = true THEN 'Y'
			WHEN _or.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		OLD.property_value = _or.property_value;
	END IF;
	OLD.property_value_timestamp = _or.property_value_timestamp;
	OLD.property_value_account_coll_id = _or.property_value_account_collection_id;
	OLD.property_value_device_coll_id = _or.property_value_device_collection_id;
	OLD.property_value_json = _or.property_value_json;
	OLD.property_value_nblk_coll_id = _or.property_value_netblock_collection_id;
	OLD.property_value_password_type = _or.property_value_password_type;
	OLD.property_value_sw_package_id = _or.property_value_sw_package_id;
	OLD.property_value_token_col_id = _or.property_value_token_collection_id;
	OLD.property_rank = _or.property_rank;
	OLD.start_date = _or.start_date;
	OLD.finish_date = _or.finish_date;
	OLD.is_enabled = CASE WHEN _or.is_enabled = true THEN 'Y' WHEN _or.is_enabled = false THEN 'N' ELSE NULL END;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_property_del INSTEAD OF DELETE ON jazzhands_legacy.property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.property_del();

-- considering NEW jazzhands_legacy.property_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN

	IF NEW.property_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_id));
	END IF;

	IF NEW.account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_id));
	END IF;

	IF NEW.account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_id));
	END IF;

	IF NEW.account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_realm_id));
	END IF;

	IF NEW.company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_id));
	END IF;

	IF NEW.company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_id));
	END IF;

	IF NEW.device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_id));
	END IF;

	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF NEW.netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF NEW.network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_id));
	END IF;

	IF NEW.operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_id));
	END IF;

	IF NEW.operating_system_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF NEW.property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_id));
	END IF;

	IF NEW.service_env_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF NEW.site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.site_code));
	END IF;

	IF NEW.x509_signed_certificate_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.property_value IS NOT NULL THEN
		SELECT property_data_type INTO _dt
			FROM val_property
			WHERE property_name = NEW.property_name
			AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			_cq := array_append(_cq, quote_ident('property_value_boolean'));
			_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.property_value = 'Y' THEN true WHEN NEW.property_value = 'N' THEN false ELSE NULL END) || '::boolean');
		ELSE
			_cq := array_append(_cq, quote_ident('property_value'));
			_vq := array_append(_vq, quote_nullable(NEW.property_value));
		END IF;
	END IF;

	IF NEW.property_value_timestamp IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_timestamp'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF NEW.property_value_account_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF NEW.property_value_device_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF NEW.property_value_json IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json));
	END IF;

	IF NEW.property_value_nblk_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF NEW.property_value_password_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_password_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_password_type));
	END IF;

	IF NEW.property_value_sw_package_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_sw_package_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_sw_package_id));
	END IF;

	IF NEW.property_value_token_col_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_token_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF NEW.property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.property_rank));
	END IF;

	IF NEW.start_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('start_date'));
		_vq := array_append(_vq, quote_nullable(NEW.start_date));
	END IF;

	IF NEW.finish_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('finish_date'));
		_vq := array_append(_vq, quote_nullable(NEW.finish_date));
	END IF;

	IF NEW.is_enabled IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_enabled'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_enabled = 'Y' THEN true WHEN NEW.is_enabled = 'N' THEN false ELSE NULL END));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_id = _nr.property_id;
	NEW.account_collection_id = _nr.account_collection_id;
	NEW.account_id = _nr.account_id;
	NEW.account_realm_id = _nr.account_realm_id;
	NEW.company_collection_id = _nr.company_collection_id;
	NEW.company_id = _nr.company_id;
	NEW.device_collection_id = _nr.device_collection_id;
	NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
	NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
	NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
	NEW.netblock_collection_id = _nr.netblock_collection_id;
	NEW.network_range_id = _nr.network_range_id;
	NEW.operating_system_id = _nr.operating_system_id;
	NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
	NEW.property_collection_id = _nr.property_name_collection_id;
	NEW.service_env_collection_id = _nr.service_environment_collection_id;
	NEW.site_code = _nr.site_code;
	NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		NEW.property_value = _nr.property_value;
	END IF;
	NEW.property_value_timestamp = _nr.property_value_timestamp;
	NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
	NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
	NEW.property_value_json = _nr.property_value_json;
	NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
	NEW.property_value_password_type = _nr.property_value_password_type;
	NEW.property_value_sw_package_id = _nr.property_value_sw_package_id;
	NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
	NEW.property_rank = _nr.property_rank;
	NEW.start_date = _nr.start_date;
	NEW.finish_date = _nr.finish_date;
	NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_property_ins INSTEAD OF INSERT ON jazzhands_legacy.property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.property_ins();

-- considering NEW jazzhands_legacy.property_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.property%rowtype;
	_nr	jazzhands.property%rowtype;
	_uq	text[];
	_dt	TEXT;
BEGIN

	IF OLD.property_id IS DISTINCT FROM NEW.property_id THEN
_uq := array_append(_uq, 'property_id = ' || quote_nullable(NEW.property_id));
	END IF;

	IF OLD.account_collection_id IS DISTINCT FROM NEW.account_collection_id THEN
_uq := array_append(_uq, 'account_collection_id = ' || quote_nullable(NEW.account_collection_id));
	END IF;

	IF OLD.account_id IS DISTINCT FROM NEW.account_id THEN
_uq := array_append(_uq, 'account_id = ' || quote_nullable(NEW.account_id));
	END IF;

	IF OLD.account_realm_id IS DISTINCT FROM NEW.account_realm_id THEN
_uq := array_append(_uq, 'account_realm_id = ' || quote_nullable(NEW.account_realm_id));
	END IF;

	IF OLD.company_collection_id IS DISTINCT FROM NEW.company_collection_id THEN
_uq := array_append(_uq, 'company_collection_id = ' || quote_nullable(NEW.company_collection_id));
	END IF;

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.device_collection_id IS DISTINCT FROM NEW.device_collection_id THEN
_uq := array_append(_uq, 'device_collection_id = ' || quote_nullable(NEW.device_collection_id));
	END IF;

	IF OLD.dns_domain_collection_id IS DISTINCT FROM NEW.dns_domain_collection_id THEN
_uq := array_append(_uq, 'dns_domain_collection_id = ' || quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF OLD.layer2_network_collection_id IS DISTINCT FROM NEW.layer2_network_collection_id THEN
_uq := array_append(_uq, 'layer2_network_collection_id = ' || quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF OLD.layer3_network_collection_id IS DISTINCT FROM NEW.layer3_network_collection_id THEN
_uq := array_append(_uq, 'layer3_network_collection_id = ' || quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF OLD.netblock_collection_id IS DISTINCT FROM NEW.netblock_collection_id THEN
_uq := array_append(_uq, 'netblock_collection_id = ' || quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF OLD.network_range_id IS DISTINCT FROM NEW.network_range_id THEN
_uq := array_append(_uq, 'network_range_id = ' || quote_nullable(NEW.network_range_id));
	END IF;

	IF OLD.operating_system_id IS DISTINCT FROM NEW.operating_system_id THEN
_uq := array_append(_uq, 'operating_system_id = ' || quote_nullable(NEW.operating_system_id));
	END IF;

	IF OLD.operating_system_snapshot_id IS DISTINCT FROM NEW.operating_system_snapshot_id THEN
_uq := array_append(_uq, 'operating_system_snapshot_id = ' || quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF OLD.property_collection_id IS DISTINCT FROM NEW.property_collection_id THEN
_uq := array_append(_uq, 'property_name_collection_id = ' || quote_nullable(NEW.property_collection_id));
	END IF;

	IF OLD.service_env_collection_id IS DISTINCT FROM NEW.service_env_collection_id THEN
_uq := array_append(_uq, 'service_environment_collection_id = ' || quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF OLD.site_code IS DISTINCT FROM NEW.site_code THEN
_uq := array_append(_uq, 'site_code = ' || quote_nullable(NEW.site_code));
	END IF;

	IF OLD.x509_signed_certificate_id IS DISTINCT FROM NEW.x509_signed_certificate_id THEN
_uq := array_append(_uq, 'x509_signed_certificate_id = ' || quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.property_value IS DISTINCT FROM NEW.property_value THEN
		SELECT property_data_type INTO _dt
		FROM val_property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			_uq := array_append(_uq, 'property_value_boolean = ' || quote_nullable(CASE WHEN NEW.is_enabled = 'Y' THEN true WHEN NEW.is_enabled = 'N' THEN false ELSE NULL END));
			_uq := array_append(_uq, 'property_value = NULL');
		ELSE
			_uq := array_append(_uq, 'property_value = ' || quote_nullable(NEW.property_value));
			_uq := array_append(_uq, 'property_value_boolean = NULL');
		END IF;
	END IF;

	IF OLD.property_value_timestamp IS DISTINCT FROM NEW.property_value_timestamp THEN
_uq := array_append(_uq, 'property_value_timestamp = ' || quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF OLD.property_value_account_coll_id IS DISTINCT FROM NEW.property_value_account_coll_id THEN
_uq := array_append(_uq, 'property_value_account_collection_id = ' || quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF OLD.property_value_device_coll_id IS DISTINCT FROM NEW.property_value_device_coll_id THEN
_uq := array_append(_uq, 'property_value_device_collection_id = ' || quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF OLD.property_value_json IS DISTINCT FROM NEW.property_value_json THEN
_uq := array_append(_uq, 'property_value_json = ' || quote_nullable(NEW.property_value_json));
	END IF;

	IF OLD.property_value_nblk_coll_id IS DISTINCT FROM NEW.property_value_nblk_coll_id THEN
_uq := array_append(_uq, 'property_value_netblock_collection_id = ' || quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF OLD.property_value_password_type IS DISTINCT FROM NEW.property_value_password_type THEN
_uq := array_append(_uq, 'property_value_password_type = ' || quote_nullable(NEW.property_value_password_type));
	END IF;

	IF OLD.property_value_sw_package_id IS DISTINCT FROM NEW.property_value_sw_package_id THEN
_uq := array_append(_uq, 'property_value_sw_package_id = ' || quote_nullable(NEW.property_value_sw_package_id));
	END IF;

	IF OLD.property_value_token_col_id IS DISTINCT FROM NEW.property_value_token_col_id THEN
_uq := array_append(_uq, 'property_value_token_collection_id = ' || quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF OLD.property_rank IS DISTINCT FROM NEW.property_rank THEN
_uq := array_append(_uq, 'property_rank = ' || quote_nullable(NEW.property_rank));
	END IF;

	IF OLD.start_date IS DISTINCT FROM NEW.start_date THEN
_uq := array_append(_uq, 'start_date = ' || quote_nullable(NEW.start_date));
	END IF;

	IF OLD.finish_date IS DISTINCT FROM NEW.finish_date THEN
_uq := array_append(_uq, 'finish_date = ' || quote_nullable(NEW.finish_date));
	END IF;

	IF OLD.is_enabled IS DISTINCT FROM NEW.is_enabled THEN
IF NEW.is_enabled = 'Y' THEN
	_uq := array_append(_uq, 'is_enabled = true');
ELSIF NEW.is_enabled = 'N' THEN
	_uq := array_append(_uq, 'is_enabled = false');
ELSE
	_uq := array_append(_uq, 'is_enabled = NULL');
END IF;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_id = $1 RETURNING *'  USING OLD.property_id
			INTO _nr;

		NEW.property_id = _nr.property_id;
		NEW.account_collection_id = _nr.account_collection_id;
		NEW.account_id = _nr.account_id;
		NEW.account_realm_id = _nr.account_realm_id;
		NEW.company_collection_id = _nr.company_collection_id;
		NEW.company_id = _nr.company_id;
		NEW.device_collection_id = _nr.device_collection_id;
		NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
		NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
		NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
		NEW.netblock_collection_id = _nr.netblock_collection_id;
		NEW.network_range_id = _nr.network_range_id;
		NEW.operating_system_id = _nr.operating_system_id;
		NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
		NEW.property_collection_id = _nr.property_name_collection_id;
		NEW.service_env_collection_id = _nr.service_environment_collection_id;
		NEW.site_code = _nr.site_code;
		NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;

		IF _dt IS NOT DISTINCT FROM 'boolean' THEN
			NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
		ELSE
			NEW.property_value = _nr.property_value;
		END IF;

		NEW.property_value_timestamp = _nr.property_value_timestamp;
		NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
		NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
		NEW.property_value_json = _nr.property_value_json;
		NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
		NEW.property_value_password_type = _nr.property_value_password_type;
		NEW.property_value_sw_package_id = _nr.property_value_sw_package_id;
		NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
		NEW.property_rank = _nr.property_rank;
		NEW.start_date = _nr.start_date;
		NEW.finish_date = _nr.finish_date;
		NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_property_upd INSTEAD OF UPDATE ON jazzhands_legacy.property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.property_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('property');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE service_environment
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'service_environment', 'service_environment');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'service_environment', tags := ARRAY['view_service_environment']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.service_environment;
CREATE VIEW jazzhands_legacy.service_environment AS
 SELECT service_environment.service_environment_id,
    service_environment.service_environment_name,
    service_environment.production_state,
    service_environment.description,
    service_environment.external_id,
    service_environment.data_ins_user,
    service_environment.data_ins_date,
    service_environment.data_upd_user,
    service_environment.data_upd_date
   FROM jazzhands.service_environment
  WHERE service_environment.service_environment_type::text = 'default'::text;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('service_environment','service_environment');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('service_environment','service_environment');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of service_environment failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands.service_environment_del
CREATE OR REPLACE FUNCTION jazzhands.service_environment_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_se		service_environment%ROWTYPE;
BEGIN
	DELETE FROM service_environment_id
	WHERE service_environment_id = OLD.service_environment_id;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_service_environment_del INSTEAD OF DELETE ON jazzhands_legacy.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_del();

-- considering NEW jazzhands.service_environment_ins
CREATE OR REPLACE FUNCTION jazzhands.service_environment_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_se	service_environment%ROWTYPE;
BEGIN
	IF NEW.service_environment_id IS NOT NULL THEN
		INSERT INTO service_environment (
				service_environment_id,
        		service_environment_name,
        		service_environment_type,
        		production_state,
        		description,
        		external_id
		) VALUES (
				NEW.service_environment_id,
        		NEW.service_environment_name,
        		'default',
        		NEW.production_state,
        		NEW.description,
        		NEW.external_id
		) RETURNING * INTO _se;
	ELSE
		INSERT INTO service_environment (
        		service_environment_name,
        		service_environment_type,
        		production_state,
        		description,
        		external_id
		) VALUES (
        		NEW.service_environment_name,
        		'default',
        		NEW.production_state,
        		NEW.description,
        		NEW.external_id
		) RETURNING * INTO _se;

	END IF;

	NEW.service_environment_id		:= _se.service_environment_id;
	NEW.service_environment_name	:= _se.service_environment_name;
	NEW.production_state			:= _se.production_state;
	NEW.description					:= _se.description;
	NEW.external_id					:= _se.external_id;
	NEW.data_ins_user 				:= _se.data_ins_user;
	NEW.data_ins_date 				:= _se.data_ins_date;
	NEW.data_upd_user 				:= _se.data_upd_user;
	NEW.data_upd_date 				:= _se.data_upd_date;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_service_environment_ins INSTEAD OF INSERT ON jazzhands_legacy.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_ins();

-- considering NEW jazzhands.service_environment_upd
CREATE OR REPLACE FUNCTION jazzhands.service_environment_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	upd_query		TEXT[];
	_se			service_environment%ROWTYPE;
BEGIN
	IF OLD.service_environment_id IS DISTINCT FROM NEW.service_environment_id THEN
		RAISE EXCEPTION 'May not update service_environment_id'
		USING ERRCODE = 'invalid_parameter_value';
	END IF;

	upd_query := NULL;
	IF NEW.service_environment_name IS DISTINCT FROM OLD.service_environment_name THEN
		upd_query := array_append(upd_query,
			'service_environment_name = ' || quote_nullable(NEW.service_environment_name));
	END IF;
	IF NEW.production_state IS DISTINCT FROM OLD.production_state THEN
		upd_query := array_append(upd_query,
			'production_state = ' || quote_nullable(NEW.production_state));
	END IF;
	IF NEW.description IS DISTINCT FROM OLD.description THEN
		upd_query := array_append(upd_query,
			'description = ' || quote_nullable(NEW.description));
	END IF;
	IF NEW.external_id IS DISTINCT FROM OLD.external_id THEN
		upd_query := array_append(upd_query,
			'external_id = ' || quote_nullable(NEW.external_id));
	END IF;

	IF upd_query IS NOT NULL THEN
		EXECUTE 'UPDATE service_environment SET ' ||
			array_to_string(upd_query, ', ') ||
			' WHERE service_environment_id = $1 RETURNING *'
		USING OLD.service_environment_id
		INTO _se;

		NEW.service_environment_id		:= _se.service_environment_id;
		NEW.service_environment_name	:= _se.service_environment_name;
		NEW.production_state			:= _se.production_state;
		NEW.description					:= _se.description;
		NEW.external_id					:= _se.external_id;
		NEW.data_ins_user 				:= _se.data_ins_user;
		NEW.data_ins_date 				:= _se.data_ins_date;
		NEW.data_upd_user 				:= _se.data_upd_user;
		NEW.data_upd_date 				:= _se.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_service_environment_upd INSTEAD OF UPDATE ON jazzhands_legacy.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('service_environment');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('service_environment');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_environment  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE service_environment (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('service_environment');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('service_environment');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_environment failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('service_environment');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('service_environment');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_environment failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE static_route
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'static_route', 'static_route');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'static_route', tags := ARRAY['view_static_route']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.static_route;
CREATE VIEW jazzhands_legacy.static_route AS
 SELECT static_route.static_route_id,
    static_route.device_source_id AS device_src_id,
    static_route.layer3_interface_destination_id AS network_interface_dst_id,
    static_route.netblock_id,
    static_route.data_ins_user,
    static_route.data_ins_date,
    static_route.data_upd_user,
    static_route.data_upd_date
   FROM jazzhands.static_route;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('static_route','static_route');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('static_route','static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of static_route failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('static_route');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('static_route');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE static_route (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE static_route_template
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'static_route_template', 'static_route_template');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'static_route_template', tags := ARRAY['view_static_route_template']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.static_route_template;
CREATE VIEW jazzhands_legacy.static_route_template AS
 SELECT static_route_template.static_route_template_id,
    static_route_template.netblock_source_id AS netblock_src_id,
    static_route_template.layer3_interface_destination_id AS network_interface_dst_id,
    static_route_template.netblock_id,
    static_route_template.description,
    static_route_template.data_ins_user,
    static_route_template.data_ins_date,
    static_route_template.data_upd_user,
    static_route_template.data_upd_date
   FROM jazzhands.static_route_template;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('static_route_template','static_route_template');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('static_route_template','static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of static_route_template failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('static_route_template');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('static_route_template');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for static_route_template  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE static_route_template (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old static_route_template failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route_template');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('static_route_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new static_route_template failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_collection_expanded
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_account_collection_expanded', 'v_account_collection_expanded');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_account_collection_expanded', tags := ARRAY['view_v_account_collection_expanded']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.v_account_collection_expanded;
CREATE VIEW jazzhands_legacy.v_account_collection_expanded AS
 WITH RECURSIVE var_recurse(level, root_account_collection_id, account_collection_id, array_path, cycle) AS (
         SELECT 0 AS level,
            a.account_collection_id AS root_account_collection_id,
            a.account_collection_id,
            ARRAY[a.account_collection_id] AS array_path,
            false AS cycle
           FROM jazzhands.account_collection a
        UNION ALL
         SELECT x.level + 1 AS level,
            x.root_account_collection_id,
            ach.child_account_collection_id AS account_collection_id,
            ach.child_account_collection_id || x.array_path AS array_path,
            ach.child_account_collection_id = ANY (x.array_path) AS cycle
           FROM var_recurse x
             JOIN jazzhands.account_collection_hier ach ON x.account_collection_id = ach.account_collection_id
          WHERE NOT x.cycle
        )
 SELECT var_recurse.level,
    var_recurse.root_account_collection_id,
    var_recurse.account_collection_id
   FROM var_recurse;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_account_collection_expanded','v_account_collection_expanded');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_collection_expanded','v_account_collection_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_collection_expanded failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_collection_expanded');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_collection_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_collection_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_collection_expanded (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_collection_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_collection_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_collection_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_collection_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_collection_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_collection_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_acct_coll_prop_expanded
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_acct_coll_prop_expanded', 'v_acct_coll_prop_expanded');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_acct_coll_prop_expanded', tags := ARRAY['view_v_acct_coll_prop_expanded']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_property', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_collection_expanded_detail', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_collection_property_expanded', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_acct_coll_prop_expanded;
CREATE VIEW jazzhands_legacy.v_acct_coll_prop_expanded AS
 SELECT v_account_collection_property_expanded.account_collection_id,
    v_account_collection_property_expanded.property_id,
    v_account_collection_property_expanded.property_name,
    v_account_collection_property_expanded.property_type,
    v_account_collection_property_expanded.property_value,
    v_account_collection_property_expanded.property_value_timestamp,
    v_account_collection_property_expanded.property_value_account_collection_id AS property_value_account_coll_id,
    v_account_collection_property_expanded.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    v_account_collection_property_expanded.property_value_password_type,
    v_account_collection_property_expanded.property_value_token_collection_id AS property_value_token_col_id,
    v_account_collection_property_expanded.property_rank,
    v_account_collection_property_expanded.is_multivalue,
    v_account_collection_property_expanded.assignment_rank AS assign_rank
   FROM jazzhands.v_account_collection_property_expanded;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_acct_coll_prop_expanded','v_acct_coll_prop_expanded');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_acct_coll_prop_expanded','v_acct_coll_prop_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_acct_coll_prop_expanded failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_acct_coll_prop_expanded');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_acct_coll_prop_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_acct_coll_prop_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_acct_coll_prop_expanded (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_acct_coll_prop_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_acct_coll_prop_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_acct_coll_prop_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_acct_coll_prop_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_acct_coll_prop_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_acct_coll_prop_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_changes_pending
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_dns_changes_pending', 'v_dns_changes_pending');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_dns_changes_pending', tags := ARRAY['view_v_dns_changes_pending']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_dns_changes_pending', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_dns_changes_pending;
CREATE VIEW jazzhands_legacy.v_dns_changes_pending AS
 SELECT v_dns_changes_pending.dns_change_record_id,
    v_dns_changes_pending.dns_domain_id,
    v_dns_changes_pending.ip_universe_id,
        CASE
            WHEN v_dns_changes_pending.should_generate IS NULL THEN NULL::text
            WHEN v_dns_changes_pending.should_generate = true THEN 'Y'::text
            WHEN v_dns_changes_pending.should_generate = false THEN 'N'::text
            ELSE NULL::text
        END AS should_generate,
    v_dns_changes_pending.last_generated,
    v_dns_changes_pending.dns_domain_name AS soa_name,
    v_dns_changes_pending.ip_address
   FROM jazzhands.v_dns_changes_pending;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_dns_changes_pending','v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_changes_pending','v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_changes_pending');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_changes_pending');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_dns_changes_pending  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_dns_changes_pending (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_changes_pending');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_dns_changes_pending failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_dns_domain_nouniverse
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse', 'v_dns_domain_nouniverse');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_dns_domain_nouniverse', tags := ARRAY['view_v_dns_domain_nouniverse']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.v_dns_domain_nouniverse;
CREATE VIEW jazzhands_legacy.v_dns_domain_nouniverse AS
 SELECT d.dns_domain_id,
    d.dns_domain_name AS soa_name,
    du.soa_class,
    du.soa_ttl,
    du.soa_serial,
    du.soa_refresh,
    du.soa_retry,
    du.soa_expire,
    du.soa_minimum,
    du.soa_mname,
    du.soa_rname,
    d.parent_dns_domain_id,
        CASE
            WHEN du.should_generate IS NULL THEN NULL::text
            WHEN du.should_generate = true THEN 'Y'::text
            WHEN du.should_generate = false THEN 'N'::text
            ELSE NULL::text
        END AS should_generate,
    du.last_generated,
    d.dns_domain_type,
    COALESCE(d.data_ins_user, du.data_ins_user) AS data_ins_user,
    COALESCE(d.data_ins_date, du.data_ins_date) AS data_ins_date,
    COALESCE(du.data_upd_user, d.data_upd_user) AS data_upd_user,
    COALESCE(du.data_upd_date, d.data_upd_date) AS data_upd_date
   FROM jazzhands.dns_domain d
     JOIN jazzhands.dns_domain_ip_universe du USING (dns_domain_id)
  WHERE du.ip_universe_id = 0;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_dns_domain_nouniverse','v_dns_domain_nouniverse');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse','v_dns_domain_nouniverse');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_dns_domain_nouniverse failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.v_dns_domain_nouniverse_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d		jazzhands.dns_domain%rowtype;
	_du		jazzhands.dns_domain_ip_universe%rowtype;
BEGIN
	DELETE FROM jazzhands.v_dns_domain_ip_universe
	WHERE  dns_domain_id = OLD.dns_domain_id
	AND ip_universe = 0
	RETURNING * INTO _du;


	DELETE FROM jazzhands.dns_domain
	WHERE  dns_domain_id = OLD.dns_domain_id
	RETURNING * INTO _d;

	OLD.dns_domain_id = _d.dns_domain_id;
	OLD.soa_name = _d.dns_domain_name;
	OLD.dns_domain_type = _d.dns_domain_type;
	OLD.parent_dns_domain_id = _d.parent_dns_domain_id;

	OLD.soa_class = _du.soa_class;
	OLD.soa_ttl = _du.soa_ttl;
	OLD.soa_serial = _du.soa_serial;
	OLD.soa_refresh = _du.soa_refresh;
	OLD.soa_retry = _du.soa_retry;
	OLD.soa_expire = _du.soa_expire;
	OLD.soa_minimum = _du.soa_minimum;
	OLD.soa_mname = _du.soa_mname;
	OLD.soa_rname = _du.soa_rname;
	OLD.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
	OLD.last_generated = _du.last_generated;
	OLD.data_ins_user = _du.data_ins_user;
	OLD.data_ins_date = _du.data_ins_date;
	OLD.data_upd_user = _du.data_upd_user;
	OLD.data_upd_date = _du.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_v_dns_domain_nouniverse_del INSTEAD OF DELETE ON jazzhands_legacy.v_dns_domain_nouniverse FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_del();

-- considering NEW jazzhands_legacy.v_dns_domain_nouniverse_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%rowtype;
	_du	jazzhands.dns_domain_ip_universe%rowtype;
BEGIN
	IF NEW.dns_domain_id IS NULL THEN
		INSERT INTO jazzhands.dns_domain (
			dns_domain_name, dns_domain_type, parent_dns_domain_id
		) VALUES (
			NEW.soa_name, NEW.dns_domain_type, NEW.parent_dns_domain_id
		) RETURNING * INTO _d;
	ELSE
		INSERT INTO jazzhands.dns_domain (
			dns_domain_id, dns_domain_name, dns_domain_type,
			parent_dns_domain_id
		) VALUES (
			NEW.dns_domain_id, NEW.soa_name, NEW.dns_domain_type,
			NEW.parent_dns_domain_id
		) RETURNING * INTO _d;
	END IF;

	INSERT INTO dns_domain_ip_universe (
		dns_domain_id, ip_universe_id,
		soa_class, soa_ttl, soa_serial, soa_refresh,
		soa_retry,
		soa_expire, soa_minimum, soa_mname, soa_rname,
		should_generate,
		last_generated
	) VALUES (
		_d.dns_domain_id, 0,
		NEW.soa_class, NEW.soa_ttl, NEW.soa_serial, NEW.soa_refresh,
		NEW.soa_retry,
		NEW.soa_expire, NEW.soa_minimum, NEW.soa_mname, NEW.soa_rname,
		CASE WHEN NEW.should_generate = 'Y' THEN true
			WHEN NEW.should_generate = 'N' THEN false
			ELSE NULL
			END,
		NEW.last_generated
	) RETURNING * INTO _du;

	NEW.dns_domain_id = _d.dns_domain_id;
	NEW.soa_name = _d.dns_domain_name;
	NEW.soa_class = _du.soa_class;
	NEW.soa_ttl = _du.soa_ttl;
	NEW.soa_serial = _du.soa_serial;
	NEW.soa_refresh = _du.soa_refresh;
	NEW.soa_retry = _du.soa_retry;
	NEW.soa_expire = _du.soa_expire;
	NEW.soa_minimum = _du.soa_minimum;
	NEW.soa_mname = _du.soa_mname;
	NEW.soa_rname = _du.soa_rname;
	NEW.parent_dns_domain_id = _d.parent_dns_domain_id;
	NEW.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
	NEW.last_generated = _du.last_generated;
	NEW.dns_domain_type = _d.dns_domain_type;
	NEW.data_ins_user = _d.data_ins_user;
	NEW.data_ins_date = _d.data_ins_date;
	NEW.data_upd_user = _d.data_upd_user;
	NEW.data_upd_date = _d.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_dns_domain_nouniverse_ins INSTEAD OF INSERT ON jazzhands_legacy.v_dns_domain_nouniverse FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_ins();

-- considering NEW jazzhands_legacy.v_dns_domain_nouniverse_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d		jazzhands.dns_domain%rowtype;
	_du		jazzhands.dns_domain_ip_universe%rowtype;
	_duq	text[];
	_uq		text[];
BEGIN

	IF OLD.dns_domain_id IS DISTINCT FROM NEW.dns_domain_id THEN
		RAISE EXCEPTION 'Can not change dns_domain_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.soa_name IS DISTINCT FROM NEW.soa_name THEN
		_duq := array_append(_duq, 'dns_domain_name = ' || quote_nullable(NEW.soa_name));
	END IF;

	IF OLD.parent_dns_domain_id IS DISTINCT FROM NEW.parent_dns_domain_id THEN
		_duq := array_append(_duq, 'parent_dns_domain_id = ' || quote_nullable(NEW.parent_dns_domain_id));
	END IF;

	IF OLD.dns_domain_type IS DISTINCT FROM NEW.dns_domain_type THEN
		_duq := array_append(_duq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	--

	IF OLD.soa_class IS DISTINCT FROM NEW.soa_class THEN
		_uq := array_append(_uq, 'soa_class = ' || quote_nullable(NEW.soa_class));
	END IF;

	IF OLD.soa_ttl IS DISTINCT FROM NEW.soa_ttl THEN
		_uq := array_append(_uq, 'soa_ttl = ' || quote_nullable(NEW.soa_ttl));
	END IF;

	IF OLD.soa_serial IS DISTINCT FROM NEW.soa_serial THEN
		_uq := array_append(_uq, 'soa_serial = ' || quote_nullable(NEW.soa_serial));
	END IF;

	IF OLD.soa_refresh IS DISTINCT FROM NEW.soa_refresh THEN
		_uq := array_append(_uq, 'soa_refresh = ' || quote_nullable(NEW.soa_refresh));
	END IF;

	IF OLD.soa_retry IS DISTINCT FROM NEW.soa_retry THEN
		_uq := array_append(_uq, 'soa_retry = ' || quote_nullable(NEW.soa_retry));
	END IF;

	IF OLD.soa_expire IS DISTINCT FROM NEW.soa_expire THEN
		_uq := array_append(_uq, 'soa_expire = ' || quote_nullable(NEW.soa_expire));
	END IF;

	IF OLD.soa_minimum IS DISTINCT FROM NEW.soa_minimum THEN
		_uq := array_append(_uq, 'soa_minimum = ' || quote_nullable(NEW.soa_minimum));
	END IF;

	IF OLD.soa_mname IS DISTINCT FROM NEW.soa_mname THEN
		_uq := array_append(_uq, 'soa_mname = ' || quote_nullable(NEW.soa_mname));
	END IF;

	IF OLD.soa_rname IS DISTINCT FROM NEW.soa_rname THEN
		_uq := array_append(_uq, 'soa_rname = ' || quote_nullable(NEW.soa_rname));
	END IF;

	IF OLD.should_generate IS DISTINCT FROM NEW.should_generate THEN
		IF NEW.should_generate = 'Y' THEN
			_uq := array_append(_uq, 'should_generate = true');
		ELSIF NEW.should_generate = 'N' THEN
			_uq := array_append(_uq, 'should_generate = false');
		ELSE
			_uq := array_append(_uq, 'should_generate = NULL');
		END IF;
	END IF;

	IF OLD.last_generated IS DISTINCT FROM NEW.last_generated THEN
		_uq := array_append(_uq, 'last_generated = ' || quote_nullable(NEW.last_generated));
	END IF;

	IF _duq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain SET ' ||
			array_to_string(_duq, ', ') ||
			' WHERE  dns_domain_id = $1 RETURNING *'
			USING OLD.dns_domain_id
			INTO _d;

		NEW.dns_domain_id = _d.dns_domain_id;
		NEW.soa_name = _d.soa_name;
		NEW.dns_domain_type = _d.dns_domain_type;
		NEW.parent_dns_domain_id = _d.parent_dns_domain_id;
		NEW.data_ins_user = _d.data_ins_user;
		NEW.data_ins_date = _d.data_ins_date;
		NEW.data_upd_user = _d.data_upd_user;
		NEW.data_upd_date = _d.data_upd_date;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain_ip_universe SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  dns_domain_id = $1 AND ip_universe = 0 RETURNING *'
			USING OLD.dns_domain_id
			INTO _du;

		NEW.soa_class = _du.soa_class;
		NEW.soa_ttl = _du.soa_ttl;
		NEW.soa_serial = _du.soa_serial;
		NEW.soa_refresh = _du.soa_refresh;
		NEW.soa_retry = _du.soa_retry;
		NEW.soa_expire = _du.soa_expire;
		NEW.soa_minimum = _du.soa_minimum;
		NEW.soa_mname = _du.soa_mname;
		NEW.soa_rname = _du.soa_rname;
		NEW.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
		NEW.last_generated = _du.last_generated;
		NEW.data_ins_user = _du.data_ins_user;
		NEW.data_ins_date = _du.data_ins_date;
		NEW.data_upd_user = _du.data_upd_user;
		NEW.data_upd_date = _du.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_dns_domain_nouniverse_upd INSTEAD OF UPDATE ON jazzhands_legacy.v_dns_domain_nouniverse FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_dns_domain_nouniverse  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_dns_domain_nouniverse (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_dns_domain_nouniverse failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_dns_domain_nouniverse');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_dns_domain_nouniverse failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_l1_all_physical_ports
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_l1_all_physical_ports', 'v_l1_all_physical_ports');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_l1_all_physical_ports', tags := ARRAY['view_v_l1_all_physical_ports']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_device_slots', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_l1_all_physical_ports;
CREATE VIEW jazzhands_legacy.v_l1_all_physical_ports AS
 WITH pp AS (
         SELECT sl.slot_id,
            ds.device_id,
            sl.slot_name,
            st.slot_function
           FROM jazzhands.slot sl
             JOIN jazzhands.slot_type st USING (slot_type_id)
             LEFT JOIN jazzhands.v_device_slots ds USING (slot_id)
        )
 SELECT icc.inter_component_connection_id AS layer1_connection_id,
    s1.slot_id AS physical_port_id,
    s1.device_id,
    s1.slot_name AS port_name,
    s1.slot_function AS port_type,
    NULL::text AS port_purpose,
    s2.slot_id AS other_physical_port_id,
    s2.device_id AS other_device_id,
    s2.slot_name AS other_port_name,
    NULL::text AS other_port_purpose,
    NULL::integer AS baud,
    NULL::integer AS data_bits,
    NULL::integer AS stop_bits,
    NULL::character varying AS parity,
    NULL::character varying AS flow_control
   FROM pp s1
     JOIN jazzhands.inter_component_connection icc ON s1.slot_id = icc.slot1_id
     JOIN pp s2 ON s2.slot_id = icc.slot2_id
UNION
 SELECT icc.inter_component_connection_id AS layer1_connection_id,
    s2.slot_id AS physical_port_id,
    s2.device_id,
    s2.slot_name AS port_name,
    s2.slot_function AS port_type,
    NULL::text AS port_purpose,
    s1.slot_id AS other_physical_port_id,
    s1.device_id AS other_device_id,
    s1.slot_name AS other_port_name,
    NULL::text AS other_port_purpose,
    NULL::integer AS baud,
    NULL::integer AS data_bits,
    NULL::integer AS stop_bits,
    NULL::character varying AS parity,
    NULL::character varying AS flow_control
   FROM pp s1
     JOIN jazzhands.inter_component_connection icc ON s1.slot_id = icc.slot1_id
     JOIN pp s2 ON s2.slot_id = icc.slot2_id
UNION
 SELECT NULL::integer AS layer1_connection_id,
    s1.slot_id AS physical_port_id,
    s1.device_id,
    s1.slot_name AS port_name,
    s1.slot_function AS port_type,
    NULL::text AS port_purpose,
    NULL::integer AS other_physical_port_id,
    NULL::integer AS other_device_id,
    NULL::character varying AS other_port_name,
    NULL::text AS other_port_purpose,
    NULL::integer AS baud,
    NULL::integer AS data_bits,
    NULL::integer AS stop_bits,
    NULL::character varying AS parity,
    NULL::character varying AS flow_control
   FROM pp s1
     LEFT JOIN jazzhands.inter_component_connection icc ON s1.slot_id = icc.slot1_id OR s1.slot_id = icc.slot2_id
  WHERE icc.inter_component_connection_id IS NULL;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_l1_all_physical_ports','v_l1_all_physical_ports');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_l1_all_physical_ports','v_l1_all_physical_ports');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_l1_all_physical_ports failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_l1_all_physical_ports');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_l1_all_physical_ports');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_l1_all_physical_ports  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_l1_all_physical_ports (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_l1_all_physical_ports failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_l1_all_physical_ports');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_l1_all_physical_ports failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_network_interface_trans
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_network_interface_trans', 'v_network_interface_trans');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_network_interface_trans', tags := ARRAY['view_v_network_interface_trans']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.v_network_interface_trans;
CREATE VIEW jazzhands_legacy.v_network_interface_trans AS
 WITH x AS (
         SELECT base.layer3_interface_id AS network_interface_id,
            base.device_id,
            base.layer3_interface_name AS network_interface_name,
            base.description,
            base.parent_layer3_interface_id AS parent_network_interface_id,
            base.parent_relation_type,
            base.netblock_id,
            base.slot_id,
            base.logical_port_id,
            base.layer3_interface_type AS network_interface_type,
            base.is_interface_up,
            base.mac_addr,
            base.should_monitor,
            base.should_manage,
            base.data_ins_user,
            base.data_ins_date,
            base.data_upd_user,
            base.data_upd_date,
            base.rnk
           FROM ( SELECT l3i.layer3_interface_id,
                    l3i.layer3_interface_name,
                    l3i.device_id,
                    l3i.description,
                    l3i.parent_layer3_interface_id,
                    l3i.parent_relation_type,
                    l3in.netblock_id,
                    l3i.slot_id,
                    l3i.logical_port_id,
                    l3i.layer3_interface_type,
                    l3i.is_interface_up,
                    l3i.mac_addr,
                    l3i.should_monitor,
                    l3i.should_manage,
                    l3i.data_ins_user,
                    l3i.data_ins_date,
                    l3i.data_upd_user,
                    l3i.data_upd_date,
                    rank() OVER (PARTITION BY l3i.layer3_interface_id ORDER BY l3in.layer3_interface_rank) AS rnk
                   FROM jazzhands.layer3_interface l3i
                     LEFT JOIN jazzhands.layer3_interface_netblock l3in USING (layer3_interface_id)) base
        )
 SELECT x.network_interface_id,
    x.device_id,
    x.network_interface_name,
    x.description,
    x.parent_network_interface_id,
    x.parent_relation_type,
    x.netblock_id,
    x.slot_id AS physical_port_id,
    x.slot_id,
    x.logical_port_id,
    x.network_interface_type,
        CASE
            WHEN x.is_interface_up = true THEN 'Y'::text
            WHEN x.is_interface_up = false THEN 'N'::text
            ELSE NULL::text
        END AS is_interface_up,
    x.mac_addr,
        CASE
            WHEN x.should_monitor = true THEN 'Y'::text
            WHEN x.should_monitor = false THEN 'N'::text
            ELSE NULL::text
        END AS should_monitor,
        CASE
            WHEN x.should_manage = true THEN 'Y'::text
            WHEN x.should_manage = false THEN 'N'::text
            ELSE NULL::text
        END AS should_manage,
    x.data_ins_user,
    x.data_ins_date,
    x.data_upd_user,
    x.data_upd_date
   FROM x
  WHERE x.rnk = 1;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_network_interface_trans','v_network_interface_trans');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_interface_trans','v_network_interface_trans');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_network_interface_trans failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands.v_network_interface_trans_del
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	_ni		network_interface%ROWTYPE;
BEGIN
	IF OLD.netblock_id IS NOT NULL THEN
		DELETE FROM network_interface_netblock
		WHERE network_interface_id = OLD.network_interface_id
		AND netblock_id = OLD.netblock_id;
	END IF;

	DELETE FROM network_interface
	WHERE network_interface_id = OLD.network_interface_id;

	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_v_network_interface_trans_del INSTEAD OF DELETE ON jazzhands_legacy.v_network_interface_trans FOR EACH ROW EXECUTE FUNCTION jazzhands.v_network_interface_trans_del();

-- considering NEW jazzhands.v_network_interface_trans_ins
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	_ni	network_interface%ROWTYPE;
BEGIN
	INSERT INTO network_interface (
		device_id,
		network_interface_name, description,
		parent_network_interface_id,
		parent_relation_type, physical_port_id,
		slot_id, logical_port_id,
		network_interface_type, is_interface_up,
		mac_addr, should_monitor,
		should_manage
	) VALUES (
		NEW.device_id,
		NEW.network_interface_name, NEW.description,
		NEW.parent_network_interface_id,
		NEW.parent_relation_type, NEW.physical_port_id,
		NEW.slot_id, NEW.logical_port_id,
		NEW.network_interface_type, NEW.is_interface_up,
		NEW.mac_addr, NEW.should_monitor,
		NEW.should_manage
	) RETURNING * INTO _ni;

	IF NEW.netblock_id IS NOT NULL THEN
		INSERT INTO network_interface_netblock (
			network_interface_id, netblock_id
		) VALUES (
			_ni.network_interface_id, NEW.netblock_id
		);
	END IF;

	NEW.network_interface_id := _ni.network_interface_id;
	NEW.device_id := _ni.device_id;
	NEW.network_interface_name := _ni.network_interface_name;
	NEW.description := _ni.description;
	NEW.parent_network_interface_id := _ni.parent_network_interface_id;
	NEW.parent_relation_type := _ni.parent_relation_type;
	NEW.physical_port_id := _ni.physical_port_id;
	NEW.slot_id := _ni.slot_id;
	NEW.logical_port_id := _ni.logical_port_id;
	NEW.network_interface_type := _ni.network_interface_type;
	NEW.is_interface_up := _ni.is_interface_up;
	NEW.mac_addr := _ni.mac_addr;
	NEW.should_monitor := _ni.should_monitor;
	NEW.should_manage := _ni.should_manage;
	NEW.data_ins_user :=_ni.data_ins_user;
	NEW.data_ins_date := _ni.data_ins_date;
	NEW.data_upd_user := _ni.data_upd_user;
	NEW.data_upd_date := _ni.data_upd_date;


	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_network_interface_trans_ins INSTEAD OF INSERT ON jazzhands_legacy.v_network_interface_trans FOR EACH ROW EXECUTE FUNCTION jazzhands.v_network_interface_trans_ins();

-- considering NEW jazzhands.v_network_interface_trans_upd
CREATE OR REPLACE FUNCTION jazzhands.v_network_interface_trans_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands_legacy'
AS $function$
DECLARE
	upd_query		TEXT[];
	_ni				network_interface%ROWTYPE;
BEGIN
	IF OLD.network_interface_id IS DISTINCT FROM NEW.network_interface_id THEN
		RAISE EXCEPTION 'May not update network_interface_id'
		USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.netblock_id IS DISTINCT FROM NEW.netblock_id THEN
		IF OLD.netblock_id IS NULL THEN
			INSERT INTO network_interface_netblock (
				network_interface_id, netblock_id
			) VALUES (
				NEW.network_interface_id, NEW.netblock_id
			);
		ELSIF NEW.netblock_id IS NULL THEN
			DELETE FROM network_interface_netblock
			WHERE network_interface_id = OLD.network_interface_id
			AND netblock_id = OLD.netblock_id;

			WITH x AS (
				SELECT *,
				rank() OVER (PARTITION BY
					network_interface_id ORDER BY
					network_interface_rank) AS rnk
				FROM network_interface_netblock
				WHERE network_interface_id = NEW.network_interface_id
			) SELECT netblock_id
			INTO NEW.netblock_id
				FROM x
				WHERE x.rnk = 1;
		ELSE
			UPDATE network_interface_netblock
			SET netblock_id = NEW.netblock_id
			WHERE netblock_id = OLD.netblock_id
			AND network_interface_id = NEW.network_interface_id;
		END IF;
	END IF;

	upd_query := NULL;
		IF NEW.device_id IS DISTINCT FROM OLD.device_id THEN
			upd_query := array_append(upd_query,
				'device_id = ' || quote_nullable(NEW.device_id));
		END IF;
		IF NEW.network_interface_name IS DISTINCT FROM OLD.network_interface_name THEN
			upd_query := array_append(upd_query,
				'network_interface_name = ' || quote_nullable(NEW.network_interface_name));
		END IF;
		IF NEW.description IS DISTINCT FROM OLD.description THEN
			upd_query := array_append(upd_query,
				'description = ' || quote_nullable(NEW.description));
		END IF;
		IF NEW.parent_network_interface_id IS DISTINCT FROM OLD.parent_network_interface_id THEN
			upd_query := array_append(upd_query,
				'parent_network_interface_id = ' || quote_nullable(NEW.parent_network_interface_id));
		END IF;
		IF NEW.parent_relation_type IS DISTINCT FROM OLD.parent_relation_type THEN
			upd_query := array_append(upd_query,
				'parent_relation_type = ' || quote_nullable(NEW.parent_relation_type));
		END IF;
		IF NEW.physical_port_id IS DISTINCT FROM OLD.physical_port_id THEN
			upd_query := array_append(upd_query,
				'physical_port_id = ' || quote_nullable(NEW.physical_port_id));
		END IF;
		IF NEW.slot_id IS DISTINCT FROM OLD.slot_id THEN
			upd_query := array_append(upd_query,
				'slot_id = ' || quote_nullable(NEW.slot_id));
		END IF;
		IF NEW.logical_port_id IS DISTINCT FROM OLD.logical_port_id THEN
			upd_query := array_append(upd_query,
				'logical_port_id = ' || quote_nullable(NEW.logical_port_id));
		END IF;
		IF NEW.network_interface_type IS DISTINCT FROM OLD.network_interface_type THEN
			upd_query := array_append(upd_query,
				'network_interface_type = ' || quote_nullable(NEW.network_interface_type));
		END IF;
		IF NEW.is_interface_up IS DISTINCT FROM OLD.is_interface_up THEN
			upd_query := array_append(upd_query,
				'is_interface_up = ' || quote_nullable(NEW.is_interface_Up));
		END IF;
		IF NEW.mac_addr IS DISTINCT FROM OLD.mac_addr THEN
			upd_query := array_append(upd_query,
				'mac_addr = ' || quote_nullable(NEW.mac_addr));
		END IF;
		IF NEW.should_monitor IS DISTINCT FROM OLD.should_monitor THEN
			upd_query := array_append(upd_query,
				'should_monitor = ' || quote_nullable(NEW.should_monitor));
		END IF;
		IF NEW.should_manage IS DISTINCT FROM OLD.should_manage THEN
			upd_query := array_append(upd_query,
				'should_manage = ' || quote_nullable(NEW.should_manage));
		END IF;

		IF upd_query IS NOT NULL THEN
			EXECUTE 'UPDATE network_interface SET ' ||
				array_to_string(upd_query, ', ') ||
				' WHERE network_interface_id = $1 RETURNING *'
			USING OLD.network_interface_id
			INTO _ni;

			NEW.device_id := _ni.device_id;
			NEW.network_interface_name := _ni.network_interface_name;
			NEW.description := _ni.description;
			NEW.parent_network_interface_id := _ni.parent_network_interface_id;
			NEW.parent_relation_type := _ni.parent_relation_type;
			NEW.physical_port_id := _ni.physical_port_id;
			NEW.slot_id := _ni.slot_id;
			NEW.logical_port_id := _ni.logical_port_id;
			NEW.network_interface_type := _ni.network_interface_type;
			NEW.is_interface_up := _ni.is_interface_up;
			NEW.mac_addr := _ni.mac_addr;
			NEW.should_monitor := _ni.should_monitor;
			NEW.should_manage := _ni.should_manage;
			NEW.data_ins_user := _ni.data_ins_user;
			NEW.data_ins_date := _ni.data_ins_date;
			NEW.data_upd_user := _ni.data_upd_user;
			NEW.data_upd_date := _ni.data_upd_date;
		END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_network_interface_trans_upd INSTEAD OF UPDATE ON jazzhands_legacy.v_network_interface_trans FOR EACH ROW EXECUTE FUNCTION jazzhands.v_network_interface_trans_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_interface_trans');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_interface_trans');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_network_interface_trans  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_network_interface_trans (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_interface_trans');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_interface_trans');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_network_interface_trans failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_interface_trans');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_interface_trans');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_network_interface_trans failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_network_range_expanded
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_network_range_expanded', 'v_network_range_expanded');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_network_range_expanded', tags := ARRAY['view_v_network_range_expanded']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_network_range_expanded', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_network_range_expanded;
CREATE VIEW jazzhands_legacy.v_network_range_expanded AS
 SELECT v_network_range_expanded.network_range_id,
    v_network_range_expanded.network_range_type,
    v_network_range_expanded.description,
    v_network_range_expanded.parent_netblock_id,
    v_network_range_expanded.ip_address,
    v_network_range_expanded.netblock_type,
    v_network_range_expanded.ip_universe_id,
    v_network_range_expanded.start_netblock_id,
    v_network_range_expanded.start_ip_address,
    v_network_range_expanded.start_netblock_type,
    v_network_range_expanded.start_ip_universe_id,
    v_network_range_expanded.stop_netblock_id,
    v_network_range_expanded.stop_ip_address,
    v_network_range_expanded.stop_netblock_type,
    v_network_range_expanded.stop_ip_universe_id,
    v_network_range_expanded.dns_prefix,
    v_network_range_expanded.dns_domain_id,
    v_network_range_expanded.dns_domain_name AS soa_name
   FROM jazzhands.v_network_range_expanded;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_network_range_expanded','v_network_range_expanded');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_range_expanded','v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_range_expanded');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_network_range_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_network_range_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_network_range_expanded (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_network_range_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_network_range_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_property', 'v_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_property', tags := ARRAY['view_v_property']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_property', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_property;
CREATE VIEW jazzhands_legacy.v_property AS
 SELECT v_property.property_id,
    v_property.account_collection_id,
    v_property.account_id,
    v_property.account_realm_id,
    v_property.company_collection_id,
    v_property.company_id,
    v_property.device_collection_id,
    v_property.dns_domain_collection_id,
    v_property.layer2_network_collection_id,
    v_property.layer3_network_collection_id,
    v_property.netblock_collection_id,
    v_property.network_range_id,
    v_property.operating_system_id,
    v_property.operating_system_snapshot_id,
    v_property.property_name_collection_id AS property_collection_id,
    v_property.service_environment_collection_id AS service_env_collection_id,
    v_property.site_code,
    v_property.x509_signed_certificate_id,
    v_property.property_name,
    v_property.property_type,
        CASE
            WHEN v_property.property_value_boolean = true THEN 'Y'::character varying
            WHEN v_property.property_value_boolean = false THEN 'N'::character varying
            ELSE v_property.property_value
        END::character varying(1024) AS property_value,
    v_property.property_value_timestamp,
    v_property.property_value_account_collection_id AS property_value_account_coll_id,
    v_property.property_value_device_collection_id AS property_value_device_coll_id,
    v_property.property_value_json,
    v_property.property_value_netblock_collection_id AS property_value_nblk_coll_id,
    v_property.property_value_password_type,
    v_property.property_value_sw_package_id,
    v_property.property_value_token_collection_id AS property_value_token_col_id,
    v_property.property_rank,
    v_property.start_date,
    v_property.finish_date,
        CASE
            WHEN v_property.is_enabled IS NULL THEN NULL::text
            WHEN v_property.is_enabled = true THEN 'Y'::text
            WHEN v_property.is_enabled = false THEN 'N'::text
            ELSE NULL::text
        END AS is_enabled,
    v_property.data_ins_user,
    v_property.data_ins_date,
    v_property.data_upd_user,
    v_property.data_upd_date
   FROM jazzhands.v_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_property','v_property');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_property','v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_property');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_purpose
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_network_interface_purpose', 'val_network_interface_purpose');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_network_interface_purpose', tags := ARRAY['view_val_network_interface_purpose']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_network_interface_purpose;
CREATE VIEW jazzhands_legacy.val_network_interface_purpose AS
 SELECT val_layer3_interface_purpose.layer3_interface_purpose AS network_interface_purpose,
    val_layer3_interface_purpose.description,
    val_layer3_interface_purpose.data_ins_user,
    val_layer3_interface_purpose.data_ins_date,
    val_layer3_interface_purpose.data_upd_user,
    val_layer3_interface_purpose.data_upd_date
   FROM jazzhands.val_layer3_interface_purpose;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_network_interface_purpose','val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_purpose','val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_purpose');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_network_interface_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_network_interface_purpose (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_network_interface_purpose failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_network_interface_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_network_interface_type', 'val_network_interface_type');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_network_interface_type', tags := ARRAY['view_val_network_interface_type']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_network_interface_type;
CREATE VIEW jazzhands_legacy.val_network_interface_type AS
 SELECT val_layer3_interface_type.layer3_interface_type AS network_interface_type,
    val_layer3_interface_type.description,
    val_layer3_interface_type.data_ins_user,
    val_layer3_interface_type.data_ins_date,
    val_layer3_interface_type.data_upd_user,
    val_layer3_interface_type.data_upd_date
   FROM jazzhands.val_layer3_interface_type;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_network_interface_type','val_network_interface_type');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_type','val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_type');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_network_interface_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_network_interface_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_network_interface_type (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_type');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_network_interface_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_network_interface_type failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE val_property
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_property', 'val_property');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_property', tags := ARRAY['view_val_property']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.val_property;
CREATE VIEW jazzhands_legacy.val_property AS
 SELECT val_property.property_name,
    val_property.property_type,
    val_property.description,
    val_property.account_collection_type,
    val_property.company_collection_type,
    val_property.device_collection_type,
    val_property.dns_domain_collection_type,
    val_property.layer2_network_collection_type,
    val_property.layer3_network_collection_type,
    val_property.netblock_collection_type,
    val_property.network_range_type,
    val_property.property_name_collection_type AS property_collection_type,
    val_property.service_environment_collection_type AS service_env_collection_type,
        CASE
            WHEN val_property.is_multivalue IS NULL THEN NULL::text
            WHEN val_property.is_multivalue = true THEN 'Y'::text
            WHEN val_property.is_multivalue = false THEN 'N'::text
            ELSE NULL::text
        END AS is_multivalue,
    val_property.property_value_account_collection_type_restriction AS prop_val_acct_coll_type_rstrct,
    val_property.property_value_device_collection_type_restriction AS prop_val_dev_coll_type_rstrct,
    val_property.property_value_netblock_collection_type_restriction AS prop_val_nblk_coll_type_rstrct,
    val_property.property_data_type,
    val_property.property_value_json_schema,
    val_property.permit_account_collection_id,
    val_property.permit_account_id,
    val_property.permit_account_realm_id,
    val_property.permit_company_id,
    val_property.permit_company_collection_id,
    val_property.permit_device_collection_id,
    val_property.permit_dns_domain_collection_id AS permit_dns_domain_coll_id,
    val_property.permit_layer2_network_collection_id AS permit_layer2_network_coll_id,
    val_property.permit_layer3_network_collection_id AS permit_layer3_network_coll_id,
    val_property.permit_netblock_collection_id,
    val_property.permit_network_range_id,
    val_property.permit_operating_system_id,
    val_property.permit_operating_system_snapshot_id AS permit_os_snapshot_id,
    val_property.permit_property_name_collection_id AS permit_property_collection_id,
    val_property.permit_service_environment_collection AS permit_service_env_collection,
    val_property.permit_site_code,
    val_property.permit_x509_signed_certificate_id AS permit_x509_signed_cert_id,
    val_property.permit_property_rank,
    val_property.data_ins_user,
    val_property.data_ins_date,
    val_property.data_upd_user,
    val_property.data_upd_date
   FROM jazzhands.val_property;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('val_property','val_property');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_property','val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of val_property failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();
ALTER TABLE jazzhands_legacy.val_property
	ALTER is_multivalue
	SET DEFAULT 'N'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_account_realm_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_company_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_company_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_device_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_dns_domain_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_layer2_network_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_layer3_network_coll_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_netblock_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_network_range_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_operating_system_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_os_snapshot_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_property_collection_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_service_env_collection
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_site_code
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_x509_signed_cert_id
	SET DEFAULT 'PROHIBITED'::bpchar;
ALTER TABLE jazzhands_legacy.val_property
	ALTER permit_property_rank
	SET DEFAULT 'PROHIBITED'::bpchar;

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.val_property_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.val_property%rowtype;
BEGIN
	DELETE FROM jazzhands.val_property
	WHERE  property_name = OLD.property_name  AND  property_type = OLD.property_type  RETURNING *
	INTO _or;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	OLD.description = _or.description;
	OLD.account_collection_type = _or.account_collection_type;
	OLD.company_collection_type = _or.company_collection_type;
	OLD.device_collection_type = _or.device_collection_type;
	OLD.dns_domain_collection_type = _or.dns_domain_collection_type;
	OLD.layer2_network_collection_type = _or.layer2_network_collection_type;
	OLD.layer3_network_collection_type = _or.layer3_network_collection_type;
	OLD.netblock_collection_type = _or.netblock_collection_type;
	OLD.network_range_type = _or.network_range_type;
	OLD.property_collection_type = _or.property_name_collection_type;
	OLD.service_env_collection_type = _or.service_environment_collection_type;
	OLD.is_multivalue = CASE WHEN _or.is_multivalue = true THEN 'Y' WHEN _or.is_multivalue = false THEN 'N' ELSE NULL END;
	OLD.prop_val_acct_coll_type_rstrct = _or.property_value_account_collection_type_restriction;
	OLD.prop_val_dev_coll_type_rstrct = _or.property_value_device_collection_type_restriction;
	OLD.prop_val_nblk_coll_type_rstrct = _or.property_value_netblock_collection_type_restriction;
	OLD.property_data_type = _or.property_data_type;
	OLD.property_value_json_schema = _or.property_value_json_schema;
	OLD.permit_account_collection_id = _or.permit_account_collection_id;
	OLD.permit_account_id = _or.permit_account_id;
	OLD.permit_account_realm_id = _or.permit_account_realm_id;
	OLD.permit_company_id = _or.permit_company_id;
	OLD.permit_company_collection_id = _or.permit_company_collection_id;
	OLD.permit_device_collection_id = _or.permit_device_collection_id;
	OLD.permit_dns_domain_coll_id = _or.permit_dns_domain_collection_id;
	OLD.permit_layer2_network_coll_id = _or.permit_layer2_network_collection_id;
	OLD.permit_layer3_network_coll_id = _or.permit_layer3_network_collection_id;
	OLD.permit_netblock_collection_id = _or.permit_netblock_collection_id;
	OLD.permit_network_range_id = _or.permit_network_range_id;
	OLD.permit_operating_system_id = _or.permit_operating_system_id;
	OLD.permit_os_snapshot_id = _or.permit_operating_system_snapshot_id;
	OLD.permit_property_collection_id = _or.permit_property_name_collection_id;
	OLD.permit_service_env_collection = _or.permit_service_environment_collection;
	OLD.permit_site_code = _or.permit_site_code;
	OLD.permit_x509_signed_cert_id = _or.permit_x509_signed_certificate_id;
	OLD.permit_property_rank = _or.permit_property_rank;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_val_property_del INSTEAD OF DELETE ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.val_property_del();

-- considering NEW jazzhands_legacy.val_property_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.val_property%rowtype;
BEGIN

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.account_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_type));
	END IF;

	IF NEW.company_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_type));
	END IF;

	IF NEW.device_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_type));
	END IF;

	IF NEW.dns_domain_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF NEW.layer2_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF NEW.layer3_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF NEW.netblock_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF NEW.network_range_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_type'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_type));
	END IF;

	IF NEW.property_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_type));
	END IF;

	IF NEW.service_env_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF NEW.is_multivalue IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_multivalue'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_multivalue = 'Y' THEN true WHEN NEW.is_multivalue = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.prop_val_acct_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_dev_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_nblk_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF NEW.property_data_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_data_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_data_type));
	END IF;

	IF NEW.property_value_json_schema IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json_schema'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF NEW.permit_account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF NEW.permit_account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_id));
	END IF;

	IF NEW.permit_account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF NEW.permit_company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_id));
	END IF;

	IF NEW.permit_company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF NEW.permit_device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF NEW.permit_dns_domain_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF NEW.permit_layer2_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF NEW.permit_layer3_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF NEW.permit_netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF NEW.permit_network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF NEW.permit_operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF NEW.permit_os_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF NEW.permit_property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF NEW.permit_service_env_collection IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_service_environment_collection'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF NEW.permit_site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_site_code));
	END IF;

	IF NEW.permit_x509_signed_cert_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF NEW.permit_property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_rank));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.val_property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	NEW.description = _nr.description;
	NEW.account_collection_type = _nr.account_collection_type;
	NEW.company_collection_type = _nr.company_collection_type;
	NEW.device_collection_type = _nr.device_collection_type;
	NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
	NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
	NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
	NEW.netblock_collection_type = _nr.netblock_collection_type;
	NEW.network_range_type = _nr.network_range_type;
	NEW.property_collection_type = _nr.property_name_collection_type;
	NEW.service_env_collection_type = _nr.service_environment_collection_type;
	NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
	NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
	NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
	NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
	NEW.property_data_type = _nr.property_data_type;
	NEW.property_value_json_schema = _nr.property_value_json_schema;
	NEW.permit_account_collection_id = _nr.permit_account_collection_id;
	NEW.permit_account_id = _nr.permit_account_id;
	NEW.permit_account_realm_id = _nr.permit_account_realm_id;
	NEW.permit_company_id = _nr.permit_company_id;
	NEW.permit_company_collection_id = _nr.permit_company_collection_id;
	NEW.permit_device_collection_id = _nr.permit_device_collection_id;
	NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
	NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
	NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
	NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
	NEW.permit_network_range_id = _nr.permit_network_range_id;
	NEW.permit_operating_system_id = _nr.permit_operating_system_id;
	NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
	NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
	NEW.permit_service_env_collection = _nr.permit_service_environment_collection;
	NEW.permit_site_code = _nr.permit_site_code;
	NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
	NEW.permit_property_rank = _nr.permit_property_rank;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_val_property_ins INSTEAD OF INSERT ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.val_property_ins();

-- considering NEW jazzhands_legacy.val_property_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.val_property%rowtype;
	_nr	jazzhands.val_property%rowtype;
	_uq	text[];
BEGIN

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.account_collection_type IS DISTINCT FROM NEW.account_collection_type THEN
_uq := array_append(_uq, 'account_collection_type = ' || quote_nullable(NEW.account_collection_type));
	END IF;

	IF OLD.company_collection_type IS DISTINCT FROM NEW.company_collection_type THEN
_uq := array_append(_uq, 'company_collection_type = ' || quote_nullable(NEW.company_collection_type));
	END IF;

	IF OLD.device_collection_type IS DISTINCT FROM NEW.device_collection_type THEN
_uq := array_append(_uq, 'device_collection_type = ' || quote_nullable(NEW.device_collection_type));
	END IF;

	IF OLD.dns_domain_collection_type IS DISTINCT FROM NEW.dns_domain_collection_type THEN
_uq := array_append(_uq, 'dns_domain_collection_type = ' || quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF OLD.layer2_network_collection_type IS DISTINCT FROM NEW.layer2_network_collection_type THEN
_uq := array_append(_uq, 'layer2_network_collection_type = ' || quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF OLD.layer3_network_collection_type IS DISTINCT FROM NEW.layer3_network_collection_type THEN
_uq := array_append(_uq, 'layer3_network_collection_type = ' || quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF OLD.netblock_collection_type IS DISTINCT FROM NEW.netblock_collection_type THEN
_uq := array_append(_uq, 'netblock_collection_type = ' || quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF OLD.network_range_type IS DISTINCT FROM NEW.network_range_type THEN
_uq := array_append(_uq, 'network_range_type = ' || quote_nullable(NEW.network_range_type));
	END IF;

	IF OLD.property_collection_type IS DISTINCT FROM NEW.property_collection_type THEN
_uq := array_append(_uq, 'property_name_collection_type = ' || quote_nullable(NEW.property_collection_type));
	END IF;

	IF OLD.service_env_collection_type IS DISTINCT FROM NEW.service_env_collection_type THEN
_uq := array_append(_uq, 'service_environment_collection_type = ' || quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF OLD.is_multivalue IS DISTINCT FROM NEW.is_multivalue THEN
IF NEW.is_multivalue = 'Y' THEN
	_uq := array_append(_uq, 'is_multivalue = true');
ELSIF NEW.is_multivalue = 'N' THEN
	_uq := array_append(_uq, 'is_multivalue = false');
ELSE
	_uq := array_append(_uq, 'is_multivalue = NULL');
END IF;
	END IF;

	IF OLD.prop_val_acct_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_acct_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_account_collection_type_restriction = ' || quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_dev_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_dev_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_device_collection_type_restriction = ' || quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_nblk_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_nblk_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_netblock_collection_type_restriction = ' || quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF OLD.property_data_type IS DISTINCT FROM NEW.property_data_type THEN
_uq := array_append(_uq, 'property_data_type = ' || quote_nullable(NEW.property_data_type));
	END IF;

	IF OLD.property_value_json_schema IS DISTINCT FROM NEW.property_value_json_schema THEN
_uq := array_append(_uq, 'property_value_json_schema = ' || quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF OLD.permit_account_collection_id IS DISTINCT FROM NEW.permit_account_collection_id THEN
_uq := array_append(_uq, 'permit_account_collection_id = ' || quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF OLD.permit_account_id IS DISTINCT FROM NEW.permit_account_id THEN
_uq := array_append(_uq, 'permit_account_id = ' || quote_nullable(NEW.permit_account_id));
	END IF;

	IF OLD.permit_account_realm_id IS DISTINCT FROM NEW.permit_account_realm_id THEN
_uq := array_append(_uq, 'permit_account_realm_id = ' || quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF OLD.permit_company_id IS DISTINCT FROM NEW.permit_company_id THEN
_uq := array_append(_uq, 'permit_company_id = ' || quote_nullable(NEW.permit_company_id));
	END IF;

	IF OLD.permit_company_collection_id IS DISTINCT FROM NEW.permit_company_collection_id THEN
_uq := array_append(_uq, 'permit_company_collection_id = ' || quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF OLD.permit_device_collection_id IS DISTINCT FROM NEW.permit_device_collection_id THEN
_uq := array_append(_uq, 'permit_device_collection_id = ' || quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF OLD.permit_dns_domain_coll_id IS DISTINCT FROM NEW.permit_dns_domain_coll_id THEN
_uq := array_append(_uq, 'permit_dns_domain_collection_id = ' || quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF OLD.permit_layer2_network_coll_id IS DISTINCT FROM NEW.permit_layer2_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer2_network_collection_id = ' || quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF OLD.permit_layer3_network_coll_id IS DISTINCT FROM NEW.permit_layer3_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer3_network_collection_id = ' || quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF OLD.permit_netblock_collection_id IS DISTINCT FROM NEW.permit_netblock_collection_id THEN
_uq := array_append(_uq, 'permit_netblock_collection_id = ' || quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF OLD.permit_network_range_id IS DISTINCT FROM NEW.permit_network_range_id THEN
_uq := array_append(_uq, 'permit_network_range_id = ' || quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF OLD.permit_operating_system_id IS DISTINCT FROM NEW.permit_operating_system_id THEN
_uq := array_append(_uq, 'permit_operating_system_id = ' || quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF OLD.permit_os_snapshot_id IS DISTINCT FROM NEW.permit_os_snapshot_id THEN
_uq := array_append(_uq, 'permit_operating_system_snapshot_id = ' || quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF OLD.permit_property_collection_id IS DISTINCT FROM NEW.permit_property_collection_id THEN
_uq := array_append(_uq, 'permit_property_name_collection_id = ' || quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF OLD.permit_service_env_collection IS DISTINCT FROM NEW.permit_service_env_collection THEN
_uq := array_append(_uq, 'permit_service_environment_collection = ' || quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF OLD.permit_site_code IS DISTINCT FROM NEW.permit_site_code THEN
_uq := array_append(_uq, 'permit_site_code = ' || quote_nullable(NEW.permit_site_code));
	END IF;

	IF OLD.permit_x509_signed_cert_id IS DISTINCT FROM NEW.permit_x509_signed_cert_id THEN
_uq := array_append(_uq, 'permit_x509_signed_certificate_id = ' || quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF OLD.permit_property_rank IS DISTINCT FROM NEW.permit_property_rank THEN
_uq := array_append(_uq, 'permit_property_rank = ' || quote_nullable(NEW.permit_property_rank));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.val_property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_name = $1 AND  property_type = $2 RETURNING *'  USING OLD.property_name, OLD.property_type
			INTO _nr;

		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;
		NEW.description = _nr.description;
		NEW.account_collection_type = _nr.account_collection_type;
		NEW.company_collection_type = _nr.company_collection_type;
		NEW.device_collection_type = _nr.device_collection_type;
		NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
		NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
		NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
		NEW.netblock_collection_type = _nr.netblock_collection_type;
		NEW.network_range_type = _nr.network_range_type;
		NEW.property_collection_type = _nr.property_name_collection_type;
		NEW.service_env_collection_type = _nr.service_environment_collection_type;
		NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
		NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
		NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
		NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
		NEW.property_data_type = _nr.property_data_type;
		NEW.property_value_json_schema = _nr.property_value_json_schema;
		NEW.permit_account_collection_id = _nr.permit_account_collection_id;
		NEW.permit_account_id = _nr.permit_account_id;
		NEW.permit_account_realm_id = _nr.permit_account_realm_id;
		NEW.permit_company_id = _nr.permit_company_id;
		NEW.permit_company_collection_id = _nr.permit_company_collection_id;
		NEW.permit_device_collection_id = _nr.permit_device_collection_id;
		NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
		NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
		NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
		NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
		NEW.permit_network_range_id = _nr.permit_network_range_id;
		NEW.permit_operating_system_id = _nr.permit_operating_system_id;
		NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
		NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
		NEW.permit_service_env_collection = _nr.permit_service_environment_collection;
		NEW.permit_site_code = _nr.permit_site_code;
		NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
		NEW.permit_property_rank = _nr.permit_property_rank;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_val_property_upd INSTEAD OF UPDATE ON jazzhands_legacy.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.val_property_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('val_property');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_property');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_property  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE val_property (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_property failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_property failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE x509_certificate
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'x509_certificate', 'x509_certificate');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'x509_certificate', tags := ARRAY['view_x509_certificate']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.x509_certificate;
CREATE VIEW jazzhands_legacy.x509_certificate AS
 SELECT crt.x509_signed_certificate_id AS x509_cert_id,
    crt.friendly_name,
        CASE
            WHEN crt.is_active IS NULL THEN NULL::text
            WHEN crt.is_active = true THEN 'Y'::text
            WHEN crt.is_active = false THEN 'N'::text
            ELSE NULL::text
        END AS is_active,
        CASE
            WHEN crt.is_certificate_authority IS NULL THEN NULL::text
            WHEN crt.is_certificate_authority = true THEN 'Y'::text
            WHEN crt.is_certificate_authority = false THEN 'N'::text
            ELSE NULL::text
        END AS is_certificate_authority,
    crt.signing_cert_id,
    crt.x509_ca_cert_serial_number,
    crt.public_key,
    key.private_key,
    csr.certificate_signing_request AS certificate_sign_req,
    crt.subject,
    crt.subject_key_identifier,
    crt.valid_from,
    crt.valid_to,
    crt.x509_revocation_date,
    crt.x509_revocation_reason,
    key.passphrase,
    key.encryption_key_id,
    crt.ocsp_uri,
    crt.crl_uri,
    crt.data_ins_user,
    crt.data_ins_date,
    crt.data_upd_user,
    crt.data_upd_date
   FROM jazzhands.x509_signed_certificate crt
     LEFT JOIN jazzhands.private_key key USING (private_key_id)
     LEFT JOIN jazzhands.certificate_signing_request csr USING (certificate_signing_request_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('x509_certificate','x509_certificate');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate','x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of x509_certificate failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();
ALTER TABLE jazzhands_legacy.x509_certificate
	ALTER is_active
	SET DEFAULT 'Y'::bpchar;
ALTER TABLE jazzhands_legacy.x509_certificate
	ALTER is_certificate_authority
	SET DEFAULT 'N'::bpchar;

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.x509_certificate_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	crt     jazzhands.x509_signed_certificate%ROWTYPE;
	key     jazzhands.private_key%ROWTYPE;
	csr     jazzhands.certificate_signing_request%ROWTYPE;
BEGIN
	SELECT * INTO crt FROM jazzhands.x509_signed_certificate
		WHERE x509_signed_certificate_id = OLD.x509_cert_id;

	IF crt.private_key_id IS NOT NULL THEN
		DELETE FROM jazzhands.private_key
		WHERE private_key_id = crt.private_key_id
		RETURNING * INTO key;
	END IF;

	IF crt.private_key_id IS NOT NULL THEN
		DELETE FROM jazzhands.certificate_signing_request
		WHERE certificate_signing_request_id =
		crt.certificate_signing_request_id
		RETURNING * INTO crt;
	END IF;

	OLD.x509_cert_id = crt.x509_signed_certiciate_id;
	OLD.friendly_name = crt.friendly_name;
	OLD.is_active = CASE WHEN crt.is_active = true THEN 'Y' WHEN crt.is_active = false THEN 'N' ELSE NULL END;
	OLD.is_certificate_authority = CASE WHEN crt.is_certificate_authority = true THEN 'Y' WHEN crt.is_certificate_authority = false THEN 'N' ELSE NULL END;
	OLD.signing_cert_id = crt.signing_cert_id;
	OLD.x509_ca_cert_serial_number = crt.x509_ca_cert_serial_number;
	OLD.public_key = crt.public_key;
	OLD.private_key = key.private_key;
	OLD.certificate_sign_req = crt.certificate_signing_request;
	OLD.subject = crt.subject;
	OLD.subject_key_identifier = crt.subject_key_identifier;
	OLD.valid_from = crt.valid_from;
	OLD.valid_to = crt.valid_to;
	OLD.x509_revocation_date = crt.x509_revocation_date;
	OLD.x509_revocation_reason = crt.x509_revocation_reason;
	OLD.passphrase = key.passphrase;
	OLD.encryption_key_id = key.encryption_key_id;
	OLD.ocsp_uri = crt.ocsp_uri;
	OLD.crl_uri = crt.crl_uri;
	OLD.data_ins_user = crt.data_ins_user;
	OLD.data_ins_date = crt.data_ins_date;
	OLD.data_upd_user = crt.data_upd_user;
	OLD.data_upd_date = crt.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_x509_certificate_del INSTEAD OF DELETE ON jazzhands_legacy.x509_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.x509_certificate_del();

-- considering NEW jazzhands_legacy.x509_certificate_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	key	jazzhands.private_key%rowtype;
	csr	jazzhands.certificate_signing_request%rowtype;
	crt	jazzhands.x509_signed_certificate%rowtype;
BEGIN
	IF NEW.private_key IS NOT NULL THEN
		INSERT INTO jazzhands.private_key (
			private_key_encryption_type,
			is_active,
			subject_key_identifier,
			private_key,
			passphrase,
			encryption_key_id
		) VALUES (
			'rsa',
			NEW.is_active,
			NEW.subject_key_identifier,
			NEW.private_key,
			NEW.passphrase,
			NEW.encryption_key_id
		) RETURNING * INTO key;
		NEW.x509_cert_id := key;
	ELSE
		IF NEW.subject_key_identifier IS NOT NULL THEN
			SELECT jazzhands.private_key_id
			INTO key
			FROM private_key
			WHERE subject_key_identifier = NEW.subject_key_identifier;

			SELECT private_key
			INTO NEW.private_key
			FROM private_key
			WHERE private_key_id = key;
		END IF;
	END IF;

	IF NEW.certificate_sign_req IS NOT NULL THEN
		INSERT INTO jazzhands.certificate_signing_request (
			friendly_name,
			subject,
			certificate_signing_request,
			private_key_id
		) VALUES (
			NEW.friendly_name,
			NEW.subject,
			NEW.certificate_sign_req,
			key
		) RETURNING * INTO csr;
		IF NEW.x509_cert_id IS NULL THEN
			NEW.x509_cert_id := csr;
		END IF;
	ELSE
		IF NEW.subject_key_identifier IS NOT NULL THEN
			SELECT certificate_signing_request_id
			INTO csr
			FROM certificate_signing_request
				JOIN private_key USING (private_key_id)
			WHERE subject_key_identifier = NEW.subject_key_identifier
			ORDER BY certificate_signing_request_id
			LIMIT 1;

			SELECT certificate_signing_request
			INTO NEW.certificate_sign_req
			FROM certificate_signing_request
			WHERE certificate_signing_request_id  = csr;
		END IF;
	END IF;

	IF NEW.public_key IS NOT NULL THEN
		INSERT INTO jazzhands.x509_signed_certificate (
			friendly_name,
			is_active,
			is_certificate_authority,
			signing_cert_id,
			x509_ca_cert_serial_number,
			public_key,
			subject,
			subject_key_identifier,
			valid_from,
			valid_to,
			x509_revocation_date,
			x509_revocation_reason,
			ocsp_uri,
			crl_uri,
			private_key_id,
			certificate_signing_request_id
		) VALUES (
			NEW.friendly_name,
			CASE WHEN NEW.is_active = 'Y' THEN true
				WHEN NEW.is_active = 'N' THEN false
				ELSE NULL END,
			CASE WHEN NEW.is_certificate_authority = 'Y' THEN true
				WHEN NEW.is_certificate_authority = 'N' THEN false
				ELSE NULL END,
			NEW.signing_cert_id,
			NEW.x509_ca_cert_serial_number,
			NEW.public_key,
			NEW.subject,
			NEW.subject_key_identifier,
			NEW.valid_from,
			NEW.valid_to,
			NEW.x509_revocation_date,
			NEW.x509_revocation_reason,
			NEW.ocsp_uri,
			NEW.crl_uri,
			key,
			csr
		) RETURNING * INTO crt;
	END IF;

	NEW.x509_cert_id 		= crt.x509_signed_certificate_id;
	NEW.friendly_name 		= crt.friendly_name;
	NEW.is_active 			= CASE WHEN crt.is_active = true THEN 'Y'
								WHEN crt.is_active = false THEN 'N'
								ELSE NULL END;
	NEW.is_certificate_authority = CASE WHEN crt.is_certificate_authority =
									true THEN 'Y'
								WHEN crt.is_certificate_authority = false
									THEN 'N'
								ELSE NULL END;

	NEW.signing_cert_id 			= crt.signing_cert_id;
	NEW.x509_ca_cert_serial_number	= crt.x509_ca_cert_serial_number;
	NEW.public_key 					= crt.public_key;
	NEW.private_key 				= key.private_key;
	NEW.certificate_sign_req 		= csr.certificate_signing_request;
	NEW.subject 					= crt.subject;
	NEW.subject_key_identifier 		= crt.subject_key_identifier;
	NEW.valid_from 					= crt.valid_from;
	NEW.valid_to 					= crt.valid_to;
	NEW.x509_revocation_date 		= crt.x509_revocation_date;
	NEW.x509_revocation_reason 		= crt.x509_revocation_reason;
	NEW.passphrase 					= key.passphrase;
	NEW.encryption_key_id 			= key.encryption_key_id;
	NEW.ocsp_uri 					= crt.ocsp_uri;
	NEW.crl_uri 					= crt.crl_uri;
	NEW.data_ins_user 				= crt.data_ins_user;
	NEW.data_ins_date 				= crt.data_ins_date;
	NEW.data_upd_user 				= crt.data_upd_user;
	NEW.data_upd_date 				= crt.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_x509_certificate_ins INSTEAD OF INSERT ON jazzhands_legacy.x509_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.x509_certificate_ins();

-- considering NEW jazzhands_legacy.x509_certificate_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	crt	jazzhands.x509_signed_certificate%rowtype;
	key	jazzhands.private_key%rowtype;
	csr	jazzhands.certificate_signing_request%rowtype;
	_uq	text[];
BEGIN
	SELECT * INTO crt FROM jazzhands.x509_signed_certificate
        WHERE x509_signed_certificate_id = OLD.x509_cert_id;

	IF crt.private_key_ID IS NULL AND NEW.private_key IS NOT NULL THEN
		INSERT INTO private_key (
			private_key_encryption_type,
			is_active,
			subject_key_identifier,
			private_key,
			passphrase,
			encryption_key_id
		) VALUES (
			'rsa',
			NEW.is_active,
			NEW.subject_key_identifier,
			NEW.private_key,
			NEW.passphrase,
			NEW.encryption_key_id
		) RETURNING * INTO key;
	ELSE IF crt.private_key_id IS NOT NULL THEN
		SELECT * INTO key FROM jazzhands.private_key k
			WHERE k.private_key_id =  crt.private_key_id;

		-- delete happens at the end, after update
		IF NEW.private_key IS NOT NULL THEN
			IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
				_uq := array_append(_uq,
					'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
				);
			END IF;
			IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
				_uq := array_append(_uq,
					'is_active = ' || quote_literal(NEW.is_active)
				);
			END IF;
			IF OLD.private_key IS DISTINCT FROM NEW.private_key THEN
				_uq := array_append(_uq,
					'private_key = ' || quote_nullable(NEW.private_key)
				);
			END IF;
			IF OLD.passphrase IS DISTINCT FROM NEW.passphrase THEN
				_uq := array_append(_uq,
					'passphrase = ' || quote_nullable(NEW.passphrase)
				);
			END IF;
			IF OLD.encryption_key_id IS DISTINCT FROM NEW.encryption_key_id THEN
				_uq := array_append(_uq,
					'encryption_key_id = ' || quote_nullable(NEW.encryption_key_id)
				);
			END IF;
			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.private_key 	= key.private_key;
		NEW.is_active 		= key.private_key;
		NEW.passphrase 		= key.passphrase;
		NEW.encryption_key 	= key.passphrase;
	END IF;

	-- private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF crt.certificate_signing_request_id IS NULL AND NEW.certificate_sign_req IS NOT NULL THEN
		INSERT INTO jazzhands.certificate_signing_request (
			friendly_name,
			subject,
			certificate_signing_request,
			private_key_id
		) VALUES (
			NEW.friendly_name,
			NEW.subject,
			NEW.certificate_sign_req,
			key.private_key_id
		) RETURNING * INTO csr;
	ELSIF crt.certificate_sign_req IS NOT NULL THEN
		SELECT * INTO csr FROM jazzhands.certificate_signing_request c
			WHERE c.certificate_sign_req =  crt.certificate_signing_request_id;

		-- delete happens at the end, after update
		IF NEW.certificate_sign_req IS NOT NULL THEN
			IF OLD.certificate_sign_req IS DISTINCT FROM NEW.certificate_sign_req THEN
				_uq := array_append(_uq,
					'certificate_signing_request = ' || quote_nullable(NEW.certificate_sign_req)
				);
			END IF;
			IF OLD.subject IS DISTINCT FROM NEW.subject THEN
				_uq := array_append(_uq,
					'subject = ' || quote_nullable(NEW.subject)
				);
			END IF;
			IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
				_uq := array_append(_uq,
					'friendly_name = ' || quote_nullable(NEW.friendly_name)
				);
			END IF;
			IF OLD.private_key_id IS DISTINCT FROM key.private_key_id THEN
				_uq := array_append(_uq,
					'private_key_id = ' || quote_nullable(NEW.private_key_id)
				);
			END IF;

			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.certificate_sign_req 	= csr.certificate_signing_request;
	END IF;

	-- csr and private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
		IF NEW.is_active = 'Y' THEN
			_uq := array_append(_uq, 'is_active = true');
		ELSIF NEW.is_active = 'N' THEN
			_uq := array_append(_uq, 'is_active = false');
		ELSE
			_uq := array_append(_uq, 'is_active = NULL');
		END IF;
	END IF;

	END IF;
	IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
		_uq := array_append(_uq,
			'friendly_name = ' || quote_literal(NEW.friendly_name)
		);
	END IF;
	IF OLD.subject IS DISTINCT FROM NEW.subject THEN
		_uq := array_append(_uq,
			'subject = ' || quote_literal(NEW.subject)
		);
	END IF;
	IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
		_uq := array_append(_uq,
			'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
		);
	END IF;

	IF OLD.is_certificate_authority IS DISTINCT FROM NEW.is_certificate_authority THEN
		IF NEW.is_certificate_authority = 'Y' THEN
			_uq := array_append(_uq, 'is_certificate_authority = true');
		ELSIF NEW.is_certificate_authority = 'N' THEN
			_uq := array_append(_uq, 'is_certificate_authority = false');
		ELSE
			_uq := array_append(_uq, 'is_certificate_authority = NULL');
		END IF;
	END IF;

	IF OLD.signing_cert_id IS DISTINCT FROM NEW.signing_cert_id THEN
		_uq := array_append(_uq,
			'signing_cert_id = ' || quote_nullable(NEW.signing_cert_id)
		);
	END IF;
	IF OLD.x509_ca_cert_serial_number IS DISTINCT FROM NEW.x509_ca_cert_serial_number THEN
		_uq := array_append(_uq,
			'x509_ca_cert_serial_number = ' || quote_nullable(NEW.x509_ca_cert_serial_number)
		);
	END IF;
	IF OLD.public_key IS DISTINCT FROM NEW.public_key THEN
		_uq := array_append(_uq,
			'public_key = ' || quote_nullable(NEW.public_key)
		);
	END IF;
	IF OLD.valid_from IS DISTINCT FROM NEW.valid_from THEN
		_uq := array_append(_uq,
			'valid_from = ' || quote_nullable(NEW.valid_from)
		);
	END IF;
	IF OLD.valid_to IS DISTINCT FROM NEW.valid_to THEN
		_uq := array_append(_uq,
			'valid_to = ' || quote_nullable(NEW.valid_to)
		);
	END IF;
	IF OLD.x509_revocation_date IS DISTINCT FROM NEW.x509_revocation_date THEN
		_uq := array_append(_uq,
			'x509_revocation_date = ' || quote_nullable(NEW.x509_revocation_date)
		);
	END IF;
	IF OLD.x509_revocation_reason IS DISTINCT FROM NEW.x509_revocation_reason THEN
		_uq := array_append(_uq,
			'x509_revocation_reason = ' || quote_nullable(NEW.x509_revocation_reason)
		);
	END IF;
	IF OLD.ocsp_uri IS DISTINCT FROM NEW.ocsp_uri THEN
		_uq := array_append(_uq,
			'ocsp_uri = ' || quote_nullable(NEW.ocsp_uri)
		);
	END IF;
	IF OLD.crl_uri IS DISTINCT FROM NEW.crl_uri THEN
		_uq := array_append(_uq,
			'crl_uri = ' || quote_nullable(NEW.crl_uri)
		);
	END IF;

	IF array_length(_uq, 1) > 0 THEN
		EXECUTE 'UPDATE x509_signed_certificate SET '
			|| array_to_string(upq, ', ')
			|| ' WHERE x509_signed_certificate_id = '
			|| NEW.x509_cert_id;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.x509_certificate SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  x509_cert_id = $1 RETURNING *'  USING OLD.x509_cert_id
			INTO crt;

		NEW.x509_cert_id = _crt.x509_signed_certificate_id;
		NEW.friendly_name = crt.friendly_name;
		NEW.is_active = CASE WHEN crt.is_active = true THEN 'Y' WHEN crt.is_active = false THEN 'N' ELSE NULL END;
		NEW.is_certificate_authority = CASE WHEN crt.is_certificate_authority = true THEN 'Y' WHEN crt.is_certificate_authority = false THEN 'N' ELSE NULL END;
		NEW.signing_cert_id = crt.signing_cert_id;
		NEW.x509_ca_cert_serial_number = crt.x509_ca_cert_serial_number;
		NEW.public_key = crt.public_key;
		NEW.subject = crt.subject;
		NEW.subject_key_identifier = crt.subject_key_identifier;
		NEW.valid_from = crt.valid_from;
		NEW.valid_to = crt.valid_to;
		NEW.x509_revocation_date = crt.x509_revocation_date;
		NEW.x509_revocation_reason = crt.x509_revocation_reason;
		NEW.ocsp_uri = crt.ocsp_uri;
		NEW.crl_uri = crt.crl_uri;
		NEW.data_ins_user = crt.data_ins_user;
		NEW.data_ins_date = crt.data_ins_date;
		NEW.data_upd_user = crt.data_upd_user;
		NEW.data_upd_date = crt.data_upd_date;
	END IF;

	IF OLD.certificate_sign_req IS NOT NULL AND NEW.certificate_sign_req IS NULL THEN
		DELETE FROM jazzhands.certificate_signing_request
		WHERE certificate_signing_request_id = crt.certificate_signing_request_id;
	END IF;

	IF OLD.private_key IS NOT NULL AND NEW.private_key IS NULL THEN
		DELETE FROM jazzhands.private_key
		WHERE private_key_id = crt.private_key_id;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_x509_certificate_upd INSTEAD OF UPDATE ON jazzhands_legacy.x509_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.x509_certificate_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for x509_certificate  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE x509_certificate (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('x509_certificate');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old x509_certificate failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('x509_certificate');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('x509_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new x509_certificate failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_person_company
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_person_company', 'v_person_company');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_person_company', tags := ARRAY['view_v_person_company']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.v_person_company;
CREATE VIEW jazzhands_legacy.v_person_company AS
 SELECT pc.company_id,
    pc.person_id,
    pc.person_company_status,
    pc.person_company_relation,
        CASE
            WHEN pc.is_exempt IS NULL THEN NULL::text
            WHEN pc.is_exempt = true THEN 'Y'::text
            WHEN pc.is_exempt = false THEN 'N'::text
            ELSE NULL::text
        END AS is_exempt,
        CASE
            WHEN pc.is_management IS NULL THEN NULL::text
            WHEN pc.is_management = true THEN 'Y'::text
            WHEN pc.is_management = false THEN 'N'::text
            ELSE NULL::text
        END AS is_management,
        CASE
            WHEN pc.is_full_time IS NULL THEN NULL::text
            WHEN pc.is_full_time = true THEN 'Y'::text
            WHEN pc.is_full_time = false THEN 'N'::text
            ELSE NULL::text
        END AS is_full_time,
    pc.description,
    empid.attribute_value AS employee_id,
    payid.attribute_value AS payroll_id,
    hrid.attribute_value AS external_hr_id,
    pc.position_title,
    badge.attribute_value AS badge_system_id,
    pc.hire_date,
    pc.termination_date,
    pc.manager_person_id,
    super.attribute_value_person_id AS supervisor_person_id,
    pc.nickname,
    pc.data_ins_user,
    pc.data_ins_date,
    pc.data_upd_user,
    pc.data_upd_date
   FROM jazzhands.person_company pc
     LEFT JOIN ( SELECT person_company_attribute.company_id,
            person_company_attribute.person_id,
            person_company_attribute.person_company_attribute_name,
            person_company_attribute.attribute_value,
            person_company_attribute.attribute_value_timestamp,
            person_company_attribute.attribute_value_person_id,
            person_company_attribute.start_date,
            person_company_attribute.finish_date,
            person_company_attribute.data_ins_user,
            person_company_attribute.data_ins_date,
            person_company_attribute.data_upd_user,
            person_company_attribute.data_upd_date
           FROM jazzhands.person_company_attribute
          WHERE person_company_attribute.person_company_attribute_name::text = 'employee_id'::text) empid USING (company_id, person_id)
     LEFT JOIN ( SELECT person_company_attribute.company_id,
            person_company_attribute.person_id,
            person_company_attribute.person_company_attribute_name,
            person_company_attribute.attribute_value,
            person_company_attribute.attribute_value_timestamp,
            person_company_attribute.attribute_value_person_id,
            person_company_attribute.start_date,
            person_company_attribute.finish_date,
            person_company_attribute.data_ins_user,
            person_company_attribute.data_ins_date,
            person_company_attribute.data_upd_user,
            person_company_attribute.data_upd_date
           FROM jazzhands.person_company_attribute
          WHERE person_company_attribute.person_company_attribute_name::text = 'payroll_id'::text) payid USING (company_id, person_id)
     LEFT JOIN ( SELECT person_company_attribute.company_id,
            person_company_attribute.person_id,
            person_company_attribute.person_company_attribute_name,
            person_company_attribute.attribute_value,
            person_company_attribute.attribute_value_timestamp,
            person_company_attribute.attribute_value_person_id,
            person_company_attribute.start_date,
            person_company_attribute.finish_date,
            person_company_attribute.data_ins_user,
            person_company_attribute.data_ins_date,
            person_company_attribute.data_upd_user,
            person_company_attribute.data_upd_date
           FROM jazzhands.person_company_attribute
          WHERE person_company_attribute.person_company_attribute_name::text = 'badge_system_id'::text) badge USING (company_id, person_id)
     LEFT JOIN ( SELECT person_company_attribute.company_id,
            person_company_attribute.person_id,
            person_company_attribute.person_company_attribute_name,
            person_company_attribute.attribute_value,
            person_company_attribute.attribute_value_timestamp,
            person_company_attribute.attribute_value_person_id,
            person_company_attribute.start_date,
            person_company_attribute.finish_date,
            person_company_attribute.data_ins_user,
            person_company_attribute.data_ins_date,
            person_company_attribute.data_upd_user,
            person_company_attribute.data_upd_date
           FROM jazzhands.person_company_attribute
          WHERE person_company_attribute.person_company_attribute_name::text = 'supervisor_id'::text) super USING (company_id, person_id)
     LEFT JOIN ( SELECT person_company_attribute.company_id,
            person_company_attribute.person_id,
            person_company_attribute.person_company_attribute_name,
            person_company_attribute.attribute_value,
            person_company_attribute.attribute_value_timestamp,
            person_company_attribute.attribute_value_person_id,
            person_company_attribute.start_date,
            person_company_attribute.finish_date,
            person_company_attribute.data_ins_user,
            person_company_attribute.data_ins_date,
            person_company_attribute.data_upd_user,
            person_company_attribute.data_upd_date
           FROM jazzhands.person_company_attribute
          WHERE person_company_attribute.person_company_attribute_name::text = 'external_hr_id'::text) hrid USING (company_id, person_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_person_company','v_person_company');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company','v_person_company');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_person_company failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();
ALTER TABLE jazzhands_legacy.v_person_company
	ALTER is_exempt
	SET DEFAULT 'Y'::text;
ALTER TABLE jazzhands_legacy.v_person_company
	ALTER is_management
	SET DEFAULT 'N'::text;
ALTER TABLE jazzhands_legacy.v_person_company
	ALTER is_full_time
	SET DEFAULT 'Y'::text;

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
-- considering NEW jazzhands_legacy.v_person_company_del
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.person_company%rowtype;
BEGIN

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'employee_id'
	RETURNING attribute_value INTO OLD.employee_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'payroll_id'
	RETURNING attribute_value INTO OLD.payroll_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'external_hr_id'
	RETURNING attribute_value INTO OLD.external_hr_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'badge_system_id'
	RETURNING attribute_value INTO OLD.badge_system_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'supervisor_person_id'
	RETURNING attribute_value_person_id INTO OLD.supervisor_person_id;

	DELETE FROM jazzhands.person_company
	WHERE  person_id = OLD.person_id  AND  company_id = OLD.company_id  RETURNING *
	INTO _or;
	OLD.company_id = _or.company_id;
	OLD.person_id = _or.person_id;
	OLD.person_company_status = _or.person_company_status;
	OLD.person_company_relation = _or.person_company_relation;
	OLD.is_exempt = CASE WHEN _or.is_exempt = true THEN 'Y' WHEN _or.is_exempt = false THEN 'N' ELSE NULL END;
	OLD.is_management = CASE WHEN _or.is_management = true THEN 'Y' WHEN _or.is_management = false THEN 'N' ELSE NULL END;
	OLD.is_full_time = CASE WHEN _or.is_full_time = true THEN 'Y' WHEN _or.is_full_time = false THEN 'N' ELSE NULL END;
	OLD.description = _or.description;
	OLD.position_title = _or.position_title;
	OLD.hire_date = _or.hire_date;
	OLD.termination_date = _or.termination_date;
	OLD.manager_person_id = _or.manager_person_id;
	OLD.nickname = _or.nickname;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;
CREATE TRIGGER trigger_v_person_company_del INSTEAD OF DELETE ON jazzhands_legacy.v_person_company FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_person_company_del();

-- considering NEW jazzhands_legacy.v_person_company_ins
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.person_company%rowtype;
BEGIN

	IF NEW.company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_id));
	END IF;

	IF NEW.person_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_id'));
		_vq := array_append(_vq, quote_nullable(NEW.person_id));
	END IF;

	IF NEW.person_company_status IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_company_status'));
		_vq := array_append(_vq, quote_nullable(NEW.person_company_status));
	END IF;

	IF NEW.person_company_relation IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_company_relation'));
		_vq := array_append(_vq, quote_nullable(NEW.person_company_relation));
	END IF;

	IF NEW.is_exempt IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_exempt'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_exempt = 'Y' THEN true WHEN NEW.is_exempt = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.is_management IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_management'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_management = 'Y' THEN true WHEN NEW.is_management = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.is_full_time IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_full_time'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_full_time = 'Y' THEN true WHEN NEW.is_full_time = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.position_title IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('position_title'));
		_vq := array_append(_vq, quote_nullable(NEW.position_title));
	END IF;

	IF NEW.hire_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('hire_date'));
		_vq := array_append(_vq, quote_nullable(NEW.hire_date));
	END IF;

	IF NEW.termination_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('termination_date'));
		_vq := array_append(_vq, quote_nullable(NEW.termination_date));
	END IF;

	IF NEW.manager_person_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('manager_person_id'));
		_vq := array_append(_vq, quote_nullable(NEW.manager_person_id));
	END IF;

	IF NEW.nickname IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('nickname'));
		_vq := array_append(_vq, quote_nullable(NEW.nickname));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.person_company (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	--
	-- These are the backwards compatability columns no longer in jazzhands.
	--

	IF NEW.employee_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'employee_id',
			NEW.employee_id
		) RETURNING attribute_value INTO NEW.employee_id;
	END IF;

	IF NEW.payroll_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'payroll_id',
			NEW.payroll_id
		) RETURNING attribute_value INTO NEW.payroll_id;
	END IF;

	IF NEW.external_hr_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'external_hr_id',
			NEW.external_hr_id
		) RETURNING attribute_value INTO NEW.external_hr_id;
	END IF;

	IF NEW.badge_system_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'badge_system_id',
			NEW.badge_system_id
		) RETURNING attribute_value INTO NEW.badge_system_id;
	END IF;

	IF NEW.supervisor_person_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value_person_id
		) VALUES  (
			NEW.company_id, NEW.person_id, 'supervisor_person_id',
			NEW.attribute_value_person_id
		) RETURNING attribute_value_person_id INTO NEW.supervisor_person_id;
	END IF;

	--
	-- End of backwards compatability columns no longer in jazzhands
	--

	NEW.company_id = _nr.company_id;
	NEW.person_id = _nr.person_id;
	NEW.person_company_status = _nr.person_company_status;
	NEW.person_company_relation = _nr.person_company_relation;
	NEW.is_exempt = CASE WHEN _nr.is_exempt = true THEN 'Y' WHEN _nr.is_exempt = false THEN 'N' ELSE NULL END;
	NEW.is_management = CASE WHEN _nr.is_management = true THEN 'Y' WHEN _nr.is_management = false THEN 'N' ELSE NULL END;
	NEW.is_full_time = CASE WHEN _nr.is_full_time = true THEN 'Y' WHEN _nr.is_full_time = false THEN 'N' ELSE NULL END;
	NEW.description = _nr.description;
	NEW.position_title = _nr.position_title;
	NEW.hire_date = _nr.hire_date;
	NEW.termination_date = _nr.termination_date;
	NEW.manager_person_id = _nr.manager_person_id;
	NEW.nickname = _nr.nickname;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_person_company_ins INSTEAD OF INSERT ON jazzhands_legacy.v_person_company FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_person_company_ins();

-- considering NEW jazzhands_legacy.v_person_company_upd
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.v_person_company%rowtype;
	_nr	jazzhands.person_company%rowtype;
	_uq	text[];
BEGIN

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.person_id IS DISTINCT FROM NEW.person_id THEN
_uq := array_append(_uq, 'person_id = ' || quote_nullable(NEW.person_id));
	END IF;

	IF OLD.person_company_status IS DISTINCT FROM NEW.person_company_status THEN
_uq := array_append(_uq, 'person_company_status = ' || quote_nullable(NEW.person_company_status));
	END IF;

	IF OLD.person_company_relation IS DISTINCT FROM NEW.person_company_relation THEN
_uq := array_append(_uq, 'person_company_relation = ' || quote_nullable(NEW.person_company_relation));
	END IF;

	IF OLD.is_exempt IS DISTINCT FROM NEW.is_exempt THEN
IF NEW.is_exempt = 'Y' THEN
	_uq := array_append(_uq, 'is_exempt = true');
ELSIF NEW.is_exempt = 'N' THEN
	_uq := array_append(_uq, 'is_exempt = false');
ELSE
	_uq := array_append(_uq, 'is_exempt = NULL');
END IF;
	END IF;

	IF OLD.is_management IS DISTINCT FROM NEW.is_management THEN
IF NEW.is_management = 'Y' THEN
	_uq := array_append(_uq, 'is_management = true');
ELSIF NEW.is_management = 'N' THEN
	_uq := array_append(_uq, 'is_management = false');
ELSE
	_uq := array_append(_uq, 'is_management = NULL');
END IF;
	END IF;

	IF OLD.is_full_time IS DISTINCT FROM NEW.is_full_time THEN
IF NEW.is_full_time = 'Y' THEN
	_uq := array_append(_uq, 'is_full_time = true');
ELSIF NEW.is_full_time = 'N' THEN
	_uq := array_append(_uq, 'is_full_time = false');
ELSE
	_uq := array_append(_uq, 'is_full_time = NULL');
END IF;
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.position_title IS DISTINCT FROM NEW.position_title THEN
_uq := array_append(_uq, 'position_title = ' || quote_nullable(NEW.position_title));
	END IF;

	IF OLD.hire_date IS DISTINCT FROM NEW.hire_date THEN
_uq := array_append(_uq, 'hire_date = ' || quote_nullable(NEW.hire_date));
	END IF;

	IF OLD.termination_date IS DISTINCT FROM NEW.termination_date THEN
_uq := array_append(_uq, 'termination_date = ' || quote_nullable(NEW.termination_date));
	END IF;

	IF OLD.manager_person_id IS DISTINCT FROM NEW.manager_person_id THEN
_uq := array_append(_uq, 'manager_person_id = ' || quote_nullable(NEW.manager_person_id));
	END IF;

	IF OLD.nickname IS DISTINCT FROM NEW.nickname THEN
_uq := array_append(_uq, 'nickname = ' || quote_nullable(NEW.nickname));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.person_company SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  person_id = $1 AND  company_id = $2 RETURNING *'  USING OLD.person_id, OLD.company_id
			INTO _nr;

		NEW.company_id = _nr.company_id;
		NEW.person_id = _nr.person_id;
		NEW.person_company_status = _nr.person_company_status;
		NEW.person_company_relation = _nr.person_company_relation;
		NEW.is_exempt = CASE WHEN _nr.is_exempt = true THEN 'Y' WHEN _nr.is_exempt = false THEN 'N' ELSE NULL END;
		NEW.is_management = CASE WHEN _nr.is_management = true THEN 'Y' WHEN _nr.is_management = false THEN 'N' ELSE NULL END;
		NEW.is_full_time = CASE WHEN _nr.is_full_time = true THEN 'Y' WHEN _nr.is_full_time = false THEN 'N' ELSE NULL END;
		NEW.description = _nr.description;
		NEW.position_title = _nr.position_title;
		NEW.hire_date = _nr.hire_date;
		NEW.termination_date = _nr.termination_date;
		NEW.manager_person_id = _nr.manager_person_id;
		NEW.nickname = _nr.nickname;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;

       IF NEW.employee_id IS NOT NULL AND OLD.employee_id IS DISTINCT FROM NEW.employee_id  THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'employee_id', NEW.employee_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO UPDATE
			SET     attribute_value = NEW.employee_id
			WHERE pca.person_company_attribute_name = 'employee_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.employee_id;

	END IF;

	IF NEW.payroll_id IS NOT NULL AND OLD.payroll_id IS DISTINCT FROM NEW.payroll_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'payroll_id', NEW.payroll_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.payroll_id
			WHERE pca.person_company_attribute_name = 'payroll_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.payroll_id;
	END IF;

	IF NEW.external_hr_id IS NOT NULL AND OLD.external_hr_id IS DISTINCT FROM NEW.external_hr_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'external_hr_id', NEW.external_hr_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.external_hr_id
			WHERE pca.person_company_attribute_name = 'external_hr_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.external_hr_id;
	END IF;

	IF NEW.badge_system_id IS NOT NULL AND OLD.badge_system_id IS DISTINCT FROM NEW.badge_system_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'badge_system_id', NEW.badge_system_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.badge_system_id
			WHERE pca.person_company_attribute_name = 'badge_system_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.badge_system_id;
	END IF;

	IF NEW.supervisor_person_id IS NOT NULL AND OLD.supervisor_person_id IS DISTINCT FROM NEW.supervisor_person_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'supervisor__id', NEW.supervisor_person_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.supervisor_person_id
			WHERE pca.person_company_attribute_name = 'supervisor_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value_person_id INTO NEW.supervisor_person_id;
	END IF;

	RETURN NEW;
END;
$function$
;
CREATE TRIGGER trigger_v_person_company_upd INSTEAD OF UPDATE ON jazzhands_legacy.v_person_company FOR EACH ROW EXECUTE FUNCTION jazzhands_legacy.v_person_company_upd();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_person_company  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_person_company (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_person_company');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_person_company');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_person_company failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_person_company');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_person_company');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_person_company failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH TABLE v_account_manager_map
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_account_manager_map', 'v_account_manager_map');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'v_account_manager_map', tags := ARRAY['view_v_account_manager_map']);
-- restore any missing random views that may be cached that this one needs.
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', object := 'v_account_manager_map', type := 'view');
SELECT schema_support.replay_object_recreates(schema := 'jazzhands_legacy', object := 'v_person_company', type := 'view');
DROP VIEW IF EXISTS jazzhands_legacy.v_account_manager_map;
CREATE VIEW jazzhands_legacy.v_account_manager_map AS
 SELECT map.login,
    map.account_id,
    map.person_id,
    map.company_id,
    map.account_realm_id,
    map.first_name,
    map.last_name,
    map.middle_name,
    map.manager_person_id,
    emp_pc.employee_id,
    map.human_readable,
    map.manager_account_id,
    map.manager_login,
    map.manager_human_readable,
    map.manager_last_name,
    map.manager_middle_name,
    map.manger_first_name,
    mgr_pc.manager_employee_id,
    map.manager_company_id
   FROM jazzhands.v_account_manager_map map
     JOIN ( SELECT v_person_company.company_id,
            v_person_company.person_id,
            v_person_company.employee_id
           FROM jazzhands_legacy.v_person_company) emp_pc USING (person_id, company_id)
     JOIN ( SELECT v_person_company.company_id AS manager_company_id,
            v_person_company.person_id AS manager_person_id,
            v_person_company.employee_id AS manager_employee_id
           FROM jazzhands_legacy.v_person_company) mgr_pc USING (manager_person_id, manager_company_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('v_account_manager_map','v_account_manager_map');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_manager_map','v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_manager_map');
		DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_account_manager_map');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_account_manager_map  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_account_manager_map (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_manager_map');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_manager_map');
	DELETE FROM __regrants WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('v_account_manager_map');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_account_manager_map failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
-- DONE: process_ancillary_schema(jazzhands_legacy)
--
-- BEGIN: Fix cache table entries.
--
-- removing old
-- adding new cache tables that are not there
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  WHERE ('jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  WHERE ('jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
--
-- DONE: Fix cache table entries.
--


-- Clean Up
--
-- Process post-schema jazzhands_cache
--
select clock_timestamp(), clock_timestamp() - now() AS len;
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_columns_after ON jazzhands.device_collection_device;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_cache'::text, object := 'jazzhands_legacy_device_columns (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands_cache'::text]);
DROP FUNCTION IF EXISTS jazzhands_cache.jazzhands_legacy_device_columns (  );
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_setup_after ON jazzhands.device;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_cache'::text, object := 'jazzhands_legacy_device_setup (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands_cache'::text]);
DROP FUNCTION IF EXISTS jazzhands_cache.jazzhands_legacy_device_setup (  );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_columns_after ON jazzhands.device_collection_device;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_cache'::text, object := 'jazzhands_legacy_device_columns (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands_cache'::text]);
DROP FUNCTION IF EXISTS jazzhands_cache.jazzhands_legacy_device_columns (  );
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_setup_after ON jazzhands.device;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_cache'::text, object := 'jazzhands_legacy_device_setup (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands_cache'::text]);
DROP FUNCTION IF EXISTS jazzhands_cache.jazzhands_legacy_device_setup (  );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
	_uq	TEXT[];
BEGIN
	-- RAISE NOTICE 'Deleting cache record for dc#% %...', OLD.device_collection_id, OLD.device_id;
	FOR _r IN SELECT * FROM property
		WHERE device_collection_id = OLD.device_collection_id
		AND property_type = 'JazzHandsLegacySupport'
	LOOP
		IF _r.property_name = 'IsMonitoredDevice' THEN
			_uq := array_append(_uq, 'is_monitored = ' ||
				quote_nullable('N'));
		END IF;
		IF _r.property_name = 'ShouldConfigFetch' THEN
			_uq := array_append(_uq, 'should_fetch_config = ' ||
				quote_nullable('N'));
		END IF;
		IF _r.property_name = 'IsLocallyManagedDevice' THEN
			_uq := array_append(_uq, 'is_locally_managed = ' ||
				quote_nullable('N'));
		END IF;
		IF _r.property_name = 'AutoMgmtProtocol' THEN
			_uq := array_append(_uq, 'auto_mgmt_protocol = ' ||
				quote_nullable(_r.property_value));
		END IF;
	END LOOP;

	IF _uq IS NOT NULL THEN
		EXECUTE
			'UPDATE jazzhands_cache.ct_jazzhands_legacy_device_support SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  device_id = $1 RETURNING *'  USING OLD.device_id;
	END IF;
	RETURN OLD;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
	_uq	TEXT[];
BEGIN
	-- RAISE NOTICE 'Inserting cache record for dc#% %...', NEW.device_collection_id, NEW.device_id;
	FOR _r IN SELECT * FROM property
		WHERE device_collection_id = NEW.device_collection_id
		AND property_type = 'JazzHandsLegacySupport'
	LOOP
		IF _r.property_name = 'IsMonitoredDevice' THEN
			_uq := array_append(_uq, 'is_monitored = ' ||
				quote_nullable('Y'));
		END IF;
		IF _r.property_name = 'ShouldConfigFetch' THEN
			_uq := array_append(_uq, 'should_fetch_config = ' ||
				quote_nullable('Y'));
		END IF;
		IF _r.property_name = 'IsLocallyManagedDevice' THEN
			_uq := array_append(_uq, 'is_locally_managed = ' ||
				quote_nullable('Y'));
		END IF;
		IF _r.property_name = 'AutoMgmtProtocol' THEN
			_uq := array_append(_uq, 'auto_mgmt_protocol = ' ||
				quote_nullable(_r.property_value));
		END IF;
	END LOOP;
	IF _uq IS NOT NULL THEN
		EXECUTE
			'UPDATE jazzhands_cache.ct_jazzhands_legacy_device_support SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  device_id = $1 RETURNING *'  USING NEW.device_id;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or		RECORD;
	_nr		RECORD;
	_ouq	TEXT[];
	_nuq	TEXT[];
	_q		TEXT;
	tally	INTEGER;
BEGIN
	-- RAISE NOTICE 'device_collection_device update trigger: % % % %',
	-- 	OLD.device_collection_id, OLD.device_id,
	-- 	NEW.device_collection_id, NEW.device_id;
	tally := 0;
	FOR _or IN
		SELECT 'old' as direction, *
		FROM property
		WHERE device_collection_id = OLD.device_collection_id
		AND property_type = 'JazzHandsLegacySupport'
		UNION
		SELECT 'new' as direction, *
		FROM property
		WHERE device_collection_id = NEW.device_collection_id
		AND property_type = 'JazzHandsLegacySupport'
	LOOP
		_ouq := NULL;
		_nuq := NULL;
		_nr := NULL;
		-- This is a hack
		IF _or.direction = 'new' THEN
			-- If the row was already processed, which is likely, abort
			--
			-- This code only gets executed when the device colletion is
			-- switching from something not legacy to legacy, which is dumb
			-- but could happen.
			IF tally > 0 THEN
				CONTINUE;
			END IF;
		ELSE
			-- build _ouq into stuff that changes in the old
			IF _or.property_name = 'IsMonitoredDevice' THEN
				_ouq := array_append(_ouq, 'is_monitored = ' ||
					quote_nullable('N'));
			END IF;
			IF _or.property_name = 'ShouldConfigFetch' THEN
				_ouq := array_append(_ouq, 'should_fetch_config = ' ||
					quote_nullable('N'));
			END IF;
			IF _or.property_name = 'IsLocallyManagedDevice' THEN
				_ouq := array_append(_ouq, 'is_locally_managed = ' ||
					quote_nullable('N'));
			END IF;
		END IF;

		-- get where it is moving to.
		IF OLD.device_collection_id != NEW.device_collection_id THEN
			SELECT * INTO _nr
			FROM property
			WHERE device_collection_id = NEW.device_collection_id
			AND property_type = 'JazzHandsLegacySupport'
			LIMIT 1;
		ELSE
			_nr := _or;
		END IF;

		IF  OLD.device_collection_id != NEW.device_collection_id THEN
			-- build _nuq into stuff that changes in the new
			IF _nr.property_name = 'IsMonitoredDevice' THEN
				_nuq := array_append(_nuq, 'is_monitored = ' ||
					quote_nullable('Y'));
			END IF;
			IF _nr.property_name = 'ShouldConfigFetch' THEN
				_nuq := array_append(_nuq, 'should_fetch_config = ' ||
					quote_nullable('Y'));
			END IF;
			IF _nr.property_name = 'IsLocallyManagedDevice' THEN
				_nuq := array_append(_nuq, 'is_locally_managed = ' ||
					quote_nullable('Y'));
			END IF;
		END IF;

		-- this one is special
		IF _or.property_name = 'AutoMgmtProtocol' THEN
			IF OLD.device_id != NEW.device_id THEN
				_ouq := array_append(_ouq, 'auto_mgmt_protocol = ' ||
					quote_nullable(_r.property_value));
				IF _nr IS NOT NULL THEN
					_nuq := array_append(_nuq, 'auto_mgmt_protocol = ' ||
						quote_nullable(_nr.property_value));
				ELSE
					_nuq := array_append(_nuq, 'auto_mgmt_protocol = ' ||
						quote_nullable(_r.property_value));
				END IF;
			ELSIF  OLD.device_collection_id != NEW.device_collection_id THEN
				-- device si the same, so adjust the new side.
				_nuq := array_append(_nuq, 'auto_mgmt_protocol = ' ||
					quote_nullable(_nr.property_value));
			ELSE
				RAISE EXCEPTION 'This should not happen: % % % %',
					jsonb_pretty(to_json(OLD)::jsonb),
					jsonb_pretty(to_json(NEW)::jsonb),
					jsonb_pretty(to_json(_or)::jsonb),
					jsonb_pretty(to_json(_nr)::jsonb);
			END IF;
		ELSIF _nr.property_name = 'AutoMgmtProtocol' THEN
			-- in this case, it's not changing from one type to another,
			-- old device is getting cleared and new device is getting set.
			_nuq := array_append(_nuq, 'auto_mgmt_protocol = ' ||
				quote_nullable(_nr.property_value));
		END IF;

		-- At this point, _or is popiulated with what needs to happen to
		-- the old device and _nr is populated with what needs to happen
		-- to the new device

		IF OLD.device_id = NEW.device_id THEN
			IF _or.property_name = _nr.property_name THEN
				_ouq := NULL;
			END IF;
			IF _ouq IS NOT NULL AND _nuq IS NOT NULL THEN
				_q := concat(
					array_to_string(_ouq, ', '), ', ',
					array_to_string(_nuq, ', ')
				);
			ELSIF _ouq IS NOT NULL THEN
				_q := array_to_string(_ouq, ', ');
			ELSIF _nuq IS NOT NULL THEN
				_q := array_to_string(_nuq, ', ');
			ELSE
				RAISE EXCEPTION 'THis should not happen % %', _ouq, _nuq;
			END IF;
			EXECUTE
				format('UPDATE %s SET %s WHERE device_id = $1 RETURNING *',
					'jazzhands_cache.ct_jazzhands_legacy_device_support',
					_q)
				USING OLD.device_id;
		ELSE
			-- device is getting taken out of old and put in new.  The
			-- device_id is changing, so tweaking needs to happen to both.
			RAISE NOTICE 'oine';
			EXECUTE
				format('UPDATE %s SET %s WHERE device_id = $1 RETURNING *',
					'jazzhands_cache.ct_jazzhands_legacy_device_support',
					array_to_string(_ouq, ', '))
				USING OLD.device_id;
			EXECUTE
				format('UPDATE %s SET %s WHERE device_id = $1 RETURNING *',
					'jazzhands_cache.ct_jazzhands_legacy_device_support',
					array_to_string(_nuq, ', '))
				USING NEW.device_id;
		END IF;

		tally := tally + 1;
	END LOOP;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	-- RAISE NOTICE 'delete cache record for %...', OLD.device_id;
	DELETE FROM jazzhands_cache.ct_jazzhands_legacy_device_support
	WHERE device_id = OLD.device_id;
	RETURN OLD;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	-- RAISE NOTICE 'inserting cache record for %...', NEW.device_id;
	INSERT INTO jazzhands_cache.ct_jazzhands_legacy_device_support
		VALUES (NEW.device_id, 'N', 'N','N');
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	IF OLD.device_id != NEW.device_id THEN
		RAISE EXCEPTION 'device_id can not be changed at this time.'
			USING ERRCODE = 'error_in_assignment';
	END IF;
	RETURN NEW;
END;
$function$
;

--
-- Process post-schema jazzhands_legacy
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'property_del');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property_del');
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN
	DELETE FROM jazzhands.property
	WHERE  property_id = OLD.property_id  RETURNING *
	INTO _or;

	SELECT property_data_type INTO _dt
	FROM val_property
	WHERE property_name = OLD.property_name
	AND property_type = OLD.property_type;

	OLD.property_id = _or.property_id;
	OLD.account_collection_id = _or.account_collection_id;
	OLD.account_id = _or.account_id;
	OLD.account_realm_id = _or.account_realm_id;
	OLD.company_collection_id = _or.company_collection_id;
	OLD.company_id = _or.company_id;
	OLD.device_collection_id = _or.device_collection_id;
	OLD.dns_domain_collection_id = _or.dns_domain_collection_id;
	OLD.layer2_network_collection_id = _or.layer2_network_collection_id;
	OLD.layer3_network_collection_id = _or.layer3_network_collection_id;
	OLD.netblock_collection_id = _or.netblock_collection_id;
	OLD.network_range_id = _or.network_range_id;
	OLD.operating_system_id = _or.operating_system_id;
	OLD.operating_system_snapshot_id = _or.operating_system_snapshot_id;
	OLD.property_collection_id = _or.property_name_collection_id;
	OLD.service_env_collection_id = _or.service_environment_collection_id;
	OLD.site_code = _or.site_code;
	OLD.x509_signed_certificate_id = _or.x509_signed_certificate_id;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		OLD.property_value = CASE
			WHEN _or.property_value_boolean = true THEN 'Y'
			WHEN _or.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		OLD.property_value = _or.property_value;
	END IF;
	OLD.property_value_timestamp = _or.property_value_timestamp;
	OLD.property_value_account_coll_id = _or.property_value_account_collection_id;
	OLD.property_value_device_coll_id = _or.property_value_device_collection_id;
	OLD.property_value_json = _or.property_value_json;
	OLD.property_value_nblk_coll_id = _or.property_value_netblock_collection_id;
	OLD.property_value_password_type = _or.property_value_password_type;
	OLD.property_value_sw_package_id = _or.property_value_sw_package_id;
	OLD.property_value_token_col_id = _or.property_value_token_collection_id;
	OLD.property_rank = _or.property_rank;
	OLD.start_date = _or.start_date;
	OLD.finish_date = _or.finish_date;
	OLD.is_enabled = CASE WHEN _or.is_enabled = true THEN 'Y' WHEN _or.is_enabled = false THEN 'N' ELSE NULL END;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('property_del');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('property_del');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc property_del failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'property_ins');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property_ins');
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.property%rowtype;
	_dt	TEXT;
BEGIN

	IF NEW.property_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_id));
	END IF;

	IF NEW.account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_id));
	END IF;

	IF NEW.account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_id));
	END IF;

	IF NEW.account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.account_realm_id));
	END IF;

	IF NEW.company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_id));
	END IF;

	IF NEW.company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_id));
	END IF;

	IF NEW.device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_id));
	END IF;

	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF NEW.netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF NEW.network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_id));
	END IF;

	IF NEW.operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_id));
	END IF;

	IF NEW.operating_system_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF NEW.property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_id));
	END IF;

	IF NEW.service_env_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF NEW.site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.site_code));
	END IF;

	IF NEW.x509_signed_certificate_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.property_value IS NOT NULL THEN
		SELECT property_data_type INTO _dt
			FROM val_property
			WHERE property_name = NEW.property_name
			AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			_cq := array_append(_cq, quote_ident('property_value_boolean'));
			_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.property_value = 'Y' THEN true WHEN NEW.property_value = 'N' THEN false ELSE NULL END) || '::boolean');
		ELSE
			_cq := array_append(_cq, quote_ident('property_value'));
			_vq := array_append(_vq, quote_nullable(NEW.property_value));
		END IF;
	END IF;

	IF NEW.property_value_timestamp IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_timestamp'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF NEW.property_value_account_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF NEW.property_value_device_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF NEW.property_value_json IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json));
	END IF;

	IF NEW.property_value_nblk_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF NEW.property_value_password_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_password_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_password_type));
	END IF;

	IF NEW.property_value_sw_package_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_sw_package_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_sw_package_id));
	END IF;

	IF NEW.property_value_token_col_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_token_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF NEW.property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.property_rank));
	END IF;

	IF NEW.start_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('start_date'));
		_vq := array_append(_vq, quote_nullable(NEW.start_date));
	END IF;

	IF NEW.finish_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('finish_date'));
		_vq := array_append(_vq, quote_nullable(NEW.finish_date));
	END IF;

	IF NEW.is_enabled IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_enabled'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_enabled = 'Y' THEN true WHEN NEW.is_enabled = 'N' THEN false ELSE NULL END));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_id = _nr.property_id;
	NEW.account_collection_id = _nr.account_collection_id;
	NEW.account_id = _nr.account_id;
	NEW.account_realm_id = _nr.account_realm_id;
	NEW.company_collection_id = _nr.company_collection_id;
	NEW.company_id = _nr.company_id;
	NEW.device_collection_id = _nr.device_collection_id;
	NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
	NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
	NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
	NEW.netblock_collection_id = _nr.netblock_collection_id;
	NEW.network_range_id = _nr.network_range_id;
	NEW.operating_system_id = _nr.operating_system_id;
	NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
	NEW.property_collection_id = _nr.property_name_collection_id;
	NEW.service_env_collection_id = _nr.service_environment_collection_id;
	NEW.site_code = _nr.site_code;
	NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	IF _dt IS NOT DISTINCT FROM 'boolean' THEN
		NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
	ELSE
		NEW.property_value = _nr.property_value;
	END IF;
	NEW.property_value_timestamp = _nr.property_value_timestamp;
	NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
	NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
	NEW.property_value_json = _nr.property_value_json;
	NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
	NEW.property_value_password_type = _nr.property_value_password_type;
	NEW.property_value_sw_package_id = _nr.property_value_sw_package_id;
	NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
	NEW.property_rank = _nr.property_rank;
	NEW.start_date = _nr.start_date;
	NEW.finish_date = _nr.finish_date;
	NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('property_ins');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('property_ins');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc property_ins failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'property_upd');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'property_upd');
CREATE OR REPLACE FUNCTION jazzhands_legacy.property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.property%rowtype;
	_nr	jazzhands.property%rowtype;
	_uq	text[];
	_dt	TEXT;
BEGIN

	IF OLD.property_id IS DISTINCT FROM NEW.property_id THEN
_uq := array_append(_uq, 'property_id = ' || quote_nullable(NEW.property_id));
	END IF;

	IF OLD.account_collection_id IS DISTINCT FROM NEW.account_collection_id THEN
_uq := array_append(_uq, 'account_collection_id = ' || quote_nullable(NEW.account_collection_id));
	END IF;

	IF OLD.account_id IS DISTINCT FROM NEW.account_id THEN
_uq := array_append(_uq, 'account_id = ' || quote_nullable(NEW.account_id));
	END IF;

	IF OLD.account_realm_id IS DISTINCT FROM NEW.account_realm_id THEN
_uq := array_append(_uq, 'account_realm_id = ' || quote_nullable(NEW.account_realm_id));
	END IF;

	IF OLD.company_collection_id IS DISTINCT FROM NEW.company_collection_id THEN
_uq := array_append(_uq, 'company_collection_id = ' || quote_nullable(NEW.company_collection_id));
	END IF;

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.device_collection_id IS DISTINCT FROM NEW.device_collection_id THEN
_uq := array_append(_uq, 'device_collection_id = ' || quote_nullable(NEW.device_collection_id));
	END IF;

	IF OLD.dns_domain_collection_id IS DISTINCT FROM NEW.dns_domain_collection_id THEN
_uq := array_append(_uq, 'dns_domain_collection_id = ' || quote_nullable(NEW.dns_domain_collection_id));
	END IF;

	IF OLD.layer2_network_collection_id IS DISTINCT FROM NEW.layer2_network_collection_id THEN
_uq := array_append(_uq, 'layer2_network_collection_id = ' || quote_nullable(NEW.layer2_network_collection_id));
	END IF;

	IF OLD.layer3_network_collection_id IS DISTINCT FROM NEW.layer3_network_collection_id THEN
_uq := array_append(_uq, 'layer3_network_collection_id = ' || quote_nullable(NEW.layer3_network_collection_id));
	END IF;

	IF OLD.netblock_collection_id IS DISTINCT FROM NEW.netblock_collection_id THEN
_uq := array_append(_uq, 'netblock_collection_id = ' || quote_nullable(NEW.netblock_collection_id));
	END IF;

	IF OLD.network_range_id IS DISTINCT FROM NEW.network_range_id THEN
_uq := array_append(_uq, 'network_range_id = ' || quote_nullable(NEW.network_range_id));
	END IF;

	IF OLD.operating_system_id IS DISTINCT FROM NEW.operating_system_id THEN
_uq := array_append(_uq, 'operating_system_id = ' || quote_nullable(NEW.operating_system_id));
	END IF;

	IF OLD.operating_system_snapshot_id IS DISTINCT FROM NEW.operating_system_snapshot_id THEN
_uq := array_append(_uq, 'operating_system_snapshot_id = ' || quote_nullable(NEW.operating_system_snapshot_id));
	END IF;

	IF OLD.property_collection_id IS DISTINCT FROM NEW.property_collection_id THEN
_uq := array_append(_uq, 'property_name_collection_id = ' || quote_nullable(NEW.property_collection_id));
	END IF;

	IF OLD.service_env_collection_id IS DISTINCT FROM NEW.service_env_collection_id THEN
_uq := array_append(_uq, 'service_environment_collection_id = ' || quote_nullable(NEW.service_env_collection_id));
	END IF;

	IF OLD.site_code IS DISTINCT FROM NEW.site_code THEN
_uq := array_append(_uq, 'site_code = ' || quote_nullable(NEW.site_code));
	END IF;

	IF OLD.x509_signed_certificate_id IS DISTINCT FROM NEW.x509_signed_certificate_id THEN
_uq := array_append(_uq, 'x509_signed_certificate_id = ' || quote_nullable(NEW.x509_signed_certificate_id));
	END IF;

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.property_value IS DISTINCT FROM NEW.property_value THEN
		SELECT property_data_type INTO _dt
		FROM val_property
		WHERE property_name = NEW.property_name
		AND property_type = NEW.property_type;

		IF _dt = 'boolean' THEN
			_uq := array_append(_uq, 'property_value_boolean = ' || quote_nullable(CASE WHEN NEW.is_enabled = 'Y' THEN true WHEN NEW.is_enabled = 'N' THEN false ELSE NULL END));
			_uq := array_append(_uq, 'property_value = NULL');
		ELSE
			_uq := array_append(_uq, 'property_value = ' || quote_nullable(NEW.property_value));
			_uq := array_append(_uq, 'property_value_boolean = NULL');
		END IF;
	END IF;

	IF OLD.property_value_timestamp IS DISTINCT FROM NEW.property_value_timestamp THEN
_uq := array_append(_uq, 'property_value_timestamp = ' || quote_nullable(NEW.property_value_timestamp));
	END IF;

	IF OLD.property_value_account_coll_id IS DISTINCT FROM NEW.property_value_account_coll_id THEN
_uq := array_append(_uq, 'property_value_account_collection_id = ' || quote_nullable(NEW.property_value_account_coll_id));
	END IF;

	IF OLD.property_value_device_coll_id IS DISTINCT FROM NEW.property_value_device_coll_id THEN
_uq := array_append(_uq, 'property_value_device_collection_id = ' || quote_nullable(NEW.property_value_device_coll_id));
	END IF;

	IF OLD.property_value_json IS DISTINCT FROM NEW.property_value_json THEN
_uq := array_append(_uq, 'property_value_json = ' || quote_nullable(NEW.property_value_json));
	END IF;

	IF OLD.property_value_nblk_coll_id IS DISTINCT FROM NEW.property_value_nblk_coll_id THEN
_uq := array_append(_uq, 'property_value_netblock_collection_id = ' || quote_nullable(NEW.property_value_nblk_coll_id));
	END IF;

	IF OLD.property_value_password_type IS DISTINCT FROM NEW.property_value_password_type THEN
_uq := array_append(_uq, 'property_value_password_type = ' || quote_nullable(NEW.property_value_password_type));
	END IF;

	IF OLD.property_value_sw_package_id IS DISTINCT FROM NEW.property_value_sw_package_id THEN
_uq := array_append(_uq, 'property_value_sw_package_id = ' || quote_nullable(NEW.property_value_sw_package_id));
	END IF;

	IF OLD.property_value_token_col_id IS DISTINCT FROM NEW.property_value_token_col_id THEN
_uq := array_append(_uq, 'property_value_token_collection_id = ' || quote_nullable(NEW.property_value_token_col_id));
	END IF;

	IF OLD.property_rank IS DISTINCT FROM NEW.property_rank THEN
_uq := array_append(_uq, 'property_rank = ' || quote_nullable(NEW.property_rank));
	END IF;

	IF OLD.start_date IS DISTINCT FROM NEW.start_date THEN
_uq := array_append(_uq, 'start_date = ' || quote_nullable(NEW.start_date));
	END IF;

	IF OLD.finish_date IS DISTINCT FROM NEW.finish_date THEN
_uq := array_append(_uq, 'finish_date = ' || quote_nullable(NEW.finish_date));
	END IF;

	IF OLD.is_enabled IS DISTINCT FROM NEW.is_enabled THEN
IF NEW.is_enabled = 'Y' THEN
	_uq := array_append(_uq, 'is_enabled = true');
ELSIF NEW.is_enabled = 'N' THEN
	_uq := array_append(_uq, 'is_enabled = false');
ELSE
	_uq := array_append(_uq, 'is_enabled = NULL');
END IF;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_id = $1 RETURNING *'  USING OLD.property_id
			INTO _nr;

		NEW.property_id = _nr.property_id;
		NEW.account_collection_id = _nr.account_collection_id;
		NEW.account_id = _nr.account_id;
		NEW.account_realm_id = _nr.account_realm_id;
		NEW.company_collection_id = _nr.company_collection_id;
		NEW.company_id = _nr.company_id;
		NEW.device_collection_id = _nr.device_collection_id;
		NEW.dns_domain_collection_id = _nr.dns_domain_collection_id;
		NEW.layer2_network_collection_id = _nr.layer2_network_collection_id;
		NEW.layer3_network_collection_id = _nr.layer3_network_collection_id;
		NEW.netblock_collection_id = _nr.netblock_collection_id;
		NEW.network_range_id = _nr.network_range_id;
		NEW.operating_system_id = _nr.operating_system_id;
		NEW.operating_system_snapshot_id = _nr.operating_system_snapshot_id;
		NEW.property_collection_id = _nr.property_name_collection_id;
		NEW.service_env_collection_id = _nr.service_environment_collection_id;
		NEW.site_code = _nr.site_code;
		NEW.x509_signed_certificate_id = _nr.x509_signed_certificate_id;
		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;

		IF _dt IS NOT DISTINCT FROM 'boolean' THEN
			NEW.property_value = CASE
			WHEN _nr.property_value_boolean = true THEN 'Y'
			WHEN _nr.property_value_boolean = false THEN 'N'
			ELSE NULL END;
		ELSE
			NEW.property_value = _nr.property_value;
		END IF;

		NEW.property_value_timestamp = _nr.property_value_timestamp;
		NEW.property_value_account_coll_id = _nr.property_value_account_collection_id;
		NEW.property_value_device_coll_id = _nr.property_value_device_collection_id;
		NEW.property_value_json = _nr.property_value_json;
		NEW.property_value_nblk_coll_id = _nr.property_value_netblock_collection_id;
		NEW.property_value_password_type = _nr.property_value_password_type;
		NEW.property_value_sw_package_id = _nr.property_value_sw_package_id;
		NEW.property_value_token_col_id = _nr.property_value_token_collection_id;
		NEW.property_rank = _nr.property_rank;
		NEW.start_date = _nr.start_date;
		NEW.finish_date = _nr.finish_date;
		NEW.is_enabled = CASE WHEN _nr.is_enabled = true THEN 'Y' WHEN _nr.is_enabled = false THEN 'N' ELSE NULL END;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('property_upd');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('property_upd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc property_upd failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_del');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_del');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d		jazzhands.dns_domain%rowtype;
	_du		jazzhands.dns_domain_ip_universe%rowtype;
BEGIN
	DELETE FROM jazzhands.v_dns_domain_ip_universe
	WHERE  dns_domain_id = OLD.dns_domain_id
	AND ip_universe = 0
	RETURNING * INTO _du;


	DELETE FROM jazzhands.dns_domain
	WHERE  dns_domain_id = OLD.dns_domain_id
	RETURNING * INTO _d;

	OLD.dns_domain_id = _d.dns_domain_id;
	OLD.soa_name = _d.dns_domain_name;
	OLD.dns_domain_type = _d.dns_domain_type;
	OLD.parent_dns_domain_id = _d.parent_dns_domain_id;

	OLD.soa_class = _du.soa_class;
	OLD.soa_ttl = _du.soa_ttl;
	OLD.soa_serial = _du.soa_serial;
	OLD.soa_refresh = _du.soa_refresh;
	OLD.soa_retry = _du.soa_retry;
	OLD.soa_expire = _du.soa_expire;
	OLD.soa_minimum = _du.soa_minimum;
	OLD.soa_mname = _du.soa_mname;
	OLD.soa_rname = _du.soa_rname;
	OLD.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
	OLD.last_generated = _du.last_generated;
	OLD.data_ins_user = _du.data_ins_user;
	OLD.data_ins_date = _du.data_ins_date;
	OLD.data_upd_user = _du.data_upd_user;
	OLD.data_upd_date = _du.data_upd_date;
	RETURN OLD;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_dns_domain_nouniverse_del');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse_del');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_dns_domain_nouniverse_del failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_ins');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_ins');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%rowtype;
	_du	jazzhands.dns_domain_ip_universe%rowtype;
BEGIN
	IF NEW.dns_domain_id IS NULL THEN
		INSERT INTO jazzhands.dns_domain (
			dns_domain_name, dns_domain_type, parent_dns_domain_id
		) VALUES (
			NEW.soa_name, NEW.dns_domain_type, NEW.parent_dns_domain_id
		) RETURNING * INTO _d;
	ELSE
		INSERT INTO jazzhands.dns_domain (
			dns_domain_id, dns_domain_name, dns_domain_type,
			parent_dns_domain_id
		) VALUES (
			NEW.dns_domain_id, NEW.soa_name, NEW.dns_domain_type,
			NEW.parent_dns_domain_id
		) RETURNING * INTO _d;
	END IF;

	INSERT INTO dns_domain_ip_universe (
		dns_domain_id, ip_universe_id,
		soa_class, soa_ttl, soa_serial, soa_refresh,
		soa_retry,
		soa_expire, soa_minimum, soa_mname, soa_rname,
		should_generate,
		last_generated
	) VALUES (
		_d.dns_domain_id, 0,
		NEW.soa_class, NEW.soa_ttl, NEW.soa_serial, NEW.soa_refresh,
		NEW.soa_retry,
		NEW.soa_expire, NEW.soa_minimum, NEW.soa_mname, NEW.soa_rname,
		CASE WHEN NEW.should_generate = 'Y' THEN true
			WHEN NEW.should_generate = 'N' THEN false
			ELSE NULL
			END,
		NEW.last_generated
	) RETURNING * INTO _du;

	NEW.dns_domain_id = _d.dns_domain_id;
	NEW.soa_name = _d.dns_domain_name;
	NEW.soa_class = _du.soa_class;
	NEW.soa_ttl = _du.soa_ttl;
	NEW.soa_serial = _du.soa_serial;
	NEW.soa_refresh = _du.soa_refresh;
	NEW.soa_retry = _du.soa_retry;
	NEW.soa_expire = _du.soa_expire;
	NEW.soa_minimum = _du.soa_minimum;
	NEW.soa_mname = _du.soa_mname;
	NEW.soa_rname = _du.soa_rname;
	NEW.parent_dns_domain_id = _d.parent_dns_domain_id;
	NEW.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
	NEW.last_generated = _du.last_generated;
	NEW.dns_domain_type = _d.dns_domain_type;
	NEW.data_ins_user = _d.data_ins_user;
	NEW.data_ins_date = _d.data_ins_date;
	NEW.data_upd_user = _d.data_upd_user;
	NEW.data_upd_date = _d.data_upd_date;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_dns_domain_nouniverse_ins');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse_ins');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_dns_domain_nouniverse_ins failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_upd');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_dns_domain_nouniverse_upd');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_dns_domain_nouniverse_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d		jazzhands.dns_domain%rowtype;
	_du		jazzhands.dns_domain_ip_universe%rowtype;
	_duq	text[];
	_uq		text[];
BEGIN

	IF OLD.dns_domain_id IS DISTINCT FROM NEW.dns_domain_id THEN
		RAISE EXCEPTION 'Can not change dns_domain_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.soa_name IS DISTINCT FROM NEW.soa_name THEN
		_duq := array_append(_duq, 'dns_domain_name = ' || quote_nullable(NEW.soa_name));
	END IF;

	IF OLD.parent_dns_domain_id IS DISTINCT FROM NEW.parent_dns_domain_id THEN
		_duq := array_append(_duq, 'parent_dns_domain_id = ' || quote_nullable(NEW.parent_dns_domain_id));
	END IF;

	IF OLD.dns_domain_type IS DISTINCT FROM NEW.dns_domain_type THEN
		_duq := array_append(_duq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	--

	IF OLD.soa_class IS DISTINCT FROM NEW.soa_class THEN
		_uq := array_append(_uq, 'soa_class = ' || quote_nullable(NEW.soa_class));
	END IF;

	IF OLD.soa_ttl IS DISTINCT FROM NEW.soa_ttl THEN
		_uq := array_append(_uq, 'soa_ttl = ' || quote_nullable(NEW.soa_ttl));
	END IF;

	IF OLD.soa_serial IS DISTINCT FROM NEW.soa_serial THEN
		_uq := array_append(_uq, 'soa_serial = ' || quote_nullable(NEW.soa_serial));
	END IF;

	IF OLD.soa_refresh IS DISTINCT FROM NEW.soa_refresh THEN
		_uq := array_append(_uq, 'soa_refresh = ' || quote_nullable(NEW.soa_refresh));
	END IF;

	IF OLD.soa_retry IS DISTINCT FROM NEW.soa_retry THEN
		_uq := array_append(_uq, 'soa_retry = ' || quote_nullable(NEW.soa_retry));
	END IF;

	IF OLD.soa_expire IS DISTINCT FROM NEW.soa_expire THEN
		_uq := array_append(_uq, 'soa_expire = ' || quote_nullable(NEW.soa_expire));
	END IF;

	IF OLD.soa_minimum IS DISTINCT FROM NEW.soa_minimum THEN
		_uq := array_append(_uq, 'soa_minimum = ' || quote_nullable(NEW.soa_minimum));
	END IF;

	IF OLD.soa_mname IS DISTINCT FROM NEW.soa_mname THEN
		_uq := array_append(_uq, 'soa_mname = ' || quote_nullable(NEW.soa_mname));
	END IF;

	IF OLD.soa_rname IS DISTINCT FROM NEW.soa_rname THEN
		_uq := array_append(_uq, 'soa_rname = ' || quote_nullable(NEW.soa_rname));
	END IF;

	IF OLD.should_generate IS DISTINCT FROM NEW.should_generate THEN
		IF NEW.should_generate = 'Y' THEN
			_uq := array_append(_uq, 'should_generate = true');
		ELSIF NEW.should_generate = 'N' THEN
			_uq := array_append(_uq, 'should_generate = false');
		ELSE
			_uq := array_append(_uq, 'should_generate = NULL');
		END IF;
	END IF;

	IF OLD.last_generated IS DISTINCT FROM NEW.last_generated THEN
		_uq := array_append(_uq, 'last_generated = ' || quote_nullable(NEW.last_generated));
	END IF;

	IF _duq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain SET ' ||
			array_to_string(_duq, ', ') ||
			' WHERE  dns_domain_id = $1 RETURNING *'
			USING OLD.dns_domain_id
			INTO _d;

		NEW.dns_domain_id = _d.dns_domain_id;
		NEW.soa_name = _d.soa_name;
		NEW.dns_domain_type = _d.dns_domain_type;
		NEW.parent_dns_domain_id = _d.parent_dns_domain_id;
		NEW.data_ins_user = _d.data_ins_user;
		NEW.data_ins_date = _d.data_ins_date;
		NEW.data_upd_user = _d.data_upd_user;
		NEW.data_upd_date = _d.data_upd_date;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain_ip_universe SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  dns_domain_id = $1 AND ip_universe = 0 RETURNING *'
			USING OLD.dns_domain_id
			INTO _du;

		NEW.soa_class = _du.soa_class;
		NEW.soa_ttl = _du.soa_ttl;
		NEW.soa_serial = _du.soa_serial;
		NEW.soa_refresh = _du.soa_refresh;
		NEW.soa_retry = _du.soa_retry;
		NEW.soa_expire = _du.soa_expire;
		NEW.soa_minimum = _du.soa_minimum;
		NEW.soa_mname = _du.soa_mname;
		NEW.soa_rname = _du.soa_rname;
		NEW.should_generate = CASE WHEN _du.should_generate = true THEN 'Y' WHEN _du.should_generate = false THEN 'N' ELSE NULL END;
		NEW.last_generated = _du.last_generated;
		NEW.data_ins_user = _du.data_ins_user;
		NEW.data_ins_date = _du.data_ins_date;
		NEW.data_upd_user = _du.data_upd_user;
		NEW.data_upd_date = _du.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_dns_domain_nouniverse_upd');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_dns_domain_nouniverse_upd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_dns_domain_nouniverse_upd failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_person_company_del');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_person_company_del');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.person_company%rowtype;
BEGIN

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'employee_id'
	RETURNING attribute_value INTO OLD.employee_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'payroll_id'
	RETURNING attribute_value INTO OLD.payroll_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'external_hr_id'
	RETURNING attribute_value INTO OLD.external_hr_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'badge_system_id'
	RETURNING attribute_value INTO OLD.badge_system_id;

	DELETE FROM person_company_attribute
	WHERE person_id = OLD.person_id
	AND company_id = OLD.company_id
	AND person_company_attribute_name = 'supervisor_person_id'
	RETURNING attribute_value_person_id INTO OLD.supervisor_person_id;

	DELETE FROM jazzhands.person_company
	WHERE  person_id = OLD.person_id  AND  company_id = OLD.company_id  RETURNING *
	INTO _or;
	OLD.company_id = _or.company_id;
	OLD.person_id = _or.person_id;
	OLD.person_company_status = _or.person_company_status;
	OLD.person_company_relation = _or.person_company_relation;
	OLD.is_exempt = CASE WHEN _or.is_exempt = true THEN 'Y' WHEN _or.is_exempt = false THEN 'N' ELSE NULL END;
	OLD.is_management = CASE WHEN _or.is_management = true THEN 'Y' WHEN _or.is_management = false THEN 'N' ELSE NULL END;
	OLD.is_full_time = CASE WHEN _or.is_full_time = true THEN 'Y' WHEN _or.is_full_time = false THEN 'N' ELSE NULL END;
	OLD.description = _or.description;
	OLD.position_title = _or.position_title;
	OLD.hire_date = _or.hire_date;
	OLD.termination_date = _or.termination_date;
	OLD.manager_person_id = _or.manager_person_id;
	OLD.nickname = _or.nickname;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_person_company_del');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company_del');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_person_company_del failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_person_company_ins');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_person_company_ins');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.person_company%rowtype;
BEGIN

	IF NEW.company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.company_id));
	END IF;

	IF NEW.person_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_id'));
		_vq := array_append(_vq, quote_nullable(NEW.person_id));
	END IF;

	IF NEW.person_company_status IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_company_status'));
		_vq := array_append(_vq, quote_nullable(NEW.person_company_status));
	END IF;

	IF NEW.person_company_relation IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('person_company_relation'));
		_vq := array_append(_vq, quote_nullable(NEW.person_company_relation));
	END IF;

	IF NEW.is_exempt IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_exempt'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_exempt = 'Y' THEN true WHEN NEW.is_exempt = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.is_management IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_management'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_management = 'Y' THEN true WHEN NEW.is_management = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.is_full_time IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_full_time'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_full_time = 'Y' THEN true WHEN NEW.is_full_time = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.position_title IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('position_title'));
		_vq := array_append(_vq, quote_nullable(NEW.position_title));
	END IF;

	IF NEW.hire_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('hire_date'));
		_vq := array_append(_vq, quote_nullable(NEW.hire_date));
	END IF;

	IF NEW.termination_date IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('termination_date'));
		_vq := array_append(_vq, quote_nullable(NEW.termination_date));
	END IF;

	IF NEW.manager_person_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('manager_person_id'));
		_vq := array_append(_vq, quote_nullable(NEW.manager_person_id));
	END IF;

	IF NEW.nickname IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('nickname'));
		_vq := array_append(_vq, quote_nullable(NEW.nickname));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.person_company (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	--
	-- These are the backwards compatability columns no longer in jazzhands.
	--

	IF NEW.employee_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'employee_id',
			NEW.employee_id
		) RETURNING attribute_value INTO NEW.employee_id;
	END IF;

	IF NEW.payroll_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'payroll_id',
			NEW.payroll_id
		) RETURNING attribute_value INTO NEW.payroll_id;
	END IF;

	IF NEW.external_hr_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'external_hr_id',
			NEW.external_hr_id
		) RETURNING attribute_value INTO NEW.external_hr_id;
	END IF;

	IF NEW.badge_system_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value
		) VALUES  (
			NEW.company_id, NEW.person_id, 'badge_system_id',
			NEW.badge_system_id
		) RETURNING attribute_value INTO NEW.badge_system_id;
	END IF;

	IF NEW.supervisor_person_id IS NOT NULL THEN
		INSERT INTO jazzhands.person_company_attribute (
			company_id, person_id, person_company_attribute_name,
			attribute_value_person_id
		) VALUES  (
			NEW.company_id, NEW.person_id, 'supervisor_person_id',
			NEW.attribute_value_person_id
		) RETURNING attribute_value_person_id INTO NEW.supervisor_person_id;
	END IF;

	--
	-- End of backwards compatability columns no longer in jazzhands
	--

	NEW.company_id = _nr.company_id;
	NEW.person_id = _nr.person_id;
	NEW.person_company_status = _nr.person_company_status;
	NEW.person_company_relation = _nr.person_company_relation;
	NEW.is_exempt = CASE WHEN _nr.is_exempt = true THEN 'Y' WHEN _nr.is_exempt = false THEN 'N' ELSE NULL END;
	NEW.is_management = CASE WHEN _nr.is_management = true THEN 'Y' WHEN _nr.is_management = false THEN 'N' ELSE NULL END;
	NEW.is_full_time = CASE WHEN _nr.is_full_time = true THEN 'Y' WHEN _nr.is_full_time = false THEN 'N' ELSE NULL END;
	NEW.description = _nr.description;
	NEW.position_title = _nr.position_title;
	NEW.hire_date = _nr.hire_date;
	NEW.termination_date = _nr.termination_date;
	NEW.manager_person_id = _nr.manager_person_id;
	NEW.nickname = _nr.nickname;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_person_company_ins');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company_ins');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_person_company_ins failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'v_person_company_upd');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'v_person_company_upd');
CREATE OR REPLACE FUNCTION jazzhands_legacy.v_person_company_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.v_person_company%rowtype;
	_nr	jazzhands.person_company%rowtype;
	_uq	text[];
BEGIN

	IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
_uq := array_append(_uq, 'company_id = ' || quote_nullable(NEW.company_id));
	END IF;

	IF OLD.person_id IS DISTINCT FROM NEW.person_id THEN
_uq := array_append(_uq, 'person_id = ' || quote_nullable(NEW.person_id));
	END IF;

	IF OLD.person_company_status IS DISTINCT FROM NEW.person_company_status THEN
_uq := array_append(_uq, 'person_company_status = ' || quote_nullable(NEW.person_company_status));
	END IF;

	IF OLD.person_company_relation IS DISTINCT FROM NEW.person_company_relation THEN
_uq := array_append(_uq, 'person_company_relation = ' || quote_nullable(NEW.person_company_relation));
	END IF;

	IF OLD.is_exempt IS DISTINCT FROM NEW.is_exempt THEN
IF NEW.is_exempt = 'Y' THEN
	_uq := array_append(_uq, 'is_exempt = true');
ELSIF NEW.is_exempt = 'N' THEN
	_uq := array_append(_uq, 'is_exempt = false');
ELSE
	_uq := array_append(_uq, 'is_exempt = NULL');
END IF;
	END IF;

	IF OLD.is_management IS DISTINCT FROM NEW.is_management THEN
IF NEW.is_management = 'Y' THEN
	_uq := array_append(_uq, 'is_management = true');
ELSIF NEW.is_management = 'N' THEN
	_uq := array_append(_uq, 'is_management = false');
ELSE
	_uq := array_append(_uq, 'is_management = NULL');
END IF;
	END IF;

	IF OLD.is_full_time IS DISTINCT FROM NEW.is_full_time THEN
IF NEW.is_full_time = 'Y' THEN
	_uq := array_append(_uq, 'is_full_time = true');
ELSIF NEW.is_full_time = 'N' THEN
	_uq := array_append(_uq, 'is_full_time = false');
ELSE
	_uq := array_append(_uq, 'is_full_time = NULL');
END IF;
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.position_title IS DISTINCT FROM NEW.position_title THEN
_uq := array_append(_uq, 'position_title = ' || quote_nullable(NEW.position_title));
	END IF;

	IF OLD.hire_date IS DISTINCT FROM NEW.hire_date THEN
_uq := array_append(_uq, 'hire_date = ' || quote_nullable(NEW.hire_date));
	END IF;

	IF OLD.termination_date IS DISTINCT FROM NEW.termination_date THEN
_uq := array_append(_uq, 'termination_date = ' || quote_nullable(NEW.termination_date));
	END IF;

	IF OLD.manager_person_id IS DISTINCT FROM NEW.manager_person_id THEN
_uq := array_append(_uq, 'manager_person_id = ' || quote_nullable(NEW.manager_person_id));
	END IF;

	IF OLD.nickname IS DISTINCT FROM NEW.nickname THEN
_uq := array_append(_uq, 'nickname = ' || quote_nullable(NEW.nickname));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.person_company SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  person_id = $1 AND  company_id = $2 RETURNING *'  USING OLD.person_id, OLD.company_id
			INTO _nr;

		NEW.company_id = _nr.company_id;
		NEW.person_id = _nr.person_id;
		NEW.person_company_status = _nr.person_company_status;
		NEW.person_company_relation = _nr.person_company_relation;
		NEW.is_exempt = CASE WHEN _nr.is_exempt = true THEN 'Y' WHEN _nr.is_exempt = false THEN 'N' ELSE NULL END;
		NEW.is_management = CASE WHEN _nr.is_management = true THEN 'Y' WHEN _nr.is_management = false THEN 'N' ELSE NULL END;
		NEW.is_full_time = CASE WHEN _nr.is_full_time = true THEN 'Y' WHEN _nr.is_full_time = false THEN 'N' ELSE NULL END;
		NEW.description = _nr.description;
		NEW.position_title = _nr.position_title;
		NEW.hire_date = _nr.hire_date;
		NEW.termination_date = _nr.termination_date;
		NEW.manager_person_id = _nr.manager_person_id;
		NEW.nickname = _nr.nickname;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;

       IF NEW.employee_id IS NOT NULL AND OLD.employee_id IS DISTINCT FROM NEW.employee_id  THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'employee_id', NEW.employee_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO UPDATE
			SET     attribute_value = NEW.employee_id
			WHERE pca.person_company_attribute_name = 'employee_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.employee_id;

	END IF;

	IF NEW.payroll_id IS NOT NULL AND OLD.payroll_id IS DISTINCT FROM NEW.payroll_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'payroll_id', NEW.payroll_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.payroll_id
			WHERE pca.person_company_attribute_name = 'payroll_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.payroll_id;
	END IF;

	IF NEW.external_hr_id IS NOT NULL AND OLD.external_hr_id IS DISTINCT FROM NEW.external_hr_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'external_hr_id', NEW.external_hr_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.external_hr_id
			WHERE pca.person_company_attribute_name = 'external_hr_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.external_hr_id;
	END IF;

	IF NEW.badge_system_id IS NOT NULL AND OLD.badge_system_id IS DISTINCT FROM NEW.badge_system_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'badge_system_id', NEW.badge_system_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.badge_system_id
			WHERE pca.person_company_attribute_name = 'badge_system_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value INTO NEW.badge_system_id;
	END IF;

	IF NEW.supervisor_person_id IS NOT NULL AND OLD.supervisor_person_id IS DISTINCT FROM NEW.supervisor_person_id THEN
		INSERT INTO jazzhands.person_company_attribute AS pca (
			company_id, person_id, person_company_attribute_name, attribute_value
		) VALUES (
			NEW.company_id, NEW.person_id, 'supervisor__id', NEW.supervisor_person_id
		) ON CONFLICT ON CONSTRAINT pk_person_company_attribute
		DO
			UPDATE
			SET     attribute_value = NEW.supervisor_person_id
			WHERE pca.person_company_attribute_name = 'supervisor_id'
			AND pca.person_id = NEW.person_id
			AND pca.company_id = NEW.company_id
		RETURNING attribute_value_person_id INTO NEW.supervisor_person_id;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('v_person_company_upd');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('v_person_company_upd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc v_person_company_upd failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'val_property_del');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_property_del');
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_or	jazzhands.val_property%rowtype;
BEGIN
	DELETE FROM jazzhands.val_property
	WHERE  property_name = OLD.property_name  AND  property_type = OLD.property_type  RETURNING *
	INTO _or;
	OLD.property_name = _or.property_name;
	OLD.property_type = _or.property_type;
	OLD.description = _or.description;
	OLD.account_collection_type = _or.account_collection_type;
	OLD.company_collection_type = _or.company_collection_type;
	OLD.device_collection_type = _or.device_collection_type;
	OLD.dns_domain_collection_type = _or.dns_domain_collection_type;
	OLD.layer2_network_collection_type = _or.layer2_network_collection_type;
	OLD.layer3_network_collection_type = _or.layer3_network_collection_type;
	OLD.netblock_collection_type = _or.netblock_collection_type;
	OLD.network_range_type = _or.network_range_type;
	OLD.property_collection_type = _or.property_name_collection_type;
	OLD.service_env_collection_type = _or.service_environment_collection_type;
	OLD.is_multivalue = CASE WHEN _or.is_multivalue = true THEN 'Y' WHEN _or.is_multivalue = false THEN 'N' ELSE NULL END;
	OLD.prop_val_acct_coll_type_rstrct = _or.property_value_account_collection_type_restriction;
	OLD.prop_val_dev_coll_type_rstrct = _or.property_value_device_collection_type_restriction;
	OLD.prop_val_nblk_coll_type_rstrct = _or.property_value_netblock_collection_type_restriction;
	OLD.property_data_type = _or.property_data_type;
	OLD.property_value_json_schema = _or.property_value_json_schema;
	OLD.permit_account_collection_id = _or.permit_account_collection_id;
	OLD.permit_account_id = _or.permit_account_id;
	OLD.permit_account_realm_id = _or.permit_account_realm_id;
	OLD.permit_company_id = _or.permit_company_id;
	OLD.permit_company_collection_id = _or.permit_company_collection_id;
	OLD.permit_device_collection_id = _or.permit_device_collection_id;
	OLD.permit_dns_domain_coll_id = _or.permit_dns_domain_collection_id;
	OLD.permit_layer2_network_coll_id = _or.permit_layer2_network_collection_id;
	OLD.permit_layer3_network_coll_id = _or.permit_layer3_network_collection_id;
	OLD.permit_netblock_collection_id = _or.permit_netblock_collection_id;
	OLD.permit_network_range_id = _or.permit_network_range_id;
	OLD.permit_operating_system_id = _or.permit_operating_system_id;
	OLD.permit_os_snapshot_id = _or.permit_operating_system_snapshot_id;
	OLD.permit_property_collection_id = _or.permit_property_name_collection_id;
	OLD.permit_service_env_collection = _or.permit_service_environment_collection;
	OLD.permit_site_code = _or.permit_site_code;
	OLD.permit_x509_signed_cert_id = _or.permit_x509_signed_certificate_id;
	OLD.permit_property_rank = _or.permit_property_rank;
	OLD.data_ins_user = _or.data_ins_user;
	OLD.data_ins_date = _or.data_ins_date;
	OLD.data_upd_user = _or.data_upd_user;
	OLD.data_upd_date = _or.data_upd_date;
	RETURN OLD;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('val_property_del');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_property_del');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc val_property_del failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'val_property_ins');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_property_ins');
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_cq	text[];
	_vq	text[];
	_nr	jazzhands.val_property%rowtype;
BEGIN

	IF NEW.property_name IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name'));
		_vq := array_append(_vq, quote_nullable(NEW.property_name));
	END IF;

	IF NEW.property_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_type));
	END IF;

	IF NEW.description IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('description'));
		_vq := array_append(_vq, quote_nullable(NEW.description));
	END IF;

	IF NEW.account_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('account_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.account_collection_type));
	END IF;

	IF NEW.company_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('company_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.company_collection_type));
	END IF;

	IF NEW.device_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('device_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.device_collection_type));
	END IF;

	IF NEW.dns_domain_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('dns_domain_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF NEW.layer2_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer2_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF NEW.layer3_network_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('layer3_network_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF NEW.netblock_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('netblock_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF NEW.network_range_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('network_range_type'));
		_vq := array_append(_vq, quote_nullable(NEW.network_range_type));
	END IF;

	IF NEW.property_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_name_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_collection_type));
	END IF;

	IF NEW.service_env_collection_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('service_environment_collection_type'));
		_vq := array_append(_vq, quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF NEW.is_multivalue IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('is_multivalue'));
		_vq := array_append(_vq, quote_nullable(CASE WHEN NEW.is_multivalue = 'Y' THEN true WHEN NEW.is_multivalue = 'N' THEN false ELSE NULL END));
	END IF;

	IF NEW.prop_val_acct_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_account_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_dev_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_device_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF NEW.prop_val_nblk_coll_type_rstrct IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_netblock_collection_type_restriction'));
		_vq := array_append(_vq, quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF NEW.property_data_type IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_data_type'));
		_vq := array_append(_vq, quote_nullable(NEW.property_data_type));
	END IF;

	IF NEW.property_value_json_schema IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('property_value_json_schema'));
		_vq := array_append(_vq, quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF NEW.permit_account_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF NEW.permit_account_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_id));
	END IF;

	IF NEW.permit_account_realm_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_account_realm_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF NEW.permit_company_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_id));
	END IF;

	IF NEW.permit_company_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_company_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF NEW.permit_device_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_device_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF NEW.permit_dns_domain_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_dns_domain_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF NEW.permit_layer2_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer2_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF NEW.permit_layer3_network_coll_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_layer3_network_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF NEW.permit_netblock_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_netblock_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF NEW.permit_network_range_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_network_range_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF NEW.permit_operating_system_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF NEW.permit_os_snapshot_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_operating_system_snapshot_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF NEW.permit_property_collection_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_name_collection_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF NEW.permit_service_env_collection IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_service_environment_collection'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF NEW.permit_site_code IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_site_code'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_site_code));
	END IF;

	IF NEW.permit_x509_signed_cert_id IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_x509_signed_certificate_id'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF NEW.permit_property_rank IS NOT NULL THEN
		_cq := array_append(_cq, quote_ident('permit_property_rank'));
		_vq := array_append(_vq, quote_nullable(NEW.permit_property_rank));
	END IF;

	EXECUTE 'INSERT INTO jazzhands.val_property (' ||
		array_to_string(_cq, ', ') ||
		') VALUES ( ' ||
		array_to_string(_vq, ', ') ||
		') RETURNING *' INTO _nr;

	NEW.property_name = _nr.property_name;
	NEW.property_type = _nr.property_type;
	NEW.description = _nr.description;
	NEW.account_collection_type = _nr.account_collection_type;
	NEW.company_collection_type = _nr.company_collection_type;
	NEW.device_collection_type = _nr.device_collection_type;
	NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
	NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
	NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
	NEW.netblock_collection_type = _nr.netblock_collection_type;
	NEW.network_range_type = _nr.network_range_type;
	NEW.property_collection_type = _nr.property_name_collection_type;
	NEW.service_env_collection_type = _nr.service_environment_collection_type;
	NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
	NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
	NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
	NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
	NEW.property_data_type = _nr.property_data_type;
	NEW.property_value_json_schema = _nr.property_value_json_schema;
	NEW.permit_account_collection_id = _nr.permit_account_collection_id;
	NEW.permit_account_id = _nr.permit_account_id;
	NEW.permit_account_realm_id = _nr.permit_account_realm_id;
	NEW.permit_company_id = _nr.permit_company_id;
	NEW.permit_company_collection_id = _nr.permit_company_collection_id;
	NEW.permit_device_collection_id = _nr.permit_device_collection_id;
	NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
	NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
	NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
	NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
	NEW.permit_network_range_id = _nr.permit_network_range_id;
	NEW.permit_operating_system_id = _nr.permit_operating_system_id;
	NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
	NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
	NEW.permit_service_env_collection = _nr.permit_service_environment_collection;
	NEW.permit_site_code = _nr.permit_site_code;
	NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
	NEW.permit_property_rank = _nr.permit_property_rank;
	NEW.data_ins_user = _nr.data_ins_user;
	NEW.data_ins_date = _nr.data_ins_date;
	NEW.data_upd_user = _nr.data_upd_user;
	NEW.data_upd_date = _nr.data_upd_date;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('val_property_ins');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_property_ins');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc val_property_ins failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'val_property_upd');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'val_property_upd');
CREATE OR REPLACE FUNCTION jazzhands_legacy.val_property_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	jazzhands_legacy.val_property%rowtype;
	_nr	jazzhands.val_property%rowtype;
	_uq	text[];
BEGIN

	IF OLD.property_name IS DISTINCT FROM NEW.property_name THEN
_uq := array_append(_uq, 'property_name = ' || quote_nullable(NEW.property_name));
	END IF;

	IF OLD.property_type IS DISTINCT FROM NEW.property_type THEN
_uq := array_append(_uq, 'property_type = ' || quote_nullable(NEW.property_type));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.account_collection_type IS DISTINCT FROM NEW.account_collection_type THEN
_uq := array_append(_uq, 'account_collection_type = ' || quote_nullable(NEW.account_collection_type));
	END IF;

	IF OLD.company_collection_type IS DISTINCT FROM NEW.company_collection_type THEN
_uq := array_append(_uq, 'company_collection_type = ' || quote_nullable(NEW.company_collection_type));
	END IF;

	IF OLD.device_collection_type IS DISTINCT FROM NEW.device_collection_type THEN
_uq := array_append(_uq, 'device_collection_type = ' || quote_nullable(NEW.device_collection_type));
	END IF;

	IF OLD.dns_domain_collection_type IS DISTINCT FROM NEW.dns_domain_collection_type THEN
_uq := array_append(_uq, 'dns_domain_collection_type = ' || quote_nullable(NEW.dns_domain_collection_type));
	END IF;

	IF OLD.layer2_network_collection_type IS DISTINCT FROM NEW.layer2_network_collection_type THEN
_uq := array_append(_uq, 'layer2_network_collection_type = ' || quote_nullable(NEW.layer2_network_collection_type));
	END IF;

	IF OLD.layer3_network_collection_type IS DISTINCT FROM NEW.layer3_network_collection_type THEN
_uq := array_append(_uq, 'layer3_network_collection_type = ' || quote_nullable(NEW.layer3_network_collection_type));
	END IF;

	IF OLD.netblock_collection_type IS DISTINCT FROM NEW.netblock_collection_type THEN
_uq := array_append(_uq, 'netblock_collection_type = ' || quote_nullable(NEW.netblock_collection_type));
	END IF;

	IF OLD.network_range_type IS DISTINCT FROM NEW.network_range_type THEN
_uq := array_append(_uq, 'network_range_type = ' || quote_nullable(NEW.network_range_type));
	END IF;

	IF OLD.property_collection_type IS DISTINCT FROM NEW.property_collection_type THEN
_uq := array_append(_uq, 'property_name_collection_type = ' || quote_nullable(NEW.property_collection_type));
	END IF;

	IF OLD.service_env_collection_type IS DISTINCT FROM NEW.service_env_collection_type THEN
_uq := array_append(_uq, 'service_environment_collection_type = ' || quote_nullable(NEW.service_env_collection_type));
	END IF;

	IF OLD.is_multivalue IS DISTINCT FROM NEW.is_multivalue THEN
IF NEW.is_multivalue = 'Y' THEN
	_uq := array_append(_uq, 'is_multivalue = true');
ELSIF NEW.is_multivalue = 'N' THEN
	_uq := array_append(_uq, 'is_multivalue = false');
ELSE
	_uq := array_append(_uq, 'is_multivalue = NULL');
END IF;
	END IF;

	IF OLD.prop_val_acct_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_acct_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_account_collection_type_restriction = ' || quote_nullable(NEW.prop_val_acct_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_dev_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_dev_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_device_collection_type_restriction = ' || quote_nullable(NEW.prop_val_dev_coll_type_rstrct));
	END IF;

	IF OLD.prop_val_nblk_coll_type_rstrct IS DISTINCT FROM NEW.prop_val_nblk_coll_type_rstrct THEN
_uq := array_append(_uq, 'property_value_netblock_collection_type_restriction = ' || quote_nullable(NEW.prop_val_nblk_coll_type_rstrct));
	END IF;

	IF OLD.property_data_type IS DISTINCT FROM NEW.property_data_type THEN
_uq := array_append(_uq, 'property_data_type = ' || quote_nullable(NEW.property_data_type));
	END IF;

	IF OLD.property_value_json_schema IS DISTINCT FROM NEW.property_value_json_schema THEN
_uq := array_append(_uq, 'property_value_json_schema = ' || quote_nullable(NEW.property_value_json_schema));
	END IF;

	IF OLD.permit_account_collection_id IS DISTINCT FROM NEW.permit_account_collection_id THEN
_uq := array_append(_uq, 'permit_account_collection_id = ' || quote_nullable(NEW.permit_account_collection_id));
	END IF;

	IF OLD.permit_account_id IS DISTINCT FROM NEW.permit_account_id THEN
_uq := array_append(_uq, 'permit_account_id = ' || quote_nullable(NEW.permit_account_id));
	END IF;

	IF OLD.permit_account_realm_id IS DISTINCT FROM NEW.permit_account_realm_id THEN
_uq := array_append(_uq, 'permit_account_realm_id = ' || quote_nullable(NEW.permit_account_realm_id));
	END IF;

	IF OLD.permit_company_id IS DISTINCT FROM NEW.permit_company_id THEN
_uq := array_append(_uq, 'permit_company_id = ' || quote_nullable(NEW.permit_company_id));
	END IF;

	IF OLD.permit_company_collection_id IS DISTINCT FROM NEW.permit_company_collection_id THEN
_uq := array_append(_uq, 'permit_company_collection_id = ' || quote_nullable(NEW.permit_company_collection_id));
	END IF;

	IF OLD.permit_device_collection_id IS DISTINCT FROM NEW.permit_device_collection_id THEN
_uq := array_append(_uq, 'permit_device_collection_id = ' || quote_nullable(NEW.permit_device_collection_id));
	END IF;

	IF OLD.permit_dns_domain_coll_id IS DISTINCT FROM NEW.permit_dns_domain_coll_id THEN
_uq := array_append(_uq, 'permit_dns_domain_collection_id = ' || quote_nullable(NEW.permit_dns_domain_coll_id));
	END IF;

	IF OLD.permit_layer2_network_coll_id IS DISTINCT FROM NEW.permit_layer2_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer2_network_collection_id = ' || quote_nullable(NEW.permit_layer2_network_coll_id));
	END IF;

	IF OLD.permit_layer3_network_coll_id IS DISTINCT FROM NEW.permit_layer3_network_coll_id THEN
_uq := array_append(_uq, 'permit_layer3_network_collection_id = ' || quote_nullable(NEW.permit_layer3_network_coll_id));
	END IF;

	IF OLD.permit_netblock_collection_id IS DISTINCT FROM NEW.permit_netblock_collection_id THEN
_uq := array_append(_uq, 'permit_netblock_collection_id = ' || quote_nullable(NEW.permit_netblock_collection_id));
	END IF;

	IF OLD.permit_network_range_id IS DISTINCT FROM NEW.permit_network_range_id THEN
_uq := array_append(_uq, 'permit_network_range_id = ' || quote_nullable(NEW.permit_network_range_id));
	END IF;

	IF OLD.permit_operating_system_id IS DISTINCT FROM NEW.permit_operating_system_id THEN
_uq := array_append(_uq, 'permit_operating_system_id = ' || quote_nullable(NEW.permit_operating_system_id));
	END IF;

	IF OLD.permit_os_snapshot_id IS DISTINCT FROM NEW.permit_os_snapshot_id THEN
_uq := array_append(_uq, 'permit_operating_system_snapshot_id = ' || quote_nullable(NEW.permit_os_snapshot_id));
	END IF;

	IF OLD.permit_property_collection_id IS DISTINCT FROM NEW.permit_property_collection_id THEN
_uq := array_append(_uq, 'permit_property_name_collection_id = ' || quote_nullable(NEW.permit_property_collection_id));
	END IF;

	IF OLD.permit_service_env_collection IS DISTINCT FROM NEW.permit_service_env_collection THEN
_uq := array_append(_uq, 'permit_service_environment_collection = ' || quote_nullable(NEW.permit_service_env_collection));
	END IF;

	IF OLD.permit_site_code IS DISTINCT FROM NEW.permit_site_code THEN
_uq := array_append(_uq, 'permit_site_code = ' || quote_nullable(NEW.permit_site_code));
	END IF;

	IF OLD.permit_x509_signed_cert_id IS DISTINCT FROM NEW.permit_x509_signed_cert_id THEN
_uq := array_append(_uq, 'permit_x509_signed_certificate_id = ' || quote_nullable(NEW.permit_x509_signed_cert_id));
	END IF;

	IF OLD.permit_property_rank IS DISTINCT FROM NEW.permit_property_rank THEN
_uq := array_append(_uq, 'permit_property_rank = ' || quote_nullable(NEW.permit_property_rank));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.val_property SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  property_name = $1 AND  property_type = $2 RETURNING *'  USING OLD.property_name, OLD.property_type
			INTO _nr;

		NEW.property_name = _nr.property_name;
		NEW.property_type = _nr.property_type;
		NEW.description = _nr.description;
		NEW.account_collection_type = _nr.account_collection_type;
		NEW.company_collection_type = _nr.company_collection_type;
		NEW.device_collection_type = _nr.device_collection_type;
		NEW.dns_domain_collection_type = _nr.dns_domain_collection_type;
		NEW.layer2_network_collection_type = _nr.layer2_network_collection_type;
		NEW.layer3_network_collection_type = _nr.layer3_network_collection_type;
		NEW.netblock_collection_type = _nr.netblock_collection_type;
		NEW.network_range_type = _nr.network_range_type;
		NEW.property_collection_type = _nr.property_name_collection_type;
		NEW.service_env_collection_type = _nr.service_environment_collection_type;
		NEW.is_multivalue = CASE WHEN _nr.is_multivalue = true THEN 'Y' WHEN _nr.is_multivalue = false THEN 'N' ELSE NULL END;
		NEW.prop_val_acct_coll_type_rstrct = _nr.property_value_account_collection_type_restriction;
		NEW.prop_val_dev_coll_type_rstrct = _nr.property_value_device_collection_type_restriction;
		NEW.prop_val_nblk_coll_type_rstrct = _nr.property_value_netblock_collection_type_restriction;
		NEW.property_data_type = _nr.property_data_type;
		NEW.property_value_json_schema = _nr.property_value_json_schema;
		NEW.permit_account_collection_id = _nr.permit_account_collection_id;
		NEW.permit_account_id = _nr.permit_account_id;
		NEW.permit_account_realm_id = _nr.permit_account_realm_id;
		NEW.permit_company_id = _nr.permit_company_id;
		NEW.permit_company_collection_id = _nr.permit_company_collection_id;
		NEW.permit_device_collection_id = _nr.permit_device_collection_id;
		NEW.permit_dns_domain_coll_id = _nr.permit_dns_domain_collection_id;
		NEW.permit_layer2_network_coll_id = _nr.permit_layer2_network_collection_id;
		NEW.permit_layer3_network_coll_id = _nr.permit_layer3_network_collection_id;
		NEW.permit_netblock_collection_id = _nr.permit_netblock_collection_id;
		NEW.permit_network_range_id = _nr.permit_network_range_id;
		NEW.permit_operating_system_id = _nr.permit_operating_system_id;
		NEW.permit_os_snapshot_id = _nr.permit_operating_system_snapshot_id;
		NEW.permit_property_collection_id = _nr.permit_property_name_collection_id;
		NEW.permit_service_env_collection = _nr.permit_service_environment_collection;
		NEW.permit_site_code = _nr.permit_site_code;
		NEW.permit_x509_signed_cert_id = _nr.permit_x509_signed_certificate_id;
		NEW.permit_property_rank = _nr.permit_property_rank;
		NEW.data_ins_user = _nr.data_ins_user;
		NEW.data_ins_date = _nr.data_ins_date;
		NEW.data_upd_user = _nr.data_upd_user;
		NEW.data_upd_date = _nr.data_upd_date;
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('val_property_upd');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('val_property_upd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc val_property_upd failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'x509_certificate_del');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'x509_certificate_del');
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	crt     jazzhands.x509_signed_certificate%ROWTYPE;
	key     jazzhands.private_key%ROWTYPE;
	csr     jazzhands.certificate_signing_request%ROWTYPE;
BEGIN
	SELECT * INTO crt FROM jazzhands.x509_signed_certificate
		WHERE x509_signed_certificate_id = OLD.x509_cert_id;

	IF crt.private_key_id IS NOT NULL THEN
		DELETE FROM jazzhands.private_key
		WHERE private_key_id = crt.private_key_id
		RETURNING * INTO key;
	END IF;

	IF crt.private_key_id IS NOT NULL THEN
		DELETE FROM jazzhands.certificate_signing_request
		WHERE certificate_signing_request_id =
		crt.certificate_signing_request_id
		RETURNING * INTO crt;
	END IF;

	OLD.x509_cert_id = crt.x509_signed_certiciate_id;
	OLD.friendly_name = crt.friendly_name;
	OLD.is_active = CASE WHEN crt.is_active = true THEN 'Y' WHEN crt.is_active = false THEN 'N' ELSE NULL END;
	OLD.is_certificate_authority = CASE WHEN crt.is_certificate_authority = true THEN 'Y' WHEN crt.is_certificate_authority = false THEN 'N' ELSE NULL END;
	OLD.signing_cert_id = crt.signing_cert_id;
	OLD.x509_ca_cert_serial_number = crt.x509_ca_cert_serial_number;
	OLD.public_key = crt.public_key;
	OLD.private_key = key.private_key;
	OLD.certificate_sign_req = crt.certificate_signing_request;
	OLD.subject = crt.subject;
	OLD.subject_key_identifier = crt.subject_key_identifier;
	OLD.valid_from = crt.valid_from;
	OLD.valid_to = crt.valid_to;
	OLD.x509_revocation_date = crt.x509_revocation_date;
	OLD.x509_revocation_reason = crt.x509_revocation_reason;
	OLD.passphrase = key.passphrase;
	OLD.encryption_key_id = key.encryption_key_id;
	OLD.ocsp_uri = crt.ocsp_uri;
	OLD.crl_uri = crt.crl_uri;
	OLD.data_ins_user = crt.data_ins_user;
	OLD.data_ins_date = crt.data_ins_date;
	OLD.data_upd_user = crt.data_upd_user;
	OLD.data_upd_date = crt.data_upd_date;
	RETURN OLD;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('x509_certificate_del');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate_del');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc x509_certificate_del failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'x509_certificate_ins');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'x509_certificate_ins');
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	key	jazzhands.private_key%rowtype;
	csr	jazzhands.certificate_signing_request%rowtype;
	crt	jazzhands.x509_signed_certificate%rowtype;
BEGIN
	IF NEW.private_key IS NOT NULL THEN
		INSERT INTO jazzhands.private_key (
			private_key_encryption_type,
			is_active,
			subject_key_identifier,
			private_key,
			passphrase,
			encryption_key_id
		) VALUES (
			'rsa',
			NEW.is_active,
			NEW.subject_key_identifier,
			NEW.private_key,
			NEW.passphrase,
			NEW.encryption_key_id
		) RETURNING * INTO key;
		NEW.x509_cert_id := key;
	ELSE
		IF NEW.subject_key_identifier IS NOT NULL THEN
			SELECT jazzhands.private_key_id
			INTO key
			FROM private_key
			WHERE subject_key_identifier = NEW.subject_key_identifier;

			SELECT private_key
			INTO NEW.private_key
			FROM private_key
			WHERE private_key_id = key;
		END IF;
	END IF;

	IF NEW.certificate_sign_req IS NOT NULL THEN
		INSERT INTO jazzhands.certificate_signing_request (
			friendly_name,
			subject,
			certificate_signing_request,
			private_key_id
		) VALUES (
			NEW.friendly_name,
			NEW.subject,
			NEW.certificate_sign_req,
			key
		) RETURNING * INTO csr;
		IF NEW.x509_cert_id IS NULL THEN
			NEW.x509_cert_id := csr;
		END IF;
	ELSE
		IF NEW.subject_key_identifier IS NOT NULL THEN
			SELECT certificate_signing_request_id
			INTO csr
			FROM certificate_signing_request
				JOIN private_key USING (private_key_id)
			WHERE subject_key_identifier = NEW.subject_key_identifier
			ORDER BY certificate_signing_request_id
			LIMIT 1;

			SELECT certificate_signing_request
			INTO NEW.certificate_sign_req
			FROM certificate_signing_request
			WHERE certificate_signing_request_id  = csr;
		END IF;
	END IF;

	IF NEW.public_key IS NOT NULL THEN
		INSERT INTO jazzhands.x509_signed_certificate (
			friendly_name,
			is_active,
			is_certificate_authority,
			signing_cert_id,
			x509_ca_cert_serial_number,
			public_key,
			subject,
			subject_key_identifier,
			valid_from,
			valid_to,
			x509_revocation_date,
			x509_revocation_reason,
			ocsp_uri,
			crl_uri,
			private_key_id,
			certificate_signing_request_id
		) VALUES (
			NEW.friendly_name,
			CASE WHEN NEW.is_active = 'Y' THEN true
				WHEN NEW.is_active = 'N' THEN false
				ELSE NULL END,
			CASE WHEN NEW.is_certificate_authority = 'Y' THEN true
				WHEN NEW.is_certificate_authority = 'N' THEN false
				ELSE NULL END,
			NEW.signing_cert_id,
			NEW.x509_ca_cert_serial_number,
			NEW.public_key,
			NEW.subject,
			NEW.subject_key_identifier,
			NEW.valid_from,
			NEW.valid_to,
			NEW.x509_revocation_date,
			NEW.x509_revocation_reason,
			NEW.ocsp_uri,
			NEW.crl_uri,
			key,
			csr
		) RETURNING * INTO crt;
	END IF;

	NEW.x509_cert_id 		= crt.x509_signed_certificate_id;
	NEW.friendly_name 		= crt.friendly_name;
	NEW.is_active 			= CASE WHEN crt.is_active = true THEN 'Y'
								WHEN crt.is_active = false THEN 'N'
								ELSE NULL END;
	NEW.is_certificate_authority = CASE WHEN crt.is_certificate_authority =
									true THEN 'Y'
								WHEN crt.is_certificate_authority = false
									THEN 'N'
								ELSE NULL END;

	NEW.signing_cert_id 			= crt.signing_cert_id;
	NEW.x509_ca_cert_serial_number	= crt.x509_ca_cert_serial_number;
	NEW.public_key 					= crt.public_key;
	NEW.private_key 				= key.private_key;
	NEW.certificate_sign_req 		= csr.certificate_signing_request;
	NEW.subject 					= crt.subject;
	NEW.subject_key_identifier 		= crt.subject_key_identifier;
	NEW.valid_from 					= crt.valid_from;
	NEW.valid_to 					= crt.valid_to;
	NEW.x509_revocation_date 		= crt.x509_revocation_date;
	NEW.x509_revocation_reason 		= crt.x509_revocation_reason;
	NEW.passphrase 					= key.passphrase;
	NEW.encryption_key_id 			= key.encryption_key_id;
	NEW.ocsp_uri 					= crt.ocsp_uri;
	NEW.crl_uri 					= crt.crl_uri;
	NEW.data_ins_user 				= crt.data_ins_user;
	NEW.data_ins_date 				= crt.data_ins_date;
	NEW.data_upd_user 				= crt.data_upd_user;
	NEW.data_upd_date 				= crt.data_upd_date;
	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('x509_certificate_ins');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate_ins');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc x509_certificate_ins failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_legacy', 'x509_certificate_upd');
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'x509_certificate_upd');
CREATE OR REPLACE FUNCTION jazzhands_legacy.x509_certificate_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	crt	jazzhands.x509_signed_certificate%rowtype;
	key	jazzhands.private_key%rowtype;
	csr	jazzhands.certificate_signing_request%rowtype;
	_uq	text[];
BEGIN
	SELECT * INTO crt FROM jazzhands.x509_signed_certificate
        WHERE x509_signed_certificate_id = OLD.x509_cert_id;

	IF crt.private_key_ID IS NULL AND NEW.private_key IS NOT NULL THEN
		INSERT INTO private_key (
			private_key_encryption_type,
			is_active,
			subject_key_identifier,
			private_key,
			passphrase,
			encryption_key_id
		) VALUES (
			'rsa',
			NEW.is_active,
			NEW.subject_key_identifier,
			NEW.private_key,
			NEW.passphrase,
			NEW.encryption_key_id
		) RETURNING * INTO key;
	ELSE IF crt.private_key_id IS NOT NULL THEN
		SELECT * INTO key FROM jazzhands.private_key k
			WHERE k.private_key_id =  crt.private_key_id;

		-- delete happens at the end, after update
		IF NEW.private_key IS NOT NULL THEN
			IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
				_uq := array_append(_uq,
					'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
				);
			END IF;
			IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
				_uq := array_append(_uq,
					'is_active = ' || quote_literal(NEW.is_active)
				);
			END IF;
			IF OLD.private_key IS DISTINCT FROM NEW.private_key THEN
				_uq := array_append(_uq,
					'private_key = ' || quote_nullable(NEW.private_key)
				);
			END IF;
			IF OLD.passphrase IS DISTINCT FROM NEW.passphrase THEN
				_uq := array_append(_uq,
					'passphrase = ' || quote_nullable(NEW.passphrase)
				);
			END IF;
			IF OLD.encryption_key_id IS DISTINCT FROM NEW.encryption_key_id THEN
				_uq := array_append(_uq,
					'encryption_key_id = ' || quote_nullable(NEW.encryption_key_id)
				);
			END IF;
			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.private_key 	= key.private_key;
		NEW.is_active 		= key.private_key;
		NEW.passphrase 		= key.passphrase;
		NEW.encryption_key 	= key.passphrase;
	END IF;

	-- private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF crt.certificate_signing_request_id IS NULL AND NEW.certificate_sign_req IS NOT NULL THEN
		INSERT INTO jazzhands.certificate_signing_request (
			friendly_name,
			subject,
			certificate_signing_request,
			private_key_id
		) VALUES (
			NEW.friendly_name,
			NEW.subject,
			NEW.certificate_sign_req,
			key.private_key_id
		) RETURNING * INTO csr;
	ELSIF crt.certificate_sign_req IS NOT NULL THEN
		SELECT * INTO csr FROM jazzhands.certificate_signing_request c
			WHERE c.certificate_sign_req =  crt.certificate_signing_request_id;

		-- delete happens at the end, after update
		IF NEW.certificate_sign_req IS NOT NULL THEN
			IF OLD.certificate_sign_req IS DISTINCT FROM NEW.certificate_sign_req THEN
				_uq := array_append(_uq,
					'certificate_signing_request = ' || quote_nullable(NEW.certificate_sign_req)
				);
			END IF;
			IF OLD.subject IS DISTINCT FROM NEW.subject THEN
				_uq := array_append(_uq,
					'subject = ' || quote_nullable(NEW.subject)
				);
			END IF;
			IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
				_uq := array_append(_uq,
					'friendly_name = ' || quote_nullable(NEW.friendly_name)
				);
			END IF;
			IF OLD.private_key_id IS DISTINCT FROM key.private_key_id THEN
				_uq := array_append(_uq,
					'private_key_id = ' || quote_nullable(NEW.private_key_id)
				);
			END IF;

			IF array_length(_uq, 1) > 0 THEN
				EXECUTE format('UPDATE private_key SET %s WHERE private_key_id = $1 RETURNING *',
					array_to_string(_uq, ', '))
					USING crt.private_key_id
					INTO key;
			END IF;
		END IF;

		NEW.certificate_sign_req 	= csr.certificate_signing_request;
	END IF;

	-- csr and private_key pieces are now what it is supposed to be.
	_uq := NULL;

	IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
		IF NEW.is_active = 'Y' THEN
			_uq := array_append(_uq, 'is_active = true');
		ELSIF NEW.is_active = 'N' THEN
			_uq := array_append(_uq, 'is_active = false');
		ELSE
			_uq := array_append(_uq, 'is_active = NULL');
		END IF;
	END IF;

	END IF;
	IF OLD.friendly_name IS DISTINCT FROM NEW.friendly_name THEN
		_uq := array_append(_uq,
			'friendly_name = ' || quote_literal(NEW.friendly_name)
		);
	END IF;
	IF OLD.subject IS DISTINCT FROM NEW.subject THEN
		_uq := array_append(_uq,
			'subject = ' || quote_literal(NEW.subject)
		);
	END IF;
	IF OLD.subject_key_identifier IS DISTINCT FROM NEW.subject_key_identifier THEN
		_uq := array_append(_uq,
			'subject_key_identifier = ' || quote_nullable(NEW.subject_key_identifier)
		);
	END IF;

	IF OLD.is_certificate_authority IS DISTINCT FROM NEW.is_certificate_authority THEN
		IF NEW.is_certificate_authority = 'Y' THEN
			_uq := array_append(_uq, 'is_certificate_authority = true');
		ELSIF NEW.is_certificate_authority = 'N' THEN
			_uq := array_append(_uq, 'is_certificate_authority = false');
		ELSE
			_uq := array_append(_uq, 'is_certificate_authority = NULL');
		END IF;
	END IF;

	IF OLD.signing_cert_id IS DISTINCT FROM NEW.signing_cert_id THEN
		_uq := array_append(_uq,
			'signing_cert_id = ' || quote_nullable(NEW.signing_cert_id)
		);
	END IF;
	IF OLD.x509_ca_cert_serial_number IS DISTINCT FROM NEW.x509_ca_cert_serial_number THEN
		_uq := array_append(_uq,
			'x509_ca_cert_serial_number = ' || quote_nullable(NEW.x509_ca_cert_serial_number)
		);
	END IF;
	IF OLD.public_key IS DISTINCT FROM NEW.public_key THEN
		_uq := array_append(_uq,
			'public_key = ' || quote_nullable(NEW.public_key)
		);
	END IF;
	IF OLD.valid_from IS DISTINCT FROM NEW.valid_from THEN
		_uq := array_append(_uq,
			'valid_from = ' || quote_nullable(NEW.valid_from)
		);
	END IF;
	IF OLD.valid_to IS DISTINCT FROM NEW.valid_to THEN
		_uq := array_append(_uq,
			'valid_to = ' || quote_nullable(NEW.valid_to)
		);
	END IF;
	IF OLD.x509_revocation_date IS DISTINCT FROM NEW.x509_revocation_date THEN
		_uq := array_append(_uq,
			'x509_revocation_date = ' || quote_nullable(NEW.x509_revocation_date)
		);
	END IF;
	IF OLD.x509_revocation_reason IS DISTINCT FROM NEW.x509_revocation_reason THEN
		_uq := array_append(_uq,
			'x509_revocation_reason = ' || quote_nullable(NEW.x509_revocation_reason)
		);
	END IF;
	IF OLD.ocsp_uri IS DISTINCT FROM NEW.ocsp_uri THEN
		_uq := array_append(_uq,
			'ocsp_uri = ' || quote_nullable(NEW.ocsp_uri)
		);
	END IF;
	IF OLD.crl_uri IS DISTINCT FROM NEW.crl_uri THEN
		_uq := array_append(_uq,
			'crl_uri = ' || quote_nullable(NEW.crl_uri)
		);
	END IF;

	IF array_length(_uq, 1) > 0 THEN
		EXECUTE 'UPDATE x509_signed_certificate SET '
			|| array_to_string(upq, ', ')
			|| ' WHERE x509_signed_certificate_id = '
			|| NEW.x509_cert_id;
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.x509_certificate SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  x509_cert_id = $1 RETURNING *'  USING OLD.x509_cert_id
			INTO crt;

		NEW.x509_cert_id = _crt.x509_signed_certificate_id;
		NEW.friendly_name = crt.friendly_name;
		NEW.is_active = CASE WHEN crt.is_active = true THEN 'Y' WHEN crt.is_active = false THEN 'N' ELSE NULL END;
		NEW.is_certificate_authority = CASE WHEN crt.is_certificate_authority = true THEN 'Y' WHEN crt.is_certificate_authority = false THEN 'N' ELSE NULL END;
		NEW.signing_cert_id = crt.signing_cert_id;
		NEW.x509_ca_cert_serial_number = crt.x509_ca_cert_serial_number;
		NEW.public_key = crt.public_key;
		NEW.subject = crt.subject;
		NEW.subject_key_identifier = crt.subject_key_identifier;
		NEW.valid_from = crt.valid_from;
		NEW.valid_to = crt.valid_to;
		NEW.x509_revocation_date = crt.x509_revocation_date;
		NEW.x509_revocation_reason = crt.x509_revocation_reason;
		NEW.ocsp_uri = crt.ocsp_uri;
		NEW.crl_uri = crt.crl_uri;
		NEW.data_ins_user = crt.data_ins_user;
		NEW.data_ins_date = crt.data_ins_date;
		NEW.data_upd_user = crt.data_upd_user;
		NEW.data_upd_date = crt.data_upd_date;
	END IF;

	IF OLD.certificate_sign_req IS NOT NULL AND NEW.certificate_sign_req IS NULL THEN
		DELETE FROM jazzhands.certificate_signing_request
		WHERE certificate_signing_request_id = crt.certificate_signing_request_id;
	END IF;

	IF OLD.private_key IS NOT NULL AND NEW.private_key IS NULL THEN
		DELETE FROM jazzhands.private_key
		WHERE private_key_id = crt.private_key_id;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'function' AND object IN ('x509_certificate_upd');
	DELETE FROM __regrants WHERE schema = 'jazzhands_legacy' AND object IN ('x509_certificate_upd');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc x509_certificate_upd failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_legacy.dns_domain_ins()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%ROWTYPE;
BEGIN
	IF NEW.dns_domain_name IS NOT NULL and NEW.soa_name IS NOT NULL THEN
		RAISE EXCEPTION 'Must only set dns_domain_name, not soa_name'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF NEW.dns_domain_id IS NULL THEN
		INSERT INTO jazzhands.dns_domain (
			dns_domain_name,
			dns_domain_type,
			parent_dns_domain_id,
			description,
			external_id,
			data_ins_user,
			data_ins_date,
			data_upd_user,
			data_upd_date
		) VALUES (
			coalesce(NEW.dns_domain_name, NEW.soa_name),
			NEW.dns_domain_type,
			NEW.parent_dns_domain_id,
			NEW.description,
			NEW.external_id,
			NEW.data_ins_user,
			NEW.data_ins_date,
			NEW.data_upd_user,
			NEW.data_upd_date
		) RETURNING * INTO _d;
	ELSE
		INSERT INTO jazzhands.dns_domain (
			dns_domain_id,
			dns_domain_name,
			dns_domain_type,
			parent_dns_domain_id,
			description,
			external_id,
			data_ins_user,
			data_ins_date,
			data_upd_user,
			data_upd_date
		) VALUES (
			NEW.dns_domain_id,
			coalesce(NEW.dns_domain_name, NEW.soa_name),
			NEW.dns_domain_type,
			NEW.parent_dns_domain_id,
			NEW.description,
			NEW.external_id,
			NEW.data_ins_user,
			NEW.data_ins_date,
			NEW.data_upd_user,
			NEW.data_upd_date
		) RETURNING * INTO _d;
	END IF;

	NEW.dns_domain_id			= _d.dns_domain_id;
	NEW.soa_name				= _d.dns_domain_name;
	NEW.dns_domain_name			= _d.dns_domain_name;
	NEW.dns_domain_type			= _d.dns_domain_type;
	NEW.parent_dns_domain_id	= _d.parent_dns_domain_id;
	NEW.description				= _d.description;
	NEW.external_id				= _d.external_id;
	NEW.data_ins_user			= _d.data_ins_user;
	NEW.data_ins_date			= _d.data_ins_date;
	NEW.data_upd_user			= _d.data_upd_user;
	NEW.data_upd_date			= _d.data_upd_date;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_legacy.dns_domain_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_d	jazzhands.dns_domain%ROWTYPE;
	_uq	TEXT[];
BEGIN
	IF OLD.dns_domain_name IS DISTINCT FROM NEW.dns_domain_name
		AND OLD.soa_name IS DISTINCT FROM NEW.soa_name
	 THEN
		RAISE EXCEPTION 'Must only change dns_domain_name OR soa_name'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;

	IF OLD.dns_domain_id IS DISTINCT FROM NEW.dns_domain_id THEN
		_uq := array_append(_uq, 'dns_domain_id = ' || quote_nullable(NEW.dns_domain_id));
	END IF;

	IF OLD.dns_domain_name IS DISTINCT FROM NEW.dns_domain_name THEN
		_uq := array_append(_uq, 'dns_domain_name = ' || quote_nullable(NEW.dns_domain_name));
	END IF;

	IF OLD.soa_name IS DISTINCT FROM NEW.soa_name THEN
		_uq := array_append(_uq, 'dns_domain_name = ' || quote_nullable(NEW.soa_name));
	END IF;

	IF OLD.dns_domain_type IS DISTINCT FROM NEW.dns_domain_type THEN
		_uq := array_append(_uq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	IF OLD.parent_dns_domain_id IS DISTINCT FROM NEW.parent_dns_domain_id THEN
		_uq := array_append(_uq, 'parent_dns_domain_id = ' || quote_nullable(NEW.parent_dns_domain_id));
	END IF;

	IF OLD.description IS DISTINCT FROM NEW.description THEN
		_uq := array_append(_uq, 'description = ' || quote_nullable(NEW.description));
	END IF;

	IF OLD.external_id IS DISTINCT FROM NEW.external_id THEN
		_uq := array_append(_uq, 'dns_domain_type = ' || quote_nullable(NEW.dns_domain_type));
	END IF;

	IF _uq IS NOT NULL THEN
		EXECUTE 'UPDATE jazzhands.dns_domain SET ' ||
			array_to_string(_uq, ', ') ||
			' WHERE  dns_domain_id = $1 RETURNING *'
			USING OLD.dns_domain_id
			INTO _d;

		NEW.dns_domain_id			= _d.dns_domain_id;
		NEW.soa_name				= _d.dns_domain_name;
		NEW.dns_domain_name			= _d.dns_domain_name;
		NEW.dns_domain_type			= _d.dns_domain_type;
		NEW.parent_dns_domain_id	= _d.parent_dns_domain_id;
		NEW.description				= _d.description;
		NEW.external_id				= _d.external_id;
		NEW.data_ins_user			= _d.data_ins_user;
		NEW.data_ins_date			= _d.data_ins_date;
		NEW.data_upd_user			= _d.data_upd_user;
		NEW.data_upd_date			= _d.data_upd_date;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_legacy.do_layer1_connection_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO inter_component_connection (
			slot1_id,
			slot2_id,
			circuit_id
		) VALUES (
			NEW.physical_port1_id,
			NEW.physical_port2_id,
			NEW.circuit_id
		) RETURNING inter_component_connection_id INTO NEW.layer1_connection_id;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
		IF (NEW.layer1_connection_id IS DISTINCT FROM
				OLD.layer1_connection_id) OR
			(NEW.physical_port1_id IS DISTINCT FROM OLD.physical_port1_id) OR
			(NEW.physical_port2_id IS DISTINCT FROM OLD.physical_port2_id) OR
			(NEW.circuit_id IS DISTINCT FROM OLD.circuit_id)
		THEN
			UPDATE inter_component_connection
			SET
				inter_component_connection_id = NEW.layer1_connection_id,
				slot1_id = NEW.physical_port1_id,
				slot2_id = NEW.physical_port2_id,
				circuit_id = NEW.circuit_id
			WHERE
				inter_component_connection_id = OLD.layer1_connection_id;
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM inter_component_connection WHERE
			inter_component_connection_id = OLD.layer1_connection_id;
		RETURN OLD;
	END IF;
END; $function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands_legacy.do_physical_port_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		RAISE EXCEPTION 'Physical ports must be inserted as component slots';
	ELSIF TG_OP = 'UPDATE' THEN
		IF (NEW.physical_port_id IS DISTINCT FROM OLD.physical_port_id) OR
			(NEW.device_id IS DISTINCT FROM OLD.device_id) OR
			(NEW.port_type IS DISTINCT FROM OLD.port_type) OR
			(NEW.port_plug_style IS DISTINCT FROM OLD.port_plug_style) OR
			(NEW.port_medium IS DISTINCT FROM OLD.port_medium) OR
			(NEW.port_protocol IS DISTINCT FROM OLD.port_protocol) OR
			(NEW.port_speed IS DISTINCT FROM OLD.port_speed) OR
			(NEW.port_purpose IS DISTINCT FROM OLD.port_purpose) OR
			(NEW.logical_port_id IS DISTINCT FROM OLD.logical_port_id) OR
			(NEW.tcp_port IS DISTINCT FROM OLD.tcp_port) OR
			(NEW.is_hardwired IS DISTINCT FROM OLD.is_hardwired)
		THEN
			RAISE EXCEPTION 'Attempted to update a deprecated physical_port attribute that must be changed on the slot now';
		END IF;
		IF (NEW.port_name IS DISTINCT FROM OLD.port_name) OR
			(NEW.description IS DISTINCT FROM OLD.description) OR
			(NEW.physical_label IS DISTINCT FROM OLD.physical_label)
		THEN
			UPDATE slot
			SET
				slot_name = NEW.port_name,
				description = NEW.description,
				physical_label = NEW.physical_label
			WHERE
				slot_id = NEW.physical_port_id;
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM slot WHERE
			slot_id = OLD.physical_port_id;
		RETURN OLD;
	END IF;
END; $function$
;

-- Dropping obsoleted sequences....


-- Dropping obsoleted jazzhands_audit sequences....
DROP SEQUENCE IF EXISTS jazzhands_audit.val_network_interface_purpose_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_network_interface_type_seq;


-- Processing tables with no structural changes
-- Some of these may be redundant
-- fk constraints
ALTER TABLE layer3_interface DROP CONSTRAINT IF EXISTS fk_netint_netinttyp_id;
ALTER TABLE layer3_interface
	ADD CONSTRAINT fk_netint_netinttyp_id
	FOREIGN KEY (layer3_interface_type) REFERENCES jazzhands.val_layer3_interface_type(layer3_interface_type);

ALTER TABLE person DROP CONSTRAINT IF EXISTS r_822;
ALTER TABLE person
	ADD CONSTRAINT fk_person_gender
	FOREIGN KEY (gender) REFERENCES jazzhands.val_gender(gender);

-- index
DROP INDEX "jazzhands"."xif2person";
DROP INDEX IF EXISTS "jazzhands"."fk_person_gender";
CREATE INDEX fk_person_gender ON jazzhands.person USING btree (gender);
-- triggers
DROP TRIGGER IF EXISTS trig_account_change_realm_aca_realm ON account;
CREATE TRIGGER trig_account_change_realm_aca_realm BEFORE UPDATE OF account_realm_id ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_change_realm_aca_realm();
DROP TRIGGER IF EXISTS trig_add_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_add_account_automated_reporting_ac AFTER INSERT OR UPDATE OF login, account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_add_automated_ac_on_account ON account;
CREATE TRIGGER trig_add_automated_ac_on_account AFTER INSERT OR UPDATE OF account_type, account_role, account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_rm_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_rm_account_automated_reporting_ac BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_rm_automated_ac_on_account ON account;
CREATE TRIGGER trig_rm_automated_ac_on_account BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_userlog_account ON account;
CREATE TRIGGER trig_userlog_account BEFORE INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_enforce_is_enabled ON account;
CREATE TRIGGER trigger_account_enforce_is_enabled BEFORE INSERT OR UPDATE OF account_status, is_enabled ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_enforce_is_enabled();
DROP TRIGGER IF EXISTS trigger_account_status_per_row_after_hooks ON account;
CREATE TRIGGER trigger_account_status_per_row_after_hooks AFTER UPDATE OF account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_status_per_row_after_hooks();
DROP TRIGGER IF EXISTS trigger_account_validate_login ON account;
CREATE TRIGGER trigger_account_validate_login BEFORE INSERT OR UPDATE OF login ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_validate_login();
DROP TRIGGER IF EXISTS trigger_audit_account ON account;
CREATE TRIGGER trigger_audit_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account();
DROP TRIGGER IF EXISTS trigger_create_new_unix_account ON account;
CREATE TRIGGER trigger_create_new_unix_account AFTER INSERT ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.create_new_unix_account();
DROP TRIGGER IF EXISTS trigger_delete_peraccount_account_collection ON account;
CREATE TRIGGER trigger_delete_peraccount_account_collection BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_peraccount_account_collection();
DROP TRIGGER IF EXISTS trigger_update_peraccount_account_collection ON account;
CREATE TRIGGER trigger_update_peraccount_account_collection AFTER INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.update_peraccount_account_collection();
DROP TRIGGER IF EXISTS trig_userlog_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trig_userlog_account_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trigger_audit_account_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_assigned_certificate();
DROP TRIGGER IF EXISTS trig_userlog_account_authentication_log ON account_authentication_log;
CREATE TRIGGER trig_userlog_account_authentication_log BEFORE INSERT OR UPDATE ON jazzhands.account_authentication_log FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_authentication_log ON account_authentication_log;
CREATE TRIGGER trigger_audit_account_authentication_log AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_authentication_log FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_authentication_log();
DROP TRIGGER IF EXISTS aaa_account_collection_base_handler ON account_collection;
CREATE TRIGGER aaa_account_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.account_collection_base_handler();
DROP TRIGGER IF EXISTS trig_account_collection_realm ON account_collection;
CREATE TRIGGER trig_account_collection_realm AFTER UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection ON account_collection;
CREATE TRIGGER trig_userlog_account_collection BEFORE INSERT OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection ON account_collection;
CREATE TRIGGER trigger_audit_account_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection();
DROP TRIGGER IF EXISTS trigger_validate_account_collection_type_change ON account_collection;
CREATE TRIGGER trigger_validate_account_collection_type_change BEFORE UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_account_collection_type_change();
DROP TRIGGER IF EXISTS trig_account_collection_account_realm ON account_collection_account;
CREATE TRIGGER trig_account_collection_account_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_account ON account_collection_account;
CREATE TRIGGER trig_userlog_account_collection_account BEFORE INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_coll_member_relation_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_coll_member_relation_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_coll_member_relation_enforce();
DROP TRIGGER IF EXISTS trigger_account_collection_member_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_account ON account_collection_account;
CREATE TRIGGER trigger_audit_account_collection_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_account();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_collection_account_token_changes ON account_collection_account;
CREATE TRIGGER trigger_pgnotify_account_collection_account_token_changes AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_collection_account_token_changes();
DROP TRIGGER IF EXISTS aaa_account_collection_root_handler ON account_collection_hier;
CREATE TRIGGER aaa_account_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id, child_account_collection_id ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.account_collection_root_handler();
DROP TRIGGER IF EXISTS trig_account_collection_hier_realm ON account_collection_hier;
CREATE TRIGGER trig_account_collection_hier_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_hier_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trig_userlog_account_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_collection_hier_enforce ON account_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_account_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trigger_audit_account_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_account_collection_hier_loop ON account_collection_hier;
CREATE TRIGGER trigger_check_account_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_account_colllection_hier_loop();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trig_userlog_account_collection_type_relation BEFORE INSERT OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trigger_audit_account_collection_type_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_type_relation();
DROP TRIGGER IF EXISTS trig_userlog_account_realm ON account_realm;
CREATE TRIGGER trig_userlog_account_realm BEFORE INSERT OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm ON account_realm;
CREATE TRIGGER trigger_audit_account_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trig_userlog_account_realm_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trigger_audit_account_realm_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_company ON account_realm_company;
CREATE TRIGGER trig_userlog_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_company ON account_realm_company;
CREATE TRIGGER trigger_audit_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trig_userlog_account_realm_password_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trigger_audit_account_realm_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_password_type();
DROP TRIGGER IF EXISTS trig_userlog_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trig_userlog_account_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trigger_audit_account_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_account_token ON account_token;
CREATE TRIGGER trig_userlog_account_token BEFORE INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_token ON account_token;
CREATE TRIGGER trigger_audit_account_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_token_change ON account_token;
CREATE TRIGGER trigger_pgnotify_account_token_change AFTER INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_token_change();
DROP TRIGGER IF EXISTS trig_userlog_account_unix_info ON account_unix_info;
CREATE TRIGGER trig_userlog_account_unix_info BEFORE INSERT OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_unix_info ON account_unix_info;
CREATE TRIGGER trigger_audit_account_unix_info AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_unix_info();
DROP TRIGGER IF EXISTS trig_userlog_appaal ON appaal;
CREATE TRIGGER trig_userlog_appaal BEFORE INSERT OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal ON appaal;
CREATE TRIGGER trigger_audit_appaal AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance ON appaal_instance;
CREATE TRIGGER trig_userlog_appaal_instance BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance ON appaal_instance;
CREATE TRIGGER trigger_audit_appaal_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trig_userlog_appaal_instance_device_collection BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trigger_audit_appaal_instance_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trig_userlog_appaal_instance_property BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trigger_audit_appaal_instance_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance_property();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance ON approval_instance;
CREATE TRIGGER trig_userlog_approval_instance BEFORE INSERT OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance ON approval_instance;
CREATE TRIGGER trigger_audit_approval_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trig_userlog_approval_instance_item BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approval_notify ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approval_notify AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.approval_instance_item_approval_notify();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approved_immutable ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approved_immutable BEFORE UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_item_approved_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_auto_complete ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_step_auto_complete AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_auto_complete();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trigger_audit_approval_instance_item AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_item();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trig_userlog_approval_instance_link BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trigger_audit_approval_instance_link AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_link();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trig_userlog_approval_instance_step BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_completed_immutable ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_completed_immutable BEFORE UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_completed_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_resolve_instance ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_resolve_instance AFTER UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_resolve_instance();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trigger_audit_approval_instance_step AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_step();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trig_userlog_approval_instance_step_notify BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trigger_audit_approval_instance_step_notify AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_step_notify();
DROP TRIGGER IF EXISTS trigger_legacy_approval_instance_step_notify_account ON approval_instance_step_notify;
CREATE TRIGGER trigger_legacy_approval_instance_step_notify_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION jazzhands.legacy_approval_instance_step_notify_account();
DROP TRIGGER IF EXISTS trig_userlog_approval_process ON approval_process;
CREATE TRIGGER trig_userlog_approval_process BEFORE INSERT OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_process ON approval_process;
CREATE TRIGGER trigger_audit_approval_process AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_process();
DROP TRIGGER IF EXISTS trig_userlog_asset ON asset;
CREATE TRIGGER trig_userlog_asset BEFORE INSERT OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_asset ON asset;
CREATE TRIGGER trigger_audit_asset AFTER INSERT OR DELETE OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_asset();
DROP TRIGGER IF EXISTS trigger_validate_asset_component_assignment ON asset;
CREATE CONSTRAINT TRIGGER trigger_validate_asset_component_assignment AFTER INSERT OR UPDATE OF component_id ON jazzhands.asset DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_asset_component_assignment();
DROP TRIGGER IF EXISTS trig_userlog_badge ON badge;
CREATE TRIGGER trig_userlog_badge BEFORE INSERT OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge ON badge;
CREATE TRIGGER trigger_audit_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_badge();
DROP TRIGGER IF EXISTS trig_userlog_badge_type ON badge_type;
CREATE TRIGGER trig_userlog_badge_type BEFORE INSERT OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge_type ON badge_type;
CREATE TRIGGER trigger_audit_badge_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_badge_type();
DROP TRIGGER IF EXISTS trig_userlog_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trig_userlog_certificate_signing_request BEFORE INSERT OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trigger_audit_certificate_signing_request AFTER INSERT OR DELETE OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_certificate_signing_request();
DROP TRIGGER IF EXISTS trig_userlog_chassis_location ON chassis_location;
CREATE TRIGGER trig_userlog_chassis_location BEFORE INSERT OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_chassis_location ON chassis_location;
CREATE TRIGGER trigger_audit_chassis_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_chassis_location();
DROP TRIGGER IF EXISTS trig_userlog_circuit ON circuit;
CREATE TRIGGER trig_userlog_circuit BEFORE INSERT OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_circuit ON circuit;
CREATE TRIGGER trigger_audit_circuit AFTER INSERT OR DELETE OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_circuit();
DROP TRIGGER IF EXISTS trig_userlog_company ON company;
CREATE TRIGGER trig_userlog_company BEFORE INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company ON company;
CREATE TRIGGER trigger_audit_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company();
DROP TRIGGER IF EXISTS trigger_company_insert_function_nudge ON company;
CREATE TRIGGER trigger_company_insert_function_nudge BEFORE INSERT ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.company_insert_function_nudge();
DROP TRIGGER IF EXISTS trigger_delete_per_company_company_collection ON company;
CREATE TRIGGER trigger_delete_per_company_company_collection BEFORE DELETE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_company_company_collection();
DROP TRIGGER IF EXISTS trigger_update_per_company_company_collection ON company;
CREATE TRIGGER trigger_update_per_company_company_collection AFTER INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_company_company_collection();
DROP TRIGGER IF EXISTS trig_userlog_company_collection ON company_collection;
CREATE TRIGGER trig_userlog_company_collection BEFORE INSERT OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection ON company_collection;
CREATE TRIGGER trigger_audit_company_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_del ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_del BEFORE DELETE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_insup ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_company_collection_type_change ON company_collection;
CREATE TRIGGER trigger_validate_company_collection_type_change BEFORE UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_company_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_company ON company_collection_company;
CREATE TRIGGER trig_userlog_company_collection_company BEFORE INSERT OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_company ON company_collection_company;
CREATE TRIGGER trigger_audit_company_collection_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection_company();
DROP TRIGGER IF EXISTS trigger_company_collection_member_enforce ON company_collection_company;
CREATE CONSTRAINT TRIGGER trigger_company_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_company DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.company_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trig_userlog_company_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trigger_audit_company_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection_hier();
DROP TRIGGER IF EXISTS trigger_company_collection_hier_enforce ON company_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_company_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.company_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_type ON company_type;
CREATE TRIGGER trig_userlog_company_type BEFORE INSERT OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_type ON company_type;
CREATE TRIGGER trigger_audit_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_type();
DROP TRIGGER IF EXISTS aaa_tg_cache_component_parent_handler ON component;
CREATE TRIGGER aaa_tg_cache_component_parent_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_component_parent_handler();
DROP TRIGGER IF EXISTS aab_tg_cache_device_component_component_handler ON component;
CREATE TRIGGER aab_tg_cache_device_component_component_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_device_component_component_handler();
DROP TRIGGER IF EXISTS trig_userlog_component ON component;
CREATE TRIGGER trig_userlog_component BEFORE INSERT OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component ON component;
CREATE TRIGGER trigger_audit_component AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component();
DROP TRIGGER IF EXISTS trigger_create_component_template_slots ON component;
CREATE TRIGGER trigger_create_component_template_slots AFTER INSERT OR UPDATE OF component_type_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.create_component_slots_by_trigger();
DROP TRIGGER IF EXISTS trigger_validate_component_parent_slot_id ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_parent_slot_id AFTER INSERT OR UPDATE OF parent_slot_id, component_type_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_parent_slot_id();
DROP TRIGGER IF EXISTS trigger_validate_component_rack_location ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_rack_location AFTER INSERT OR UPDATE OF rack_location_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_rack_location();
DROP TRIGGER IF EXISTS trigger_zzz_generate_slot_names ON component;
CREATE TRIGGER trigger_zzz_generate_slot_names AFTER INSERT OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.set_slot_names_by_trigger();
DROP TRIGGER IF EXISTS trig_userlog_component_property ON component_property;
CREATE TRIGGER trig_userlog_component_property BEFORE INSERT OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_property ON component_property;
CREATE TRIGGER trigger_audit_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_property();
DROP TRIGGER IF EXISTS trigger_validate_component_property ON component_property;
CREATE CONSTRAINT TRIGGER trigger_validate_component_property AFTER INSERT OR UPDATE ON jazzhands.component_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_property();
DROP TRIGGER IF EXISTS trig_userlog_component_type ON component_type;
CREATE TRIGGER trig_userlog_component_type BEFORE INSERT OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type ON component_type;
CREATE TRIGGER trigger_audit_component_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type();
DROP TRIGGER IF EXISTS trig_userlog_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trig_userlog_component_type_component_function BEFORE INSERT OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trigger_audit_component_type_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type_component_function();
DROP TRIGGER IF EXISTS trig_userlog_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trig_userlog_component_type_slot_template BEFORE INSERT OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trigger_audit_component_type_slot_template AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type_slot_template();
DROP TRIGGER IF EXISTS trig_userlog_contract ON contract;
CREATE TRIGGER trig_userlog_contract BEFORE INSERT OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract ON contract;
CREATE TRIGGER trigger_audit_contract AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_contract();
DROP TRIGGER IF EXISTS trig_userlog_contract_type ON contract_type;
CREATE TRIGGER trig_userlog_contract_type BEFORE INSERT OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract_type ON contract_type;
CREATE TRIGGER trigger_audit_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_department ON department;
CREATE TRIGGER trig_userlog_department BEFORE INSERT OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_department ON department;
CREATE TRIGGER trigger_audit_department AFTER INSERT OR DELETE OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_department();
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_setup_after ON device;
DROP TRIGGER IF EXISTS tg_cache_device_component_device_handler ON device;
CREATE TRIGGER tg_cache_device_component_device_handler AFTER INSERT OR DELETE OR UPDATE OF component_id ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_device_component_device_handler();
DROP TRIGGER IF EXISTS trig_userlog_device ON device;
CREATE TRIGGER trig_userlog_device BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device ON device;
CREATE TRIGGER trigger_audit_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device();
DROP TRIGGER IF EXISTS trigger_create_device_component ON device;
CREATE TRIGGER trigger_create_device_component BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.create_device_component_by_trigger();
DROP TRIGGER IF EXISTS trigger_del_jazzhands_legacy_support ON device;
CREATE TRIGGER trigger_del_jazzhands_legacy_support BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.del_jazzhands_legacy_support();
DROP TRIGGER IF EXISTS trigger_delete_per_device_device_collection ON device;
CREATE TRIGGER trigger_delete_per_device_device_collection BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_device_one_location_validate ON device;
CREATE TRIGGER trigger_device_one_location_validate BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.device_one_location_validate();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_del ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_del BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_ins ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_ins AFTER INSERT ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_upd ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_upd AFTER UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_upd();
DROP TRIGGER IF EXISTS trigger_update_per_device_device_collection ON device;
CREATE TRIGGER trigger_update_per_device_device_collection AFTER INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_validate_device_component_assignment ON device;
CREATE CONSTRAINT TRIGGER trigger_validate_device_component_assignment AFTER INSERT OR UPDATE OF device_type_id, component_id ON jazzhands.device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_device_component_assignment();
DROP TRIGGER IF EXISTS aaa_device_collection_base_handler ON device_collection;
CREATE TRIGGER aaa_device_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.device_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection ON device_collection;
CREATE TRIGGER trig_userlog_device_collection BEFORE INSERT OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection ON device_collection;
CREATE TRIGGER trigger_audit_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_del ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_del BEFORE DELETE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_insup ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_device_collection_type_change ON device_collection;
CREATE TRIGGER trigger_validate_device_collection_type_change BEFORE UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_device_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trig_userlog_device_collection_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trigger_audit_device_collection_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_assigned_certificate();
DROP TRIGGER IF EXISTS zz_trigger_jazzhands_legacy_device_columns_after ON device_collection_device;
DROP TRIGGER IF EXISTS trig_userlog_device_collection_device ON device_collection_device;
CREATE TRIGGER trig_userlog_device_collection_device BEFORE INSERT OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_device ON device_collection_device;
CREATE TRIGGER trigger_audit_device_collection_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_device();
DROP TRIGGER IF EXISTS trigger_device_collection_member_enforce ON device_collection_device;
CREATE CONSTRAINT TRIGGER trigger_device_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_del ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_del BEFORE DELETE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_ins ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_ins AFTER INSERT ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_upd ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_upd AFTER UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_upd();
DROP TRIGGER IF EXISTS trigger_member_device_collection_after_hooks ON device_collection_device;
CREATE TRIGGER trigger_member_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS aaa_device_collection_root_handler ON device_collection_hier;
CREATE TRIGGER aaa_device_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id, child_device_collection_id ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.device_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trig_userlog_device_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trigger_audit_device_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_device_collection_hier_loop ON device_collection_hier;
CREATE TRIGGER trigger_check_device_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_device_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_device_collection_hier_enforce ON device_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_device_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_hier_device_collection_after_hooks ON device_collection_hier;
CREATE TRIGGER trigger_hier_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trig_userlog_device_collection_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trigger_audit_device_collection_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trig_userlog_device_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trigger_audit_device_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trig_userlog_device_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trigger_audit_device_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_device_management_controller ON device_management_controller;
CREATE TRIGGER trig_userlog_device_management_controller BEFORE INSERT OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_management_controller ON device_management_controller;
CREATE TRIGGER trigger_audit_device_management_controller AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_management_controller();
DROP TRIGGER IF EXISTS trig_userlog_device_note ON device_note;
CREATE TRIGGER trig_userlog_device_note BEFORE INSERT OR UPDATE ON jazzhands.device_note FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_note ON device_note;
CREATE TRIGGER trigger_audit_device_note AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_note FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_note();
DROP TRIGGER IF EXISTS trig_userlog_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trig_userlog_device_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trigger_audit_device_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_ticket ON device_ticket;
CREATE TRIGGER trig_userlog_device_ticket BEFORE INSERT OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ticket ON device_ticket;
CREATE TRIGGER trigger_audit_device_ticket AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_ticket();
DROP TRIGGER IF EXISTS trig_userlog_device_type ON device_type;
CREATE TRIGGER trig_userlog_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type ON device_type;
CREATE TRIGGER trigger_audit_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type();
DROP TRIGGER IF EXISTS trigger_device_type_chassis_check ON device_type;
CREATE TRIGGER trigger_device_type_chassis_check BEFORE UPDATE OF is_chassis ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_model_to_name ON device_type;
CREATE TRIGGER trigger_device_type_model_to_name BEFORE INSERT OR UPDATE OF device_type_name, model ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_model_to_name();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module ON device_type_module;
CREATE TRIGGER trig_userlog_device_type_module BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module ON device_type_module;
CREATE TRIGGER trigger_audit_device_type_module AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type_module();
DROP TRIGGER IF EXISTS trigger_device_type_module_chassis_check ON device_type_module;
CREATE TRIGGER trigger_device_type_module_chassis_check BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_module_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_module_sanity_set ON device_type_module;
CREATE TRIGGER trigger_device_type_module_sanity_set BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_module_sanity_set();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trig_userlog_device_type_module_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trigger_audit_device_type_module_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type_module_device_type();
DROP TRIGGER IF EXISTS trig_userlog_dns_change_record ON dns_change_record;
CREATE TRIGGER trig_userlog_dns_change_record BEFORE INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_change_record ON dns_change_record;
CREATE TRIGGER trigger_audit_dns_change_record AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_change_record();
DROP TRIGGER IF EXISTS trigger_dns_change_record_pgnotify ON dns_change_record;
CREATE TRIGGER trigger_dns_change_record_pgnotify AFTER INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.dns_change_record_pgnotify();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trig_userlog_dns_domain_collection BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trigger_audit_dns_domain_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_del ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_del BEFORE DELETE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_insup ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_dns_domain_collection_type_change ON dns_domain_collection;
CREATE TRIGGER trigger_validate_dns_domain_collection_type_change BEFORE UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_dns_domain_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trig_userlog_dns_domain_collection_dns_domain BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trigger_audit_dns_domain_collection_dns_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_member_enforce ON dns_domain_collection_dns_domain;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trig_userlog_dns_domain_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trigger_audit_dns_domain_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection_hier();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_hier_enforce ON dns_domain_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trig_userlog_dns_domain_ip_universe BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trigger_audit_dns_domain_ip_universe AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_ip_universe();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_can_generate ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_can_generate AFTER INSERT OR UPDATE OF should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_ip_universe_can_generate();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_trigger_change ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_trigger_change AFTER INSERT OR UPDATE OF soa_class, soa_ttl, soa_serial, soa_refresh, soa_retry, soa_expire, soa_minimum, soa_mname, soa_rname, should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_ip_universe_trigger_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trig_userlog_dns_record_relation BEFORE INSERT OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trigger_audit_dns_record_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_record_relation();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trig_userlog_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trigger_audit_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trig_userlog_encapsulation_range BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trigger_audit_encapsulation_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_encapsulation_range();
DROP TRIGGER IF EXISTS trig_userlog_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trig_userlog_inter_component_connection BEFORE INSERT OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trigger_audit_inter_component_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_inter_component_connection();
DROP TRIGGER IF EXISTS trigger_validate_inter_component_connection ON inter_component_connection;
CREATE CONSTRAINT TRIGGER trigger_validate_inter_component_connection AFTER INSERT OR UPDATE ON jazzhands.inter_component_connection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_inter_component_connection();
DROP TRIGGER IF EXISTS trig_userlog_ip_universe ON ip_universe;
CREATE TRIGGER trig_userlog_ip_universe BEFORE INSERT OR UPDATE ON jazzhands.ip_universe FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ip_universe ON ip_universe;
CREATE TRIGGER trigger_audit_ip_universe AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ip_universe();
DROP TRIGGER IF EXISTS trig_userlog_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trig_userlog_ip_universe_visibility BEFORE INSERT OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trigger_audit_ip_universe_visibility AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ip_universe_visibility();
DROP TRIGGER IF EXISTS trig_userlog_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trig_userlog_kerberos_realm BEFORE INSERT OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trigger_audit_kerberos_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_kerberos_realm();
DROP TRIGGER IF EXISTS trig_userlog_klogin ON klogin;
CREATE TRIGGER trig_userlog_klogin BEFORE INSERT OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin ON klogin;
CREATE TRIGGER trigger_audit_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_klogin();
DROP TRIGGER IF EXISTS trig_userlog_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trig_userlog_klogin_mclass BEFORE INSERT OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trigger_audit_klogin_mclass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_klogin_mclass();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection ON layer2_connection;
CREATE TRIGGER trig_userlog_layer2_connection BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection ON layer2_connection;
CREATE TRIGGER trigger_audit_layer2_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_connection();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_connection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_connection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_connection_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network ON layer2_network;
CREATE TRIGGER trig_userlog_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network ON layer2_network;
CREATE TRIGGER trigger_audit_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network();
DROP TRIGGER IF EXISTS layer2_net_collection_member_enforce_on_type_change ON layer2_network_collection;
CREATE CONSTRAINT TRIGGER layer2_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trig_userlog_layer2_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trigger_audit_layer2_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_del ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_insup ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer2_network_collection_type_change ON layer2_network_collection;
CREATE TRIGGER trigger_validate_layer2_network_collection_type_change BEFORE UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_layer2_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trig_userlog_layer2_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trigger_audit_layer2_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer2_network_collection_after_hooks ON layer2_network_collection_hier;
CREATE TRIGGER trigger_hier_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_hier_enforce ON layer2_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_network_collection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_network_collection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection_layer2_network();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_member_enforce ON layer2_network_collection_layer2_network;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer2_network_collection_after_hooks ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_member_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface ON layer3_interface;
CREATE TRIGGER trig_userlog_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface ON layer3_interface;
CREATE TRIGGER trigger_audit_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_interface();
DROP TRIGGER IF EXISTS trigger_net_int_device_id_upd ON layer3_interface;
CREATE TRIGGER trigger_net_int_device_id_upd AFTER UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_device_id_upd();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_before ON layer3_interface;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_before BEFORE UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins_before();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network ON layer3_network;
CREATE TRIGGER trig_userlog_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network ON layer3_network;
CREATE TRIGGER trigger_audit_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_validate_netblock ON layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_validate_netblock AFTER INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_network NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_validate_netblock();
DROP TRIGGER IF EXISTS layer3_net_collection_member_enforce_on_type_change ON layer3_network_collection;
CREATE CONSTRAINT TRIGGER layer3_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trig_userlog_layer3_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trigger_audit_layer3_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_del ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_insup ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer3_network_collection_type_change ON layer3_network_collection;
CREATE TRIGGER trigger_validate_layer3_network_collection_type_change BEFORE UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_layer3_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trig_userlog_layer3_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trigger_audit_layer3_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer3_network_collection_after_hooks ON layer3_network_collection_hier;
CREATE TRIGGER trigger_hier_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_hier_enforce ON layer3_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trig_userlog_layer3_network_collection_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_audit_layer3_network_collection_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_member_enforce ON layer3_network_collection_layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer3_network_collection_after_hooks ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_member_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_logical_port ON logical_port;
CREATE TRIGGER trig_userlog_logical_port BEFORE INSERT OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port ON logical_port;
CREATE TRIGGER trigger_audit_logical_port AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_port();
DROP TRIGGER IF EXISTS trig_userlog_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trig_userlog_logical_port_slot BEFORE INSERT OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trigger_audit_logical_port_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_port_slot();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume ON logical_volume;
CREATE TRIGGER trig_userlog_logical_volume BEFORE INSERT OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume ON logical_volume;
CREATE TRIGGER trigger_audit_logical_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trig_userlog_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trigger_audit_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trig_userlog_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trigger_audit_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_mlag_peering ON mlag_peering;
CREATE TRIGGER trig_userlog_mlag_peering BEFORE INSERT OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_mlag_peering ON mlag_peering;
CREATE TRIGGER trigger_audit_mlag_peering AFTER INSERT OR DELETE OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_mlag_peering();
DROP TRIGGER IF EXISTS aaa_ta_manipulate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER aaa_ta_manipulate_netblock_parentage AFTER INSERT OR DELETE ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.manipulate_netblock_parentage_after();
DROP TRIGGER IF EXISTS tb_a_validate_netblock ON netblock;
CREATE TRIGGER tb_a_validate_netblock BEFORE INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock();
DROP TRIGGER IF EXISTS tb_manipulate_netblock_parentage ON netblock;
CREATE TRIGGER tb_manipulate_netblock_parentage BEFORE INSERT OR UPDATE OF ip_address, netblock_type, ip_universe_id, netblock_id, can_subnet, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.manipulate_netblock_parentage_before();
DROP TRIGGER IF EXISTS trig_userlog_netblock ON netblock;
CREATE TRIGGER trig_userlog_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock ON netblock;
CREATE TRIGGER trigger_audit_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock();
DROP TRIGGER IF EXISTS trigger_cache_netblock_hier_truncate ON netblock;
CREATE TRIGGER trigger_cache_netblock_hier_truncate AFTER TRUNCATE ON jazzhands.netblock FOR EACH STATEMENT EXECUTE FUNCTION jazzhands_cache.cache_netblock_hier_truncate_handler();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_netblock AFTER UPDATE OF netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_ip_universe_netblock();
DROP TRIGGER IF EXISTS trigger_nb_dns_a_rec_validation ON netblock;
CREATE TRIGGER trigger_nb_dns_a_rec_validation BEFORE UPDATE OF ip_address, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.nb_dns_a_rec_validation();
DROP TRIGGER IF EXISTS trigger_netblock_single_address_ni ON netblock;
CREATE TRIGGER trigger_netblock_single_address_ni BEFORE UPDATE OF is_single_address, netblock_type ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_single_address_ni();
DROP TRIGGER IF EXISTS trigger_netblock_validate_layer3_network_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_validate_layer3_network_netblock AFTER UPDATE OF can_subnet, is_single_address ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_validate_layer3_network_netblock();
DROP TRIGGER IF EXISTS trigger_validate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_parentage AFTER INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_parentage();
DROP TRIGGER IF EXISTS trigger_validate_netblock_to_range_changes ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_to_range_changes AFTER UPDATE OF ip_address, is_single_address, can_subnet, netblock_type ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_to_range_changes();
DROP TRIGGER IF EXISTS zaa_ta_cache_netblock_hier_handler ON netblock;
CREATE TRIGGER zaa_ta_cache_netblock_hier_handler AFTER INSERT OR DELETE OR UPDATE OF ip_address, parent_netblock_id ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_netblock_hier_handler();
DROP TRIGGER IF EXISTS aaa_netblock_collection_base_handler ON netblock_collection;
CREATE TRIGGER aaa_netblock_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.netblock_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection ON netblock_collection;
CREATE TRIGGER trig_userlog_netblock_collection BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection ON netblock_collection;
CREATE TRIGGER trigger_audit_netblock_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_del ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_del BEFORE DELETE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_insup ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_netblock_collection_type_change ON netblock_collection;
CREATE TRIGGER trigger_validate_netblock_collection_type_change BEFORE UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_collection_type_change();
DROP TRIGGER IF EXISTS aaa_netblock_collection_root_handler ON netblock_collection_hier;
CREATE TRIGGER aaa_netblock_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id, child_netblock_collection_id ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.netblock_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trig_userlog_netblock_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trigger_audit_netblock_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_netblock_collection_hier_loop ON netblock_collection_hier;
CREATE TRIGGER trigger_check_netblock_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_netblock_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_netblock_collection_hier_enforce ON netblock_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trig_userlog_netblock_collection_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trigger_audit_netblock_collection_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection_netblock();
DROP TRIGGER IF EXISTS trigger_netblock_collection_member_enforce ON netblock_collection_netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_network_range ON network_range;
CREATE TRIGGER trig_userlog_network_range BEFORE INSERT OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_network_range ON network_range;
CREATE TRIGGER trigger_audit_network_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_network_range();
DROP TRIGGER IF EXISTS trigger_validate_network_range_dns ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_dns AFTER INSERT OR UPDATE OF dns_domain_id ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_network_range_dns();
DROP TRIGGER IF EXISTS trigger_validate_network_range_ips ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_ips AFTER INSERT OR UPDATE OF start_netblock_id, stop_netblock_id, parent_netblock_id, network_range_type ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_network_range_ips();
DROP TRIGGER IF EXISTS trig_userlog_operating_system ON operating_system;
CREATE TRIGGER trig_userlog_operating_system BEFORE INSERT OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system ON operating_system;
CREATE TRIGGER trigger_audit_operating_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_operating_system();
DROP TRIGGER IF EXISTS trig_userlog_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trig_userlog_operating_system_snapshot BEFORE INSERT OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trigger_audit_operating_system_snapshot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_operating_system_snapshot();
DROP TRIGGER IF EXISTS trig_userlog_person ON person;
CREATE TRIGGER trig_userlog_person BEFORE INSERT OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person ON person;
CREATE TRIGGER trigger_audit_person AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person();
DROP TRIGGER IF EXISTS trig_userlog_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trig_userlog_person_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trigger_audit_person_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trig_userlog_person_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trigger_audit_person_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_person_company ON person_company;
CREATE TRIGGER trig_userlog_person_company BEFORE INSERT OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company ON person_company;
CREATE TRIGGER trigger_audit_person_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company();
DROP TRIGGER IF EXISTS trigger_propagate_person_status_to_account ON person_company;
CREATE TRIGGER trigger_propagate_person_status_to_account AFTER UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.propagate_person_status_to_account();
DROP TRIGGER IF EXISTS trigger_z_automated_ac_on_person_company ON person_company;
CREATE TRIGGER trigger_z_automated_ac_on_person_company AFTER UPDATE OF is_management, is_exempt, is_full_time, person_id, company_id, manager_person_id ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_person_company();
DROP TRIGGER IF EXISTS trig_userlog_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trig_userlog_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_audit_person_company_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company_attribute();
DROP TRIGGER IF EXISTS trigger_validate_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_validate_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_person_company_attribute();
DROP TRIGGER IF EXISTS trig_userlog_person_company_badge ON person_company_badge;
CREATE TRIGGER trig_userlog_person_company_badge BEFORE INSERT OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_badge ON person_company_badge;
CREATE TRIGGER trigger_audit_person_company_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company_badge();
DROP TRIGGER IF EXISTS trig_userlog_person_contact ON person_contact;
CREATE TRIGGER trig_userlog_person_contact BEFORE INSERT OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_contact ON person_contact;
CREATE TRIGGER trigger_audit_person_contact AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_contact();
DROP TRIGGER IF EXISTS trig_userlog_person_image ON person_image;
CREATE TRIGGER trig_userlog_person_image BEFORE INSERT OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image ON person_image;
CREATE TRIGGER trigger_audit_person_image AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_image();
DROP TRIGGER IF EXISTS trigger_fix_person_image_oid_ownership ON person_image;
CREATE TRIGGER trigger_fix_person_image_oid_ownership BEFORE INSERT ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION jazzhands.fix_person_image_oid_ownership();
DROP TRIGGER IF EXISTS trig_userlog_person_image_usage ON person_image_usage;
CREATE TRIGGER trig_userlog_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image_usage ON person_image_usage;
CREATE TRIGGER trigger_audit_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_image_usage();
DROP TRIGGER IF EXISTS trigger_check_person_image_usage_mv ON person_image_usage;
CREATE TRIGGER trigger_check_person_image_usage_mv AFTER INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.check_person_image_usage_mv();
DROP TRIGGER IF EXISTS trig_automated_realm_site_ac_pl ON person_location;
CREATE TRIGGER trig_automated_realm_site_ac_pl AFTER INSERT OR DELETE OR UPDATE OF site_code, person_id ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_realm_site_ac_pl();
DROP TRIGGER IF EXISTS trig_userlog_person_location ON person_location;
CREATE TRIGGER trig_userlog_person_location BEFORE INSERT OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_location ON person_location;
CREATE TRIGGER trigger_audit_person_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_location();
DROP TRIGGER IF EXISTS trig_userlog_person_note ON person_note;
CREATE TRIGGER trig_userlog_person_note BEFORE INSERT OR UPDATE ON jazzhands.person_note FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_note ON person_note;
CREATE TRIGGER trigger_audit_person_note AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_note FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_note();
DROP TRIGGER IF EXISTS trig_userlog_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trig_userlog_person_parking_pass BEFORE INSERT OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trigger_audit_person_parking_pass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_parking_pass();
DROP TRIGGER IF EXISTS trig_userlog_person_vehicle ON person_vehicle;
CREATE TRIGGER trig_userlog_person_vehicle BEFORE INSERT OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_vehicle ON person_vehicle;
CREATE TRIGGER trigger_audit_person_vehicle AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_vehicle();
DROP TRIGGER IF EXISTS trig_userlog_physical_address ON physical_address;
CREATE TRIGGER trig_userlog_physical_address BEFORE INSERT OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_address ON physical_address;
CREATE TRIGGER trigger_audit_physical_address AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physical_address();
DROP TRIGGER IF EXISTS trig_userlog_physical_connection ON physical_connection;
CREATE TRIGGER trig_userlog_physical_connection BEFORE INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_connection ON physical_connection;
CREATE TRIGGER trigger_audit_physical_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physical_connection();
DROP TRIGGER IF EXISTS trigger_verify_physical_connection ON physical_connection;
CREATE TRIGGER trigger_verify_physical_connection AFTER INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.verify_physical_connection();
DROP TRIGGER IF EXISTS trig_userlog_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trig_userlog_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_audit_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physicalish_volume();
DROP TRIGGER IF EXISTS trigger_verify_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_verify_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.verify_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_private_key ON private_key;
CREATE TRIGGER trig_userlog_private_key BEFORE INSERT OR UPDATE ON jazzhands.private_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_private_key ON private_key;
CREATE TRIGGER trigger_audit_private_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.private_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_private_key();
DROP TRIGGER IF EXISTS trigger_pvtkey_ski_signed_validate ON private_key;
CREATE TRIGGER trigger_pvtkey_ski_signed_validate AFTER UPDATE OF subject_key_identifier ON jazzhands.private_key FOR EACH ROW EXECUTE FUNCTION jazzhands.pvtkey_ski_signed_validate();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection ON property_name_collection;
CREATE TRIGGER trig_userlog_property_name_collection BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection ON property_name_collection;
CREATE TRIGGER trigger_audit_property_name_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection();
DROP TRIGGER IF EXISTS trigger_validate_property_name_collection_type_change ON property_name_collection;
CREATE TRIGGER trigger_validate_property_name_collection_type_change BEFORE UPDATE OF property_name_collection_type ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_property_name_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trig_userlog_property_name_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trigger_audit_property_name_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_property_name_collection_after_hooks ON property_name_collection_hier;
CREATE TRIGGER trigger_hier_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_hier_enforce ON property_name_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.property_name_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trig_userlog_property_name_collection_property_name BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trigger_audit_property_name_collection_property_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection_property_name();
DROP TRIGGER IF EXISTS trigger_member_property_name_collection_after_hooks ON property_name_collection_property_name;
CREATE TRIGGER trigger_member_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_member_enforce ON property_name_collection_property_name;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_property_name DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.property_name_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trig_userlog_pseudo_klogin BEFORE INSERT OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trigger_audit_pseudo_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_pseudo_klogin();
DROP TRIGGER IF EXISTS trig_userlog_rack ON rack;
CREATE TRIGGER trig_userlog_rack BEFORE INSERT OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack ON rack;
CREATE TRIGGER trigger_audit_rack AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_rack();
DROP TRIGGER IF EXISTS trig_userlog_rack_location ON rack_location;
CREATE TRIGGER trig_userlog_rack_location BEFORE INSERT OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack_location ON rack_location;
CREATE TRIGGER trigger_audit_rack_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_rack_location();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trig_userlog_service_environment_collection BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trigger_audit_service_environment_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_del ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_del BEFORE DELETE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_insup ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_service_environment_collection_type_change ON service_environment_collection;
CREATE TRIGGER trigger_validate_service_environment_collection_type_change BEFORE UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_service_environment_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trig_userlog_service_environment_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trigger_audit_service_environment_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_svcenv_collection_hier_loop ON service_environment_collection_hier;
CREATE TRIGGER trigger_check_svcenv_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_svcenv_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_hier_enforce ON service_environment_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_service_environment ON service_environment_collection_service_environment;
CREATE TRIGGER trig_userlog_service_environment_collection_service_environment BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_service_environmen ON service_environment_collection_service_environment;
CREATE TRIGGER trigger_audit_service_environment_collection_service_environmen AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection_service_environmen();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_member_enforce ON service_environment_collection_service_environment;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock ON shared_netblock;
CREATE TRIGGER trig_userlog_shared_netblock BEFORE INSERT OR UPDATE ON jazzhands.shared_netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock ON shared_netblock;
CREATE TRIGGER trigger_audit_shared_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.shared_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_shared_netblock();
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trig_userlog_shared_netblock_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trigger_audit_shared_netblock_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_shared_netblock_layer3_interface();
DROP TRIGGER IF EXISTS trig_userlog_site ON site;
CREATE TRIGGER trig_userlog_site BEFORE INSERT OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_site ON site;
CREATE TRIGGER trigger_audit_site AFTER INSERT OR DELETE OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_site();
DROP TRIGGER IF EXISTS trigger_del_site_netblock_collections ON site;
CREATE TRIGGER trigger_del_site_netblock_collections BEFORE DELETE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.del_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_ins_site_netblock_collections ON site;
CREATE TRIGGER trigger_ins_site_netblock_collections AFTER INSERT ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.ins_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_upd_site_netblock_collections ON site;
CREATE TRIGGER trigger_upd_site_netblock_collections AFTER UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.upd_site_netblock_collections();
DROP TRIGGER IF EXISTS trig_userlog_slot ON slot;
CREATE TRIGGER trig_userlog_slot BEFORE INSERT OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot ON slot;
CREATE TRIGGER trigger_audit_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot();
DROP TRIGGER IF EXISTS trig_userlog_slot_type ON slot_type;
CREATE TRIGGER trig_userlog_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type ON slot_type;
CREATE TRIGGER trigger_audit_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_component_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_component_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type_permitted_component_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_remote_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_remote_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type_permitted_remote_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_ssh_key ON ssh_key;
CREATE TRIGGER trig_userlog_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ssh_key ON ssh_key;
CREATE TRIGGER trigger_audit_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trig_userlog_sudo_account_collection_device_collection BEFORE INSERT OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trigger_audit_sudo_account_collection_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_sudo_account_collection_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_sudo_alias ON sudo_alias;
CREATE TRIGGER trig_userlog_sudo_alias BEFORE INSERT OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_alias ON sudo_alias;
CREATE TRIGGER trigger_audit_sudo_alias AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_sudo_alias();
DROP TRIGGER IF EXISTS trig_userlog_sw_package ON sw_package;
CREATE TRIGGER trig_userlog_sw_package BEFORE INSERT OR UPDATE ON jazzhands.sw_package FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sw_package ON sw_package;
CREATE TRIGGER trigger_audit_sw_package AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sw_package FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_sw_package();
DROP TRIGGER IF EXISTS trig_userlog_ticketing_system ON ticketing_system;
CREATE TRIGGER trig_userlog_ticketing_system BEFORE INSERT OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ticketing_system ON ticketing_system;
CREATE TRIGGER trigger_audit_ticketing_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ticketing_system();
DROP TRIGGER IF EXISTS trig_userlog_token ON token;
CREATE TRIGGER trig_userlog_token BEFORE INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token ON token;
CREATE TRIGGER trigger_audit_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_token_change ON token;
CREATE TRIGGER trigger_pgnotify_token_change AFTER INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_token_change();
DROP TRIGGER IF EXISTS trig_userlog_token_collection ON token_collection;
CREATE TRIGGER trig_userlog_token_collection BEFORE INSERT OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection ON token_collection;
CREATE TRIGGER trigger_audit_token_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trig_userlog_token_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trigger_audit_token_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_token_collection_hier_loop ON token_collection_hier;
CREATE TRIGGER trigger_check_token_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_token_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_token_collection_hier_enforce ON token_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_token_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.token_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_token ON token_collection_token;
CREATE TRIGGER trig_userlog_token_collection_token BEFORE INSERT OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_token ON token_collection_token;
CREATE TRIGGER trigger_audit_token_collection_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection_token();
DROP TRIGGER IF EXISTS trigger_token_collection_member_enforce ON token_collection_token;
CREATE CONSTRAINT TRIGGER trigger_token_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_token DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.token_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_unix_group ON unix_group;
CREATE TRIGGER trig_userlog_unix_group BEFORE INSERT OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_unix_group ON unix_group;
CREATE TRIGGER trigger_audit_unix_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_unix_group();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trig_userlog_val_account_collection_relation BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_preserve_direct ON val_account_collection_relation;
CREATE CONSTRAINT TRIGGER trigger_acct_coll_preserve_direct AFTER DELETE OR UPDATE ON jazzhands.val_account_collection_relation DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_preserve_direct();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trigger_audit_val_account_collection_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_collection_relation();
DROP TRIGGER IF EXISTS trig_account_collection_type_realm ON val_account_collection_type;
CREATE TRIGGER trig_account_collection_type_realm AFTER UPDATE OF account_realm_id ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_type_realm();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trig_userlog_val_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_insert_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_insert_direct AFTER INSERT ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_insert_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_remove_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_remove_direct BEFORE DELETE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_remove_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_update_direct_before ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_update_direct_before AFTER UPDATE OF account_collection_type ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_update_direct_before();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trigger_audit_val_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_account_role ON val_account_role;
CREATE TRIGGER trig_userlog_val_account_role BEFORE INSERT OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_role ON val_account_role;
CREATE TRIGGER trigger_audit_val_account_role AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_role();
DROP TRIGGER IF EXISTS trig_userlog_val_account_type ON val_account_type;
CREATE TRIGGER trig_userlog_val_account_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_type ON val_account_type;
CREATE TRIGGER trigger_audit_val_account_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_type();
DROP TRIGGER IF EXISTS trig_userlog_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trig_userlog_val_appaal_group_name BEFORE INSERT OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trigger_audit_val_appaal_group_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_appaal_group_name();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key ON val_application_key;
CREATE TRIGGER trig_userlog_val_application_key BEFORE INSERT OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key ON val_application_key;
CREATE TRIGGER trigger_audit_val_application_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_application_key();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trig_userlog_val_application_key_values BEFORE INSERT OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trigger_audit_val_application_key_values AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_application_key_values();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trig_userlog_val_approval_chain_response_period BEFORE INSERT OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trigger_audit_val_approval_chain_response_period AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_chain_response_period();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trig_userlog_val_approval_expiration_action BEFORE INSERT OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trigger_audit_val_approval_expiration_action AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_expiration_action();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trig_userlog_val_approval_notifty_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trigger_audit_val_approval_notifty_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_notifty_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trig_userlog_val_approval_process_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trigger_audit_val_approval_process_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_process_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_type ON val_approval_type;
CREATE TRIGGER trig_userlog_val_approval_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_type ON val_approval_type;
CREATE TRIGGER trigger_audit_val_approval_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_type();
DROP TRIGGER IF EXISTS trig_userlog_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trig_userlog_val_attestation_frequency BEFORE INSERT OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trigger_audit_val_attestation_frequency AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_attestation_frequency();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trig_userlog_val_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trigger_audit_val_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trig_userlog_val_authentication_resource BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trigger_audit_val_authentication_resource AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_authentication_resource();
DROP TRIGGER IF EXISTS trig_userlog_val_badge_status ON val_badge_status;
CREATE TRIGGER trig_userlog_val_badge_status BEFORE INSERT OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_badge_status ON val_badge_status;
CREATE TRIGGER trigger_audit_val_badge_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_badge_status();
DROP TRIGGER IF EXISTS trig_userlog_val_cable_type ON val_cable_type;
CREATE TRIGGER trig_userlog_val_cable_type BEFORE INSERT OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_cable_type ON val_cable_type;
CREATE TRIGGER trigger_audit_val_cable_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_cable_type();
DROP TRIGGER IF EXISTS trig_userlog_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trig_userlog_val_company_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trigger_audit_val_company_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_del ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_insup ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type ON val_company_type;
CREATE TRIGGER trig_userlog_val_company_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type ON val_company_type;
CREATE TRIGGER trigger_audit_val_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_type();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trig_userlog_val_company_type_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trigger_audit_val_company_type_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_type_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_component_function ON val_component_function;
CREATE TRIGGER trig_userlog_val_component_function BEFORE INSERT OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_function ON val_component_function;
CREATE TRIGGER trigger_audit_val_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_function();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property ON val_component_property;
CREATE TRIGGER trig_userlog_val_component_property BEFORE INSERT OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property ON val_component_property;
CREATE TRIGGER trigger_audit_val_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trig_userlog_val_component_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trigger_audit_val_component_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trig_userlog_val_component_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trigger_audit_val_component_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property_value();
DROP TRIGGER IF EXISTS trig_userlog_val_contract_type ON val_contract_type;
CREATE TRIGGER trig_userlog_val_contract_type BEFORE INSERT OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_contract_type ON val_contract_type;
CREATE TRIGGER trigger_audit_val_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_val_country_code ON val_country_code;
CREATE TRIGGER trig_userlog_val_country_code BEFORE INSERT OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_country_code ON val_country_code;
CREATE TRIGGER trigger_audit_val_country_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_country_code();
DROP TRIGGER IF EXISTS trig_userlog_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trig_userlog_val_device_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trigger_audit_val_device_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_del ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_insup ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_device_management_controller_type ON val_device_management_controller_type;
CREATE TRIGGER trig_userlog_val_device_management_controller_type BEFORE INSERT OR UPDATE ON jazzhands.val_device_management_controller_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_management_controller_type ON val_device_management_controller_type;
CREATE TRIGGER trigger_audit_val_device_management_controller_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_management_controller_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_management_controller_type();
DROP TRIGGER IF EXISTS trig_userlog_val_device_status ON val_device_status;
CREATE TRIGGER trig_userlog_val_device_status BEFORE INSERT OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_status ON val_device_status;
CREATE TRIGGER trigger_audit_val_device_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_status();
DROP TRIGGER IF EXISTS trig_userlog_val_diet ON val_diet;
CREATE TRIGGER trig_userlog_val_diet BEFORE INSERT OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_diet ON val_diet;
CREATE TRIGGER trigger_audit_val_diet AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_diet();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_class ON val_dns_class;
CREATE TRIGGER trig_userlog_val_dns_class BEFORE INSERT OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_class ON val_dns_class;
CREATE TRIGGER trigger_audit_val_dns_class AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_class();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trig_userlog_val_dns_domain_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_audit_val_dns_domain_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_domain_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_del ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_insup ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trig_userlog_val_dns_domain_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trigger_audit_val_dns_domain_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_domain_type();
DROP TRIGGER IF EXISTS trigger_dns_domain_type_should_generate ON val_dns_domain_type;
CREATE TRIGGER trigger_dns_domain_type_should_generate AFTER UPDATE OF can_generate ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_type_should_generate();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trig_userlog_val_dns_record_relation_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trigger_audit_val_dns_record_relation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_record_relation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trig_userlog_val_dns_srv_service BEFORE INSERT OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trigger_audit_val_dns_srv_service AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_srv_service();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_type ON val_dns_type;
CREATE TRIGGER trig_userlog_val_dns_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_type ON val_dns_type;
CREATE TRIGGER trigger_audit_val_dns_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_type();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trig_userlog_val_encapsulation_mode BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trigger_audit_val_encapsulation_mode AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encapsulation_mode();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trig_userlog_val_encapsulation_type BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trigger_audit_val_encapsulation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encapsulation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trig_userlog_val_encryption_key_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trigger_audit_val_encryption_key_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encryption_key_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trig_userlog_val_encryption_method BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trigger_audit_val_encryption_method AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encryption_method();
DROP TRIGGER IF EXISTS trig_userlog_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trig_userlog_val_filesystem_type BEFORE INSERT OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trigger_audit_val_filesystem_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_filesystem_type();
DROP TRIGGER IF EXISTS trig_userlog_val_gender ON val_gender;
CREATE TRIGGER trig_userlog_val_gender BEFORE INSERT OR UPDATE ON jazzhands.val_gender FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_gender ON val_gender;
CREATE TRIGGER trigger_audit_val_gender AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_gender FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_gender();
DROP TRIGGER IF EXISTS trig_userlog_val_image_type ON val_image_type;
CREATE TRIGGER trig_userlog_val_image_type BEFORE INSERT OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_image_type ON val_image_type;
CREATE TRIGGER trigger_audit_val_image_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_image_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trig_userlog_val_ip_namespace BEFORE INSERT OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trigger_audit_val_ip_namespace AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ip_namespace();
DROP TRIGGER IF EXISTS trig_userlog_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trig_userlog_val_iso_currency_code BEFORE INSERT OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trigger_audit_val_iso_currency_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_iso_currency_code();
DROP TRIGGER IF EXISTS trig_userlog_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trig_userlog_val_key_usage_reason_for_assignment BEFORE INSERT OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trigger_audit_val_key_usage_reason_for_assignment AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_key_usage_reason_for_assignment();
DROP TRIGGER IF EXISTS trig_userlog_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer2_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer2_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer2_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_del ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_insup ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer3_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer3_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer3_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_del ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_insup ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trig_userlog_val_logical_port_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trigger_audit_val_logical_port_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_port_type();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trig_userlog_val_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trigger_audit_val_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trig_userlog_val_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trigger_audit_val_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trig_userlog_val_logical_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trigger_audit_val_logical_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trig_userlog_val_netblock_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trigger_audit_val_netblock_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_del ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_insup ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trig_userlog_val_netblock_status BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trigger_audit_val_netblock_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_status();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trig_userlog_val_netblock_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trigger_audit_val_netblock_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trig_userlog_val_network_range_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trigger_audit_val_network_range_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_network_range_type();
DROP TRIGGER IF EXISTS trigger_validate_net_range_toggle_nonoverlap ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_net_range_toggle_nonoverlap AFTER UPDATE OF can_overlap, require_cidr_boundary ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_net_range_toggle_nonoverlap();
DROP TRIGGER IF EXISTS trigger_validate_val_network_range_type ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_val_network_range_type AFTER UPDATE OF dns_domain_required, netblock_type ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_network_range_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trig_userlog_val_network_service_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trigger_audit_val_network_service_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_network_service_type();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trig_userlog_val_operating_system_family BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trigger_audit_val_operating_system_family AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_operating_system_family();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trig_userlog_val_operating_system_snapshot_type BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trigger_audit_val_operating_system_snapshot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_operating_system_snapshot_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trig_userlog_val_ownership_status BEFORE INSERT OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trigger_audit_val_ownership_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ownership_status();
DROP TRIGGER IF EXISTS trig_userlog_val_package_relation_type ON val_package_relation_type;
CREATE TRIGGER trig_userlog_val_package_relation_type BEFORE INSERT OR UPDATE ON jazzhands.val_package_relation_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_package_relation_type ON val_package_relation_type;
CREATE TRIGGER trigger_audit_val_package_relation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_package_relation_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_package_relation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_password_type ON val_password_type;
CREATE TRIGGER trig_userlog_val_password_type BEFORE INSERT OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_password_type ON val_password_type;
CREATE TRIGGER trigger_audit_val_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_password_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trig_userlog_val_person_company_attribute_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trigger_audit_val_person_company_attribute_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trig_userlog_val_person_company_attribute_name BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trigger_audit_val_person_company_attribute_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_name();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trig_userlog_val_person_company_attribute_value BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_audit_val_person_company_attribute_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_value();
DROP TRIGGER IF EXISTS trigger_person_company_attribute_change_after_row_hooks ON val_person_company_attribute_value;
CREATE TRIGGER trigger_person_company_attribute_change_after_row_hooks AFTER INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.person_company_attribute_change_after_row_hooks();
DROP TRIGGER IF EXISTS trigger_validate_pers_comp_attr_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_validate_pers_comp_attr_value BEFORE DELETE OR UPDATE OF person_company_attribute_name, person_company_attribute_value ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_pers_comp_attr_value();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trig_userlog_val_person_company_relation BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trigger_audit_val_person_company_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trig_userlog_val_person_contact_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trigger_audit_val_person_contact_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trig_userlog_val_person_contact_technology BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trigger_audit_val_person_contact_technology AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_technology();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trig_userlog_val_person_contact_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trigger_audit_val_person_contact_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trig_userlog_val_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trigger_audit_val_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_image_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trig_userlog_val_person_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trigger_audit_val_person_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_status ON val_person_status;
CREATE TRIGGER trig_userlog_val_person_status BEFORE INSERT OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_status ON val_person_status;
CREATE TRIGGER trigger_audit_val_person_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_status();
DROP TRIGGER IF EXISTS trig_userlog_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trig_userlog_val_physical_address_type BEFORE INSERT OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trigger_audit_val_physical_address_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_physical_address_type();
DROP TRIGGER IF EXISTS trig_userlog_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trig_userlog_val_physicalish_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trigger_audit_val_physicalish_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_physicalish_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trig_userlog_val_private_key_encryption_type BEFORE INSERT OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trigger_audit_val_private_key_encryption_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_private_key_encryption_type();
DROP TRIGGER IF EXISTS trig_userlog_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trig_userlog_val_processor_architecture BEFORE INSERT OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trigger_audit_val_processor_architecture AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_processor_architecture();
DROP TRIGGER IF EXISTS trig_userlog_val_production_state ON val_production_state;
CREATE TRIGGER trig_userlog_val_production_state BEFORE INSERT OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_production_state ON val_production_state;
CREATE TRIGGER trigger_audit_val_production_state AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_production_state();
DROP TRIGGER IF EXISTS trig_userlog_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trig_userlog_val_property_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trigger_audit_val_property_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trig_userlog_val_property_name_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trigger_audit_val_property_name_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_name_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_type ON val_property_type;
CREATE TRIGGER trig_userlog_val_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_type ON val_property_type;
CREATE TRIGGER trigger_audit_val_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_value ON val_property_value;
CREATE TRIGGER trig_userlog_val_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_value ON val_property_value;
CREATE TRIGGER trigger_audit_val_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_value();
DROP TRIGGER IF EXISTS trigger_val_property_value_del_check ON val_property_value;
CREATE CONSTRAINT TRIGGER trigger_val_property_value_del_check AFTER DELETE ON jazzhands.val_property_value DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.val_property_value_del_check();
DROP TRIGGER IF EXISTS trig_userlog_val_rack_type ON val_rack_type;
CREATE TRIGGER trig_userlog_val_rack_type BEFORE INSERT OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_rack_type ON val_rack_type;
CREATE TRIGGER trigger_audit_val_rack_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_rack_type();
DROP TRIGGER IF EXISTS trig_userlog_val_raid_type ON val_raid_type;
CREATE TRIGGER trig_userlog_val_raid_type BEFORE INSERT OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_raid_type ON val_raid_type;
CREATE TRIGGER trigger_audit_val_raid_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_raid_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trig_userlog_val_service_environment_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trigger_audit_val_service_environment_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_environment_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_del ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_insup ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trig_userlog_val_shared_netblock_protocol BEFORE INSERT OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trigger_audit_val_shared_netblock_protocol AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_shared_netblock_protocol();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_function ON val_slot_function;
CREATE TRIGGER trig_userlog_val_slot_function BEFORE INSERT OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_function ON val_slot_function;
CREATE TRIGGER trigger_audit_val_slot_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_slot_function();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trig_userlog_val_slot_physical_interface BEFORE INSERT OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trigger_audit_val_slot_physical_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_slot_physical_interface();
DROP TRIGGER IF EXISTS trig_userlog_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trig_userlog_val_ssh_key_type BEFORE INSERT OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trigger_audit_val_ssh_key_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ssh_key_type();
DROP TRIGGER IF EXISTS trig_userlog_val_sw_package_type ON val_sw_package_type;
CREATE TRIGGER trig_userlog_val_sw_package_type BEFORE INSERT OR UPDATE ON jazzhands.val_sw_package_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_sw_package_type ON val_sw_package_type;
CREATE TRIGGER trigger_audit_val_sw_package_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_sw_package_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_sw_package_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trig_userlog_val_token_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trigger_audit_val_token_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_status ON val_token_status;
CREATE TRIGGER trig_userlog_val_token_status BEFORE INSERT OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_status ON val_token_status;
CREATE TRIGGER trigger_audit_val_token_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_status();
DROP TRIGGER IF EXISTS trig_userlog_val_token_type ON val_token_type;
CREATE TRIGGER trig_userlog_val_token_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_type ON val_token_type;
CREATE TRIGGER trigger_audit_val_token_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_type();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trig_userlog_val_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trigger_audit_val_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trig_userlog_val_volume_group_relation BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trigger_audit_val_volume_group_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trig_userlog_val_volume_group_type BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trigger_audit_val_volume_group_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trig_userlog_val_x509_certificate_file_format BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trigger_audit_val_x509_certificate_file_format AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_certificate_file_format();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trig_userlog_val_x509_certificate_type BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trigger_audit_val_x509_certificate_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_certificate_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trig_userlog_val_x509_key_usage BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trigger_audit_val_x509_key_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_key_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trig_userlog_val_x509_key_usage_category BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trigger_audit_val_x509_key_usage_category AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_key_usage_category();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trig_userlog_val_x509_revocation_reason BEFORE INSERT OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trigger_audit_val_x509_revocation_reason AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_revocation_reason();
DROP TRIGGER IF EXISTS trig_userlog_volume_group ON volume_group;
CREATE TRIGGER trig_userlog_volume_group BEFORE INSERT OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group ON volume_group;
CREATE TRIGGER trigger_audit_volume_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trig_userlog_volume_group_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trigger_audit_volume_group_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trig_userlog_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trigger_audit_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trig_userlog_x509_key_usage_attribute BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trigger_audit_x509_key_usage_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_attribute();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trig_userlog_x509_key_usage_categorization BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trigger_audit_x509_key_usage_categorization AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_categorization();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trig_userlog_x509_key_usage_default BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trigger_audit_x509_key_usage_default AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_default();
DROP TRIGGER IF EXISTS trig_userlog_x509_signed_certificate ON x509_signed_certificate;
CREATE TRIGGER trig_userlog_x509_signed_certificate BEFORE INSERT OR UPDATE ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_signed_certificate ON x509_signed_certificate;
CREATE TRIGGER trigger_audit_x509_signed_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_signed_certificate();
DROP TRIGGER IF EXISTS trigger_x509_signed_ski_pvtkey_validate ON x509_signed_certificate;
CREATE TRIGGER trigger_x509_signed_ski_pvtkey_validate AFTER INSERT OR UPDATE OF subject_key_identifier, private_key_id ON jazzhands.x509_signed_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.x509_signed_ski_pvtkey_validate();

--
-- BEGIN: Procesing things saved for end
--
SAVEPOINT beforerecreate;

--
-- END: Procesing things saved for end
--

SELECT schema_support.replay_object_recreates(beverbose := true);
SELECT schema_support.replay_saved_grants(beverbose := true);

--
-- BEGIN: Running final cache table sync
SELECT schema_support.synchronize_cache_tables();

--
-- END: Running final cache table sync
SELECT schema_support.reset_all_schema_table_sequences('jazzhands');
SELECT schema_support.reset_all_schema_table_sequences('jazzhands_audit');
GRANT select on all tables in schema jazzhands to ro_role;
GRANT insert,update,delete on all tables in schema jazzhands to iud_role;
GRANT insert,update,delete on all tables in schema jazzhands_legacy to iud_role;
GRANT select on all sequences in schema jazzhands to ro_role;
GRANT usage on all sequences in schema jazzhands to iud_role;
GRANT select on all tables in schema jazzhands_audit to ro_role;
GRANT select on all sequences in schema jazzhands_audit to ro_role;
GRANT select on all tables in schema audit to ro_role;
GRANT select on all sequences in schema audit to ro_role;
SELECT schema_support.end_maintenance();
SAVEPOINT maintend;
select clock_timestamp(), now(), clock_timestamp() - now() AS len;
