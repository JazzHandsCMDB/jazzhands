--
-- Copyright (c) 2021 Todd Kover
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


\pset pager
/*
Invoked:

	--suffix=v92
	--scan
	--post
	post
	--postschema
	property_utils
	--reinsert-dir
	i
	--first=service
	--first=service_version
	--first=service_sla
	--first=service_endpoint
	--first=service_endpoint_provider
	source_repository:source_repository_provider
	source_repository_location:source_repository
	source_repository_url:source_repository_provider_url_template
	service_depend:service_relationship
	service_depend_service_feature:service_relationship_service_feature
	software_artifact_system:software_artifact_provider
	software_artifact_repository_location:software_artifact_repository_uri
	val_source_repository_url_purpose:val_source_repository_uri_purpose
*/

\set ON_ERROR_STOP
SELECT schema_support.begin_maintenance(false);
select clock_timestamp(), now(), clock_timestamp() - now() AS len;
--
-- BEGIN: process_ancillary_schema(schema_support)
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'build_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'build_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.build_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, first_time boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	seqns	TEXT;
	seqname	TEXT;
BEGIN
	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN "aud#seq" SET NOT NULL',
		quote_ident(aud_schema),
		quote_ident(table_name)
	);

	EXECUTE format('ALTER TABLE %s.%s ADD PRIMARY KEY("aud#seq")',
		quote_ident(aud_schema),
		quote_ident(table_name)
	);

	--
	-- If the table name is too long, then the sequence name will
	-- definitely be too long, so need to rename to a unique name.
	--
	IF char_length(table_name) >= 60 THEN
		seqname := lpad(table_name, 46) || lpad(md5(table_name), 10) || '_seq';
	ELSE
		seqname := table_name || '_seq';
	END IF;

	EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN "aud#seq" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME %s.%s )',
		quote_ident(aud_schema), quote_ident(table_name), quote_ident(aud_schema), quote_ident(seqname)
	);


	PERFORM schema_support.rebuild_audit_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('build_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc build_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, finish_rebuild boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
	_seq_ns		TEXT;
	_seq_name	TEXT;
	tmpsn	TEXT;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;


	--
	-- get sequence name before renaming table
	--
	-- this is the same as pg_get_serial_sequence but that
	-- can be weird with special charaters, and also makes
	-- the returnvalue ns.table so they're harder to quote.
	SELECT seq_namespace, seq_name INTO _seq_ns, _seq_name
	FROM
		pg_attribute a
		JOIN pg_class c ON c.oid = a.attrelid
		JOIN pg_namespace n ON n.oid = c.relnamespace
		INNER JOIN (
			SELECT
				refobjid AS attrelid, refobjsubid AS attnum,
				c.oid AS seq_id, c.relname AS seq_name,
				n.oid AS seq_nspid, n.nspname AS seq_namespace,
				deptype
			FROM
				pg_depend d
				JOIN pg_class c ON c.oid = d.objid
				JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE c.relkind = 'S'
		) seq USING (attrelid, attnum)
	WHERE attname = 'aud#seq'
		AND nspname = aud_schema
		AND relname = table_name
		AND NOT a.attisdropped
	ORDER BY a.attnum;

	--
	-- capture sequence number before renaming table
	--
	EXECUTE format('SELECT max("aud#seq") + 1 FROM %s.%s',
		quote_ident(aud_schema), quote_ident(table_name)) INTO seq;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__t' || table_name);

	--
	-- RENAME sequence
	--
	tmpsn := '_old_s' || table_name || '_seq';
	EXECUTE FORMAT('ALTER SEQUENCE %s.%s RENAME TO %s',
		quote_ident(_seq_ns), quote_ident(_seq_name), tmpsn);

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- figure out the new sequence name.  This may be some namel length adjusted
	-- name.  Also, it's possible the old sequence was not an identity column and
	-- this one is.
	--

	--
	-- fix sequence primary key to have the correct next value
	--

	-- this is the same as pg_get_serial_sequence but that
	-- can be weird with special charaters, and also makes
	-- the returnvalue ns.table so they're harder to quote.
	SELECT seq_namespace, seq_name INTO _seq_ns, _seq_name
	FROM pg_attribute a
		JOIN pg_class c ON c.oid = a.attrelid
		JOIN pg_namespace n ON n.oid = c.relnamespace
		INNER JOIN (
			SELECT
				refobjid AS attrelid,
				refobjsubid AS attnum,
				c.oid AS seq_id,
				c.relname AS seq_name,
				n.oid AS seq_nspid,
				n.nspname AS seq_namespace,
				deptype
			FROM pg_depend d
				JOIN pg_class c ON c.oid = d.objid
				JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE c.relkind = 'S'
		) seq USING (attrelid, attnum)
	WHERE attname = 'aud#seq'
		AND nspname = aud_schema
		AND relname = table_name
		AND NOT a.attisdropped
	ORDER BY a.attnum;

	IF seq IS NOT NULL THEN
		EXECUTE format('ALTER SEQUENCE %s.%s RESTART WITH %s',
			quote_ident(_seq_ns), quote_ident(_seq_name), seq);
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'reset_table_sequence');
SELECT schema_support.save_grants_for_replay('schema_support', 'reset_table_sequence');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.reset_table_sequence ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence(schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		SELECT attname AS column, seq_namespace, seq_name,
			nextval(concat_ws('.', quote_ident(seq_namespace), quote_ident(seq_name))) AS nv
		FROM
			pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			INNER JOIN (
				SELECT
					refobjid AS attrelid, refobjsubid AS attnum,
					c.oid AS seq_id, c.relname AS seq_name,
					n.oid AS seq_nspid, n.nspname AS seq_namespace,
					deptype
				FROM
					pg_depend d
					JOIN pg_class c ON c.oid = d.objid
					JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE c.relkind = 'S'
			) seq USING (attrelid, attnum)
		WHERE nspname = reset_table_sequence.schema
		AND relname = reset_table_sequence.table_name
		AND NOT a.attisdropped
	LOOP
		EXECUTE  format('SELECT max(%s)+1 FROM %s.%s',
			quote_ident(_r.column),
			quote_ident(schema),
			quote_ident(table_name)
		) INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE format('ALTER SEQUENCE %s.%s RESTART WITH %s',
				quote_ident(_r.seq_namespace),
				quote_ident(_r.seq_name),
				m
			);
		END IF;
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('reset_table_sequence');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc reset_table_sequence failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.migrate_legacy_serial_to_identity(schema text, relation text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r	RECORD;
	_d	RECORD;
	_s	RECORD;
	_t	INTEGER;
BEGIN
	_t := 0;
	FOR _r IN SELECT attrelid, attname, seq_id, seq_name, deptype
		FROM pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			INNER JOIN (
				SELECT refobjid AS attrelid, refobjsubid AS attnum,
					c.oid AS seq_id, c.relname AS seq_name,
					n.oid AS seq_nspid, n.nspname AS seq_namespace,
					deptype
				FROM
					pg_depend d
					JOIN pg_class c ON c.oid = d.objid
					JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE	c.relkind = 'S'
					AND deptype = 'a'
			) seq USING (attrelid, attnum)
		WHERE	NOT a.attisdropped
			AND nspname = SCHEMA
			AND relname = relation
		ORDER BY
			a.attnum
	LOOP
		EXECUTE format('SELECT s.*, coalesce(pg_sequence_last_value(''%s.%s''), nextval(''%s.%s''))  as lastval  FROM pg_sequence s WHERE seqrelid = %s',
			quote_ident(schema), quote_ident(_r.seq_name),
			quote_ident(schema), quote_ident(_r.seq_name),
			_r.seq_id
		) INTO _s;

		EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN %s DROP DEFAULT',
			quote_ident(schema),
			quote_ident(relation),
			quote_ident(_r.attname));

		EXECUTE format('ALTER SEQUENCE %s.%s OWNED BY NONE',
			quote_ident(schema),
			quote_ident(_r.seq_name));

		EXECUTE format('DROP SEQUENCE %s.%s;',
			quote_ident(schema),
			quote_ident(_r.seq_name));

		EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN %s ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME %s INCREMENT BY %s RESTART WITH %s )',
			quote_ident(schema),
			quote_ident(relation),
			quote_ident(_r.attname),
			quote_ident(_r.seq_name),
			_s.seqincrement, _s.lastval + 1
		);
		_t := _t + 1;
	END LOOP;
	RETURN _t;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.migrate_legacy_serials_to_identities(tbl_schema text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		INTEGER;
	_tally	INTEGER;
	table_list	TEXT;
BEGIN

	_tally := 0;
    FOR table_list IN
		SELECT table_name::text FROM information_schema.tables
		WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
		ORDER BY table_name
    LOOP
		SELECT schema_support.migrate_legacy_serial_to_identity(tbl_schema, table_list) INTO _r;
		_tally := _tally + _r;
    END LOOP;
	RETURN _tally;
END;
$function$
;

-- DONE: process_ancillary_schema(schema_support)
DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'service_manip';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS service_manip;
		CREATE SCHEMA service_manip AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA service_manip IS 'part of jazzhands';
	END IF;
END;
			$$;DO $$
DECLARE
	_tal INTEGER;
BEGIN
	select count(*)
	from pg_catalog.pg_namespace
	into _tal
	where nspname = 'service_utils';
	IF _tal = 0 THEN
		DROP SCHEMA IF EXISTS service_utils;
		CREATE SCHEMA service_utils AUTHORIZATION jazzhands;
		COMMENT ON SCHEMA service_utils IS 'part of jazzhands';
	END IF;
END;
			$$;--
-- Process middle (non-trigger) schema jazzhands_cache
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
--
-- Process middle (non-trigger) schema account_collection_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process middle (non-trigger) schema account_password_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('account_password_manip', 'lock_account_passwords');
DROP FUNCTION IF EXISTS account_password_manip.lock_account_passwords ( integer );
CREATE OR REPLACE FUNCTION account_password_manip.lock_account_passwords(account_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM account_password ap
	WHERE ap.account_Id = lock_account_passwords.account_id
	FOR UPDATE;
END;
$function$
;

--
-- Process middle (non-trigger) schema approval_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
--
-- Process middle (non-trigger) schema audit
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Process middle (non-trigger) schema auto_ac_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process middle (non-trigger) schema backend_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
--
-- Process middle (non-trigger) schema company_manip
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('company_manip', 'add_auto_collections_site');
SELECT schema_support.save_grants_for_replay('company_manip', 'add_auto_collections_site');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS company_manip.add_auto_collections_site ( integer,integer,character varying );
CREATE OR REPLACE FUNCTION company_manip.add_auto_collections_site(company_id integer, account_realm_id integer, site_code character varying)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_ar		account_realm.account_realm_name%TYPE;
	_csn	company.company_short_name%TYPE;
	acname	account_collection.account_collection_name%TYPE;
	acid	account_collection.account_collection_id%TYPE;
	tally	integer;
BEGIN
	PERFORM *
	FROM	account_realm_company arc
	WHERE	arc.company_id = add_auto_collections_site.company_id
	AND		arc.account_realm_id = add_auto_collections_site.account_realm_id;
	IF NOT FOUND THEN
		RAISE EXCEPTION 'Company and Account Realm are not associated together'
			USING ERRCODE = 'not_null_violation';
	END IF;

	acname := concat(_ar, '_', site_code);

	INSERT INTO account_collection (
		account_collection_name, account_collection_type
	) VALUES (
		acname, 'automated'
	) RETURNING account_collection_id INTO acid;

	INSERT INTO property (
		property_name, property_type, account_realm_id,
		account_collection_id,
		site_code
	) VALUES (
		'site', 'auto_acct_coll', add_auto_collections_site.account_realm_id,
		acid,
		add_auto_collections_site.site_code
	);
	tally := tally + 1;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'company_manip' AND type = 'function' AND object IN ('add_auto_collections_site');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_auto_collections_site failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('company_manip', 'add_location');
SELECT schema_support.save_grants_for_replay('company_manip', 'add_location');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS company_manip.add_location ( integer,character varying,integer,integer,character varying,text );
CREATE OR REPLACE FUNCTION company_manip.add_location(company_id integer, site_code character varying, physical_address_id integer, account_realm_id integer DEFAULT NULL::integer, site_status character varying DEFAULT 'ACTIVE'::character varying, description text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
BEGIN
	INSERT INTO site (site_code, colo_company_id,
		physical_address_id, site_status,
		description
	) VALUES (
		add_location.site_code, add_location.company_id,
		add_location.physical_address_id, add_location.site_status,
		add_location.description
	);

	IF add_location.account_realm_id IS NOT NULL THEN
		PERFORM company_manip.add_auto_collections_site(
			company_id 	:= add_location.company_id,
			account_realm_id := add_location.account_realm_id,
			site_code := add_location.site_code
		);
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'company_manip' AND type = 'function' AND object IN ('add_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc add_location failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('company_manip', 'add_location');
DROP FUNCTION IF EXISTS company_manip.add_location ( integer,character varying,integer,integer,character varying,text,boolean );
CREATE OR REPLACE FUNCTION company_manip.add_location(_company_id integer, _site_code character varying, _physical_address_id integer, _account_realm_id integer DEFAULT NULL::integer, _site_status character varying DEFAULT 'ACTIVE'::character varying, _description text DEFAULT NULL::text, will_soon_be_dropped boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM company_manip.add_location(
		company_id := _company_id,
		site_code := _site_code,
		physical_address_id := _physical_address_id,
		account_realm_id := _account_realm_id,
		site_status := _site_status,
		description := _description
	);
END;
$function$
;

--
-- Process middle (non-trigger) schema component_connection_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process middle (non-trigger) schema component_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_manip']);
--
-- Process middle (non-trigger) schema component_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process middle (non-trigger) schema device_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process middle (non-trigger) schema device_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
--
-- Process middle (non-trigger) schema dns_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_manip']);
--
-- Process middle (non-trigger) schema dns_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
--
-- Process middle (non-trigger) schema jazzhands
--
DROP TRIGGER IF EXISTS trigger_service_depend_feature_check ON jazzhands.service_depend_service_feature;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'service_depend_feature_check (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.service_depend_feature_check (  );
DROP TRIGGER IF EXISTS trigger_source_repository_url_endpoint_enforcement ON jazzhands.source_repository_url;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'source_repository_url_endpoint_enforcement (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.source_repository_url_endpoint_enforcement (  );
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
--
-- Process middle (non-trigger) schema layerx_network_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process middle (non-trigger) schema logical_port_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process middle (non-trigger) schema lv_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process middle (non-trigger) schema net_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process middle (non-trigger) schema netblock_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process middle (non-trigger) schema netblock_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process middle (non-trigger) schema network_strings
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process middle (non-trigger) schema obfuscation_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process middle (non-trigger) schema person_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process middle (non-trigger) schema pgcrypto
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process middle (non-trigger) schema physical_address_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process middle (non-trigger) schema port_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process middle (non-trigger) schema rack_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process middle (non-trigger) schema schema_support
--
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'build_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'build_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.build_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.build_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, first_time boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	seqns	TEXT;
	seqname	TEXT;
BEGIN
	EXECUTE 'CREATE TABLE ' || quote_ident(aud_schema) || '.'
		|| quote_ident(table_name) || ' AS '
		|| 'SELECT *, NULL::char(3) as "aud#action", now() as "aud#timestamp", '
		|| 'clock_timestamp() as "aud#realtime", '
		|| 'txid_current() as "aud#txid", '
		|| 'NULL::varchar(255) AS "aud#user", NULL::integer AS "aud#seq" '
		|| 'FROM ' || quote_ident(tbl_schema) || '.' || quote_ident(table_name)
		|| ' LIMIT 0';

	EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN "aud#seq" SET NOT NULL',
		quote_ident(aud_schema),
		quote_ident(table_name)
	);

	EXECUTE format('ALTER TABLE %s.%s ADD PRIMARY KEY("aud#seq")',
		quote_ident(aud_schema),
		quote_ident(table_name)
	);

	--
	-- If the table name is too long, then the sequence name will
	-- definitely be too long, so need to rename to a unique name.
	--
	IF char_length(table_name) >= 60 THEN
		seqname := lpad(table_name, 46) || lpad(md5(table_name), 10) || '_seq';
	ELSE
		seqname := table_name || '_seq';
	END IF;

	EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN "aud#seq" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME %s.%s )',
		quote_ident(aud_schema), quote_ident(table_name), quote_ident(aud_schema), quote_ident(seqname)
	);


	PERFORM schema_support.rebuild_audit_indexes(
		aud_schema, tbl_schema, table_name);

	IF first_time THEN
		PERFORM schema_support.rebuild_audit_trigger
			( aud_schema, tbl_schema, table_name );
	END IF;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('build_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc build_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'rebuild_audit_table');
SELECT schema_support.save_grants_for_replay('schema_support', 'rebuild_audit_table');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.rebuild_audit_table ( character varying,character varying,character varying,boolean );
CREATE OR REPLACE FUNCTION schema_support.rebuild_audit_table(aud_schema character varying, tbl_schema character varying, table_name character varying, finish_rebuild boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	idx		text[];
	keys		text[];
	i		text;
	seq		integer;
	_seq_ns		TEXT;
	_seq_name	TEXT;
	tmpsn	TEXT;
BEGIN
	-- rename all the old indexes and constraints on the old audit table
	SELECT	array_agg(c2.relname)
		INTO	 idx
		  FROM	pg_catalog.pg_index i
			LEFT JOIN pg_catalog.pg_class c
				ON c.oid = i.indrelid
			LEFT JOIN pg_catalog.pg_class c2
				ON i.indexrelid = c2.oid
			LEFT JOIN pg_catalog.pg_namespace n
				ON c2.relnamespace = n.oid
			LEFT JOIN pg_catalog.pg_constraint con
				ON (conrelid = i.indrelid
				AND conindid = i.indexrelid
				AND contype IN ('p','u','x'))
		 WHERE n.nspname = quote_ident(aud_schema)
		  AND	c.relname = quote_ident(table_name)
		  AND	contype is NULL
	;

	SELECT array_agg(con.conname)
	INTO	keys
    FROM pg_catalog.pg_class c
		INNER JOIN pg_namespace n
			ON relnamespace = n.oid
		INNER JOIN pg_catalog.pg_index i
			ON c.oid = i.indrelid
		INNER JOIN pg_catalog.pg_class c2
			ON i.indexrelid = c2.oid
		INNER JOIN pg_catalog.pg_constraint con ON
			(con.conrelid = i.indrelid
			AND con.conindid = i.indexrelid )
	WHERE		n.nspname = quote_ident(aud_schema)
	AND		c.relname = quote_ident(table_name)
	AND con.contype in ('p', 'u')
	;

	IF idx IS NOT NULL THEN
		FOREACH i IN ARRAY idx
		LOOP
			EXECUTE 'ALTER INDEX '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(i)
				|| ' RENAME TO '
				|| quote_ident('_' || i);
		END LOOP;
	END IF;

	IF array_length(keys, 1) > 0 THEN
		FOREACH i IN ARRAY keys
		LOOP
			EXECUTE 'ALTER TABLE '
				|| quote_ident(aud_schema) || '.'
				|| quote_ident(table_name)
				|| ' RENAME CONSTRAINT '
				|| quote_ident(i)
				|| ' TO '
			|| quote_ident('__old__' || i);
		END LOOP;
	END IF;


	--
	-- get sequence name before renaming table
	--
	-- this is the same as pg_get_serial_sequence but that
	-- can be weird with special charaters, and also makes
	-- the returnvalue ns.table so they're harder to quote.
	SELECT seq_namespace, seq_name INTO _seq_ns, _seq_name
	FROM
		pg_attribute a
		JOIN pg_class c ON c.oid = a.attrelid
		JOIN pg_namespace n ON n.oid = c.relnamespace
		INNER JOIN (
			SELECT
				refobjid AS attrelid, refobjsubid AS attnum,
				c.oid AS seq_id, c.relname AS seq_name,
				n.oid AS seq_nspid, n.nspname AS seq_namespace,
				deptype
			FROM
				pg_depend d
				JOIN pg_class c ON c.oid = d.objid
				JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE c.relkind = 'S'
		) seq USING (attrelid, attnum)
	WHERE attname = 'aud#seq'
		AND nspname = aud_schema
		AND relname = table_name
		AND NOT a.attisdropped
	ORDER BY a.attnum;

	--
	-- capture sequence number before renaming table
	--
	EXECUTE format('SELECT max("aud#seq") + 1 FROM %s.%s',
		quote_ident(aud_schema), quote_ident(table_name)) INTO seq;

	--
	-- rename table
	--
	EXECUTE 'ALTER TABLE '
		|| quote_ident(aud_schema) || '.'
		|| quote_ident(table_name)
		|| ' RENAME TO '
		|| quote_ident('__old__t' || table_name);

	--
	-- RENAME sequence
	--
	tmpsn := '_old_s' || table_name || '_seq';
	EXECUTE FORMAT('ALTER SEQUENCE %s.%s RENAME TO %s',
		quote_ident(_seq_ns), quote_ident(_seq_name), tmpsn);

	--
	-- create a new audit table
	--
	PERFORM schema_support.build_audit_table(aud_schema,tbl_schema,table_name);

	--
	-- figure out the new sequence name.  This may be some namel length adjusted
	-- name.  Also, it's possible the old sequence was not an identity column and
	-- this one is.
	--

	--
	-- fix sequence primary key to have the correct next value
	--

	-- this is the same as pg_get_serial_sequence but that
	-- can be weird with special charaters, and also makes
	-- the returnvalue ns.table so they're harder to quote.
	SELECT seq_namespace, seq_name INTO _seq_ns, _seq_name
	FROM pg_attribute a
		JOIN pg_class c ON c.oid = a.attrelid
		JOIN pg_namespace n ON n.oid = c.relnamespace
		INNER JOIN (
			SELECT
				refobjid AS attrelid,
				refobjsubid AS attnum,
				c.oid AS seq_id,
				c.relname AS seq_name,
				n.oid AS seq_nspid,
				n.nspname AS seq_namespace,
				deptype
			FROM pg_depend d
				JOIN pg_class c ON c.oid = d.objid
				JOIN pg_namespace n ON n.oid = c.relnamespace
			WHERE c.relkind = 'S'
		) seq USING (attrelid, attnum)
	WHERE attname = 'aud#seq'
		AND nspname = aud_schema
		AND relname = table_name
		AND NOT a.attisdropped
	ORDER BY a.attnum;

	IF seq IS NOT NULL THEN
		EXECUTE format('ALTER SEQUENCE %s.%s RESTART WITH %s',
			quote_ident(_seq_ns), quote_ident(_seq_name), seq);
	END IF;

	IF finish_rebuild THEN
		EXECUTE schema_support.rebuild_audit_table_finish(aud_schema,tbl_schema,table_name);
	END IF;

	--
	-- recreate audit trigger
	--
	PERFORM schema_support.rebuild_audit_trigger (
		aud_schema, tbl_schema, table_name );

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('rebuild_audit_table');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc rebuild_audit_table failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'reset_table_sequence');
SELECT schema_support.save_grants_for_replay('schema_support', 'reset_table_sequence');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS schema_support.reset_table_sequence ( character varying,character varying );
CREATE OR REPLACE FUNCTION schema_support.reset_table_sequence(schema character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'schema_support'
AS $function$
DECLARE
	_r	RECORD;
	m	BIGINT;
BEGIN
	FOR _r IN
		SELECT attname AS column, seq_namespace, seq_name,
			nextval(concat_ws('.', quote_ident(seq_namespace), quote_ident(seq_name))) AS nv
		FROM
			pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			INNER JOIN (
				SELECT
					refobjid AS attrelid, refobjsubid AS attnum,
					c.oid AS seq_id, c.relname AS seq_name,
					n.oid AS seq_nspid, n.nspname AS seq_namespace,
					deptype
				FROM
					pg_depend d
					JOIN pg_class c ON c.oid = d.objid
					JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE c.relkind = 'S'
			) seq USING (attrelid, attnum)
		WHERE nspname = reset_table_sequence.schema
		AND relname = reset_table_sequence.table_name
		AND NOT a.attisdropped
	LOOP
		EXECUTE  format('SELECT max(%s)+1 FROM %s.%s',
			quote_ident(_r.column),
			quote_ident(schema),
			quote_ident(table_name)
		) INTO m;
		IF m IS NOT NULL THEN
			IF _r.nv > m THEN
				m := _r.nv;
			END IF;
			EXECUTE format('ALTER SEQUENCE %s.%s RESTART WITH %s',
				quote_ident(_r.seq_namespace),
				quote_ident(_r.seq_name),
				m
			);
		END IF;
	END LOOP;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('reset_table_sequence');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc reset_table_sequence failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.migrate_legacy_serial_to_identity(schema text, relation text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r	RECORD;
	_d	RECORD;
	_s	RECORD;
	_t	INTEGER;
BEGIN
	_t := 0;
	FOR _r IN SELECT attrelid, attname, seq_id, seq_name, deptype
		FROM pg_attribute a
			JOIN pg_class c ON c.oid = a.attrelid
			JOIN pg_namespace n ON n.oid = c.relnamespace
			INNER JOIN (
				SELECT refobjid AS attrelid, refobjsubid AS attnum,
					c.oid AS seq_id, c.relname AS seq_name,
					n.oid AS seq_nspid, n.nspname AS seq_namespace,
					deptype
				FROM
					pg_depend d
					JOIN pg_class c ON c.oid = d.objid
					JOIN pg_namespace n ON n.oid = c.relnamespace
				WHERE	c.relkind = 'S'
					AND deptype = 'a'
			) seq USING (attrelid, attnum)
		WHERE	NOT a.attisdropped
			AND nspname = SCHEMA
			AND relname = relation
		ORDER BY
			a.attnum
	LOOP
		EXECUTE format('SELECT s.*, coalesce(pg_sequence_last_value(''%s.%s''), nextval(''%s.%s''))  as lastval  FROM pg_sequence s WHERE seqrelid = %s',
			quote_ident(schema), quote_ident(_r.seq_name),
			quote_ident(schema), quote_ident(_r.seq_name),
			_r.seq_id
		) INTO _s;

		EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN %s DROP DEFAULT',
			quote_ident(schema),
			quote_ident(relation),
			quote_ident(_r.attname));

		EXECUTE format('ALTER SEQUENCE %s.%s OWNED BY NONE',
			quote_ident(schema),
			quote_ident(_r.seq_name));

		EXECUTE format('DROP SEQUENCE %s.%s;',
			quote_ident(schema),
			quote_ident(_r.seq_name));

		EXECUTE format('ALTER TABLE %s.%s ALTER COLUMN %s ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME %s INCREMENT BY %s RESTART WITH %s )',
			quote_ident(schema),
			quote_ident(relation),
			quote_ident(_r.attname),
			quote_ident(_r.seq_name),
			_s.seqincrement, _s.lastval + 1
		);
		_t := _t + 1;
	END LOOP;
	RETURN _t;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION schema_support.migrate_legacy_serials_to_identities(tbl_schema text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
	_r		INTEGER;
	_tally	INTEGER;
	table_list	TEXT;
BEGIN

	_tally := 0;
    FOR table_list IN
		SELECT table_name::text FROM information_schema.tables
		WHERE table_type = 'BASE TABLE' AND table_schema = tbl_schema
		ORDER BY table_name
    LOOP
		SELECT schema_support.migrate_legacy_serial_to_identity(tbl_schema, table_list) INTO _r;
		_tally := _tally + _r;
    END LOOP;
	RETURN _tally;
END;
$function$
;

--
-- Process middle (non-trigger) schema script_hooks
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process middle (non-trigger) schema snapshot_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process middle (non-trigger) schema time_util
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process middle (non-trigger) schema token_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
--
-- Process middle (non-trigger) schema versioning_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_versioning_utils']);
--
-- Process middle (non-trigger) schema jazzhands_legacy
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
--
-- Process middle (non-trigger) schema service_manip
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_service_manip']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('service_manip', 'direct_connect_endpoint_to_device');
DROP FUNCTION IF EXISTS service_manip.direct_connect_endpoint_to_device ( integer,integer,integer,integer,integer,integer,integer );
CREATE OR REPLACE FUNCTION service_manip.direct_connect_endpoint_to_device(device_id integer, service_version_id integer, service_environment_id integer, service_endpoint_id integer DEFAULT NULL::integer, port_range_id integer DEFAULT NULL::integer, dns_record_id integer DEFAULT NULL::integer, service_sla_id integer DEFAULT NULL::integer)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_in_device_id			ALIAS FOR device_id;
	_in_service_endpoint_id	ALIAS FOR service_endpoint_id;
	_in_service_version_id	ALIAS FOR service_version_id;
	_in_port_range_id		ALIAS FOR port_range_id;
	_in_dns_record_id		ALIAS FOR dns_record_id;
	_s		service%ROWTYPE;
	_sv		service_version%ROWTYPE;
	_si		service_instance%ROWTYPE;
	_send		service_endpoint%ROWTYPE;
	_senv		service_endpoint%ROWTYPE;
	_sep	service_endpoint_provider%ROWTYPE;
	_sepc	service_endpoint_provider_collection%ROWTYPE;
BEGIN
	SELECT * INTO _sv
	FROM service_version sv
	WHERE sv.service_version_id = _in_service_version_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Did not find service_version'
			USING ERRCODE = 'foreign_key_violation';
	END IF;
	SELECT * INTO _s
	FROM service s
	WHERE s.service_id = _sv.service_version_id;

	IF _in_service_endpoint_id IS NOT NULL THEN
		SELECT * INTO _send
		FROM service_endpoint se
		WHERE se.service_endpoint_id = _in_service_endpoint_id;


		IF NOT FOUND THEN
			RAISE EXCEPTION 'service_endpoint_id not found'
			USING ERRCODE = 'foreign_key_violation';
		END IF;

		IF _send.service_id != _sv.service_id THEN
			RAISE EXCEPTION 'service of service_endpoint and service_version do not match'
			USING ERRCODE = 'foreign_key_violation',
			HINT = format('%s v %s', _send.service_id, _sv.service_id);
		END IF;
	ELSE
		--- XXX probably need to revisit.
		IF _in_dns_record_id IS NULL THEN
			RAISE EXCEPTION 'Need to set dns_record_id and port_range_id. This may be revisited'
				USING ERRCODE = 'not_null_violation';
		END IF;
		IF _in_port_range_id IS NULL THEN
			RAISE EXCEPTION 'Need to set port_range_id and dns_record_id. This may be revisited'
				USING ERRCODE = 'not_null_violation';
		END IF;

		INSERT INTO service_endpoint (
			service_id, dns_record_id, port_range_id
		) SELECT
			_sv.service_id, dr.dns_record_id, pr.port_range_id
		FROM port_range pr, dns_record dr 
		WHERE pr.port_range_id = _in_port_range_id
		AND dr.dns_record_id = _in_dns_record_id
		RETURNING * INTO _send;
	END IF;

	IF _send IS NULL THEN
		RAISE EXCEPTION '_send is NULL.  This should not happen.';
	END IF;

	INSERT INTO service_endpoint_provider (
		service_endpoint_provider_name, service_endpoint_provider_type,
        dns_record_id
	) SELECT concat(_s.service_name, concat_ws('.', dns_name, dns_domain_name), '-', port_range_name), 'direct',
		dr.dns_record_id
	FROM    dns_record dr JOIN dns_domain dd USING (dns_domain_id),
		port_range pr
	WHERE dr.dns_record_id = _send.dns_record_id
	AND pr.port_range_id = _send.port_range_id
	RETURNING * INTO _sep;

	IF _sep IS NULL THEN
		RAISE EXCEPTION 'Failed to insert into service_endpoint_provider.  This should not happen';
	END IF;

	INSERT INTO service_endpoint_provider_collection (
		service_endpoint_provider_collection_name,
		service_endpoint_provider_collection_type
	) SELECT
		_sep.service_endpoint_provider_name,
		'per-service-endpoint-provider'
	RETURNING * INTO _sepc;

	INSERT INTO service_endpoint_service_endpoint_provider_collection (
		service_endpoint_id, service_endpoint_provider_collection_id,
		service_endpoint_relation_type
	) VALUES (
		_send.service_endpoint_id, _sepc.service_endpoint_provider_collection_id,
		'direct'
	);

	INSERT INTO service_endpoint_provider_collection_service_endpoint_provider(
		service_endpoint_provider_collection_id,
		service_endpoint_provider_id
	) VALUES (
		_sepc.service_endpoint_provider_collection_id,
		_sep.service_endpoint_provider_id
	);

	INSERT INTO service_instance (
		device_id,
		service_version_id, service_environment_id
	) VALUES (
		_in_device_id,
		_sv.service_version_id, service_environment_id
	) RETURNING * INTO _si;

	INSERT INTO service_endpoint_provider_service_instance (
		service_endpoint_provider_id,
		service_instance_id,
		port_range_id
	) VALUES (
		_sep.service_endpoint_provider_id,
		_si.service_instance_id,
		_send.port_range_id
	);

	-- XXX need to handle if one is set and the other is not
	IF service_sla_id IS NOT NULL AND service_environment_id IS NOT NULL
	THEN
		INSERT INTO service_endpoint_service_sla (
			service_endpoint_id, service_sla_id,
			service_environment_id
		) VALUES (
			_send.service_endpoint_id, service_sla_id,
			service_environment_id
		);
	END IF;

	RETURN _si.service_instance_id;
END;
$function$
;

--
-- Process middle (non-trigger) schema service_utils
--
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_service_utils']);
-- New function; dropping in case it returned because of type change
SELECT schema_support.save_grants_for_replay('service_utils', 'build_software_repository_uri');
DROP FUNCTION IF EXISTS service_utils.build_software_repository_uri ( text,text,text );
CREATE OR REPLACE FUNCTION service_utils.build_software_repository_uri(template text, project_name text, repository_name text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_rv	TEXT;
BEGIN
	_rv := template;
	_rv := regexp_replace(_rv, '%{lc_project}', lower(project_name));
	_rv := regexp_replace(_rv, '%{uc_project}', upper(project_name));
	_rv := regexp_replace(_rv, '%{project}', project_name);
	_rv := regexp_replace(_rv, '%{lc_repository}', lower(repository_name));
	_rv := regexp_replace(_rv, '%{uc_repository}', upper(repository_name));
	_rv := regexp_replace(_rv, '%{repository}', repository_name);
	RETURN _rv;
END;
$function$
;

-- Processing tables in main schema...
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service
ALTER TABLE "jazzhands"."service" ALTER COLUMN "service_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_service_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_service_id_seq;
ALTER TABLE "jazzhands"."service" ALTER COLUMN "service_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_service_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_version
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_version', 'service_version');

-- FOREIGN KEYS FROM
ALTER TABLE service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_max_service_version_id;
ALTER TABLE service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_min_service_version_id;
ALTER TABLE service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_service_version_id;
ALTER TABLE service_instance DROP CONSTRAINT IF EXISTS fk_service_instance_svcversionid;
ALTER TABLE service_version_artifact DROP CONSTRAINT IF EXISTS fk_service_version_artifact_service_version_id;
ALTER TABLE service_version_collection_service_version DROP CONSTRAINT IF EXISTS fk_service_version_collection_service_version_version;
ALTER TABLE service_version_software_artifact_repository DROP CONSTRAINT IF EXISTS fk_service_version_software_artifact_repository_svi;
ALTER TABLE service_version_source_repository DROP CONSTRAINT IF EXISTS fk_service_version_source_repository_svi;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_version DROP CONSTRAINT IF EXISTS fk_service_version_service_id;
ALTER TABLE jazzhands.service_version DROP CONSTRAINT IF EXISTS fk_svc_version_service_type;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_version', newobject := 'service_version', newmap := '{"ak_service_version_service_id_version_name":{"columns":["service_id","service_version_name"],"def":"UNIQUE (service_id, service_version_name)","deferrable":false,"deferred":false,"name":"ak_service_version_service_id_version_name","type":"u"},"pk_service_version":{"columns":["service_version_id"],"def":"PRIMARY KEY (service_version_id)","deferrable":false,"deferred":false,"name":"pk_service_version","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_version DROP CONSTRAINT IF EXISTS ak_service_version_service_id_version_name;
ALTER TABLE jazzhands.service_version DROP CONSTRAINT IF EXISTS pk_service_version;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_version_service_id";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_version_service_type";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_version ON jazzhands.service_version;
DROP TRIGGER IF EXISTS trigger_audit_service_version ON jazzhands.service_version;
DROP FUNCTION IF EXISTS perform_audit_service_version();
DROP TRIGGER IF EXISTS trigger_manip_all_svc_collection_members ON jazzhands.service_version;
DROP TRIGGER IF EXISTS trigger_manip_all_svc_collection_members_del ON jazzhands.service_version;
DROP TRIGGER IF EXISTS trigger_propagate_service_type_to_version ON jazzhands.service_version;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_version ALTER COLUMN "service_version_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_version_service_version_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_version_service_version_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_version', tags := ARRAY['table_service_version']);
---- BEGIN jazzhands_audit.service_version TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_version', tags := ARRAY['table_service_version']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_version', 'service_version');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_version');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_version DROP CONSTRAINT IF EXISTS service_version_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_version_ak_service_version_service_id_version_name";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_version_pk_service_version";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_version ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_version_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_version_seq;
---- DONE jazzhands_audit.service_version TEARDOWN


ALTER TABLE service_version RENAME TO service_version_v92;
ALTER TABLE jazzhands_audit.service_version RENAME TO service_version_v92;

CREATE TABLE jazzhands.service_version
(
	service_version_id	integer NOT NULL,
	service_id	integer NOT NULL,
	service_type	varchar(255) NOT NULL,
	service_version_name	varchar(255) NOT NULL,
	is_enabled	boolean NOT NULL,
	is_deprecated	boolean NOT NULL,
	is_synthesized	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version', false);
ALTER TABLE service_version
	ALTER COLUMN service_version_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE service_version
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE service_version
	ALTER is_deprecated
	SET DEFAULT false;
ALTER TABLE service_version
	ALTER is_synthesized
	SET DEFAULT false;


-- BEGIN Manually written insert function

INSERT INTO service_version (
	service_version_id,
	service_id,
	service_type,
	service_version_name,		-- new column (service_version_name)
	is_enabled,
	is_deprecated,
	is_synthesized,		-- new column (is_synthesized)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_version_id,
	service_id,
	service_type,
	version_name,		-- new column (service_version_name)
	is_enabled,
	is_deprecated,
	false,		-- new column (is_synthesized)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_version_v92;


INSERT INTO jazzhands_audit.service_version (
	service_version_id,
	service_id,
	service_type,
	service_version_name,		-- new column (service_version_name)
	is_enabled,
	is_deprecated,
	is_synthesized,		-- new column (is_synthesized)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_version_id,
	service_id,
	service_type,
	version_name,		-- new column (service_version_name)
	is_enabled,
	is_deprecated,
	NULL,		-- new column (is_synthesized)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_version_v92;



-- END Manually written insert function
ALTER TABLE jazzhands.service_version
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_version
	ALTER is_deprecated
	SET DEFAULT false;
ALTER TABLE jazzhands.service_version
	ALTER is_synthesized
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version ADD CONSTRAINT ak_service_version_service_id_version_name UNIQUE (service_id, service_version_name);
ALTER TABLE jazzhands.service_version ADD CONSTRAINT pk_service_version PRIMARY KEY (service_version_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version IS 'Each release of a service has a row here.  There may also be synthesized rows here.';
COMMENT ON COLUMN jazzhands.service_version.service_type IS 'The service type for this version.  This may vary from version to version.';
COMMENT ON COLUMN jazzhands.service_version.is_deprecated IS 'service version is no longer in use or in the process of being turned down';
COMMENT ON COLUMN jazzhands.service_version.is_synthesized IS 'used by subsystems that may need to make up a service version in order to create appropriate linkage.';
-- INDEXES
CREATE INDEX xifservice_version_service_id ON jazzhands.service_version USING btree (service_id);
CREATE INDEX xifsvc_version_service_type ON jazzhands.service_version USING btree (service_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_version and jazzhands.service_instance
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_svcversionid
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_relationship
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_relationship
--	ADD CONSTRAINT fk_service_relationship_related_service_version_id
--	FOREIGN KEY (related_service_version_id) REFERENCES jazzhands.service_version(service_version_id);

-- consider FK between service_version and jazzhands.service_relationship
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_relationship
--	ADD CONSTRAINT fk_service_relationship_service_version_id
--	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id);

-- consider FK between service_version and jazzhands.service_version_artifact
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_service_version_artifact_service_version_id
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_version_collection_service_version
ALTER TABLE jazzhands.service_version_collection_service_version
	ADD CONSTRAINT fk_service_version_collection_service_version_version
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_version_software_artifact_repository
ALTER TABLE jazzhands.service_version_software_artifact_repository
	ADD CONSTRAINT fk_service_version_software_artifact_repository_svi
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK between service_version and jazzhands.service_version_source_repository
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_service_version_source_repository_svi
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service_version and service
ALTER TABLE jazzhands.service_version
	ADD CONSTRAINT fk_service_version_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_version and val_service_type
ALTER TABLE jazzhands.service_version
	ADD CONSTRAINT fk_svc_version_service_type
	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.manip_all_svc_collection_members
CREATE OR REPLACE FUNCTION jazzhands.manip_all_svc_collection_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'all-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'current-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'all-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'current-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);

		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.manip_all_svc_collection_members() FROM public;
CREATE TRIGGER trigger_manip_all_svc_collection_members AFTER INSERT ON jazzhands.service_version FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_all_svc_collection_members();

-- considering NEW jazzhands.manip_all_svc_collection_members
CREATE OR REPLACE FUNCTION jazzhands.manip_all_svc_collection_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'all-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
		INSERT INTO service_version_collection_service_version (
			service_version_collection_id, service_version_id
		) SELECT service_version_collection_id, NEW.service_version_id
		FROM service_version_collection
		WHERE service_version_collection_type = 'current-services'
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = NEW.service_id
		);
	ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'all-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);
		DELETE FROM service_version_collection_service_version
		WHERE service_version_collection_type = 'current-services'
		AND service_version_id = OLD.service_version_id
		AND service_version_collection_name IN (SELECT service_name
			FROM service
			WHERE service_id = OLD.service_id
		);

		RETURN OLD;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.manip_all_svc_collection_members() FROM public;
CREATE TRIGGER trigger_manip_all_svc_collection_members_del BEFORE DELETE ON jazzhands.service_version FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_all_svc_collection_members();

-- considering NEW jazzhands.propagate_service_type_to_version
CREATE OR REPLACE FUNCTION jazzhands.propagate_service_type_to_version()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.service_type IS NULL THEN
		SELECT service_type
		INTO NEW.service_type
		FROM service
		WHERE service_id = NEW.service_id;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.propagate_service_type_to_version() FROM public;
CREATE TRIGGER trigger_propagate_service_type_to_version BEFORE INSERT ON jazzhands.service_version FOR EACH ROW EXECUTE FUNCTION jazzhands.propagate_service_type_to_version();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version');
DROP TABLE IF EXISTS service_version_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_version_v92;
-- DONE DEALING WITH TABLE service_version (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_sla
ALTER TABLE "jazzhands"."service_sla" ALTER COLUMN "service_sla_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_sla_service_sla_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_sla_service_sla_id_seq;
ALTER TABLE "jazzhands"."service_sla" ALTER COLUMN "service_sla_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_sla_service_sla_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_endpoint
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_endpoint', 'service_endpoint');

-- FOREIGN KEYS FROM
ALTER TABLE service_endpoint_health_check DROP CONSTRAINT IF EXISTS fk_service_endpoint_health_check_svc_endpoint_id;
ALTER TABLE service_endpoint_service_sla DROP CONSTRAINT IF EXISTS fk_service_endpoint_service_sla_endpoint_id;
ALTER TABLE service_endpoint_x509_certificate DROP CONSTRAINT IF EXISTS fk_service_endpoint_x509_certificate_seid;
ALTER TABLE source_repository_url DROP CONSTRAINT IF EXISTS fk_svc_endpoint_source_repo_url;
ALTER TABLE service_endpoint_service_endpoint_provider_collection DROP CONSTRAINT IF EXISTS fk_svc_endpoint_svc_endpoint_prov_collection_endpoint_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_endpoint DROP CONSTRAINT IF EXISTS fk_service_endpoint_dns_rec_id;
ALTER TABLE jazzhands.service_endpoint DROP CONSTRAINT IF EXISTS fk_service_endpoint_svc;
ALTER TABLE jazzhands.service_endpoint DROP CONSTRAINT IF EXISTS fk_svc_endpoint_port_range_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_endpoint', newobject := 'service_endpoint', newmap := '{"pk_service_endpoint":{"columns":["service_endpoint_id"],"def":"PRIMARY KEY (service_endpoint_id)","deferrable":false,"deferred":false,"name":"pk_service_endpoint","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint DROP CONSTRAINT IF EXISTS pk_service_endpoint;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_endpoint_dns_rec_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_endpoint_svc";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_endpoint_port_range_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint ON jazzhands.service_endpoint;
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint ON jazzhands.service_endpoint;
DROP FUNCTION IF EXISTS perform_audit_service_endpoint();
DROP TRIGGER IF EXISTS trigger_service_endpoint_direct_check ON jazzhands.service_endpoint;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_endpoint ALTER COLUMN "service_endpoint_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_endpoint_service_endpoint_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_endpoint_service_endpoint_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_endpoint', tags := ARRAY['table_service_endpoint']);
---- BEGIN jazzhands_audit.service_endpoint TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_endpoint', tags := ARRAY['table_service_endpoint']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_endpoint', 'service_endpoint');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_endpoint');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_endpoint DROP CONSTRAINT IF EXISTS service_endpoint_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_endpoint_pk_service_endpoint";
DROP INDEX IF EXISTS "jazzhands_audit"."service_endpoint_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_endpoint_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_endpoint_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_endpoint ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_endpoint_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_endpoint_seq;
---- DONE jazzhands_audit.service_endpoint TEARDOWN


ALTER TABLE service_endpoint RENAME TO service_endpoint_v92;
ALTER TABLE jazzhands_audit.service_endpoint RENAME TO service_endpoint_v92;

CREATE TABLE jazzhands.service_endpoint
(
	service_endpoint_id	integer NOT NULL,
	service_id	integer NOT NULL,
	dns_record_id	integer  NULL,
	port_range_id	integer  NULL,
	service_endpoint_uri_fragment	varchar(512)  NULL,
	description	varchar(4096)  NULL,
	is_synthesized	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_endpoint', false);
ALTER TABLE service_endpoint
	ALTER COLUMN service_endpoint_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE service_endpoint
	ALTER is_synthesized
	SET DEFAULT false;

INSERT INTO service_endpoint (
	service_endpoint_id,
	service_id,
	dns_record_id,
	port_range_id,
	service_endpoint_uri_fragment,		-- new column (service_endpoint_uri_fragment)
	description,
	is_synthesized,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_endpoint_id,
	service_id,
	dns_record_id,
	port_range_id,
	NULL,		-- new column (service_endpoint_uri_fragment)
	description,
	is_synthesized,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_endpoint_v92;


INSERT INTO jazzhands_audit.service_endpoint (
	service_endpoint_id,
	service_id,
	dns_record_id,
	port_range_id,
	service_endpoint_uri_fragment,		-- new column (service_endpoint_uri_fragment)
	description,
	is_synthesized,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_endpoint_id,
	service_id,
	dns_record_id,
	port_range_id,
	NULL,		-- new column (service_endpoint_uri_fragment)
	description,
	is_synthesized,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_endpoint_v92;

ALTER TABLE jazzhands.service_endpoint
	ALTER is_synthesized
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_endpoint ADD CONSTRAINT pk_service_endpoint PRIMARY KEY (service_endpoint_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_endpoint IS 'Models the thing that gets talked to for a service usually a DNS name+port or could be path inside a name+portion a dns name.';
COMMENT ON COLUMN jazzhands.service_endpoint.dns_record_id IS 'For network services, the DNS name that is used to refer to this service endpoint';
COMMENT ON COLUMN jazzhands.service_endpoint.port_range_id IS 'For network services, the port that provides the service';
COMMENT ON COLUMN jazzhands.service_endpoint.service_endpoint_uri_fragment IS 'optinal UI elements that provide the service (inside the dns record)';
COMMENT ON COLUMN jazzhands.service_endpoint.is_synthesized IS 'The service was made up by some subsystem to glue features together (these are typcially not shown to users)';
-- INDEXES
CREATE INDEX xifservice_endpoint_dns_rec_id ON jazzhands.service_endpoint USING btree (dns_record_id);
CREATE INDEX xifservice_endpoint_svc ON jazzhands.service_endpoint USING btree (service_id);
CREATE INDEX xifsvc_endpoint_port_range_id ON jazzhands.service_endpoint USING btree (port_range_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_endpoint and jazzhands.service_endpoint_health_check
ALTER TABLE jazzhands.service_endpoint_health_check
	ADD CONSTRAINT fk_service_endpoint_health_check_svc_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;
-- consider FK between service_endpoint and jazzhands.service_endpoint_service_sla
ALTER TABLE jazzhands.service_endpoint_service_sla
	ADD CONSTRAINT fk_service_endpoint_service_sla_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;
-- consider FK between service_endpoint and jazzhands.service_endpoint_x509_certificate
ALTER TABLE jazzhands.service_endpoint_x509_certificate
	ADD CONSTRAINT fk_service_endpoint_x509_certificate_seid
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;
-- consider FK between service_endpoint and jazzhands.software_artifact_repository_uri
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.software_artifact_repository_uri
--	ADD CONSTRAINT fk_svc_art_repo_uri_svc_endpoint_id
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);

-- consider FK between service_endpoint and jazzhands.source_repository_provider_uri_template
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_provider_uri_template
--	ADD CONSTRAINT fk_svc_endpoint_source_repo_uri
--	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);

-- consider FK between service_endpoint and jazzhands.service_endpoint_service_endpoint_provider_collection
ALTER TABLE jazzhands.service_endpoint_service_endpoint_provider_collection
	ADD CONSTRAINT fk_svc_endpoint_svc_endpoint_prov_collection_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service_endpoint and dns_record
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_service_endpoint_dns_rec_id
	FOREIGN KEY (dns_record_id) REFERENCES jazzhands.dns_record(dns_record_id) DEFERRABLE;
-- consider FK service_endpoint and service
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_service_endpoint_svc
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_endpoint and port_range
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_svc_endpoint_port_range_id
	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_endpoint_direct_check
CREATE OR REPLACE FUNCTION jazzhands.service_endpoint_direct_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.dns_record_id IS NOT NULL OR NEW.port_range_id IS NOT NULL THEN
		SELECT	sep.*
		INTO	_r
		FROM	service_endpoint_service_endpoint_provider_collection
				JOIN service_endpoint_provider_collection
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider_collection_service_endpoint_provider
					USING (service_endpoint_provider_collection_id)
				JOIN service_endpoint_provider sep
					USING (service_endpoint_provider_id)
		WHERE	service_endpoint_id = NEW.service_endpoint_id;

		IF FOUND THEN
			--
			-- It is possible that these don't need to match, but that use
			-- case needs to be thought through, so it is disallowed for now.
			--
			IF _r.service_endpoint_provider_type = 'direct' THEN
				IF _r.dns_record_id IS DISTINCT FROM NEW.dns_record_id THEN
					RAISE EXCEPTION 'dns_record_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
				IF _r.port_range_id IS DISTINCT FROM NEW.port_range_id THEN
					RAISE EXCEPTION 'port_range_id of service_endpoint_provider and service_endpoint must match'
					USING ERRCODE = 'foreign_key_violation',
					HINT = 'This check may be overly agressive but applies only to diret connects';
				END IF;
			END IF;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_endpoint_direct_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_direct_check AFTER INSERT OR UPDATE OF dns_record_id, port_range_id ON jazzhands.service_endpoint NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_endpoint_direct_check();

-- considering NEW jazzhands.validate_service_endpoint_fksets
CREATE OR REPLACE FUNCTION jazzhands.validate_service_endpoint_fksets()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.dns_record_id IS NOT NULL
		OR NEW.port_range_id IS NOT NULL
	THEN
		IF NEW.dns_record_id IS NULL
			OR NEW.port_range_id IS NULL
		THEN
			RAISE EXCEPTION 'both dns_record_id and port_range_id must be set'
				USING ERRCODE = 'not_null_violation';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.validate_service_endpoint_fksets() FROM public;
CREATE CONSTRAINT TRIGGER trigger_validate_service_endpoint_fksets AFTER INSERT OR UPDATE OF dns_record_id, port_range_id ON jazzhands.service_endpoint NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_service_endpoint_fksets();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_endpoint');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_endpoint  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_endpoint');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_endpoint');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_endpoint');
DROP TABLE IF EXISTS service_endpoint_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_endpoint_v92;
-- DONE DEALING WITH TABLE service_endpoint (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_endpoint failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_endpoint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_endpoint failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_provider
ALTER TABLE "jazzhands"."service_endpoint_provider" ALTER COLUMN "service_endpoint_provider_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_endpoint_provider_service_endpoint_provider_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_endpoint_provider_service_endpoint_provider_id_seq;
ALTER TABLE "jazzhands"."service_endpoint_provider" ALTER COLUMN "service_endpoint_provider_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_endpoint_provider_service_endpoint_provider_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE source_repository
-- ... renaming to source_repository_provider (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'source_repository', 'source_repository_provider');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'source_repository', 'source_repository_provider');

-- FOREIGN KEYS FROM
ALTER TABLE source_repository_location DROP CONSTRAINT IF EXISTS fk_src_repo_location_src_repo_id;
ALTER TABLE source_repository_url DROP CONSTRAINT IF EXISTS fk_src_repo_url_src_repo_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.source_repository DROP CONSTRAINT IF EXISTS fk_src_repo_src_repo_method;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'source_repository', newobject := 'source_repository_provider', newmap := '{"ak_source_repository_prov_src_repo_name":{"columns":["source_repository_provider_name"],"def":"UNIQUE (source_repository_provider_name)","deferrable":false,"deferred":false,"name":"ak_source_repository_prov_src_repo_name","type":"u"},"pk_source_repository_provider":{"columns":["source_repository_provider_id"],"def":"PRIMARY KEY (source_repository_provider_id)","deferrable":false,"deferred":false,"name":"pk_source_repository_provider","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository DROP CONSTRAINT IF EXISTS ak_source_repository_src_repo_name;
ALTER TABLE jazzhands.source_repository DROP CONSTRAINT IF EXISTS pk_source_repository;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsrc_repo_src_repo_method";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_source_repository ON jazzhands.source_repository;
DROP TRIGGER IF EXISTS trigger_audit_source_repository ON jazzhands.source_repository;
DROP FUNCTION IF EXISTS perform_audit_source_repository();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.source_repository ALTER COLUMN "source_repository_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.source_repository_source_repository_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.source_repository_source_repository_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'source_repository', tags := ARRAY['table_source_repository_provider']);
---- BEGIN jazzhands_audit.source_repository TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'source_repository', tags := ARRAY['table_source_repository_provider']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'source_repository', 'source_repository_provider');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'source_repository');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.source_repository DROP CONSTRAINT IF EXISTS source_repository_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_source_repository_ak_source_repository_src_repo_name";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_source_repository_pk_source_repository";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.source_repository ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.source_repository_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.source_repository_seq;
---- DONE jazzhands_audit.source_repository TEARDOWN


ALTER TABLE source_repository RENAME TO source_repository_v92;
ALTER TABLE jazzhands_audit.source_repository RENAME TO source_repository_v92;

CREATE TABLE jazzhands.source_repository_provider
(
	source_repository_provider_id	integer NOT NULL,
	source_repository_provider_name	varchar(255) NOT NULL,
	source_repository_method	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_provider', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_provider');
ALTER TABLE source_repository_provider
	ALTER COLUMN source_repository_provider_id
	ADD GENERATED BY DEFAULT AS IDENTITY;


-- BEGIN Manually written insert function

INSERT INTO source_repository_provider (
	source_repository_provider_id,		-- new column (source_repository_provider_id)
	source_repository_provider_name,		-- new column (source_repository_provider_name)
	source_repository_method,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	source_repository_id,		-- new column (source_repository_provider_id)
	source_repository_name,		-- new column (source_repository_provider_name)
	source_repository_method,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM source_repository_v92;


INSERT INTO jazzhands_audit.source_repository_provider (
	source_repository_provider_id,		-- new column (source_repository_provider_id)
	source_repository_provider_name,		-- new column (source_repository_provider_name)
	source_repository_method,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	source_repository_id,		-- new column (source_repository_provider_id)
	source_repository_name,		-- new column (source_repository_provider_name)
	source_repository_method,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.source_repository_v92;



-- END Manually written insert function
-- cleaning up sequences with droppe/renamed table
ALTER SEQUENCE IF EXISTS source_repository_source_repository_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS source_repository_source_repository_id_seq;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_provider ADD CONSTRAINT ak_source_repository_prov_src_repo_name UNIQUE (source_repository_provider_name);
ALTER TABLE jazzhands.source_repository_provider ADD CONSTRAINT pk_source_repository_provider PRIMARY KEY (source_repository_provider_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifsrc_repo_src_repo_method ON jazzhands.source_repository_provider USING btree (source_repository_method);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository_provider and jazzhands.source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository
--	ADD CONSTRAINT fk_src_repo_location_src_repo_id
--	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id) DEFERRABLE;

-- consider FK between source_repository_provider and jazzhands.source_repository_project
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_project
--	ADD CONSTRAINT fk_src_repo_project_provider_id
--	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id);

-- consider FK between source_repository_provider and jazzhands.source_repository_provider_uri_template
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_provider_uri_template
--	ADD CONSTRAINT fk_src_repo_uri_src_repo_id
--	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK source_repository_provider and val_source_repository_method
ALTER TABLE jazzhands.source_repository_provider
	ADD CONSTRAINT fk_src_repo_src_repo_method
	FOREIGN KEY (source_repository_method) REFERENCES jazzhands.val_source_repository_method(source_repository_method) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_provider');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_provider  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_provider');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_provider');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_provider');
DROP TABLE IF EXISTS source_repository_v92;
DROP TABLE IF EXISTS jazzhands_audit.source_repository_v92;
-- DONE DEALING WITH TABLE source_repository_provider (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_provider failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE source_repository_location
-- ... renaming to source_repository (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'source_repository_location', 'source_repository');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'source_repository_location', 'source_repository');

-- FOREIGN KEYS FROM
ALTER TABLE service_source_repository DROP CONSTRAINT IF EXISTS fk_service_source_repo_srcrepoid;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.source_repository_location DROP CONSTRAINT IF EXISTS fk_src_repo_location_purpose;
ALTER TABLE jazzhands.source_repository_location DROP CONSTRAINT IF EXISTS fk_src_repo_location_src_repo_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'source_repository_location', newobject := 'source_repository', newmap := '{"ak_source_repository_project_name":{"columns":["source_repository_project_id","source_repository_name"],"def":"UNIQUE (source_repository_project_id, source_repository_name)","deferrable":false,"deferred":false,"name":"ak_source_repository_project_name","type":"u"},"pk_source_repository":{"columns":["source_repository_id"],"def":"PRIMARY KEY (source_repository_id)","deferrable":false,"deferred":false,"name":"pk_source_repository","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_location DROP CONSTRAINT IF EXISTS pk_source_repository_location;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsrc_repo_location_purpose";
DROP INDEX IF EXISTS "jazzhands"."xifsrc_repo_location_src_repo_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_source_repository_location ON jazzhands.source_repository_location;
DROP TRIGGER IF EXISTS trigger_audit_source_repository_location ON jazzhands.source_repository_location;
DROP FUNCTION IF EXISTS perform_audit_source_repository_location();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.source_repository_location ALTER COLUMN "source_repository_location_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.source_repository_location_source_repository_location_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.source_repository_location_source_repository_location_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'source_repository_location', tags := ARRAY['table_source_repository']);
---- BEGIN jazzhands_audit.source_repository_location TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'source_repository_location', tags := ARRAY['table_source_repository']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'source_repository_location', 'source_repository');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'source_repository_location');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.source_repository_location DROP CONSTRAINT IF EXISTS source_repository_location_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_source_repository_location_pk_source_repository_location";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_location_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_location_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_location_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.source_repository_location ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.source_repository_location_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.source_repository_location_seq;
---- DONE jazzhands_audit.source_repository_location TEARDOWN


ALTER TABLE source_repository_location RENAME TO source_repository_location_v92;
ALTER TABLE jazzhands_audit.source_repository_location RENAME TO source_repository_location_v92;

CREATE TABLE jazzhands.source_repository
(
	source_repository_id	integer NOT NULL,
	source_repository_provider_id	integer NOT NULL,
	source_repository_project_id	integer NOT NULL,
	source_repository_name	varchar(255) NOT NULL,
	source_repository_path_fragment	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository');
ALTER TABLE source_repository
	ALTER COLUMN source_repository_id
	ADD GENERATED BY DEFAULT AS IDENTITY;


-- BEGIN Manually written insert function


INSERT INTO source_repository (
	source_repository_id,
	source_repository_provider_id,		-- new column (source_repository_provider_id)
	source_repository_project_id,		-- new column (source_repository_project_id)
	source_repository_name,		-- new column (source_repository_name)
	source_repository_path_fragment,		-- new column (source_repository_path_fragment)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	source_repository_location_id,
	source_repository_id,		-- new column (source_repository_provider_id)
	NULL,		-- new column (source_repository_project_id)
	NULL,		-- new column (source_repository_name)
	service_source_repository_path,		-- new column (source_repository_path_fragment)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM source_repository_location_v92;


INSERT INTO jazzhands_audit.source_repository (
	source_repository_id,
	source_repository_provider_id,		-- new column (source_repository_provider_id)
	source_repository_project_id,		-- new column (source_repository_project_id)
	source_repository_name,		-- new column (source_repository_name)
	source_repository_path_fragment,		-- new column (source_repository_path_fragment)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	source_repository_location_id,
	source_repository_id,		-- new column (source_repository_provider_id)
	NULL,		-- new column (source_repository_project_id)
	NULL,		-- new column (source_repository_name)
	service_source_repository_path,		-- new column (source_repository_path_fragment)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.source_repository_location_v92;



-- END Manually written insert function
-- cleaning up sequences with droppe/renamed table
ALTER SEQUENCE IF EXISTS source_repository_location_source_repository_location_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS source_repository_location_source_repository_location_id_seq;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository ADD CONSTRAINT ak_source_repository_project_name UNIQUE (source_repository_project_id, source_repository_name);
ALTER TABLE jazzhands.source_repository ADD CONSTRAINT pk_source_repository PRIMARY KEY (source_repository_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.source_repository.source_repository_path_fragment IS 'path inside a repository to find source';
-- INDEXES
CREATE INDEX xifsrc_repo_location_src_repo_id ON jazzhands.source_repository USING btree (source_repository_provider_id);
CREATE INDEX xifsrc_repo_project_id ON jazzhands.source_repository USING btree (source_repository_project_id, source_repository_provider_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository and jazzhands.service_source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_source_repository
--	ADD CONSTRAINT fk_service_source_repo_srcrepoid
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;

-- consider FK between source_repository and jazzhands.source_repository_commit
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_commit
--	ADD CONSTRAINT fk_src_repo_commit_src_repo_id
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id);


-- FOREIGN KEYS TO
-- consider FK source_repository and source_repository_provider
ALTER TABLE jazzhands.source_repository
	ADD CONSTRAINT fk_src_repo_location_src_repo_id
	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id) DEFERRABLE;
-- consider FK source_repository and source_repository_project
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.source_repository
--	ADD CONSTRAINT fk_src_repo_project_id
--	FOREIGN KEY (source_repository_project_id, source_repository_provider_id) REFERENCES jazzhands.source_repository_project(source_repository_project_id, source_repository_provider_id);


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository');
DROP TABLE IF EXISTS source_repository_location_v92;
DROP TABLE IF EXISTS jazzhands_audit.source_repository_location_v92;
-- DONE DEALING WITH TABLE source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_location failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE source_repository_url

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS fk_src_repo_url_src_repo_id;
ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS fk_src_repo_url_url_purpose;
ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS fk_svc_endpoint_source_repo_url;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands',  object := 'source_repository_url');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS pk_source_repository_url;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsrc_repo_url_src_repo_id";
DROP INDEX IF EXISTS "jazzhands"."xifsrc_repo_url_url_purpose";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_endpoint_source_repo_url";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS ckc_valid_url_1827807252;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_source_repository_url ON jazzhands.source_repository_url;
DROP TRIGGER IF EXISTS trigger_audit_source_repository_url ON jazzhands.source_repository_url;
DROP FUNCTION IF EXISTS perform_audit_source_repository_url();
DROP TRIGGER IF EXISTS trigger_source_repository_url_endpoint_enforcement ON jazzhands.source_repository_url;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.source_repository_url ALTER COLUMN "source_repository_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.source_repository_url_source_repository_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.source_repository_url_source_repository_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'source_repository_url', tags := ARRAY['table_source_repository_url']);
---- BEGIN jazzhands_audit.source_repository_url TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'source_repository_url', tags := ARRAY['table_source_repository_url']);

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'source_repository_url');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.source_repository_url DROP CONSTRAINT IF EXISTS source_repository_url_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_source_repository_url_pk_source_repository_url";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_url_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_url_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."source_repository_url_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.source_repository_url ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.source_repository_url_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.source_repository_url_seq;
---- DONE jazzhands_audit.source_repository_url TEARDOWN


ALTER TABLE source_repository_url RENAME TO source_repository_url_v92;
ALTER TABLE jazzhands_audit.source_repository_url RENAME TO source_repository_url_v92;

-- cleaning up sequences with droppe/renamed table
ALTER SEQUENCE IF EXISTS source_repository_url_source_repository_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS source_repository_url_source_repository_id_seq;

DROP TABLE IF EXISTS source_repository_url_v92;
DROP TABLE IF EXISTS jazzhands_audit.source_repository_url_v92;
-- DONE DEALING WITH OLD TABLE source_repository_url (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_url');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_url failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_depend
-- ... renaming to service_relationship (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_depend', 'service_relationship');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_depend', 'service_relationship');

-- FOREIGN KEYS FROM
ALTER TABLE service_layer3_acl DROP CONSTRAINT IF EXISTS fk_service_l3acl_depend_id;
ALTER TABLE service_depend_service_feature DROP CONSTRAINT IF EXISTS fk_svc_depend_service_feature_service_depend_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_max_service_version_id;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_min_service_version_id;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_service_endpoint_provider_id;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_service_id;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_service_sla_id;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS fk_service_depend_service_version_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_depend', newobject := 'service_relationship', newmap := '{"ak_svc_relship_vers_svc_sla":{"columns":["service_relationship_id","service_version_id","service_version_restriction_service_id","service_sla_id"],"def":"UNIQUE (service_version_id, service_version_restriction_service_id, service_relationship_id, service_sla_id)","deferrable":false,"deferred":false,"name":"ak_svc_relship_vers_svc_sla","type":"u"},"pk_service_relationship":{"columns":["service_relationship_id"],"def":"PRIMARY KEY (service_relationship_id)","deferrable":false,"deferred":false,"name":"pk_service_relationship","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS ak_svc_depend_vers_svc_sla;
ALTER TABLE jazzhands.service_depend DROP CONSTRAINT IF EXISTS pk_service_depend;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_max_service_version_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_min_service_version_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_service_endpoint_provider_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_service_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_service_sla_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_depend_service_version_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_depend ON jazzhands.service_depend;
DROP TRIGGER IF EXISTS trigger_audit_service_depend ON jazzhands.service_depend;
DROP FUNCTION IF EXISTS perform_audit_service_depend();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_depend ALTER COLUMN "service_depend_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_depend_service_depend_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_depend_service_depend_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_depend', tags := ARRAY['table_service_relationship']);
---- BEGIN jazzhands_audit.service_depend TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_depend', tags := ARRAY['table_service_relationship']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_depend', 'service_relationship');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_depend');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_depend DROP CONSTRAINT IF EXISTS service_depend_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_depend_ak_svc_depend_vers_svc_sla";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_depend_pk_service_depend";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_depend ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_depend_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_depend_seq;
---- DONE jazzhands_audit.service_depend TEARDOWN


ALTER TABLE service_depend RENAME TO service_depend_v92;
ALTER TABLE jazzhands_audit.service_depend RENAME TO service_depend_v92;

CREATE TABLE jazzhands.service_relationship
(
	service_relationship_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	service_relationship_type	varchar(255)  NULL,
	related_service_version_id	integer  NULL,
	service_version_restriction_service_id	integer  NULL,
	service_version_restriction	varchar(255)  NULL,
	is_calculated	boolean NOT NULL,
	service_sla_id	integer  NULL,
	service_endpoint_provider_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_relationship', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_relationship');
ALTER TABLE service_relationship
	ALTER COLUMN service_relationship_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE service_relationship
	ALTER is_calculated
	SET DEFAULT false;


-- BEGIN Manually written insert function


INSERT INTO service_relationship (
	service_relationship_id,		-- new column (service_relationship_id)
	service_version_id,
	service_version_restriction_service_id,
	service_relationship_type,		-- new column (service_relationship_type)
	related_service_version_id,
	service_sla_id,
	service_endpoint_provider_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_depend_id,		-- new column (service_relationship_id)
	service_version_id,
	service_id,
	'depend',		-- new column (service_relationship_type)
	minimum_service_version_id,
	service_sla_id,
	service_endpoint_provider_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_depend_v92;


INSERT INTO jazzhands_audit.service_relationship (
	service_relationship_id,		-- new column (service_relationship_id)
	service_version_id,
	service_version_restriction_service_id,
	service_relationship_type,		-- new column (service_relationship_type)
	related_service_version_id,
	service_sla_id,
	service_endpoint_provider_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_depend_id,		-- new column (service_relationship_id)
	service_version_id,
	service_id,
	'depend',		-- new column (service_relationship_type)
	minimum_service_version_id,
	service_sla_id,
	service_endpoint_provider_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_depend_v92;



-- END Manually written insert function
-- cleaning up sequences with droppe/renamed table
ALTER SEQUENCE IF EXISTS service_depend_service_depend_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS service_depend_service_depend_id_seq;

ALTER TABLE jazzhands.service_relationship
	ALTER is_calculated
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_relationship ADD CONSTRAINT ak_svc_relship_vers_svc_sla UNIQUE (service_version_id, service_version_restriction_service_id, service_relationship_id, service_sla_id);
ALTER TABLE jazzhands.service_relationship ADD CONSTRAINT pk_service_relationship PRIMARY KEY (service_relationship_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_relationship IS 'Required relationships between services.  These are not explicit mappings, rather indicates of what is required to make things work to be resolved at runtime.';
COMMENT ON COLUMN jazzhands.service_relationship.service_version_id IS 'The dependee';
COMMENT ON COLUMN jazzhands.service_relationship.related_service_version_id IS 'Specific version related version that froms a relationship.  This sets an explicit relationship if needed.  service_id/service_version_restriction sets a fuzzy one.  If set, and service_id is set, they must point to the same service.';
COMMENT ON COLUMN jazzhands.service_relationship.service_version_restriction_service_id IS 'Dependee which is potentially limited by service_version_restriction.   If set, and related_service_version_id is set, they must point to the same service.';
COMMENT ON COLUMN jazzhands.service_relationship.service_version_restriction IS 'Funny version related version that froms a relationship.  This is not enforced but informational.  service_id indicates what service it applies to.';
COMMENT ON COLUMN jazzhands.service_relationship.service_sla_id IS 'Servie Level Agreement required to fufill the dependency (to be fleshed out)';
COMMENT ON COLUMN jazzhands.service_relationship.service_endpoint_provider_id IS 'The service endpoint that manages this dependency (optional)';
-- INDEXES
CREATE INDEX xifservice_relationship_related_service_version_id ON jazzhands.service_relationship USING btree (related_service_version_id);
CREATE INDEX xifservice_relationship_relationship_type ON jazzhands.service_relationship USING btree (service_relationship_type);
CREATE INDEX xifservice_relationship_service_endpoint_provider_id ON jazzhands.service_relationship USING btree (service_endpoint_provider_id);
CREATE INDEX xifservice_relationship_service_id ON jazzhands.service_relationship USING btree (service_version_restriction_service_id);
CREATE INDEX xifservice_relationship_service_sla_id ON jazzhands.service_relationship USING btree (service_sla_id);
CREATE INDEX xifservice_relationship_service_version_id ON jazzhands.service_relationship USING btree (service_version_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_relationship and jazzhands.service_layer3_acl
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_layer3_acl
--	ADD CONSTRAINT fk_service_l3acl_relationship_id
--	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_relationship(service_relationship_id);

-- consider FK between service_relationship and jazzhands.service_relationship_service_feature
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.service_relationship_service_feature
--	ADD CONSTRAINT fk_svc_relationship_service_feature_service_relationship_id
--	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_relationship(service_relationship_id);


-- FOREIGN KEYS TO
-- consider FK service_relationship and service_version
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_related_service_version_id
	FOREIGN KEY (related_service_version_id) REFERENCES jazzhands.service_version(service_version_id);
-- consider FK service_relationship and val_service_relationship_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_relationship
--	ADD CONSTRAINT fk_service_relationship_relationship_type
--	FOREIGN KEY (service_relationship_type) REFERENCES jazzhands.val_service_relationship_type(service_relationship_type);

-- consider FK service_relationship and service_endpoint_provider
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_service_endpoint_provider_id
	FOREIGN KEY (service_endpoint_provider_id) REFERENCES jazzhands.service_endpoint_provider(service_endpoint_provider_id);
-- consider FK service_relationship and service
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_service_id
	FOREIGN KEY (service_version_restriction_service_id) REFERENCES jazzhands.service(service_id);
-- consider FK service_relationship and service_sla
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_service_sla_id
	FOREIGN KEY (service_sla_id) REFERENCES jazzhands.service_sla(service_sla_id);
-- consider FK service_relationship and service_version
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_service_version_id
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id);

-- TRIGGERS
-- considering NEW jazzhands.check_service_relationship_rhs
CREATE OR REPLACE FUNCTION jazzhands.check_service_relationship_rhs()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_t	BOOLEAN;
	_id	INTEGER;
	_re	TEXT;
BEGIN
	IF NEW.service_version_restriction IS NOT NULL THEN
		IF NEW.service_version_restriction_service_id IS NULL THEN
			RAISE EXCEPTION 'If service_version_restriction is set, service_version_restriction_service_id must also be set'
				USING ERRCODE = 'not_null_violation';
		END IF;

		--
		-- Either use the user specified regex or the default one and
		-- check the relationship against it
		--

		SELECT st.service_version_restriction_regular_expression
		INTO _re
		FROM val_service_type st
		JOIN service USING (service_type)
		JOIn service_version USING (service_id)
		WHERE service_version_id = NEW.service_version_id;

		IF _re IS NULL THEN
			_re := '^((<=? [-_\.a-z0-9]+) (>=? [-_\.a-z0-9]+)|(([<>]=?|=) [-_\.a-z0-9]+))$';
		END IF;

		IF NEW.service_version_restriction !~_re THEN
			RAISE EXCEPTION 'restriction must match rules for this service type'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = format('Using regexp %s', _re);
		END IF;
	END IF;

	IF NEW.related_service_version_id IS NOT NULL THEN
		IF NEW.related_service_version_id IS NOT NULL THEN
			SELECT v1.service_id = v2.service_id INTO _t
			FROM service_version v1, service_version v2
			WHERE v1.service_version_id = NEW.service_version_id
			AND v2.service_version_id = NEW.related_service_version_id;
			IF _t THEN
				RAISE EXCEPTION 'service_version_restriction_service_id and '
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
		END IF;
	END IF;

	IF NEW.service_version_restriction_service_id IS NOT NULL THEN
		IF NEW.related_service_version_id IS NOT NULL  THEN
			IF NEW.service_version_restriction IS NULL THEN
				RAISE EXCEPTION 'If service_version_restriction_service_id and related_service_version_id is set, service_version_restriction must also be set'
					USING ERRCODE = 'not_null_violation';
			END IF;

			--
			-- make sure service_version_restriction_service_id points to
			-- the same service as related_service_version_id
			--
			SELECT service_id
			INTO _id
			FROM service_version
			WHERE service_version_id = NEW.related_service_version_id;

			IF _id != NEW.service_version_restriction_service_id THEN
				RAISE EXCEPTION 'service_version_restriction_service_id and related_service_version_id must point to the same services.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
		END IF;

		SELECT service_id
		INTO _id
		FROM service_version
		WHERE service_version_id = NEW.service_version_id;

		IF _id = NEW.service_version_restriction_service_id THEN
			RAISE EXCEPTION 'May not relate to oneself'
					USING ERRCODE = 'invalid_parameter_value';
		END IF;
	ELSE
		IF NEW.related_service_version_id IS NULL THEN
			RAISE EXCEPTION 'One of service_version_restriction_service_id and related_service_version_id must be set.'
				USING ERRCODE = 'not_null_violation';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.check_service_relationship_rhs() FROM public;
CREATE CONSTRAINT TRIGGER trigger_check_service_relationship_rhs AFTER INSERT OR UPDATE OF related_service_version_id, service_version_restriction_service_id, service_version_restriction ON jazzhands.service_relationship NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_service_relationship_rhs();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_relationship');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_relationship  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_relationship');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_relationship');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_relationship');
DROP TABLE IF EXISTS service_depend_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_depend_v92;
-- DONE DEALING WITH TABLE service_relationship (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_depend failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_relationship');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_relationship failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_depend_service_feature
-- ... renaming to service_relationship_service_feature (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_depend_service_feature', 'service_relationship_service_feature');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_depend_service_feature', 'service_relationship_service_feature');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_depend_service_feature DROP CONSTRAINT IF EXISTS fk_svc_depend_service_feature_service_depend_id;
ALTER TABLE jazzhands.service_depend_service_feature DROP CONSTRAINT IF EXISTS fk_svc_depend_service_feature_service_feature;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_depend_service_feature', newobject := 'service_relationship_service_feature', newmap := '{"pk_service_relationship_service_feature":{"columns":["service_relationship_id","service_feature"],"def":"PRIMARY KEY (service_relationship_id, service_feature)","deferrable":false,"deferred":false,"name":"pk_service_relationship_service_feature","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_depend_service_feature DROP CONSTRAINT IF EXISTS pk_service_depend_service_feature;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsvc_depend_service_feature_service_depend_id";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_depend_service_feature_service_feature";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_depend_service_feature ON jazzhands.service_depend_service_feature;
DROP TRIGGER IF EXISTS trigger_audit_service_depend_service_feature ON jazzhands.service_depend_service_feature;
DROP FUNCTION IF EXISTS perform_audit_service_depend_service_feature();
DROP TRIGGER IF EXISTS trigger_service_depend_feature_check ON jazzhands.service_depend_service_feature;
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_depend_service_feature', tags := ARRAY['table_service_relationship_service_feature']);
---- BEGIN jazzhands_audit.service_depend_service_feature TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_depend_service_feature', tags := ARRAY['table_service_relationship_service_feature']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_depend_service_feature', 'service_relationship_service_feature');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_depend_service_feature');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_depend_service_feature DROP CONSTRAINT IF EXISTS service_depend_service_feature_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0service_depend_service_feature_pk_service_depend_service_f";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_service_feature_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_service_feature_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_depend_service_feature_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_depend_service_feature ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_depend_service_feature_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_depend_service_feature_seq;
---- DONE jazzhands_audit.service_depend_service_feature TEARDOWN


ALTER TABLE service_depend_service_feature RENAME TO service_depend_service_feature_v92;
ALTER TABLE jazzhands_audit.service_depend_service_feature RENAME TO service_depend_service_feature_v92;

CREATE TABLE jazzhands.service_relationship_service_feature
(
	service_relationship_id	integer NOT NULL,
	service_feature	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_relationship_service_feature', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_relationship_service_feature');

INSERT INTO service_relationship_service_feature (
	service_relationship_id,		-- new column (service_relationship_id)
	service_feature,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	NULL,		-- new column (service_relationship_id)
	service_feature,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_depend_service_feature_v92;


INSERT INTO jazzhands_audit.service_relationship_service_feature (
	service_relationship_id,		-- new column (service_relationship_id)
	service_feature,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	NULL,		-- new column (service_relationship_id)
	service_feature,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_depend_service_feature_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_relationship_service_feature ADD CONSTRAINT pk_service_relationship_service_feature PRIMARY KEY (service_relationship_id, service_feature);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_relationship_service_feature IS 'Features required for a specific service dependency.';
-- INDEXES
CREATE INDEX xifsvc_relationship_service_feature_service_feature ON jazzhands.service_relationship_service_feature USING btree (service_feature);
CREATE INDEX xifsvc_relationship_service_feature_service_relationship_id ON jazzhands.service_relationship_service_feature USING btree (service_relationship_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_relationship_service_feature and val_service_feature
ALTER TABLE jazzhands.service_relationship_service_feature
	ADD CONSTRAINT fk_svc_relationship_service_feature_service_feature
	FOREIGN KEY (service_feature) REFERENCES jazzhands.val_service_feature(service_feature);
-- consider FK service_relationship_service_feature and service_relationship
ALTER TABLE jazzhands.service_relationship_service_feature
	ADD CONSTRAINT fk_svc_relationship_service_feature_service_relationship_id
	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_relationship(service_relationship_id);

-- TRIGGERS
-- considering NEW jazzhands.service_relationship_feature_check
CREATE OR REPLACE FUNCTION jazzhands.service_relationship_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'UPDATE' AND OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
			USING ERRCODE = 'invalid_paramater',
			HINT = 'This feature is not implemented';
	END IF;

	PERFORM *
	FROM (select service_relationship_id, service_id from service_version) sd
		JOIN service_version USING (service_id)
		JOIN service_instance si USING (service_version_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_id)
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_permitted_feature svcpf
			USING (service_version_collection_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND	sd.service_relationship = NEW.service_relationship_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'service_feature is not offered by any versions of service'
			USING ERRCODE = 'foreign_key_violation',
			HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_relationship_feature_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_relationship_feature_check AFTER INSERT OR UPDATE OF service_feature ON jazzhands.service_relationship_service_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_relationship_feature_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_relationship_service_feature');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_relationship_service_feature  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_relationship_service_feature');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_relationship_service_feature');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_relationship_service_feature');
DROP TABLE IF EXISTS service_depend_service_feature_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_depend_service_feature_v92;
-- DONE DEALING WITH TABLE service_relationship_service_feature (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_depend_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_depend_service_feature failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_relationship_service_feature');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_relationship_service_feature failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE software_artifact_system
-- ... renaming to software_artifact_provider (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'software_artifact_system', 'software_artifact_provider');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'software_artifact_system', 'software_artifact_provider');

-- FOREIGN KEYS FROM
ALTER TABLE software_artifact_repository DROP CONSTRAINT IF EXISTS fk_software_artifact_repository_location_pkg_repo_id;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'software_artifact_system', newobject := 'software_artifact_provider', newmap := '{"ak_sw_artifcate_system_name":{"columns":["software_artifact_provider_name"],"def":"UNIQUE (software_artifact_provider_name)","deferrable":false,"deferred":false,"name":"ak_sw_artifcate_system_name","type":"u"},"pk_software_artifact_system":{"columns":["software_artifact_provider_id"],"def":"PRIMARY KEY (software_artifact_provider_id)","deferrable":false,"deferred":false,"name":"pk_software_artifact_system","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_system DROP CONSTRAINT IF EXISTS ak_sw_artifcate_system_name;
ALTER TABLE jazzhands.software_artifact_system DROP CONSTRAINT IF EXISTS pk_software_artifact_system;
-- INDEXES
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.software_artifact_system DROP CONSTRAINT IF EXISTS ckc_valid_url_2059589952;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_software_artifact_system ON jazzhands.software_artifact_system;
DROP TRIGGER IF EXISTS trigger_audit_software_artifact_system ON jazzhands.software_artifact_system;
DROP FUNCTION IF EXISTS perform_audit_software_artifact_system();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.software_artifact_system ALTER COLUMN "software_artifact_system_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.software_artifact_system_software_artifact_system_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.software_artifact_system_software_artifact_system_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'software_artifact_system', tags := ARRAY['table_software_artifact_provider']);
---- BEGIN jazzhands_audit.software_artifact_system TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'software_artifact_system', tags := ARRAY['table_software_artifact_provider']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'software_artifact_system', 'software_artifact_provider');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'software_artifact_system');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.software_artifact_system DROP CONSTRAINT IF EXISTS software_artifact_system_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_software_artifact_system_ak_sw_artifcate_system_name";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_software_artifact_system_pk_software_artifact_system";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_system_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_system_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_system_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.software_artifact_system ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.software_artifact_system_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.software_artifact_system_seq;
---- DONE jazzhands_audit.software_artifact_system TEARDOWN


ALTER TABLE software_artifact_system RENAME TO software_artifact_system_v92;
ALTER TABLE jazzhands_audit.software_artifact_system RENAME TO software_artifact_system_v92;

CREATE TABLE jazzhands.software_artifact_provider
(
	software_artifact_provider_id	integer NOT NULL,
	software_artifact_provider_name	varchar(255) NOT NULL,
	software_artifact_provider_uri	varchar(512) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_provider', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_provider');
ALTER TABLE software_artifact_provider
	ALTER COLUMN software_artifact_provider_id
	ADD GENERATED BY DEFAULT AS IDENTITY;


-- BEGIN Manually written insert function
INSERT INTO software_artifact_provider (
        software_artifact_provider_id,          -- new column (software_artifact_provider_id)
        software_artifact_provider_name,                -- new column (software_artifact_provider_name)
        software_artifact_provider_uri,           -- new column (software_artifact_system_uri)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        software_artifact_system_id,            -- new column (software_artifact_provider_id)
        software_artifact_system_name,           -- new column (software_artifact_provider_name)
        software_artifact_system_url,           -- new column (software_artifact_system_uri)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM software_artifact_system_v92;


INSERT INTO jazzhands_audit.software_artifact_provider (
        software_artifact_provider_id,          -- new column (software_artifact_provider_id)
        software_artifact_provider_name,                -- new column (software_artifact_provider_name)
        software_artifact_provider_uri,           -- new column (software_artifact_system_uri)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        software_artifact_system_id,            -- new column (software_artifact_provider_id)
        software_artifact_system_name,           -- new column (software_artifact_provider_name)
        software_artifact_system_url,           -- new column (software_artifact_system_uri)
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.software_artifact_system_v92;


-- END Manually written insert function
-- cleaning up sequences with droppe/renamed table
ALTER SEQUENCE IF EXISTS software_artifact_system_software_artifact_system_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS software_artifact_system_software_artifact_system_id_seq;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_provider ADD CONSTRAINT ak_sw_artifcate_system_name UNIQUE (software_artifact_provider_name);
ALTER TABLE jazzhands.software_artifact_provider ADD CONSTRAINT pk_software_artifact_system PRIMARY KEY (software_artifact_provider_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_provider IS 'Systems that contain repositories that are used to provide artifacts';
-- INDEXES

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.software_artifact_provider ADD CONSTRAINT ckc_valid_uri_188419722
	CHECK (((software_artifact_provider_uri)::text ~ '^([a-z][-_a-z0-9]*)://[^\s/$.?#].[^\s]*$'::text));

-- FOREIGN KEYS FROM
-- consider FK between software_artifact_provider and jazzhands.software_artifact_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.software_artifact_repository
--	ADD CONSTRAINT fk_sw_artifact_repository_provider_id
--	FOREIGN KEY (software_artifact_provider_id) REFERENCES jazzhands.software_artifact_provider(software_artifact_provider_id);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_provider');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_provider  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_provider');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_provider');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_provider');
DROP TABLE IF EXISTS software_artifact_system_v92;
DROP TABLE IF EXISTS jazzhands_audit.software_artifact_system_v92;
-- DONE DEALING WITH TABLE software_artifact_provider (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_system');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_system failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_provider');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_provider failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE software_artifact_repository_location
-- ... renaming to software_artifact_repository_uri (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'software_artifact_repository_location', 'software_artifact_repository_uri');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'software_artifact_repository_location', 'software_artifact_repository_uri');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.software_artifact_repository_location DROP CONSTRAINT IF EXISTS fk_software_artifact_repo_loc_sw_art_repo_id;
ALTER TABLE jazzhands.software_artifact_repository_location DROP CONSTRAINT IF EXISTS fk_software_artifact_repo_location_se_col_id;
ALTER TABLE jazzhands.software_artifact_repository_location DROP CONSTRAINT IF EXISTS fk_sw_artifact_repo_loc_sw_artifact_type;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'software_artifact_repository_location', newobject := 'software_artifact_repository_uri', newmap := '{"pk_software_artifact_repository_uri":{"columns":["software_artifact_repository_id","software_artifact_repository_uri_type"],"def":"PRIMARY KEY (software_artifact_repository_id, software_artifact_repository_uri_type)","deferrable":false,"deferred":false,"name":"pk_software_artifact_repository_uri","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository_location DROP CONSTRAINT IF EXISTS pk_software_artifact_repository_location;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsoftware_artifact_repo_loc_sw_art_repo_id";
DROP INDEX IF EXISTS "jazzhands"."xifsoftware_artifact_repo_location_se_col_id";
DROP INDEX IF EXISTS "jazzhands"."xifsw_artifact_repo_loc_sw_artifact_type";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_software_artifact_repository_location ON jazzhands.software_artifact_repository_location;
DROP TRIGGER IF EXISTS trigger_audit_software_artifact_repository_location ON jazzhands.software_artifact_repository_location;
DROP FUNCTION IF EXISTS perform_audit_software_artifact_repository_location();
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'software_artifact_repository_location', tags := ARRAY['table_software_artifact_repository_uri']);
---- BEGIN jazzhands_audit.software_artifact_repository_location TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'software_artifact_repository_location', tags := ARRAY['table_software_artifact_repository_uri']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'software_artifact_repository_location', 'software_artifact_repository_uri');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'software_artifact_repository_location');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.software_artifact_repository_location DROP CONSTRAINT IF EXISTS software_artifact_repository_location_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0software_artifact_repository_location_pk_software_artifact";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_location_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_location_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_location_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.software_artifact_repository_location ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.software_artifact_repository_location_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.software_artifact_repository_location_seq;
---- DONE jazzhands_audit.software_artifact_repository_location TEARDOWN


ALTER TABLE software_artifact_repository_location RENAME TO software_artifact_repository_location_v92;
ALTER TABLE jazzhands_audit.software_artifact_repository_location RENAME TO software_artifact_repository_location_v92;

CREATE TABLE jazzhands.software_artifact_repository_uri
(
	software_artifact_repository_id	integer NOT NULL,
	software_artifact_repository_uri_type	varchar(50) NOT NULL,
	software_artifact_type	varchar(50) NOT NULL,
	software_artifact_repository_uri	varchar(255) NOT NULL,
	service_endpoint_id	integer  NULL,
	service_environment_collection_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_repository_uri', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository_uri');


-- BEGIN Manually written insert function
INSERT INTO software_artifact_repository_uri (
        software_artifact_repository_id,
        software_artifact_repository_uri_type,
        software_artifact_type,
        software_artifact_repository_uri,
        service_endpoint_id,            -- new column (service_endpoint_id)
        service_environment_collection_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        software_artifact_repository_id,
        software_artifact_repository_location_type,
        software_artifact_type,
        repository_uri,
        NULL,           -- new column (service_endpoint_id)
        service_environment_collection_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM software_artifact_repository_location_v92;


INSERT INTO jazzhands_audit.software_artifact_repository_uri (
        software_artifact_repository_id,
        software_artifact_repository_uri_type,
        software_artifact_type,
        software_artifact_repository_uri,
        service_endpoint_id,            -- new column (service_endpoint_id)
        service_environment_collection_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        software_artifact_repository_id,
        software_artifact_repository_location_type,
        software_artifact_type,
        repository_uri,
        NULL,           -- new column (service_endpoint_id)
        service_environment_collection_id,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.software_artifact_repository_location_v92;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository_uri ADD CONSTRAINT pk_software_artifact_repository_uri PRIMARY KEY (software_artifact_repository_id, software_artifact_repository_uri_type);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_repository_uri IS 'Locations inside artifact repositories.  This may go away or merge into software_artifact_repository.';
COMMENT ON COLUMN jazzhands.software_artifact_repository_uri.software_artifact_repository_uri IS 'Only one of software_artifact_repository_uri or service_endpoint_id can be set and software_artifact_repository_uri will likely go away.';
COMMENT ON COLUMN jazzhands.software_artifact_repository_uri.service_endpoint_id IS 'Only one of software_artifact_repository_uri or service_endpoint_id can be set and software_artifact_repository_uri will likely go away.';
COMMENT ON COLUMN jazzhands.software_artifact_repository_uri.service_environment_collection_id IS 'indicates which environments are permitted to use this uri.';
-- INDEXES
CREATE INDEX xifsoftware_artifact_repo_loc_sw_art_repo_id ON jazzhands.software_artifact_repository_uri USING btree (software_artifact_repository_id);
CREATE INDEX xifsoftware_artifact_repo_location_se_col_id ON jazzhands.software_artifact_repository_uri USING btree (service_environment_collection_id);
CREATE INDEX xifsvc_art_repo_uri_svc_endpoint_id ON jazzhands.software_artifact_repository_uri USING btree (service_endpoint_id);
CREATE INDEX xifsw_artifact_repo_loc_sw_artifact_type ON jazzhands.software_artifact_repository_uri USING btree (software_artifact_type);
CREATE INDEX xifsw_artifact_repo_url_repo_type ON jazzhands.software_artifact_repository_uri USING btree (software_artifact_repository_uri_type);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK software_artifact_repository_uri and software_artifact_repository
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_software_artifact_repo_loc_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK software_artifact_repository_uri and service_environment_collection
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_software_artifact_repo_location_se_col_id
	FOREIGN KEY (service_environment_collection_id) REFERENCES jazzhands.service_environment_collection(service_environment_collection_id) DEFERRABLE;
-- consider FK software_artifact_repository_uri and service_endpoint
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_svc_art_repo_uri_svc_endpoint_id
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);
-- consider FK software_artifact_repository_uri and val_software_artifact_type
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_sw_artifact_repo_loc_sw_artifact_type
	FOREIGN KEY (software_artifact_type) REFERENCES jazzhands.val_software_artifact_type(software_artifact_type) DEFERRABLE;
-- consider FK software_artifact_repository_uri and val_software_artifact_repository_uri_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.software_artifact_repository_uri
--	ADD CONSTRAINT fk_sw_artifact_repo_url_repo_type
--	FOREIGN KEY (software_artifact_repository_uri_type) REFERENCES jazzhands.val_software_artifact_repository_uri_type(software_artifact_repository_uri_type);


-- TRIGGERS
-- considering NEW jazzhands.software_artifact_repository_uri_endpoint_enforce
CREATE OR REPLACE FUNCTION jazzhands.software_artifact_repository_uri_endpoint_enforce()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.software_artifact_repository_uri IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either software_artifact_repository_uri or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.software_artifact_repository_uri IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of software_artifact_repository_uri or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.software_artifact_repository_uri_endpoint_enforce() FROM public;
CREATE CONSTRAINT TRIGGER trigger_software_artifact_repository_uri_endpoint_enforce AFTER INSERT OR UPDATE OF software_artifact_repository_uri, service_endpoint_id ON jazzhands.software_artifact_repository_uri NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.software_artifact_repository_uri_endpoint_enforce();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_repository_uri');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_repository_uri  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_repository_uri');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_repository_uri');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository_uri');
DROP TABLE IF EXISTS software_artifact_repository_location_v92;
DROP TABLE IF EXISTS jazzhands_audit.software_artifact_repository_location_v92;
-- DONE DEALING WITH TABLE software_artifact_repository_uri (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_location');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_repository_location failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_repository_uri failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE val_source_repository_url_purpose
-- ... renaming to val_source_repository_uri_purpose (jazzhands))
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_source_repository_url_purpose', 'val_source_repository_uri_purpose');
-- transfering grants from old object to new
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_source_repository_url_purpose', 'val_source_repository_uri_purpose');

-- FOREIGN KEYS FROM
-- Skipping this FK since table jazzhands.source_repository_url has been dropped (table_teardown)
--ALTER TABLE jazzhands.source_repository_url DROP CONSTRAINT IF EXISTS fk_src_repo_url_url_purpose;


-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_source_repository_url_purpose', newobject := 'val_source_repository_uri_purpose', newmap := '{"pk_val_source_repository_uri_purpose":{"columns":["source_repository_uri_purpose"],"def":"PRIMARY KEY (source_repository_uri_purpose)","deferrable":false,"deferred":false,"name":"pk_val_source_repository_uri_purpose","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_source_repository_url_purpose DROP CONSTRAINT IF EXISTS pk_val_source_repository_url_purpose;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_source_repository_url_purpose ON jazzhands.val_source_repository_url_purpose;
DROP TRIGGER IF EXISTS trigger_audit_val_source_repository_url_purpose ON jazzhands.val_source_repository_url_purpose;
DROP FUNCTION IF EXISTS perform_audit_val_source_repository_url_purpose();
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_source_repository_url_purpose', tags := ARRAY['table_val_source_repository_uri_purpose']);
---- BEGIN jazzhands_audit.val_source_repository_url_purpose TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_source_repository_url_purpose', tags := ARRAY['table_val_source_repository_uri_purpose']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_source_repository_url_purpose', 'val_source_repository_uri_purpose');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_source_repository_url_purpose');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_source_repository_url_purpose DROP CONSTRAINT IF EXISTS val_source_repository_url_purpose_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0val_source_repository_url_purpose_pk_val_source_repository";
DROP INDEX IF EXISTS "jazzhands_audit"."val_source_repository_url_purpose_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_source_repository_url_purpose_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_source_repository_url_purpose_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.val_source_repository_url_purpose ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.val_source_repository_url_purpose_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_source_repository_url_purpose_seq;
---- DONE jazzhands_audit.val_source_repository_url_purpose TEARDOWN


ALTER TABLE val_source_repository_url_purpose RENAME TO val_source_repository_url_purpose_v92;
ALTER TABLE jazzhands_audit.val_source_repository_url_purpose RENAME TO val_source_repository_url_purpose_v92;

CREATE TABLE jazzhands.val_source_repository_uri_purpose
(
	source_repository_uri_purpose	varchar(50) NOT NULL,
	description	varchar(50)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_source_repository_uri_purpose', false);
--# no idea what I was thinking:SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_source_repository_uri_purpose');


-- BEGIN Manually written insert function
INSERT INTO val_source_repository_uri_purpose (
        source_repository_uri_purpose,          -- new column (source_repository_uri_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        source_repository_url_purpose,           -- new column (source_repository_uri_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM val_source_repository_url_purpose_v92;


INSERT INTO jazzhands_audit.val_source_repository_uri_purpose (
        source_repository_uri_purpose,           -- new column (source_repository_uri_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        source_repository_url_purpose,           -- new column (source_repository_uri_purpose)
        description,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.val_source_repository_url_purpose_v92;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_source_repository_uri_purpose ADD CONSTRAINT pk_val_source_repository_uri_purpose PRIMARY KEY (source_repository_uri_purpose);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_source_repository_uri_purpose and jazzhands.source_repository_provider_uri_template
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_provider_uri_template
--	ADD CONSTRAINT fk_src_repo_uri_uri_purpose
--	FOREIGN KEY (source_repository_uri_purpose) REFERENCES jazzhands.val_source_repository_uri_purpose(source_repository_uri_purpose) DEFERRABLE;


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_source_repository_uri_purpose');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_source_repository_uri_purpose  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_source_repository_uri_purpose');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_source_repository_uri_purpose');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_source_repository_uri_purpose');
DROP TABLE IF EXISTS val_source_repository_url_purpose_v92;
DROP TABLE IF EXISTS jazzhands_audit.val_source_repository_url_purpose_v92;
-- DONE DEALING WITH TABLE val_source_repository_uri_purpose (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_url_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_source_repository_url_purpose failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_uri_purpose');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_source_repository_uri_purpose failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to val_authentication_question
ALTER TABLE "jazzhands"."val_authentication_question" ALTER COLUMN "authentication_question_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."val_authentication_question_authentication_question_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".val_authentication_question_authentication_question_id_seq;
ALTER TABLE "jazzhands"."val_authentication_question" ALTER COLUMN "authentication_question_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME val_authentication_question_authentication_question_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to val_encryption_key_purpose
ALTER TABLE "jazzhands"."val_encryption_key_purpose" ALTER COLUMN "encryption_key_purpose_version" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."val_encryption_key_purpose_encryption_key_purpose_version_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".val_encryption_key_purpose_encryption_key_purpose_version_seq;
ALTER TABLE "jazzhands"."val_encryption_key_purpose" ALTER COLUMN "encryption_key_purpose_version" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME val_encryption_key_purpose_encryption_key_purpose_version_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE val_package_relation_type

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands',  object := 'val_package_relation_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_package_relation_type DROP CONSTRAINT IF EXISTS pk_val_package_relation_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_package_relation_type ON jazzhands.val_package_relation_type;
DROP TRIGGER IF EXISTS trigger_audit_val_package_relation_type ON jazzhands.val_package_relation_type;
DROP FUNCTION IF EXISTS perform_audit_val_package_relation_type();
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_package_relation_type', tags := ARRAY['table_val_package_relation_type']);
---- BEGIN jazzhands_audit.val_package_relation_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_package_relation_type', tags := ARRAY['table_val_package_relation_type']);

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_package_relation_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_package_relation_type DROP CONSTRAINT IF EXISTS val_package_relation_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_package_relation_type_pk_val_package_relation_type";
DROP INDEX IF EXISTS "jazzhands_audit"."val_package_relation_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_package_relation_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_package_relation_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.val_package_relation_type ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.val_package_relation_type_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_package_relation_type_seq;
---- DONE jazzhands_audit.val_package_relation_type TEARDOWN


ALTER TABLE val_package_relation_type RENAME TO val_package_relation_type_v92;
ALTER TABLE jazzhands_audit.val_package_relation_type RENAME TO val_package_relation_type_v92;

DROP TABLE IF EXISTS val_package_relation_type_v92;
DROP TABLE IF EXISTS jazzhands_audit.val_package_relation_type_v92;
-- DONE DEALING WITH OLD TABLE val_package_relation_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_package_relation_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_package_relation_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_namespace (jazzhands)
CREATE TABLE jazzhands.val_service_namespace
(
	service_namespace	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_namespace', true);
--
-- Copying initialization data
--

INSERT INTO val_service_namespace (
service_namespace,description
) VALUES
	('default',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_namespace ADD CONSTRAINT pk_val_service_namespace PRIMARY KEY (service_namespace);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.val_service_namespace IS 'service names with types that share a namespace must be uniquely named.';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_namespace and jazzhands.val_service_type
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.val_service_type
--	ADD CONSTRAINT fk_service_type_namespace
--	FOREIGN KEY (service_namespace) REFERENCES jazzhands.val_service_namespace(service_namespace);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_namespace');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_namespace  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_namespace');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_namespace');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_namespace');
-- DONE DEALING WITH TABLE val_service_namespace (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_namespace');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_namespace failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_namespace');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_namespace failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_service_relationship_type (jazzhands)
CREATE TABLE jazzhands.val_service_relationship_type
(
	service_relationship_type	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_relationship_type', true);
--
-- Copying initialization data
--

INSERT INTO val_service_relationship_type (
service_relationship_type,description
) VALUES
	('depend',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_relationship_type ADD CONSTRAINT pk_val_service_relationship_type PRIMARY KEY (service_relationship_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_relationship_type and jazzhands.service_relationship
ALTER TABLE jazzhands.service_relationship
	ADD CONSTRAINT fk_service_relationship_relationship_type
	FOREIGN KEY (service_relationship_type) REFERENCES jazzhands.val_service_relationship_type(service_relationship_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_relationship_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_relationship_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_relationship_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_relationship_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_relationship_type');
-- DONE DEALING WITH TABLE val_service_relationship_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_relationship_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_relationship_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_relationship_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_relationship_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE val_service_type
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'val_service_type', 'val_service_type');

-- FOREIGN KEYS FROM
ALTER TABLE service DROP CONSTRAINT IF EXISTS fk_service_service_type;
ALTER TABLE service_version DROP CONSTRAINT IF EXISTS fk_svc_version_service_type;

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'val_service_type', newobject := 'val_service_type', newmap := '{"pk_val_service_type":{"columns":["service_type"],"def":"PRIMARY KEY (service_type)","deferrable":false,"deferred":false,"name":"pk_val_service_type","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_type DROP CONSTRAINT IF EXISTS pk_val_service_type;
-- INDEXES
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_val_service_type ON jazzhands.val_service_type;
DROP TRIGGER IF EXISTS trigger_audit_val_service_type ON jazzhands.val_service_type;
DROP FUNCTION IF EXISTS perform_audit_val_service_type();
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'val_service_type', tags := ARRAY['table_val_service_type']);
---- BEGIN jazzhands_audit.val_service_type TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'val_service_type', tags := ARRAY['table_val_service_type']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'val_service_type', 'val_service_type');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'val_service_type');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.val_service_type DROP CONSTRAINT IF EXISTS val_service_type_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_val_service_type_pk_val_service_type";
DROP INDEX IF EXISTS "jazzhands_audit"."val_service_type_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_service_type_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."val_service_type_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.val_service_type ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.val_service_type_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_service_type_seq;
---- DONE jazzhands_audit.val_service_type TEARDOWN


ALTER TABLE val_service_type RENAME TO val_service_type_v92;
ALTER TABLE jazzhands_audit.val_service_type RENAME TO val_service_type_v92;

CREATE TABLE jazzhands.val_service_type
(
	service_type	varchar(255) NOT NULL,
	service_namespace	varchar(255)  NULL,
	service_version_restriction_regular_expression	varchar(255)  NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_service_type', false);
ALTER TABLE val_service_type
	ALTER service_namespace
	SET DEFAULT 'default'::character varying;

INSERT INTO val_service_type (
	service_type,
	service_namespace,		-- new column (service_namespace)
	service_version_restriction_regular_expression,		-- new column (service_version_restriction_regular_expression)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_type,
	'default'::character varying,		-- new column (service_namespace)
	NULL,		-- new column (service_version_restriction_regular_expression)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM val_service_type_v92;


INSERT INTO jazzhands_audit.val_service_type (
	service_type,
	service_namespace,		-- new column (service_namespace)
	service_version_restriction_regular_expression,		-- new column (service_version_restriction_regular_expression)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_type,
	NULL,		-- new column (service_namespace)
	NULL,		-- new column (service_version_restriction_regular_expression)
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.val_service_type_v92;

ALTER TABLE jazzhands.val_service_type
	ALTER service_namespace
	SET DEFAULT 'default'::character varying;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_service_type ADD CONSTRAINT pk_val_service_type PRIMARY KEY (service_type);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.val_service_type.service_namespace IS 'service names with types that share a namespace must be uniquely named.';
COMMENT ON COLUMN jazzhands.val_service_type.service_version_restriction_regular_expression IS 'Regular Expression used by triggers to limit service_relationship.service_version_restriction for service versions of this service.  (Ths LHS of service_relationship)';
-- INDEXES
CREATE INDEX xifservice_type_namespace ON jazzhands.val_service_type USING btree (service_namespace);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_service_type and jazzhands.service
ALTER TABLE jazzhands.service
	ADD CONSTRAINT fk_service_service_type
	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;
-- consider FK between val_service_type and jazzhands.service_version
ALTER TABLE jazzhands.service_version
	ADD CONSTRAINT fk_svc_version_service_type
	FOREIGN KEY (service_type) REFERENCES jazzhands.val_service_type(service_type) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK val_service_type and val_service_namespace
ALTER TABLE jazzhands.val_service_type
	ADD CONSTRAINT fk_service_type_namespace
	FOREIGN KEY (service_namespace) REFERENCES jazzhands.val_service_namespace(service_namespace);

-- TRIGGERS
-- considering NEW jazzhands.check_service_type_namespace
CREATE OR REPLACE FUNCTION jazzhands.check_service_type_namespace()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	SELECT coalesce(sum(n), 0)
	INTO _tally
	FROM (
		SELECT service_name, count(*) as n
		FROM service
			JOIN val_service_type USING (service_type)
		WHERE service_namespace = NEW.service_namespace
		GROUP BY 1
		HAVING count(*) > 1
	) x;

	IF _tally > 0 THEN
		RAISE EXCEPTION 'namespace % has % conflicting services',
			NEW.service_type, _tally
		USING ERRCODE = 'unique_violation';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.check_service_type_namespace() FROM public;
CREATE CONSTRAINT TRIGGER trigger_check_service_type_namespace AFTER UPDATE OF service_namespace ON jazzhands.val_service_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_service_type_namespace();

-- considering NEW jazzhands.check_service_type_relation_regexp_change
CREATE OR REPLACE FUNCTION jazzhands.check_service_type_relation_regexp_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	IF NEW.service_version_restriction_regular_expression IS NOT NULL THEN
		FOR _r IN
			SELECT sr.*
			FROM service_relationship sr
			JOIN service_version USING (service_version_id)
			WHERE service_type = NEW.service_type
			AND service_version_restriction IS NOT NULL
			AND service_version_restriction !~
				NEW.service_version_restriction_regular_expression
		LOOP
			RAISE EXCEPTION 'Existing service_relationships must match type.'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = format('Check relationship %s',
					_r.service_relationship_id);
		END LOOP;
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.check_service_type_relation_regexp_change() FROM public;
CREATE CONSTRAINT TRIGGER trigger_check_service_type_relation_regexp_change AFTER UPDATE OF service_version_restriction_regular_expression ON jazzhands.val_service_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_service_type_relation_regexp_change();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_service_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_service_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_service_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_service_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_service_type');
DROP TABLE IF EXISTS val_service_type_v92;
DROP TABLE IF EXISTS jazzhands_audit.val_service_type_v92;
-- DONE DEALING WITH TABLE val_service_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_service_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_service_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_service_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_software_artifact_repository_uri_type (jazzhands)
CREATE TABLE jazzhands.val_software_artifact_repository_uri_type
(
	software_artifact_repository_uri_type	varchar(50) NOT NULL,
	description	varchar(50)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_software_artifact_repository_uri_type', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_software_artifact_repository_uri_type ADD CONSTRAINT pk_val_softwre_artifact_repostory_url_type PRIMARY KEY (software_artifact_repository_uri_type);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_software_artifact_repository_uri_type and jazzhands.software_artifact_repository_uri
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_sw_artifact_repo_url_repo_type
	FOREIGN KEY (software_artifact_repository_uri_type) REFERENCES jazzhands.val_software_artifact_repository_uri_type(software_artifact_repository_uri_type);

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_software_artifact_repository_uri_type');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_software_artifact_repository_uri_type  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_software_artifact_repository_uri_type');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_software_artifact_repository_uri_type');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_software_artifact_repository_uri_type');
-- DONE DEALING WITH TABLE val_software_artifact_repository_uri_type (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_software_artifact_repository_uri_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_software_artifact_repository_uri_type failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_software_artifact_repository_uri_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_software_artifact_repository_uri_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_source_repository_protocol (jazzhands)
CREATE TABLE jazzhands.val_source_repository_protocol
(
	source_repository_protocol	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_source_repository_protocol', true);
--
-- Copying initialization data
--

INSERT INTO val_source_repository_protocol (
source_repository_protocol,description
) VALUES
	('https',NULL),
	('ssh',NULL)
;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_source_repository_protocol ADD CONSTRAINT pk_val_source_repository_protocol PRIMARY KEY (source_repository_protocol);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_source_repository_protocol and jazzhands.source_repository_provider_uri_template
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.source_repository_provider_uri_template
--	ADD CONSTRAINT fk_src_repo_provider_tempate_protocol
--	FOREIGN KEY (source_repository_protocol) REFERENCES jazzhands.val_source_repository_protocol(source_repository_protocol);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_source_repository_protocol');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_source_repository_protocol  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_source_repository_protocol');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_source_repository_protocol');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_source_repository_protocol');
-- DONE DEALING WITH TABLE val_source_repository_protocol (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_protocol');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_source_repository_protocol failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_source_repository_protocol');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_source_repository_protocol failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE val_x509_fingerprint_hash_algorithm (jazzhands)
CREATE TABLE jazzhands.val_x509_fingerprint_hash_algorithm
(
	x509_fingerprint_hash_algorighm	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'val_x509_fingerprint_hash_algorithm', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.val_x509_fingerprint_hash_algorithm ADD CONSTRAINT pk_val_x509_fingerprint_hash_algorithm PRIMARY KEY (x509_fingerprint_hash_algorighm);

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between val_x509_fingerprint_hash_algorithm and jazzhands.public_key_hash_hash
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.public_key_hash_hash
--	ADD CONSTRAINT fk_public_key_hash_hash_algorithm
--	FOREIGN KEY (x509_fingerprint_hash_algorighm) REFERENCES jazzhands.val_x509_fingerprint_hash_algorithm(x509_fingerprint_hash_algorighm);

-- consider FK between val_x509_fingerprint_hash_algorithm and jazzhands.x509_signed_certificate_fingerprint
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.x509_signed_certificate_fingerprint
--	ADD CONSTRAINT fk_x509_signed_cert_fprint_algorithm
--	FOREIGN KEY (x509_fingerprint_hash_algorighm) REFERENCES jazzhands.val_x509_fingerprint_hash_algorithm(x509_fingerprint_hash_algorighm);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('val_x509_fingerprint_hash_algorithm');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for val_x509_fingerprint_hash_algorithm  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'val_x509_fingerprint_hash_algorithm');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'val_x509_fingerprint_hash_algorithm');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'val_x509_fingerprint_hash_algorithm');
-- DONE DEALING WITH TABLE val_x509_fingerprint_hash_algorithm (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_x509_fingerprint_hash_algorithm');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_x509_fingerprint_hash_algorithm failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('val_x509_fingerprint_hash_algorithm');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new val_x509_fingerprint_hash_algorithm failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to account
ALTER TABLE "jazzhands"."account" ALTER COLUMN "account_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."account_account_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".account_account_id_seq;
ALTER TABLE "jazzhands"."account" ALTER COLUMN "account_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME account_account_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to account_collection
ALTER TABLE "jazzhands"."account_collection" ALTER COLUMN "account_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."account_collection_account_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".account_collection_account_collection_id_seq;
ALTER TABLE "jazzhands"."account_collection" ALTER COLUMN "account_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME account_collection_account_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to account_realm
ALTER TABLE "jazzhands"."account_realm" ALTER COLUMN "account_realm_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."account_realm_account_realm_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".account_realm_account_realm_id_seq;
ALTER TABLE "jazzhands"."account_realm" ALTER COLUMN "account_realm_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME account_realm_account_realm_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to account_token
ALTER TABLE "jazzhands"."account_token" ALTER COLUMN "account_token_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."account_token_account_token_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".account_token_account_token_id_seq;
ALTER TABLE "jazzhands"."account_token" ALTER COLUMN "account_token_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME account_token_account_token_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to appaal
ALTER TABLE "jazzhands"."appaal" ALTER COLUMN "appaal_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."appaal_appaal_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".appaal_appaal_id_seq;
ALTER TABLE "jazzhands"."appaal" ALTER COLUMN "appaal_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME appaal_appaal_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to appaal_instance
ALTER TABLE "jazzhands"."appaal_instance" ALTER COLUMN "appaal_instance_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."appaal_instance_appaal_instance_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".appaal_instance_appaal_instance_id_seq;
ALTER TABLE "jazzhands"."appaal_instance" ALTER COLUMN "appaal_instance_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME appaal_instance_appaal_instance_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_instance
ALTER TABLE "jazzhands"."approval_instance" ALTER COLUMN "approval_instance_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_instance_approval_instance_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_instance_approval_instance_id_seq;
ALTER TABLE "jazzhands"."approval_instance" ALTER COLUMN "approval_instance_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_instance_approval_instance_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_instance_item
ALTER TABLE "jazzhands"."approval_instance_item" ALTER COLUMN "approval_instance_item_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_instance_item_approval_instance_item_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_instance_item_approval_instance_item_id_seq;
ALTER TABLE "jazzhands"."approval_instance_item" ALTER COLUMN "approval_instance_item_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_instance_item_approval_instance_item_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_instance_link
ALTER TABLE "jazzhands"."approval_instance_link" ALTER COLUMN "approval_instance_link_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_instance_link_approval_instance_link_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_instance_link_approval_instance_link_id_seq;
ALTER TABLE "jazzhands"."approval_instance_link" ALTER COLUMN "approval_instance_link_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_instance_link_approval_instance_link_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_instance_step
ALTER TABLE "jazzhands"."approval_instance_step" ALTER COLUMN "approval_instance_step_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_instance_step_approval_instance_step_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_instance_step_approval_instance_step_id_seq;
ALTER TABLE "jazzhands"."approval_instance_step" ALTER COLUMN "approval_instance_step_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_instance_step_approval_instance_step_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_instance_step_notify
ALTER TABLE "jazzhands"."approval_instance_step_notify" ALTER COLUMN "approv_instance_step_notify_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_instance_step_notify_approv_instance_step_notify_i_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_instance_step_notify_approv_instance_step_notify_i_seq;
ALTER TABLE "jazzhands"."approval_instance_step_notify" ALTER COLUMN "approv_instance_step_notify_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_instance_step_notify_approv_instance_step_notify_i_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_process
ALTER TABLE "jazzhands"."approval_process" ALTER COLUMN "approval_process_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_process_approval_process_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_process_approval_process_id_seq;
ALTER TABLE "jazzhands"."approval_process" ALTER COLUMN "approval_process_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_process_approval_process_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to approval_process_chain
ALTER TABLE "jazzhands"."approval_process_chain" ALTER COLUMN "approval_process_chain_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."approval_process_chain_approval_process_chain_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".approval_process_chain_approval_process_chain_id_seq;
ALTER TABLE "jazzhands"."approval_process_chain" ALTER COLUMN "approval_process_chain_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME approval_process_chain_approval_process_chain_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to asset
ALTER TABLE "jazzhands"."asset" ALTER COLUMN "asset_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."asset_asset_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".asset_asset_id_seq;
ALTER TABLE "jazzhands"."asset" ALTER COLUMN "asset_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME asset_asset_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to badge_type
ALTER TABLE "jazzhands"."badge_type" ALTER COLUMN "badge_type_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."badge_type_badge_type_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".badge_type_badge_type_id_seq;
ALTER TABLE "jazzhands"."badge_type" ALTER COLUMN "badge_type_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME badge_type_badge_type_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to certificate_signing_request
ALTER TABLE "jazzhands"."certificate_signing_request" ALTER COLUMN "certificate_signing_request_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."certificate_signing_request_certificate_signing_request_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".certificate_signing_request_certificate_signing_request_id_seq;
ALTER TABLE "jazzhands"."certificate_signing_request" ALTER COLUMN "certificate_signing_request_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME certificate_signing_request_certificate_signing_request_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to chassis_location
ALTER TABLE "jazzhands"."chassis_location" ALTER COLUMN "chassis_location_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."chassis_location_chassis_location_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".chassis_location_chassis_location_id_seq;
ALTER TABLE "jazzhands"."chassis_location" ALTER COLUMN "chassis_location_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME chassis_location_chassis_location_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to circuit
ALTER TABLE "jazzhands"."circuit" ALTER COLUMN "circuit_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."circuit_circuit_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".circuit_circuit_id_seq;
ALTER TABLE "jazzhands"."circuit" ALTER COLUMN "circuit_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME circuit_circuit_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to company
ALTER TABLE "jazzhands"."company" ALTER COLUMN "company_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."company_company_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".company_company_id_seq;
ALTER TABLE "jazzhands"."company" ALTER COLUMN "company_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME company_company_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to company_collection
ALTER TABLE "jazzhands"."company_collection" ALTER COLUMN "company_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."company_collection_company_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".company_collection_company_collection_id_seq;
ALTER TABLE "jazzhands"."company_collection" ALTER COLUMN "company_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME company_collection_company_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to component
ALTER TABLE "jazzhands"."component" ALTER COLUMN "component_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."component_component_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".component_component_id_seq;
ALTER TABLE "jazzhands"."component" ALTER COLUMN "component_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME component_component_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to component_property
ALTER TABLE "jazzhands"."component_property" ALTER COLUMN "component_property_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."component_property_component_property_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".component_property_component_property_id_seq;
ALTER TABLE "jazzhands"."component_property" ALTER COLUMN "component_property_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME component_property_component_property_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to component_type
ALTER TABLE "jazzhands"."component_type" ALTER COLUMN "component_type_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."component_type_component_type_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".component_type_component_type_id_seq;
ALTER TABLE "jazzhands"."component_type" ALTER COLUMN "component_type_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME component_type_component_type_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to component_type_slot_template
ALTER TABLE "jazzhands"."component_type_slot_template" ALTER COLUMN "component_type_slot_template_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."component_type_slot_template_component_type_slot_template_i_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".component_type_slot_template_component_type_slot_template_i_seq;
ALTER TABLE "jazzhands"."component_type_slot_template" ALTER COLUMN "component_type_slot_template_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME component_type_slot_template_component_type_slot_template_i_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to contract
ALTER TABLE "jazzhands"."contract" ALTER COLUMN "contract_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."contract_contract_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".contract_contract_id_seq;
ALTER TABLE "jazzhands"."contract" ALTER COLUMN "contract_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME contract_contract_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to device
ALTER TABLE "jazzhands"."device" ALTER COLUMN "device_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."device_device_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".device_device_id_seq;
ALTER TABLE "jazzhands"."device" ALTER COLUMN "device_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME device_device_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to device_collection
ALTER TABLE "jazzhands"."device_collection" ALTER COLUMN "device_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."device_collection_device_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".device_collection_device_collection_id_seq;
ALTER TABLE "jazzhands"."device_collection" ALTER COLUMN "device_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME device_collection_device_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE device_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'device_note', 'device_note');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.device_note DROP CONSTRAINT IF EXISTS fk_device_note_device;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'device_note', newobject := 'device_note', newmap := '{"pk_device_note":{"columns":["device_note_id"],"def":"PRIMARY KEY (device_note_id)","deferrable":false,"deferred":false,"name":"pk_device_note","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.device_note DROP CONSTRAINT IF EXISTS pk_device_note;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."idx_devnote_devid";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.device_note DROP CONSTRAINT IF EXISTS ckc_note_user_device_n;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_device_note ON jazzhands.device_note;
DROP TRIGGER IF EXISTS trigger_audit_device_note ON jazzhands.device_note;
DROP FUNCTION IF EXISTS perform_audit_device_note();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.device_note ALTER COLUMN "note_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.device_note_note_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.device_note_note_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'device_note', tags := ARRAY['table_device_note']);
---- BEGIN jazzhands_audit.device_note TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'device_note', tags := ARRAY['table_device_note']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'device_note', 'device_note');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'device_note');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.device_note DROP CONSTRAINT IF EXISTS device_note_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_device_note_pk_device_note";
DROP INDEX IF EXISTS "jazzhands_audit"."device_note_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."device_note_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."device_note_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.device_note ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.device_note_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.device_note_seq;
---- DONE jazzhands_audit.device_note TEARDOWN


ALTER TABLE device_note RENAME TO device_note_v92;
ALTER TABLE jazzhands_audit.device_note RENAME TO device_note_v92;

CREATE TABLE jazzhands.device_note
(
	device_note_id	integer NOT NULL,
	device_id	integer NOT NULL,
	note_text	varchar(4000) NOT NULL,
	note_date	timestamp with time zone NOT NULL,
	note_user	varchar(30) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'device_note', false);
ALTER TABLE device_note
	ALTER COLUMN device_note_id
	ADD GENERATED BY DEFAULT AS IDENTITY;


-- BEGIN Manually written insert function
INSERT INTO device_note (
        device_note_id,         -- new column (device_note_id)
        device_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        note_id,           -- new column (device_note_id)
        device_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM device_note_v92;


INSERT INTO jazzhands_audit.device_note (
        device_note_id,         -- new column (device_note_id)
        device_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        note_id,           -- new column (device_note_id)
        device_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.device_note_v92;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.device_note ADD CONSTRAINT pk_device_note PRIMARY KEY (device_note_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX idx_devnote_devid ON jazzhands.device_note USING btree (device_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.device_note ADD CONSTRAINT ckc_note_user_device_n
	CHECK (((note_user)::text = upper((note_user)::text)));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK device_note and device
ALTER TABLE jazzhands.device_note
	ADD CONSTRAINT fk_device_note_device
	FOREIGN KEY (device_id) REFERENCES jazzhands.device(device_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('device_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for device_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'device_note');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'device_note');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'device_note');
DROP TABLE IF EXISTS device_note_v92;
DROP TABLE IF EXISTS jazzhands_audit.device_note_v92;
-- DONE DEALING WITH TABLE device_note (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new device_note failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to device_type
ALTER TABLE "jazzhands"."device_type" ALTER COLUMN "device_type_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."device_type_device_type_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".device_type_device_type_id_seq;
ALTER TABLE "jazzhands"."device_type" ALTER COLUMN "device_type_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME device_type_device_type_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to dns_change_record
ALTER TABLE "jazzhands"."dns_change_record" ALTER COLUMN "dns_change_record_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."dns_change_record_dns_change_record_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".dns_change_record_dns_change_record_id_seq;
ALTER TABLE "jazzhands"."dns_change_record" ALTER COLUMN "dns_change_record_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME dns_change_record_dns_change_record_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to dns_domain
ALTER TABLE "jazzhands"."dns_domain" ALTER COLUMN "dns_domain_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."dns_domain_dns_domain_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".dns_domain_dns_domain_id_seq;
ALTER TABLE "jazzhands"."dns_domain" ALTER COLUMN "dns_domain_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME dns_domain_dns_domain_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to dns_domain_collection
ALTER TABLE "jazzhands"."dns_domain_collection" ALTER COLUMN "dns_domain_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."dns_domain_collection_dns_domain_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".dns_domain_collection_dns_domain_collection_id_seq;
ALTER TABLE "jazzhands"."dns_domain_collection" ALTER COLUMN "dns_domain_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME dns_domain_collection_dns_domain_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to dns_record
ALTER TABLE "jazzhands"."dns_record" ALTER COLUMN "dns_record_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."dns_record_dns_record_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".dns_record_dns_record_id_seq;
ALTER TABLE "jazzhands"."dns_record" ALTER COLUMN "dns_record_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME dns_record_dns_record_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to encapsulation_range
ALTER TABLE "jazzhands"."encapsulation_range" ALTER COLUMN "encapsulation_range_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."encapsulation_range_encapsulation_range_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".encapsulation_range_encapsulation_range_id_seq;
ALTER TABLE "jazzhands"."encapsulation_range" ALTER COLUMN "encapsulation_range_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME encapsulation_range_encapsulation_range_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to encryption_key
ALTER TABLE "jazzhands"."encryption_key" ALTER COLUMN "encryption_key_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."encryption_key_encryption_key_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".encryption_key_encryption_key_id_seq;
ALTER TABLE "jazzhands"."encryption_key" ALTER COLUMN "encryption_key_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME encryption_key_encryption_key_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to inter_component_connection
ALTER TABLE "jazzhands"."inter_component_connection" ALTER COLUMN "inter_component_connection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."inter_component_connection_inter_component_connection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".inter_component_connection_inter_component_connection_id_seq;
ALTER TABLE "jazzhands"."inter_component_connection" ALTER COLUMN "inter_component_connection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME inter_component_connection_inter_component_connection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to ip_universe
ALTER TABLE "jazzhands"."ip_universe" ALTER COLUMN "ip_universe_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."ip_universe_ip_universe_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".ip_universe_ip_universe_id_seq;
ALTER TABLE "jazzhands"."ip_universe" ALTER COLUMN "ip_universe_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME ip_universe_ip_universe_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to kerberos_realm
ALTER TABLE "jazzhands"."kerberos_realm" ALTER COLUMN "krb_realm_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."kerberos_realm_krb_realm_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".kerberos_realm_krb_realm_id_seq;
ALTER TABLE "jazzhands"."kerberos_realm" ALTER COLUMN "krb_realm_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME kerberos_realm_krb_realm_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to klogin
ALTER TABLE "jazzhands"."klogin" ALTER COLUMN "klogin_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."klogin_klogin_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".klogin_klogin_id_seq;
ALTER TABLE "jazzhands"."klogin" ALTER COLUMN "klogin_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME klogin_klogin_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer2_connection
ALTER TABLE "jazzhands"."layer2_connection" ALTER COLUMN "layer2_connection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer2_connection_layer2_connection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer2_connection_layer2_connection_id_seq;
ALTER TABLE "jazzhands"."layer2_connection" ALTER COLUMN "layer2_connection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer2_connection_layer2_connection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer2_network
ALTER TABLE "jazzhands"."layer2_network" ALTER COLUMN "layer2_network_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer2_network_layer2_network_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer2_network_layer2_network_id_seq;
ALTER TABLE "jazzhands"."layer2_network" ALTER COLUMN "layer2_network_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer2_network_layer2_network_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer2_network_collection
ALTER TABLE "jazzhands"."layer2_network_collection" ALTER COLUMN "layer2_network_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer2_network_collection_layer2_network_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer2_network_collection_layer2_network_collection_id_seq;
ALTER TABLE "jazzhands"."layer2_network_collection" ALTER COLUMN "layer2_network_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer2_network_collection_layer2_network_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_acl_chain
ALTER TABLE "jazzhands"."layer3_acl_chain" ALTER COLUMN "layer3_acl_chain_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer3_acl_chain_layer3_acl_chain_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer3_acl_chain_layer3_acl_chain_id_seq;
ALTER TABLE "jazzhands"."layer3_acl_chain" ALTER COLUMN "layer3_acl_chain_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer3_acl_chain_layer3_acl_chain_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_acl_chain_layer3_interface
ALTER TABLE "jazzhands"."layer3_acl_chain_layer3_interface" ALTER COLUMN "layer3_acl_chain_id" DROP DEFAULT;
ALTER TABLE "jazzhands"."layer3_acl_chain_layer3_interface" ALTER COLUMN "layer3_interface_id" DROP DEFAULT;
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_acl_group
ALTER TABLE "jazzhands"."layer3_acl_group" ALTER COLUMN "layer3_acl_group_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer3_acl_group_layer3_acl_group_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer3_acl_group_layer3_acl_group_id_seq;
ALTER TABLE "jazzhands"."layer3_acl_group" ALTER COLUMN "layer3_acl_group_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer3_acl_group_layer3_acl_group_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE layer3_acl_rule
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'layer3_acl_rule', 'layer3_acl_rule');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_dst_nblk_collection;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_dst_port_range;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_group_id;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_service_depend_id;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_src_netblk_collection;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_src_port_range;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'layer3_acl_rule', newobject := 'layer3_acl_rule', newmap := '{"ak_l3acl_rule_group_rank":{"columns":["layer3_acl_group_id","layer3_acl_rank"],"def":"UNIQUE (layer3_acl_group_id, layer3_acl_rank)","deferrable":false,"deferred":false,"name":"ak_l3acl_rule_group_rank","type":"u"},"pk_layer3_acl_rule":{"columns":["layer3_acl_rule_id"],"def":"PRIMARY KEY (layer3_acl_rule_id)","deferrable":false,"deferred":false,"name":"pk_layer3_acl_rule","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS ak_l3acl_rule_group_rank;
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS pk_layer3_acl_rule;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_dst_nblk_collection";
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_dst_port_range";
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_group_id";
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_service_depend_id";
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_src_netblk_collection";
DROP INDEX IF EXISTS "jazzhands"."xifl3acl_rule_l3acl_src_port_range";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.layer3_acl_rule DROP CONSTRAINT IF EXISTS ckc_l3_acl_action;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_layer3_acl_rule ON jazzhands.layer3_acl_rule;
DROP TRIGGER IF EXISTS trigger_audit_layer3_acl_rule ON jazzhands.layer3_acl_rule;
DROP FUNCTION IF EXISTS perform_audit_layer3_acl_rule();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.layer3_acl_rule ALTER COLUMN "layer3_acl_rule_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.layer3_acl_rule_layer3_acl_rule_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.layer3_acl_rule_layer3_acl_rule_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'layer3_acl_rule', tags := ARRAY['table_layer3_acl_rule']);
---- BEGIN jazzhands_audit.layer3_acl_rule TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'layer3_acl_rule', tags := ARRAY['table_layer3_acl_rule']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'layer3_acl_rule', 'layer3_acl_rule');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'layer3_acl_rule');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.layer3_acl_rule DROP CONSTRAINT IF EXISTS layer3_acl_rule_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_acl_rule_ak_l3acl_rule_group_rank";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_layer3_acl_rule_pk_layer3_acl_rule";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_acl_rule_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_acl_rule_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."layer3_acl_rule_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.layer3_acl_rule ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.layer3_acl_rule_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.layer3_acl_rule_seq;
---- DONE jazzhands_audit.layer3_acl_rule TEARDOWN


ALTER TABLE layer3_acl_rule RENAME TO layer3_acl_rule_v92;
ALTER TABLE jazzhands_audit.layer3_acl_rule RENAME TO layer3_acl_rule_v92;

CREATE TABLE jazzhands.layer3_acl_rule
(
	layer3_acl_rule_id	integer NOT NULL,
	is_enabled	boolean NOT NULL,
	layer3_acl_group_id	integer NOT NULL,
	layer3_acl_rank	integer NOT NULL,
	service_relationship_id	integer  NULL,
	description	varchar(4096)  NULL,
	layer3_acl_action	varchar(255) NOT NULL,
	source_netblock_collection_id	integer NOT NULL,
	source_port_relation_restriction	varchar(50)  NULL,
	source_port_range_id	integer  NULL,
	destination_netblock_collection_id	integer NOT NULL,
	destination_port_relation_restriction	varchar(50)  NULL,
	destination_port_range_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'layer3_acl_rule', false);
ALTER TABLE layer3_acl_rule
	ALTER COLUMN layer3_acl_rule_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE layer3_acl_rule
	ALTER is_enabled
	SET DEFAULT true;

INSERT INTO layer3_acl_rule (
	layer3_acl_rule_id,
	is_enabled,
	layer3_acl_group_id,
	layer3_acl_rank,
	service_relationship_id,		-- new column (service_relationship_id)
	description,
	layer3_acl_action,
	source_netblock_collection_id,
	source_port_relation_restriction,
	source_port_range_id,
	destination_netblock_collection_id,
	destination_port_relation_restriction,
	destination_port_range_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	layer3_acl_rule_id,
	is_enabled,
	layer3_acl_group_id,
	layer3_acl_rank,
	NULL,		-- new column (service_relationship_id)
	description,
	layer3_acl_action,
	source_netblock_collection_id,
	source_port_relation_restriction,
	source_port_range_id,
	destination_netblock_collection_id,
	destination_port_relation_restriction,
	destination_port_range_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM layer3_acl_rule_v92;


INSERT INTO jazzhands_audit.layer3_acl_rule (
	layer3_acl_rule_id,
	is_enabled,
	layer3_acl_group_id,
	layer3_acl_rank,
	service_relationship_id,		-- new column (service_relationship_id)
	description,
	layer3_acl_action,
	source_netblock_collection_id,
	source_port_relation_restriction,
	source_port_range_id,
	destination_netblock_collection_id,
	destination_port_relation_restriction,
	destination_port_range_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	layer3_acl_rule_id,
	is_enabled,
	layer3_acl_group_id,
	layer3_acl_rank,
	NULL,		-- new column (service_relationship_id)
	description,
	layer3_acl_action,
	source_netblock_collection_id,
	source_port_relation_restriction,
	source_port_range_id,
	destination_netblock_collection_id,
	destination_port_relation_restriction,
	destination_port_range_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.layer3_acl_rule_v92;

ALTER TABLE jazzhands.layer3_acl_rule
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT ak_l3acl_rule_group_rank UNIQUE (layer3_acl_group_id, layer3_acl_rank);
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT pk_layer3_acl_rule PRIMARY KEY (layer3_acl_rule_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.layer3_acl_rule IS 'Access Control Entries for layer3 traffic';
COMMENT ON COLUMN jazzhands.layer3_acl_rule.service_relationship_id IS 'indicates that this ACL rule applies to a specific inter-service relationship';
-- INDEXES
CREATE INDEX xifl3acl_rule_l3acl_dst_nblk_collection ON jazzhands.layer3_acl_rule USING btree (destination_netblock_collection_id);
CREATE INDEX xifl3acl_rule_l3acl_dst_port_range ON jazzhands.layer3_acl_rule USING btree (destination_port_range_id);
CREATE INDEX xifl3acl_rule_l3acl_group_id ON jazzhands.layer3_acl_rule USING btree (layer3_acl_group_id);
CREATE INDEX xifl3acl_rule_l3acl_service_rship_id ON jazzhands.layer3_acl_rule USING btree (service_relationship_id);
CREATE INDEX xifl3acl_rule_l3acl_src_netblk_collection ON jazzhands.layer3_acl_rule USING btree (source_netblock_collection_id);
CREATE INDEX xifl3acl_rule_l3acl_src_port_range ON jazzhands.layer3_acl_rule USING btree (source_port_range_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.layer3_acl_rule ADD CONSTRAINT ckc_l3_acl_action
	CHECK (((layer3_acl_action)::text = ANY ((ARRAY['permit'::character varying, 'deny'::character varying])::text[])));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK layer3_acl_rule and netblock_collection
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_nblk_collection
	FOREIGN KEY (destination_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id) DEFERRABLE;
-- consider FK layer3_acl_rule and port_range
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_port_range
	FOREIGN KEY (destination_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK layer3_acl_rule and layer3_acl_group
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_group_id
	FOREIGN KEY (layer3_acl_group_id) REFERENCES jazzhands.layer3_acl_group(layer3_acl_group_id) DEFERRABLE;
-- consider FK layer3_acl_rule and service_layer3_acl
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.layer3_acl_rule
--	ADD CONSTRAINT fk_l3acl_rule_l3acl_service_rship_id
--	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_layer3_acl(service_relationship_id);

-- consider FK layer3_acl_rule and netblock_collection
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_netblk_collection
	FOREIGN KEY (source_netblock_collection_id) REFERENCES jazzhands.netblock_collection(netblock_collection_id) DEFERRABLE;
-- consider FK layer3_acl_rule and port_range
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_port_range
	FOREIGN KEY (source_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('layer3_acl_rule');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for layer3_acl_rule  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'layer3_acl_rule');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'layer3_acl_rule');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'layer3_acl_rule');
DROP TABLE IF EXISTS layer3_acl_rule_v92;
DROP TABLE IF EXISTS jazzhands_audit.layer3_acl_rule_v92;
-- DONE DEALING WITH TABLE layer3_acl_rule (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_rule');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old layer3_acl_rule failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('layer3_acl_rule');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new layer3_acl_rule failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_interface
ALTER TABLE "jazzhands"."layer3_interface" ALTER COLUMN "layer3_interface_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer3_interface_layer3_interface_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer3_interface_layer3_interface_id_seq;
ALTER TABLE "jazzhands"."layer3_interface" ALTER COLUMN "layer3_interface_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer3_interface_layer3_interface_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_network
ALTER TABLE "jazzhands"."layer3_network" ALTER COLUMN "layer3_network_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer3_network_layer3_network_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer3_network_layer3_network_id_seq;
ALTER TABLE "jazzhands"."layer3_network" ALTER COLUMN "layer3_network_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer3_network_layer3_network_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to layer3_network_collection
ALTER TABLE "jazzhands"."layer3_network_collection" ALTER COLUMN "layer3_network_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."layer3_network_collection_layer3_network_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".layer3_network_collection_layer3_network_collection_id_seq;
ALTER TABLE "jazzhands"."layer3_network_collection" ALTER COLUMN "layer3_network_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME layer3_network_collection_layer3_network_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to logical_port
ALTER TABLE "jazzhands"."logical_port" ALTER COLUMN "logical_port_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."logical_port_logical_port_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".logical_port_logical_port_id_seq;
ALTER TABLE "jazzhands"."logical_port" ALTER COLUMN "logical_port_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME logical_port_logical_port_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to logical_volume
ALTER TABLE "jazzhands"."logical_volume" ALTER COLUMN "logical_volume_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."logical_volume_logical_volume_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".logical_volume_logical_volume_id_seq;
ALTER TABLE "jazzhands"."logical_volume" ALTER COLUMN "logical_volume_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME logical_volume_logical_volume_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to logical_volume_property
ALTER TABLE "jazzhands"."logical_volume_property" ALTER COLUMN "logical_volume_property_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."logical_volume_property_logical_volume_property_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".logical_volume_property_logical_volume_property_id_seq;
ALTER TABLE "jazzhands"."logical_volume_property" ALTER COLUMN "logical_volume_property_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME logical_volume_property_logical_volume_property_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to mlag_peering
ALTER TABLE "jazzhands"."mlag_peering" ALTER COLUMN "mlag_peering_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."mlag_peering_mlag_peering_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".mlag_peering_mlag_peering_id_seq;
ALTER TABLE "jazzhands"."mlag_peering" ALTER COLUMN "mlag_peering_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME mlag_peering_mlag_peering_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to netblock
ALTER TABLE "jazzhands"."netblock" ALTER COLUMN "netblock_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."netblock_netblock_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".netblock_netblock_id_seq;
ALTER TABLE "jazzhands"."netblock" ALTER COLUMN "netblock_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME netblock_netblock_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to netblock_collection
ALTER TABLE "jazzhands"."netblock_collection" ALTER COLUMN "netblock_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."netblock_collection_netblock_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".netblock_collection_netblock_collection_id_seq;
ALTER TABLE "jazzhands"."netblock_collection" ALTER COLUMN "netblock_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME netblock_collection_netblock_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to network_range
ALTER TABLE "jazzhands"."network_range" ALTER COLUMN "network_range_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."network_range_network_range_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".network_range_network_range_id_seq;
ALTER TABLE "jazzhands"."network_range" ALTER COLUMN "network_range_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME network_range_network_range_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to network_service
ALTER TABLE "jazzhands"."network_service" ALTER COLUMN "network_service_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."network_service_network_service_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".network_service_network_service_id_seq;
ALTER TABLE "jazzhands"."network_service" ALTER COLUMN "network_service_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME network_service_network_service_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to operating_system
ALTER TABLE "jazzhands"."operating_system" ALTER COLUMN "operating_system_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."operating_system_operating_system_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".operating_system_operating_system_id_seq;
ALTER TABLE "jazzhands"."operating_system" ALTER COLUMN "operating_system_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME operating_system_operating_system_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to operating_system_snapshot
ALTER TABLE "jazzhands"."operating_system_snapshot" ALTER COLUMN "operating_system_snapshot_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."operating_system_snapshot_operating_system_snapshot_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".operating_system_snapshot_operating_system_snapshot_id_seq;
ALTER TABLE "jazzhands"."operating_system_snapshot" ALTER COLUMN "operating_system_snapshot_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME operating_system_snapshot_operating_system_snapshot_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person
ALTER TABLE "jazzhands"."person" ALTER COLUMN "person_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_person_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_person_id_seq;
ALTER TABLE "jazzhands"."person" ALTER COLUMN "person_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_person_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person_contact
ALTER TABLE "jazzhands"."person_contact" ALTER COLUMN "person_contact_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_contact_person_contact_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_contact_person_contact_id_seq;
ALTER TABLE "jazzhands"."person_contact" ALTER COLUMN "person_contact_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_contact_person_contact_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person_image
ALTER TABLE "jazzhands"."person_image" ALTER COLUMN "person_image_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_image_person_image_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_image_person_image_id_seq;
ALTER TABLE "jazzhands"."person_image" ALTER COLUMN "person_image_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_image_person_image_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person_location
ALTER TABLE "jazzhands"."person_location" ALTER COLUMN "person_location_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_location_person_location_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_location_person_location_id_seq;
ALTER TABLE "jazzhands"."person_location" ALTER COLUMN "person_location_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_location_person_location_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE person_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'person_note', 'person_note');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.person_note DROP CONSTRAINT IF EXISTS fk_person_note_person_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'person_note', newobject := 'person_note', newmap := '{"pk_person_note":{"columns":["person_note_id"],"def":"PRIMARY KEY (person_note_id)","deferrable":false,"deferred":false,"name":"pk_person_note","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.person_note DROP CONSTRAINT IF EXISTS pk_person_note;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif1person_note";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.person_note DROP CONSTRAINT IF EXISTS ckc_note_user_system_u;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_person_note ON jazzhands.person_note;
DROP TRIGGER IF EXISTS trigger_audit_person_note ON jazzhands.person_note;
DROP FUNCTION IF EXISTS perform_audit_person_note();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.person_note ALTER COLUMN "note_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.person_note_note_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.person_note_note_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'person_note', tags := ARRAY['table_person_note']);
---- BEGIN jazzhands_audit.person_note TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'person_note', tags := ARRAY['table_person_note']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'person_note', 'person_note');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'person_note');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.person_note DROP CONSTRAINT IF EXISTS person_note_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_person_note_pk_person_note";
DROP INDEX IF EXISTS "jazzhands_audit"."person_note_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."person_note_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."person_note_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.person_note ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.person_note_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.person_note_seq;
---- DONE jazzhands_audit.person_note TEARDOWN


ALTER TABLE person_note RENAME TO person_note_v92;
ALTER TABLE jazzhands_audit.person_note RENAME TO person_note_v92;

CREATE TABLE jazzhands.person_note
(
	person_note_id	integer NOT NULL,
	person_id	integer  NULL,
	note_text	varchar(4000) NOT NULL,
	note_date	timestamp with time zone NOT NULL,
	note_user	varchar(30) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'person_note', false);
ALTER TABLE person_note
	ALTER COLUMN person_note_id
	ADD GENERATED BY DEFAULT AS IDENTITY;


-- BEGIN Manually written insert function
INSERT INTO person_note (
        person_note_id,         -- new column (person_note_id)
        person_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
) SELECT
        note_id,           -- new column (person_note_id)
        person_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date
FROM person_note_v92;


INSERT INTO jazzhands_audit.person_note (
        person_note_id,         -- new column (person_note_id)
        person_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
) SELECT
        note_id,           -- new column (person_note_id)
        person_id,
        note_text,
        note_date,
        note_user,
        data_ins_user,
        data_ins_date,
        data_upd_user,
        data_upd_date,
        "aud#action",
        "aud#timestamp",
        "aud#realtime",
        "aud#txid",
        "aud#user",
        "aud#seq"
FROM jazzhands_audit.person_note_v92;


-- END Manually written insert function

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.person_note ADD CONSTRAINT pk_person_note PRIMARY KEY (person_note_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xif1person_note ON jazzhands.person_note USING btree (person_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.person_note ADD CONSTRAINT ckc_note_user_system_u
	CHECK (((note_user)::text = upper((note_user)::text)));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK person_note and person
ALTER TABLE jazzhands.person_note
	ADD CONSTRAINT fk_person_note_person_id
	FOREIGN KEY (person_id) REFERENCES jazzhands.person(person_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('person_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for person_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'person_note');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'person_note');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'person_note');
DROP TABLE IF EXISTS person_note_v92;
DROP TABLE IF EXISTS jazzhands_audit.person_note_v92;
-- DONE DEALING WITH TABLE person_note (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old person_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new person_note failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person_parking_pass
ALTER TABLE "jazzhands"."person_parking_pass" ALTER COLUMN "person_parking_pass_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_parking_pass_person_parking_pass_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_parking_pass_person_parking_pass_id_seq;
ALTER TABLE "jazzhands"."person_parking_pass" ALTER COLUMN "person_parking_pass_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_parking_pass_person_parking_pass_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to person_vehicle
ALTER TABLE "jazzhands"."person_vehicle" ALTER COLUMN "person_vehicle_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."person_vehicle_person_vehicle_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".person_vehicle_person_vehicle_id_seq;
ALTER TABLE "jazzhands"."person_vehicle" ALTER COLUMN "person_vehicle_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME person_vehicle_person_vehicle_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to physical_address
ALTER TABLE "jazzhands"."physical_address" ALTER COLUMN "physical_address_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."physical_address_physical_address_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".physical_address_physical_address_id_seq;
ALTER TABLE "jazzhands"."physical_address" ALTER COLUMN "physical_address_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME physical_address_physical_address_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to physical_connection
ALTER TABLE "jazzhands"."physical_connection" ALTER COLUMN "physical_connection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."physical_connection_physical_connection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".physical_connection_physical_connection_id_seq;
ALTER TABLE "jazzhands"."physical_connection" ALTER COLUMN "physical_connection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME physical_connection_physical_connection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to physicalish_volume
ALTER TABLE "jazzhands"."physicalish_volume" ALTER COLUMN "physicalish_volume_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."physicalish_volume_physicalish_volume_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".physicalish_volume_physicalish_volume_id_seq;
ALTER TABLE "jazzhands"."physicalish_volume" ALTER COLUMN "physicalish_volume_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME physicalish_volume_physicalish_volume_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE port_range
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'port_range', 'port_range');

-- FOREIGN KEYS FROM
ALTER TABLE layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_dst_port_range;
ALTER TABLE layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_src_port_range;
ALTER TABLE service_endpoint_provider_service_instance DROP CONSTRAINT IF EXISTS fk_service_endpoint_provider_service_instance_pr_id;
ALTER TABLE service_endpoint DROP CONSTRAINT IF EXISTS fk_svc_endpoint_port_range_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.port_range DROP CONSTRAINT IF EXISTS fk_port_range_val_port_range_type_port_range_type;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'port_range', newobject := 'port_range', newmap := '{"ak_port_range_name_type_protocol":{"columns":["port_range_name","port_range_type","protocol"],"def":"UNIQUE (port_range_name, port_range_type, protocol)","deferrable":false,"deferred":false,"name":"ak_port_range_name_type_protocol","type":"u"},"pk_port_range":{"columns":["port_range_id"],"def":"PRIMARY KEY (port_range_id)","deferrable":false,"deferred":false,"name":"pk_port_range","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.port_range DROP CONSTRAINT IF EXISTS ak_port_range_name_type_protocol;
ALTER TABLE jazzhands.port_range DROP CONSTRAINT IF EXISTS pk_port_range;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifport_range_val_port_range_type_port_range_type";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_port_range ON jazzhands.port_range;
DROP TRIGGER IF EXISTS trigger_audit_port_range ON jazzhands.port_range;
DROP FUNCTION IF EXISTS perform_audit_port_range();
DROP TRIGGER IF EXISTS trigger_port_range_manage_singleton ON jazzhands.port_range;
DROP TRIGGER IF EXISTS trigger_port_range_sanity_check ON jazzhands.port_range;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.port_range ALTER COLUMN "port_range_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.port_range_port_range_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.port_range_port_range_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'port_range', tags := ARRAY['table_port_range']);
---- BEGIN jazzhands_audit.port_range TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'port_range', tags := ARRAY['table_port_range']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'port_range', 'port_range');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'port_range');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.port_range DROP CONSTRAINT IF EXISTS port_range_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_port_range_ak_port_range_name_type_protocol";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_port_range_pk_port_range";
DROP INDEX IF EXISTS "jazzhands_audit"."port_range_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."port_range_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."port_range_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.port_range ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.port_range_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.port_range_seq;
---- DONE jazzhands_audit.port_range TEARDOWN


ALTER TABLE port_range RENAME TO port_range_v92;
ALTER TABLE jazzhands_audit.port_range RENAME TO port_range_v92;

CREATE TABLE jazzhands.port_range
(
	port_range_id	integer NOT NULL,
	port_range_name	varchar(255) NOT NULL,
	port_range_type	varchar(255) NOT NULL,
	protocol	varchar(255) NOT NULL,
	port_start	integer NOT NULL,
	port_end	integer NOT NULL,
	is_singleton	boolean NOT NULL,
	service_override_port_range_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'port_range', false);
ALTER TABLE port_range
	ALTER COLUMN port_range_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

INSERT INTO port_range (
	port_range_id,
	port_range_name,
	port_range_type,
	protocol,
	port_start,
	port_end,
	is_singleton,
	service_override_port_range_id,		-- new column (service_override_port_range_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	port_range_id,
	port_range_name,
	port_range_type,
	protocol,
	port_start,
	port_end,
	is_singleton,
	NULL,		-- new column (service_override_port_range_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM port_range_v92;


INSERT INTO jazzhands_audit.port_range (
	port_range_id,
	port_range_name,
	port_range_type,
	protocol,
	port_start,
	port_end,
	is_singleton,
	service_override_port_range_id,		-- new column (service_override_port_range_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	port_range_id,
	port_range_name,
	port_range_type,
	protocol,
	port_start,
	port_end,
	is_singleton,
	NULL,		-- new column (service_override_port_range_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.port_range_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.port_range ADD CONSTRAINT ak_port_range_name_type_protocol UNIQUE (port_range_name, port_range_type, protocol);
ALTER TABLE jazzhands.port_range ADD CONSTRAINT pk_port_range PRIMARY KEY (port_range_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.port_range.port_range_name IS 'name of the range of ports (may be one port)';
COMMENT ON COLUMN jazzhands.port_range.port_range_type IS 'namespace for names';
COMMENT ON COLUMN jazzhands.port_range.protocol IS 'protocol, typically low level network protocol';
COMMENT ON COLUMN jazzhands.port_range.is_singleton IS 'if set, this the start and end ports are forced to be the same.';
COMMENT ON COLUMN jazzhands.port_range.service_override_port_range_id IS 'If set, indicates the semantics used for talking to this point.  This is used to do things like http on port 8080.';
-- INDEXES
CREATE INDEX xifport_range_service_port_name_override ON jazzhands.port_range USING btree (service_override_port_range_id);
CREATE INDEX xifport_range_val_port_range_type_port_range_type ON jazzhands.port_range USING btree (port_range_type, protocol);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between port_range and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_dst_port_range
	FOREIGN KEY (destination_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK between port_range and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_src_port_range
	FOREIGN KEY (source_port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK between port_range and jazzhands.service_endpoint_provider_service_instance
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_pr_id
	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;
-- consider FK between port_range and jazzhands.service_endpoint
ALTER TABLE jazzhands.service_endpoint
	ADD CONSTRAINT fk_svc_endpoint_port_range_id
	FOREIGN KEY (port_range_id) REFERENCES jazzhands.port_range(port_range_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK port_range and port_range
ALTER TABLE jazzhands.port_range
	ADD CONSTRAINT fk_port_range_service_port_name_override
	FOREIGN KEY (service_override_port_range_id) REFERENCES jazzhands.port_range(port_range_id);
-- consider FK port_range and val_port_range_type
ALTER TABLE jazzhands.port_range
	ADD CONSTRAINT fk_port_range_val_port_range_type_port_range_type
	FOREIGN KEY (port_range_type, protocol) REFERENCES jazzhands.val_port_range_type(port_range_type, protocol) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.port_range_manage_singleton
CREATE OR REPLACE FUNCTION jazzhands.port_range_manage_singleton()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NEW.is_singleton IS NULL THEN
		IF NEW.port_start = NEW.port_end THEN
			NEW.is_singleton = true;
		ELSE
			NEW.is_singleton = false;
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.port_range_manage_singleton() FROM public;
CREATE TRIGGER trigger_port_range_manage_singleton BEFORE INSERT ON jazzhands.port_range FOR EACH ROW EXECUTE FUNCTION jazzhands.port_range_manage_singleton();

-- considering NEW jazzhands.port_range_sanity_check
CREATE OR REPLACE FUNCTION jazzhands.port_range_sanity_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r		RECORD;
BEGIN
	IF NOT NEW.is_singleton THEN
		SELECT *
		INTO _r
		FROM val_port_range_type
		WHERE port_range_type = NEW.port_range_type
		AND protocol = NEW.protocol;

		IF NOT _r.range_permitted THEN
			RAISE EXCEPTION 'Ranges are not permitted on %:%',
				NEW.port_range_type, NEW.protocol
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	ELSE
		IF NEW.port_start != NEW.port_end THEN
			RAISE EXCEPTION 'singletons may not have a different start and end port'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.port_range_sanity_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_port_range_sanity_check AFTER INSERT OR UPDATE OF port_start, port_end, is_singleton ON jazzhands.port_range NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.port_range_sanity_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('port_range');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for port_range  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'port_range');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'port_range');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'port_range');
DROP TABLE IF EXISTS port_range_v92;
DROP TABLE IF EXISTS jazzhands_audit.port_range_v92;
-- DONE DEALING WITH TABLE port_range (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('port_range');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old port_range failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('port_range');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new port_range failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE private_key
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'private_key', 'private_key');

-- FOREIGN KEYS FROM
ALTER TABLE property DROP CONSTRAINT IF EXISTS fk_property_pval_private_key_id;
ALTER TABLE certificate_signing_request DROP CONSTRAINT IF EXISTS fk_pvtkey_csr;
ALTER TABLE x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_pvtkey_x509crt;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.private_key DROP CONSTRAINT IF EXISTS fk_pctkey_enctype;
ALTER TABLE jazzhands.private_key DROP CONSTRAINT IF EXISTS fk_pvtkey_enckey_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'private_key', newobject := 'private_key', newmap := '{"ak_private_key":{"columns":["subject_key_identifier"],"def":"UNIQUE (subject_key_identifier)","deferrable":false,"deferred":false,"name":"ak_private_key","type":"u"},"pk_private_key":{"columns":["private_key_id"],"def":"PRIMARY KEY (private_key_id)","deferrable":false,"deferred":false,"name":"pk_private_key","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.private_key DROP CONSTRAINT IF EXISTS ak_private_key;
ALTER TABLE jazzhands.private_key DROP CONSTRAINT IF EXISTS pk_private_key;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."fk_pvtkey_enctype";
DROP INDEX IF EXISTS "jazzhands"."xif2private_key";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_private_key ON jazzhands.private_key;
DROP TRIGGER IF EXISTS trigger_audit_private_key ON jazzhands.private_key;
DROP FUNCTION IF EXISTS perform_audit_private_key();
DROP TRIGGER IF EXISTS trigger_pvtkey_ski_signed_validate ON jazzhands.private_key;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.private_key ALTER COLUMN "private_key_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.private_key_private_key_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.private_key_private_key_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'private_key', tags := ARRAY['table_private_key']);
---- BEGIN jazzhands_audit.private_key TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'private_key', tags := ARRAY['table_private_key']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'private_key', 'private_key');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'private_key');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.private_key DROP CONSTRAINT IF EXISTS private_key_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_private_key_ak_private_key";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_private_key_pk_private_key";
DROP INDEX IF EXISTS "jazzhands_audit"."private_key_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."private_key_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."private_key_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.private_key ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.private_key_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.private_key_seq;
---- DONE jazzhands_audit.private_key TEARDOWN


ALTER TABLE private_key RENAME TO private_key_v92;
ALTER TABLE jazzhands_audit.private_key RENAME TO private_key_v92;

CREATE TABLE jazzhands.private_key
(
	private_key_id	integer NOT NULL,
	private_key_encryption_type	varchar(50) NOT NULL,
	is_active	boolean NOT NULL,
	subject_key_identifier	varchar(255)  NULL,
	public_key_hash_id	integer  NULL,
	description	varchar(4096)  NULL,
	private_key	text NOT NULL,
	passphrase	varchar(255)  NULL,
	encryption_key_id	integer  NULL,
	external_id	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'private_key', false);
ALTER TABLE private_key
	ALTER COLUMN private_key_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE private_key
	ALTER is_active
	SET DEFAULT true;

INSERT INTO private_key (
	private_key_id,
	private_key_encryption_type,
	is_active,
	subject_key_identifier,
	public_key_hash_id,		-- new column (public_key_hash_id)
	description,		-- new column (description)
	private_key,
	passphrase,
	encryption_key_id,
	external_id,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	private_key_id,
	private_key_encryption_type,
	is_active,
	subject_key_identifier,
	NULL,		-- new column (public_key_hash_id)
	NULL,		-- new column (description)
	private_key,
	passphrase,
	encryption_key_id,
	NULL,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM private_key_v92;


INSERT INTO jazzhands_audit.private_key (
	private_key_id,
	private_key_encryption_type,
	is_active,
	subject_key_identifier,
	public_key_hash_id,		-- new column (public_key_hash_id)
	description,		-- new column (description)
	private_key,
	passphrase,
	encryption_key_id,
	external_id,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	private_key_id,
	private_key_encryption_type,
	is_active,
	subject_key_identifier,
	NULL,		-- new column (public_key_hash_id)
	NULL,		-- new column (description)
	private_key,
	passphrase,
	encryption_key_id,
	NULL,		-- new column (external_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.private_key_v92;

ALTER TABLE jazzhands.private_key
	ALTER is_active
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.private_key ADD CONSTRAINT ak_private_key UNIQUE (subject_key_identifier);
ALTER TABLE jazzhands.private_key ADD CONSTRAINT pk_private_key PRIMARY KEY (private_key_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.private_key IS 'Signed X509 Certificate';
COMMENT ON COLUMN jazzhands.private_key.private_key_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.private_key.private_key_encryption_type IS 'encryption tyof private key (rsa, dsa, ec, etc).  
';
COMMENT ON COLUMN jazzhands.private_key.is_active IS 'indicates certificate is in active use.  This is used by tools to decide how to show it; does not indicate revocation';
COMMENT ON COLUMN jazzhands.private_key.subject_key_identifier IS 'This column wil be dropped and should not be used by new code.';
COMMENT ON COLUMN jazzhands.private_key.public_key_hash_id IS 'Used to match private keys and x509 certificates fromoutside of the database.  This will eventualyl be dropped.';
COMMENT ON COLUMN jazzhands.private_key.private_key IS 'Textual representation of Certificate Private Key. Private Key is a component of X509 standard and is used for encryption.';
COMMENT ON COLUMN jazzhands.private_key.passphrase IS 'passphrase to decrypt key.  If encrypted, encryption_key_id indicates how to decrypt.';
COMMENT ON COLUMN jazzhands.private_key.encryption_key_id IS 'if set, encryption key information for decrypting passphrase.';
COMMENT ON COLUMN jazzhands.private_key.external_id IS 'opaque id used in remote system to identifty this object.  Used for syncing an authoritative copy.';
-- INDEXES
CREATE INDEX fk_pvtkey_enctype ON jazzhands.private_key USING btree (private_key_encryption_type);
CREATE INDEX xif2private_key ON jazzhands.private_key USING btree (encryption_key_id);
CREATE INDEX xifprivate_key_pubkey_hash ON jazzhands.private_key USING btree (public_key_hash_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between private_key and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_property_pval_private_key_id
	FOREIGN KEY (property_value_private_key_id) REFERENCES jazzhands.private_key(private_key_id);
-- consider FK between private_key and jazzhands.certificate_signing_request
ALTER TABLE jazzhands.certificate_signing_request
	ADD CONSTRAINT fk_pvtkey_csr
	FOREIGN KEY (private_key_id) REFERENCES jazzhands.private_key(private_key_id);
-- consider FK between private_key and jazzhands.x509_signed_certificate
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_pvtkey_x509crt
	FOREIGN KEY (private_key_id) REFERENCES jazzhands.private_key(private_key_id);

-- FOREIGN KEYS TO
-- consider FK private_key and val_private_key_encryption_type
ALTER TABLE jazzhands.private_key
	ADD CONSTRAINT fk_pctkey_enctype
	FOREIGN KEY (private_key_encryption_type) REFERENCES jazzhands.val_private_key_encryption_type(private_key_encryption_type);
-- consider FK private_key and public_key_hash
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.private_key
--	ADD CONSTRAINT fk_private_key_pubkey_hash
--	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);

-- consider FK private_key and encryption_key
ALTER TABLE jazzhands.private_key
	ADD CONSTRAINT fk_pvtkey_enckey_id
	FOREIGN KEY (encryption_key_id) REFERENCES jazzhands.encryption_key(encryption_key_id);

-- TRIGGERS
-- considering NEW jazzhands.pvtkey_ski_signed_validate
CREATE OR REPLACE FUNCTION jazzhands.pvtkey_ski_signed_validate()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ski	TEXT;
	id	INTEGER;
BEGIN
	SELECT	subject_key_identifier, id
	INTO	ski, id
	FROM	x509_signed_certificate x
	WHERE	x.private_key_id = NEW.private_key_id;

	IF FOUND AND ski != NEW.subject_key_identifier THEN
		RAISE EXCEPTION 'subject key identifier must match private key in x509_signing_certificate' USING ERRCODE = 'foreign_key_violation';
	END IF;

	IF FOUND AND id != NEW.public_key_hash_id THEN
		RAISE EXCEPTION 'public_key_hash_id must match in x509_signed_certificate_id and private_key' USING ERRCODE = 'foreign_key_violation';
	END IF;

	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.pvtkey_ski_signed_validate() FROM public;
CREATE CONSTRAINT TRIGGER trigger_pvtkey_ski_signed_validate AFTER UPDATE OF subject_key_identifier, public_key_hash_id ON jazzhands.private_key NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.pvtkey_ski_signed_validate();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('private_key');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for private_key  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'private_key');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'private_key');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'private_key');
DROP TABLE IF EXISTS private_key_v92;
DROP TABLE IF EXISTS jazzhands_audit.private_key_v92;
-- DONE DEALING WITH TABLE private_key (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('private_key');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old private_key failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('private_key');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new private_key failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to property
ALTER TABLE "jazzhands"."property" ALTER COLUMN "property_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."property_property_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".property_property_id_seq;
ALTER TABLE "jazzhands"."property" ALTER COLUMN "property_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME property_property_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to property_name_collection
ALTER TABLE "jazzhands"."property_name_collection" ALTER COLUMN "property_name_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."property_name_collection_property_name_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".property_name_collection_property_name_collection_id_seq;
ALTER TABLE "jazzhands"."property_name_collection" ALTER COLUMN "property_name_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME property_name_collection_property_name_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to pseudo_klogin
ALTER TABLE "jazzhands"."pseudo_klogin" ALTER COLUMN "pseudo_klogin_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."pseudo_klogin_pseudo_klogin_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".pseudo_klogin_pseudo_klogin_id_seq;
ALTER TABLE "jazzhands"."pseudo_klogin" ALTER COLUMN "pseudo_klogin_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME pseudo_klogin_pseudo_klogin_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE public_key_hash (jazzhands)
CREATE TABLE jazzhands.public_key_hash
(
	public_key_hash_id	integer NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'public_key_hash', true);
ALTER TABLE public_key_hash
	ALTER COLUMN public_key_hash_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.public_key_hash ADD CONSTRAINT pk_public_key_hash PRIMARY KEY (public_key_hash_id);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.public_key_hash.public_key_hash_id IS 'Used as a unique id that identifies hashes on the same public key.  This is primarily used to correlate private keys and x509 certicates.';
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between public_key_hash and jazzhands.private_key
ALTER TABLE jazzhands.private_key
	ADD CONSTRAINT fk_private_key_pubkey_hash
	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);
-- consider FK between public_key_hash and jazzhands.public_key_hash_hash
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.public_key_hash_hash
--	ADD CONSTRAINT fk_public_key_hash_hash_hash
--	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);

-- consider FK between public_key_hash and jazzhands.x509_signed_certificate
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.x509_signed_certificate
--	ADD CONSTRAINT fk_x509_signed_cert_pkhash
--	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);


-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('public_key_hash');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for public_key_hash  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'public_key_hash');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'public_key_hash');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'public_key_hash');
-- DONE DEALING WITH TABLE public_key_hash (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('public_key_hash');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old public_key_hash failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('public_key_hash');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new public_key_hash failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE public_key_hash_hash (jazzhands)
CREATE TABLE jazzhands.public_key_hash_hash
(
	public_key_hash_id	integer NOT NULL,
	x509_fingerprint_hash_algorighm	varchar(255) NOT NULL,
	calculated_hash	varchar(255) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'public_key_hash_hash', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.public_key_hash_hash ADD CONSTRAINT pk_public_key_hash_hash PRIMARY KEY (public_key_hash_id, x509_fingerprint_hash_algorighm);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.public_key_hash_hash.public_key_hash_id IS 'Used as a unique id that identifies hashes on the same public key.  This is primarily used to correlate private keys and x509 certicates.';
COMMENT ON COLUMN jazzhands.public_key_hash_hash.calculated_hash IS 'hashing algorithm run over the der form of the public key components, which are algorithm independent.';
-- INDEXES
CREATE INDEX xifpublic_key_hash_hash_algorithm ON jazzhands.public_key_hash_hash USING btree (x509_fingerprint_hash_algorighm);
CREATE INDEX xifpublic_key_hash_hash_hash ON jazzhands.public_key_hash_hash USING btree (public_key_hash_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK public_key_hash_hash and val_x509_fingerprint_hash_algorithm
ALTER TABLE jazzhands.public_key_hash_hash
	ADD CONSTRAINT fk_public_key_hash_hash_algorithm
	FOREIGN KEY (x509_fingerprint_hash_algorighm) REFERENCES jazzhands.val_x509_fingerprint_hash_algorithm(x509_fingerprint_hash_algorighm);
-- consider FK public_key_hash_hash and public_key_hash
ALTER TABLE jazzhands.public_key_hash_hash
	ADD CONSTRAINT fk_public_key_hash_hash_hash
	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('public_key_hash_hash');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for public_key_hash_hash  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'public_key_hash_hash');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'public_key_hash_hash');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'public_key_hash_hash');
-- DONE DEALING WITH TABLE public_key_hash_hash (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('public_key_hash_hash');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old public_key_hash_hash failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('public_key_hash_hash');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new public_key_hash_hash failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to rack
ALTER TABLE "jazzhands"."rack" ALTER COLUMN "rack_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."rack_rack_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".rack_rack_id_seq;
ALTER TABLE "jazzhands"."rack" ALTER COLUMN "rack_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME rack_rack_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to rack_location
ALTER TABLE "jazzhands"."rack_location" ALTER COLUMN "rack_location_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."rack_location_rack_location_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".rack_location_rack_location_id_seq;
ALTER TABLE "jazzhands"."rack_location" ALTER COLUMN "rack_location_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME rack_location_rack_location_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_health_check
ALTER TABLE "jazzhands"."service_endpoint_health_check" ALTER COLUMN "service_endpoint_health_check_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_endpoint_health_check_service_endpoint_health_check_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_endpoint_health_check_service_endpoint_health_check_seq;
ALTER TABLE "jazzhands"."service_endpoint_health_check" ALTER COLUMN "service_endpoint_health_check_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_endpoint_health_check_service_endpoint_health_check_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_provider_collection
ALTER TABLE "jazzhands"."service_endpoint_provider_collection" ALTER COLUMN "service_endpoint_provider_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_endpoint_provider_col_service_endpoint_provider_col_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_endpoint_provider_col_service_endpoint_provider_col_seq;
ALTER TABLE "jazzhands"."service_endpoint_provider_collection" ALTER COLUMN "service_endpoint_provider_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_endpoint_provider_col_service_endpoint_provider_col_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_provider_collection_service_endpoint_provider
ALTER TABLE "jazzhands"."service_endpoint_provider_collection_service_endpoint_provider" ALTER COLUMN "service_endpoint_provider_collection_id" DROP DEFAULT;
ALTER TABLE "jazzhands"."service_endpoint_provider_collection_service_endpoint_provider" ALTER COLUMN "service_endpoint_provider_id" DROP DEFAULT;
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_provider_service_instance
ALTER TABLE "jazzhands"."service_endpoint_provider_service_instance" ALTER COLUMN "service_endpoint_provider_service_instance_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_endpoint_provider_ser_service_endpoint_provider_ser_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_endpoint_provider_ser_service_endpoint_provider_ser_seq;
ALTER TABLE "jazzhands"."service_endpoint_provider_service_instance" ALTER COLUMN "service_endpoint_provider_service_instance_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_endpoint_provider_ser_service_endpoint_provider_ser_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_endpoint_service_sla
ALTER TABLE "jazzhands"."service_endpoint_service_sla" ALTER COLUMN "service_endpoint_service_sla_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_endpoint_service_sla_service_endpoint_service_sla_i_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_endpoint_service_sla_service_endpoint_service_sla_i_seq;
ALTER TABLE "jazzhands"."service_endpoint_service_sla" ALTER COLUMN "service_endpoint_service_sla_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_endpoint_service_sla_service_endpoint_service_sla_i_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_environment
ALTER TABLE "jazzhands"."service_environment" ALTER COLUMN "service_environment_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_environment_service_environment_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_environment_service_environment_id_seq;
ALTER TABLE "jazzhands"."service_environment" ALTER COLUMN "service_environment_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_environment_service_environment_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_environment_collection
ALTER TABLE "jazzhands"."service_environment_collection" ALTER COLUMN "service_environment_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_environment_collectio_service_environment_collectio_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_environment_collectio_service_environment_collectio_seq;
ALTER TABLE "jazzhands"."service_environment_collection" ALTER COLUMN "service_environment_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_environment_collectio_service_environment_collectio_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_instance
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_instance', 'service_instance');

-- FOREIGN KEYS FROM
ALTER TABLE service_endpoint_provider_service_instance DROP CONSTRAINT IF EXISTS fk_service_endpoint_provider_service_instance_siid;
ALTER TABLE service_instance_provided_feature DROP CONSTRAINT IF EXISTS fk_svc_inst_prov_feature_inst_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_instance DROP CONSTRAINT IF EXISTS fk_service_instance_dev_nblk;
ALTER TABLE jazzhands.service_instance DROP CONSTRAINT IF EXISTS fk_service_instance_svcversionid;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_instance', newobject := 'service_instance', newmap := '{"ak_svc_instance_device_id_version":{"columns":["device_id","service_version_id"],"def":"UNIQUE (device_id, service_version_id)","deferrable":false,"deferred":false,"name":"ak_svc_instance_device_id_version","type":"u"},"pk_service_instance":{"columns":["service_instance_id"],"def":"PRIMARY KEY (service_instance_id)","deferrable":false,"deferred":false,"name":"pk_service_instance","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_instance DROP CONSTRAINT IF EXISTS ak_svc_instance_device_id_version;
ALTER TABLE jazzhands.service_instance DROP CONSTRAINT IF EXISTS pk_service_instance;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_instance_dev_nblk";
DROP INDEX IF EXISTS "jazzhands"."xifservice_instance_svcversionid";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_instance ON jazzhands.service_instance;
DROP TRIGGER IF EXISTS trigger_audit_service_instance ON jazzhands.service_instance;
DROP FUNCTION IF EXISTS perform_audit_service_instance();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_instance ALTER COLUMN "service_instance_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_instance_service_instance_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_instance_service_instance_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_instance', tags := ARRAY['table_service_instance']);
---- BEGIN jazzhands_audit.service_instance TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_instance', tags := ARRAY['table_service_instance']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_instance', 'service_instance');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_instance');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_instance DROP CONSTRAINT IF EXISTS service_instance_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_instance_ak_svc_instance_device_id_version";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_instance_pk_service_instance";
DROP INDEX IF EXISTS "jazzhands_audit"."service_instance_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_instance_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_instance_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_instance ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_instance_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_instance_seq;
---- DONE jazzhands_audit.service_instance TEARDOWN


ALTER TABLE service_instance RENAME TO service_instance_v92;
ALTER TABLE jazzhands_audit.service_instance RENAME TO service_instance_v92;

CREATE TABLE jazzhands.service_instance
(
	service_instance_id	integer NOT NULL,
	device_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	service_environment_id	integer NOT NULL,
	netblock_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_instance', false);
ALTER TABLE service_instance
	ALTER COLUMN service_instance_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

INSERT INTO service_instance (
	service_instance_id,
	device_id,
	service_version_id,
	service_environment_id,		-- new column (service_environment_id)
	netblock_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_instance_id,
	device_id,
	service_version_id,
	NULL,		-- new column (service_environment_id)
	netblock_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_instance_v92;


INSERT INTO jazzhands_audit.service_instance (
	service_instance_id,
	device_id,
	service_version_id,
	service_environment_id,		-- new column (service_environment_id)
	netblock_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_instance_id,
	device_id,
	service_version_id,
	NULL,		-- new column (service_environment_id)
	netblock_id,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_instance_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_instance ADD CONSTRAINT ak_svc_instance_device_id_version UNIQUE (device_id, service_version_id);
ALTER TABLE jazzhands.service_instance ADD CONSTRAINT pk_service_instance PRIMARY KEY (service_instance_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_instance IS 'Model the presence of something that serves up a service on a device';
COMMENT ON COLUMN jazzhands.service_instance.service_version_id IS 'This is where a specific version of a service is mapped to a host';
-- INDEXES
CREATE INDEX xifservice_instance_dev_nblk ON jazzhands.service_instance USING btree (device_id, netblock_id);
CREATE INDEX xifservice_instance_service_env_id ON jazzhands.service_instance USING btree (service_environment_id);
CREATE INDEX xifservice_instance_svcversionid ON jazzhands.service_instance USING btree (service_version_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_instance and jazzhands.service_endpoint_provider_service_instance
ALTER TABLE jazzhands.service_endpoint_provider_service_instance
	ADD CONSTRAINT fk_service_endpoint_provider_service_instance_siid
	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;
-- consider FK between service_instance and jazzhands.service_instance_provided_feature
ALTER TABLE jazzhands.service_instance_provided_feature
	ADD CONSTRAINT fk_svc_inst_prov_feature_inst_id
	FOREIGN KEY (service_instance_id) REFERENCES jazzhands.service_instance(service_instance_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK service_instance and layer3_interface_netblock
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_dev_nblk
	FOREIGN KEY (device_id, netblock_id) REFERENCES jazzhands.layer3_interface_netblock(device_id, netblock_id) DEFERRABLE;
-- consider FK service_instance and service_environment
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_service_env_id
	FOREIGN KEY (service_environment_id) REFERENCES jazzhands.service_environment(service_environment_id);
-- consider FK service_instance and service_version
ALTER TABLE jazzhands.service_instance
	ADD CONSTRAINT fk_service_instance_svcversionid
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_instance');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_instance  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_instance');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_instance');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_instance');
DROP TABLE IF EXISTS service_instance_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_instance_v92;
-- DONE DEALING WITH TABLE service_instance (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_instance failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_instance failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_layer3_acl
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_layer3_acl', 'service_layer3_acl');

-- FOREIGN KEYS FROM
ALTER TABLE layer3_acl_rule DROP CONSTRAINT IF EXISTS fk_l3acl_rule_l3acl_service_depend_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_layer3_acl DROP CONSTRAINT IF EXISTS fk_service_l3acl_depend_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_layer3_acl', newobject := 'service_layer3_acl', newmap := '{"pk_service_layer3_acl":{"columns":["service_relationship_id"],"def":"PRIMARY KEY (service_relationship_id)","deferrable":false,"deferred":false,"name":"pk_service_layer3_acl","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_layer3_acl DROP CONSTRAINT IF EXISTS pk_service_layer3_acl;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_l3acl_depend_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_layer3_acl ON jazzhands.service_layer3_acl;
DROP TRIGGER IF EXISTS trigger_audit_service_layer3_acl ON jazzhands.service_layer3_acl;
DROP FUNCTION IF EXISTS perform_audit_service_layer3_acl();
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_layer3_acl', tags := ARRAY['table_service_layer3_acl']);
---- BEGIN jazzhands_audit.service_layer3_acl TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_layer3_acl', tags := ARRAY['table_service_layer3_acl']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_layer3_acl', 'service_layer3_acl');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_layer3_acl');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_layer3_acl DROP CONSTRAINT IF EXISTS service_layer3_acl_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_layer3_acl_pk_service_layer3_acl";
DROP INDEX IF EXISTS "jazzhands_audit"."service_layer3_acl_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_layer3_acl_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_layer3_acl_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_layer3_acl ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_layer3_acl_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_layer3_acl_seq;
---- DONE jazzhands_audit.service_layer3_acl TEARDOWN


ALTER TABLE service_layer3_acl RENAME TO service_layer3_acl_v92;
ALTER TABLE jazzhands_audit.service_layer3_acl RENAME TO service_layer3_acl_v92;

CREATE TABLE jazzhands.service_layer3_acl
(
	service_relationship_id	integer NOT NULL,
	description	varchar(4096)  NULL,
	is_enabled	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_layer3_acl', false);
ALTER TABLE service_layer3_acl
	ALTER is_enabled
	SET DEFAULT true;

INSERT INTO service_layer3_acl (
	service_relationship_id,		-- new column (service_relationship_id)
	description,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	NULL,		-- new column (service_relationship_id)
	description,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_layer3_acl_v92;


INSERT INTO jazzhands_audit.service_layer3_acl (
	service_relationship_id,		-- new column (service_relationship_id)
	description,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	NULL,		-- new column (service_relationship_id)
	description,
	is_enabled,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_layer3_acl_v92;

ALTER TABLE jazzhands.service_layer3_acl
	ALTER is_enabled
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_layer3_acl ADD CONSTRAINT pk_service_layer3_acl PRIMARY KEY (service_relationship_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_layer3_acl IS 'Foreign key enforcement to tie a service realtionship to acl rules and to enable/dsiable them.  This may go away in the future.';
-- INDEXES
CREATE UNIQUE INDEX xifservice_l3acl_relationship_id ON jazzhands.service_layer3_acl USING btree (service_relationship_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_layer3_acl and jazzhands.layer3_acl_rule
ALTER TABLE jazzhands.layer3_acl_rule
	ADD CONSTRAINT fk_l3acl_rule_l3acl_service_rship_id
	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_layer3_acl(service_relationship_id);

-- FOREIGN KEYS TO
-- consider FK service_layer3_acl and service_relationship
ALTER TABLE jazzhands.service_layer3_acl
	ADD CONSTRAINT fk_service_l3acl_relationship_id
	FOREIGN KEY (service_relationship_id) REFERENCES jazzhands.service_relationship(service_relationship_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_layer3_acl');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_layer3_acl  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_layer3_acl');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_layer3_acl');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_layer3_acl');
DROP TABLE IF EXISTS service_layer3_acl_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_layer3_acl_v92;
-- DONE DEALING WITH TABLE service_layer3_acl (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_layer3_acl');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_layer3_acl failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_layer3_acl');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_layer3_acl failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_software_repository
ALTER TABLE "jazzhands"."service_software_repository" ALTER COLUMN "software_artifact_repository_id" DROP DEFAULT;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_source_repository
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_source_repository', 'service_source_repository');

-- FOREIGN KEYS FROM
ALTER TABLE service_version_source_repository DROP CONSTRAINT IF EXISTS fk_svc_ver_src_repo_svc_src_repo_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_source_repository DROP CONSTRAINT IF EXISTS fk_service_source_repo_service_id;
ALTER TABLE jazzhands.service_source_repository DROP CONSTRAINT IF EXISTS fk_service_source_repo_srcrepoid;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_source_repository', newobject := 'service_source_repository', newmap := '{"ak_service_source_repository_source_repository":{"columns":["service_source_repository_id","source_repository_id"],"def":"UNIQUE (service_source_repository_id, source_repository_id)","deferrable":false,"deferred":false,"name":"ak_service_source_repository_source_repository","type":"u"},"ak_service_src_repo_svc_location":{"columns":["service_id","source_repository_id","service_source_control_purpose"],"def":"UNIQUE (service_id, source_repository_id, service_source_control_purpose)","deferrable":false,"deferred":false,"name":"ak_service_src_repo_svc_location","type":"u"},"pk_service_source_repository":{"columns":["service_source_repository_id"],"def":"PRIMARY KEY (service_source_repository_id)","deferrable":false,"deferred":false,"name":"pk_service_source_repository","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_source_repository DROP CONSTRAINT IF EXISTS ak_service_src_repo_svc_location;
ALTER TABLE jazzhands.service_source_repository DROP CONSTRAINT IF EXISTS pk_service_source_repository;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_source_repo_service_id";
DROP INDEX IF EXISTS "jazzhands"."xifservice_source_repo_srcrepoid";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_source_repository ON jazzhands.service_source_repository;
DROP TRIGGER IF EXISTS trigger_audit_service_source_repository ON jazzhands.service_source_repository;
DROP FUNCTION IF EXISTS perform_audit_service_source_repository();
DROP TRIGGER IF EXISTS trigger_service_source_repository_sanity ON jazzhands.service_source_repository;
DROP TRIGGER IF EXISTS trigger_service_source_repository_service_match_check ON jazzhands.service_source_repository;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_source_repository ALTER COLUMN "service_source_repository_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_source_repository_service_source_repository_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_source_repository_service_source_repository_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_source_repository', tags := ARRAY['table_service_source_repository']);
---- BEGIN jazzhands_audit.service_source_repository TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_source_repository', tags := ARRAY['table_service_source_repository']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_source_repository', 'service_source_repository');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_source_repository');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_source_repository DROP CONSTRAINT IF EXISTS service_source_repository_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_source_repository_ak_service_src_repo_svc_location";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_source_repository_pk_service_source_repository";
DROP INDEX IF EXISTS "jazzhands_audit"."service_source_repository_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_source_repository_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_source_repository_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_source_repository ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_source_repository_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_source_repository_seq;
---- DONE jazzhands_audit.service_source_repository TEARDOWN


ALTER TABLE service_source_repository RENAME TO service_source_repository_v92;
ALTER TABLE jazzhands_audit.service_source_repository RENAME TO service_source_repository_v92;

CREATE TABLE jazzhands.service_source_repository
(
	service_source_repository_id	integer NOT NULL,
	service_id	integer NOT NULL,
	source_repository_id	integer NOT NULL,
	service_source_repository_path_fragment	varchar(255)  NULL,
	service_source_control_purpose	varchar(255) NOT NULL,
	is_enabled	boolean NOT NULL,
	is_primary	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_source_repository', false);
ALTER TABLE service_source_repository
	ALTER COLUMN service_source_repository_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE service_source_repository
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE service_source_repository
	ALTER is_primary
	SET DEFAULT true;

INSERT INTO service_source_repository (
	service_source_repository_id,
	service_id,
	source_repository_id,		-- new column (source_repository_id)
	service_source_repository_path_fragment,		-- new column (service_source_repository_path_fragment)
	service_source_control_purpose,		-- new column (service_source_control_purpose)
	is_enabled,
	is_primary,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_source_repository_id,
	service_id,
	NULL,		-- new column (source_repository_id)
	NULL,		-- new column (service_source_repository_path_fragment)
	NULL,		-- new column (service_source_control_purpose)
	is_enabled,
	is_primary,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_source_repository_v92;


INSERT INTO jazzhands_audit.service_source_repository (
	service_source_repository_id,
	service_id,
	source_repository_id,		-- new column (source_repository_id)
	service_source_repository_path_fragment,		-- new column (service_source_repository_path_fragment)
	service_source_control_purpose,		-- new column (service_source_control_purpose)
	is_enabled,
	is_primary,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_source_repository_id,
	service_id,
	NULL,		-- new column (source_repository_id)
	NULL,		-- new column (service_source_repository_path_fragment)
	NULL,		-- new column (service_source_control_purpose)
	is_enabled,
	is_primary,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_source_repository_v92;

ALTER TABLE jazzhands.service_source_repository
	ALTER is_enabled
	SET DEFAULT true;
ALTER TABLE jazzhands.service_source_repository
	ALTER is_primary
	SET DEFAULT true;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_source_repository ADD CONSTRAINT ak_service_source_repository_source_repository UNIQUE (service_source_repository_id, source_repository_id);
ALTER TABLE jazzhands.service_source_repository ADD CONSTRAINT ak_service_src_repo_svc_location UNIQUE (service_id, source_repository_id, service_source_control_purpose);
ALTER TABLE jazzhands.service_source_repository ADD CONSTRAINT pk_service_source_repository PRIMARY KEY (service_source_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_source_repository IS 'Indicates SCM respositories where source code can be found.';
COMMENT ON COLUMN jazzhands.service_source_repository.service_source_repository_path_fragment IS 'optional path inside a checked out repository where source can be found';
-- INDEXES
CREATE INDEX xifservice_source_repo_service_id ON jazzhands.service_source_repository USING btree (service_id);
CREATE INDEX xifservice_source_repo_srcrepoid ON jazzhands.service_source_repository USING btree (source_repository_id);
CREATE INDEX xifservice_source_repository_src_control_purpose ON jazzhands.service_source_repository USING btree (service_source_control_purpose);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between service_source_repository and jazzhands.service_version_source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_version_source_repository
--	ADD CONSTRAINT fk_svc_ver_src_repo_svc_src_repo_id
--	FOREIGN KEY (service_source_repository_id, source_repository_id) REFERENCES jazzhands.service_source_repository(service_source_repository_id, source_repository_id) DEFERRABLE;


-- FOREIGN KEYS TO
-- consider FK service_source_repository and service
ALTER TABLE jazzhands.service_source_repository
	ADD CONSTRAINT fk_service_source_repo_service_id
	FOREIGN KEY (service_id) REFERENCES jazzhands.service(service_id) DEFERRABLE;
-- consider FK service_source_repository and source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_source_repository
--	ADD CONSTRAINT fk_service_source_repo_srcrepoid
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id) DEFERRABLE;

-- consider FK service_source_repository and val_service_source_control_purpose
ALTER TABLE jazzhands.service_source_repository
	ADD CONSTRAINT fk_service_source_repository_src_control_purpose
	FOREIGN KEY (service_source_control_purpose) REFERENCES jazzhands.val_service_source_control_purpose(service_source_control_purpose);

-- TRIGGERS
-- considering NEW jazzhands.service_source_repository_sanity
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_sanity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	--
	-- check to see if there's another primary, if so fail.
	---
	IF NEW.is_primary THEN
		SELECT count(*) INTO _tally
		FROM service_source_repository
		WHERE service_source_repository_id != NEW.service_source_repository_id
		AND service_id = NEW.service_id
		AND service_source_control_purpose = NEW.service_source_control_purpose
		AND service_source_repository_path_fragment IS NOT DISTINCT FROM NEW.service_source_repository_path_fragment
		AND is_primary;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'A primary source repository already exists for this service'
				USING ERRCODE = 'unique_violation';
		END IF;

	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_source_repository_sanity() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_source_repository_sanity AFTER INSERT OR UPDATE OF is_primary ON jazzhands.service_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_source_repository_sanity();

-- considering NEW jazzhands.service_source_repository_service_match_check
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	RAISE EXCEPTION 'Can not change service_id or service_source_repository_id due to missing trigger'
		USING HINT = 'need trigger that compares to service_version_source_repository_service_match_check';
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_source_repository_service_match_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_source_repository_service_match_check AFTER UPDATE OF service_id, service_source_repository_id ON jazzhands.service_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_source_repository_service_match_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_source_repository');
DROP TABLE IF EXISTS service_source_repository_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_source_repository_v92;
-- DONE DEALING WITH TABLE service_source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_version_artifact
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_version_artifact', 'service_version_artifact');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS fk_service_version_artifact_service_version_id;
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS fk_svc_ver_artifact_sw_art_repo_id;
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS fk_svc_version_artifact_algorithma;
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS fk_svc_version_artifact_name;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_version_artifact', newobject := 'service_version_artifact', newmap := '{"pk_service_version_artifact":{"columns":["service_version_id","software_artifact_name_id","software_artifact_repository_id","checksum_algorithm"],"def":"PRIMARY KEY (service_version_id, software_artifact_name_id, software_artifact_repository_id, checksum_algorithm)","deferrable":false,"deferred":false,"name":"pk_service_version_artifact","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS pk_service_version_artifact;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_version_artifact_service_version_id";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_ver_artifact_sw_art_repo_id";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_version_artifact_algorithma";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_version_artifact_name";
-- CHECK CONSTRAINTS, etc
ALTER TABLE jazzhands.service_version_artifact DROP CONSTRAINT IF EXISTS ckc_checksum_2053854841;
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_version_artifact ON jazzhands.service_version_artifact;
DROP TRIGGER IF EXISTS trigger_audit_service_version_artifact ON jazzhands.service_version_artifact;
DROP FUNCTION IF EXISTS perform_audit_service_version_artifact();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.service_version_artifact ALTER COLUMN "software_artifact_name_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.service_version_artifact_software_artifact_name_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.service_version_artifact_software_artifact_name_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_version_artifact', tags := ARRAY['table_service_version_artifact']);
---- BEGIN jazzhands_audit.service_version_artifact TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_version_artifact', tags := ARRAY['table_service_version_artifact']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_version_artifact', 'service_version_artifact');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_version_artifact');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_version_artifact DROP CONSTRAINT IF EXISTS service_version_artifact_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_service_version_artifact_pk_service_version_artifact";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_artifact_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_artifact_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_artifact_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_version_artifact ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_version_artifact_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_version_artifact_seq;
---- DONE jazzhands_audit.service_version_artifact TEARDOWN


ALTER TABLE service_version_artifact RENAME TO service_version_artifact_v92;
ALTER TABLE jazzhands_audit.service_version_artifact RENAME TO service_version_artifact_v92;

CREATE TABLE jazzhands.service_version_artifact
(
	service_version_id	integer NOT NULL,
	software_artifact_name_id	integer NOT NULL,
	software_artifact_repository_id	integer NOT NULL,
	checksum_algorithm	varchar(255) NOT NULL,
	checksum	varchar(255)  NULL,
	label	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_artifact', false);

INSERT INTO service_version_artifact (
	service_version_id,
	software_artifact_name_id,
	software_artifact_repository_id,
	checksum_algorithm,
	checksum,
	label,		-- new column (label)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_version_id,
	software_artifact_name_id,
	software_artifact_repository_id,
	checksum_algorithm,
	checksum,
	NULL,		-- new column (label)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_version_artifact_v92;


INSERT INTO jazzhands_audit.service_version_artifact (
	service_version_id,
	software_artifact_name_id,
	software_artifact_repository_id,
	checksum_algorithm,
	checksum,
	label,		-- new column (label)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_version_id,
	software_artifact_name_id,
	software_artifact_repository_id,
	checksum_algorithm,
	checksum,
	NULL,		-- new column (label)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_version_artifact_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_artifact ADD CONSTRAINT pk_service_version_artifact PRIMARY KEY (service_version_id, software_artifact_name_id, software_artifact_repository_id, checksum_algorithm);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_artifact IS 'Maps service versions to where to find their artifacts.';
-- INDEXES
CREATE INDEX xifservice_version_artifact_service_version_id ON jazzhands.service_version_artifact USING btree (service_version_id);
CREATE INDEX xifsvc_ver_artifact_sw_art_repo_id ON jazzhands.service_version_artifact USING btree (software_artifact_repository_id);
CREATE INDEX xifsvc_version_artifact_algorithma ON jazzhands.service_version_artifact USING btree (checksum_algorithm);
CREATE INDEX xifsvc_version_artifact_name ON jazzhands.service_version_artifact USING btree (software_artifact_name_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.service_version_artifact ADD CONSTRAINT ckc_checksum_2053854841
	CHECK (((((checksum_algorithm)::text = 'none'::text) AND (checksum IS NULL)) OR (((checksum_algorithm)::text <> 'none'::text) AND (checksum IS NOT NULL))));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_artifact and service_version
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_service_version_artifact_service_version_id
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_artifact and software_artifact_repository
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_ver_artifact_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK service_version_artifact and val_checksum_algorithm
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_version_artifact_algorithma
	FOREIGN KEY (checksum_algorithm) REFERENCES jazzhands.val_checksum_algorithm(checksum_algorithm) DEFERRABLE;
-- consider FK service_version_artifact and software_artifact_name
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_version_artifact_name
	FOREIGN KEY (software_artifact_name_id) REFERENCES jazzhands.software_artifact_name(software_artifact_name_id) DEFERRABLE;

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_artifact');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_artifact  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_artifact');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_artifact');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_artifact');
DROP TABLE IF EXISTS service_version_artifact_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_version_artifact_v92;
-- DONE DEALING WITH TABLE service_version_artifact (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_artifact');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_artifact failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_artifact');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_artifact failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_version_collection
ALTER TABLE "jazzhands"."service_version_collection" ALTER COLUMN "service_version_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."service_version_collection_service_version_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".service_version_collection_service_version_collection_id_seq;
ALTER TABLE "jazzhands"."service_version_collection" ALTER COLUMN "service_version_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME service_version_collection_service_version_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to service_version_software_artifact_repository
ALTER TABLE "jazzhands"."service_version_software_artifact_repository" ALTER COLUMN "software_artifact_repository_id" DROP DEFAULT;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE service_version_source_repository
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_version_source_repository', 'service_version_source_repository');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.service_version_source_repository DROP CONSTRAINT IF EXISTS fk_service_version_source_repository_svi;
ALTER TABLE jazzhands.service_version_source_repository DROP CONSTRAINT IF EXISTS fk_svc_ver_src_repo_svc_src_repo_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'service_version_source_repository', newobject := 'service_version_source_repository', newmap := '{"pk_service_version_source_repository":{"columns":["service_source_repository_id","service_version_id","source_repository_id"],"def":"PRIMARY KEY (service_source_repository_id, service_version_id, source_repository_id)","deferrable":false,"deferred":false,"name":"pk_service_version_source_repository","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_source_repository DROP CONSTRAINT IF EXISTS pk_service_version_source_repository;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifservice_version_source_repository_svi";
DROP INDEX IF EXISTS "jazzhands"."xifsvc_ver_src_repo_svc_src_repo_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_service_version_source_repository ON jazzhands.service_version_source_repository;
DROP TRIGGER IF EXISTS trigger_audit_service_version_source_repository ON jazzhands.service_version_source_repository;
DROP FUNCTION IF EXISTS perform_audit_service_version_source_repository();
DROP TRIGGER IF EXISTS trigger_service_version_source_repository_service_match_check ON jazzhands.service_version_source_repository;
-- default sequences associations and sequences (values rebuilt at end, if needed)
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'service_version_source_repository', tags := ARRAY['table_service_version_source_repository']);
---- BEGIN jazzhands_audit.service_version_source_repository TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'service_version_source_repository', tags := ARRAY['table_service_version_source_repository']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'service_version_source_repository', 'service_version_source_repository');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'service_version_source_repository');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.service_version_source_repository DROP CONSTRAINT IF EXISTS service_version_source_repository_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0service_version_source_repository_pk_service_version_sourc";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_source_repository_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_source_repository_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."service_version_source_repository_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.service_version_source_repository ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.service_version_source_repository_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_version_source_repository_seq;
---- DONE jazzhands_audit.service_version_source_repository TEARDOWN


ALTER TABLE service_version_source_repository RENAME TO service_version_source_repository_v92;
ALTER TABLE jazzhands_audit.service_version_source_repository RENAME TO service_version_source_repository_v92;

CREATE TABLE jazzhands.service_version_source_repository
(
	service_source_repository_id	integer NOT NULL,
	service_version_id	integer NOT NULL,
	source_repository_id	integer NOT NULL,
	source_repository_commit_id	integer  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'service_version_source_repository', false);

INSERT INTO service_version_source_repository (
	service_source_repository_id,
	service_version_id,
	source_repository_id,		-- new column (source_repository_id)
	source_repository_commit_id,		-- new column (source_repository_commit_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	service_source_repository_id,
	service_version_id,
	NULL,		-- new column (source_repository_id)
	NULL,		-- new column (source_repository_commit_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM service_version_source_repository_v92;


INSERT INTO jazzhands_audit.service_version_source_repository (
	service_source_repository_id,
	service_version_id,
	source_repository_id,		-- new column (source_repository_id)
	source_repository_commit_id,		-- new column (source_repository_commit_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	service_source_repository_id,
	service_version_id,
	NULL,		-- new column (source_repository_id)
	NULL,		-- new column (source_repository_commit_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.service_version_source_repository_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.service_version_source_repository ADD CONSTRAINT pk_service_version_source_repository PRIMARY KEY (service_source_repository_id, service_version_id, source_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.service_version_source_repository IS 'Where to find the exact source code to a specifc service version';
-- INDEXES
CREATE INDEX xif4service_version_source_repository ON jazzhands.service_version_source_repository USING btree (service_source_repository_id, source_repository_id);
CREATE INDEX xifservice_version_source_repo_src_repo_commit ON jazzhands.service_version_source_repository USING btree (source_repository_commit_id, source_repository_id);
CREATE INDEX xifservice_version_source_repository_svi ON jazzhands.service_version_source_repository USING btree (service_version_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK service_version_source_repository and source_repository_commit
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.service_version_source_repository
--	ADD CONSTRAINT fk_service_version_source_repo_src_repo_commit
--	FOREIGN KEY (source_repository_commit_id, source_repository_id) REFERENCES jazzhands.source_repository_commit(source_repository_commit_id, source_repository_id);

-- consider FK service_version_source_repository and service_version
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_service_version_source_repository_svi
	FOREIGN KEY (service_version_id) REFERENCES jazzhands.service_version(service_version_id) DEFERRABLE;
-- consider FK service_version_source_repository and service_source_repository
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_svc_ver_src_repo_svc_src_repo_id
	FOREIGN KEY (service_source_repository_id, source_repository_id) REFERENCES jazzhands.service_source_repository(service_source_repository_id, source_repository_id) DEFERRABLE;

-- TRIGGERS
-- considering NEW jazzhands.service_version_source_repository_service_match_check
CREATE OR REPLACE FUNCTION jazzhands.service_version_source_repository_service_match_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_source_repository
	WHERE service_source_repository_id = NEW.service_source_repository_id
	AND service_id = (SELECT service_id FROM service_version WHERE service_version_id = NEW.service_version_id);

	IF NOT FOUND THEN
		RAISE EXCEPTION 'source repository is not associted with the service'
			USING ERRCODE = 'invalid_parameter_value',
			HINT = 'consider adding a row to service_source_repository';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.service_version_source_repository_service_match_check() FROM public;
CREATE CONSTRAINT TRIGGER trigger_service_version_source_repository_service_match_check AFTER INSERT OR UPDATE OF service_version_id, service_source_repository_id ON jazzhands.service_version_source_repository NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_version_source_repository_service_match_check();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('service_version_source_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for service_version_source_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'service_version_source_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'service_version_source_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'service_version_source_repository');
DROP TABLE IF EXISTS service_version_source_repository_v92;
DROP TABLE IF EXISTS jazzhands_audit.service_version_source_repository_v92;
-- DONE DEALING WITH TABLE service_version_source_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old service_version_source_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('service_version_source_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new service_version_source_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to shared_netblock
ALTER TABLE "jazzhands"."shared_netblock" ALTER COLUMN "shared_netblock_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."shared_netblock_shared_netblock_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".shared_netblock_shared_netblock_id_seq;
ALTER TABLE "jazzhands"."shared_netblock" ALTER COLUMN "shared_netblock_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME shared_netblock_shared_netblock_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to slot
ALTER TABLE "jazzhands"."slot" ALTER COLUMN "slot_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."slot_slot_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".slot_slot_id_seq;
ALTER TABLE "jazzhands"."slot" ALTER COLUMN "slot_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME slot_slot_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to slot_type
ALTER TABLE "jazzhands"."slot_type" ALTER COLUMN "slot_type_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."slot_type_slot_type_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".slot_type_slot_type_id_seq;
ALTER TABLE "jazzhands"."slot_type" ALTER COLUMN "slot_type_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME slot_type_slot_type_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to software_artifact_name
ALTER TABLE "jazzhands"."software_artifact_name" ALTER COLUMN "software_artifact_name_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."software_artifact_name_software_artifact_name_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".software_artifact_name_software_artifact_name_id_seq;
ALTER TABLE "jazzhands"."software_artifact_name" ALTER COLUMN "software_artifact_name_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME software_artifact_name_software_artifact_name_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE software_artifact_repository
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'software_artifact_repository', 'software_artifact_repository');

-- FOREIGN KEYS FROM
ALTER TABLE service_software_repository DROP CONSTRAINT IF EXISTS fk_service_software_repository_sw_pkg_repo_id;
ALTER TABLE service_version_software_artifact_repository DROP CONSTRAINT IF EXISTS fk_service_version_software_sw_atfict_repo_id;
ALTER TABLE software_artifact_repository_uri DROP CONSTRAINT IF EXISTS fk_software_artifact_repo_loc_sw_art_repo_id;
ALTER TABLE software_artifact_repository_relation DROP CONSTRAINT IF EXISTS fk_software_artifact_repository_relation_repository;
ALTER TABLE software_artifact_repository_relation DROP CONSTRAINT IF EXISTS fk_software_artifact_repository_relation_repository_other;
ALTER TABLE service_version_artifact DROP CONSTRAINT IF EXISTS fk_svc_ver_artifact_sw_art_repo_id;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.software_artifact_repository DROP CONSTRAINT IF EXISTS fk_software_artifact_repository_location_pkg_repo_id;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'software_artifact_repository', newobject := 'software_artifact_repository', newmap := '{"ak_sw_artifcate_repo_system_id_name":{"columns":["software_artifact_repository_name","software_artifact_provider_id"],"def":"UNIQUE (software_artifact_provider_id, software_artifact_repository_name)","deferrable":false,"deferred":false,"name":"ak_sw_artifcate_repo_system_id_name","type":"u"},"pk_software_artifact_repository":{"columns":["software_artifact_repository_id"],"def":"PRIMARY KEY (software_artifact_repository_id)","deferrable":false,"deferred":false,"name":"pk_software_artifact_repository","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository DROP CONSTRAINT IF EXISTS ak_sw_artifcate_repo_system_id_name;
ALTER TABLE jazzhands.software_artifact_repository DROP CONSTRAINT IF EXISTS pk_software_artifact_repository;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xifsoftware_artifact_repository_location_pkg_repo_id";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_software_artifact_repository ON jazzhands.software_artifact_repository;
DROP TRIGGER IF EXISTS trigger_audit_software_artifact_repository ON jazzhands.software_artifact_repository;
DROP FUNCTION IF EXISTS perform_audit_software_artifact_repository();
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.software_artifact_repository ALTER COLUMN "software_artifact_repository_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.software_artifact_repository_software_artifact_repository_i_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.software_artifact_repository_software_artifact_repository_i_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'software_artifact_repository', tags := ARRAY['table_software_artifact_repository']);
---- BEGIN jazzhands_audit.software_artifact_repository TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'software_artifact_repository', tags := ARRAY['table_software_artifact_repository']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'software_artifact_repository', 'software_artifact_repository');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'software_artifact_repository');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.software_artifact_repository DROP CONSTRAINT IF EXISTS software_artifact_repository_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_0software_artifact_repository_pk_software_artifact_reposito";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_1software_artifact_repository_ak_sw_artifcate_repo_system_i";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."software_artifact_repository_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.software_artifact_repository ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.software_artifact_repository_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.software_artifact_repository_seq;
---- DONE jazzhands_audit.software_artifact_repository TEARDOWN


ALTER TABLE software_artifact_repository RENAME TO software_artifact_repository_v92;
ALTER TABLE jazzhands_audit.software_artifact_repository RENAME TO software_artifact_repository_v92;

CREATE TABLE jazzhands.software_artifact_repository
(
	software_artifact_repository_id	integer NOT NULL,
	software_artifact_repository_name	varchar(255) NOT NULL,
	software_artifact_provider_id	integer NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'software_artifact_repository', false);
ALTER TABLE software_artifact_repository
	ALTER COLUMN software_artifact_repository_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

INSERT INTO software_artifact_repository (
	software_artifact_repository_id,
	software_artifact_repository_name,
	software_artifact_provider_id,		-- new column (software_artifact_provider_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	software_artifact_repository_id,
	software_artifact_repository_name,
	NULL,		-- new column (software_artifact_provider_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM software_artifact_repository_v92;


INSERT INTO jazzhands_audit.software_artifact_repository (
	software_artifact_repository_id,
	software_artifact_repository_name,
	software_artifact_provider_id,		-- new column (software_artifact_provider_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	software_artifact_repository_id,
	software_artifact_repository_name,
	NULL,		-- new column (software_artifact_provider_id)
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.software_artifact_repository_v92;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.software_artifact_repository ADD CONSTRAINT ak_sw_artifcate_repo_system_id_name UNIQUE (software_artifact_provider_id, software_artifact_repository_name);
ALTER TABLE jazzhands.software_artifact_repository ADD CONSTRAINT pk_software_artifact_repository PRIMARY KEY (software_artifact_repository_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.software_artifact_repository IS 'Repositories inside artifact systems that actually provide artifacts for installation';
-- INDEXES
CREATE INDEX xifsw_artifact_repository_provider_id ON jazzhands.software_artifact_repository USING btree (software_artifact_provider_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between software_artifact_repository and jazzhands.service_software_repository
ALTER TABLE jazzhands.service_software_repository
	ADD CONSTRAINT fk_service_software_repository_sw_pkg_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.service_version_software_artifact_repository
ALTER TABLE jazzhands.service_version_software_artifact_repository
	ADD CONSTRAINT fk_service_version_software_sw_atfict_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_uri
ALTER TABLE jazzhands.software_artifact_repository_uri
	ADD CONSTRAINT fk_software_artifact_repo_loc_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_relation
ALTER TABLE jazzhands.software_artifact_repository_relation
	ADD CONSTRAINT fk_software_artifact_repository_relation_repository
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.software_artifact_repository_relation
ALTER TABLE jazzhands.software_artifact_repository_relation
	ADD CONSTRAINT fk_software_artifact_repository_relation_repository_other
	FOREIGN KEY (related_software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;
-- consider FK between software_artifact_repository and jazzhands.service_version_artifact
ALTER TABLE jazzhands.service_version_artifact
	ADD CONSTRAINT fk_svc_ver_artifact_sw_art_repo_id
	FOREIGN KEY (software_artifact_repository_id) REFERENCES jazzhands.software_artifact_repository(software_artifact_repository_id) DEFERRABLE;

-- FOREIGN KEYS TO
-- consider FK software_artifact_repository and software_artifact_provider
ALTER TABLE jazzhands.software_artifact_repository
	ADD CONSTRAINT fk_sw_artifact_repository_provider_id
	FOREIGN KEY (software_artifact_provider_id) REFERENCES jazzhands.software_artifact_provider(software_artifact_provider_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('software_artifact_repository');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for software_artifact_repository  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'software_artifact_repository');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'software_artifact_repository');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'software_artifact_repository');
DROP TABLE IF EXISTS software_artifact_repository_v92;
DROP TABLE IF EXISTS jazzhands_audit.software_artifact_repository_v92;
-- DONE DEALING WITH TABLE software_artifact_repository (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('software_artifact_repository');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new software_artifact_repository failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository_commit (jazzhands)
CREATE TABLE jazzhands.source_repository_commit
(
	source_repository_commit_id	integer NOT NULL,
	source_repository_id	integer NOT NULL,
	reference_name	varchar(255) NOT NULL,
	commit_hash	varchar(255) NOT NULL,
	commit_timestamp	timestamp without time zone NOT NULL,
	is_branch	boolean NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_commit', true);
ALTER TABLE source_repository_commit
	ALTER COLUMN source_repository_commit_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_commit ADD CONSTRAINT ak_source_repositroy_commit_source_repository UNIQUE (source_repository_commit_id, source_repository_id);
ALTER TABLE jazzhands.source_repository_commit ADD CONSTRAINT ak_src_repo_commit_src_repo_id_sybolic_identifier UNIQUE (source_repository_id, reference_name);
ALTER TABLE jazzhands.source_repository_commit ADD CONSTRAINT pk_source_repository_commit PRIMARY KEY (source_repository_commit_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifsrc_repo_commit_src_repo_id ON jazzhands.source_repository_commit USING btree (source_repository_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository_commit and jazzhands.service_version_source_repository
ALTER TABLE jazzhands.service_version_source_repository
	ADD CONSTRAINT fk_service_version_source_repo_src_repo_commit
	FOREIGN KEY (source_repository_commit_id, source_repository_id) REFERENCES jazzhands.source_repository_commit(source_repository_commit_id, source_repository_id);

-- FOREIGN KEYS TO
-- consider FK source_repository_commit and source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.source_repository_commit
--	ADD CONSTRAINT fk_src_repo_commit_src_repo_id
--	FOREIGN KEY (source_repository_id) REFERENCES jazzhands.source_repository(source_repository_id);


-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_commit');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_commit  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_commit');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_commit');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_commit');
-- DONE DEALING WITH TABLE source_repository_commit (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_commit');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_commit failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_commit');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_commit failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository_project (jazzhands)
CREATE TABLE jazzhands.source_repository_project
(
	source_repository_project_id	integer NOT NULL,
	source_repository_provider_id	integer NOT NULL,
	source_repository_project_name	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_project', true);
ALTER TABLE source_repository_project
	ALTER COLUMN source_repository_project_id
	ADD GENERATED BY DEFAULT AS IDENTITY;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_project ADD CONSTRAINT ak_source_repository_project__id_provider_id UNIQUE (source_repository_project_id, source_repository_provider_id);
ALTER TABLE jazzhands.source_repository_project ADD CONSTRAINT ak_source_repository_project_name_provider_id UNIQUE (source_repository_provider_id, source_repository_project_name);
ALTER TABLE jazzhands.source_repository_project ADD CONSTRAINT pk_source_repository_project PRIMARY KEY (source_repository_project_id);

-- Table/Column Comments
-- INDEXES
CREATE INDEX xifsrc_repo_project_provider_id ON jazzhands.source_repository_project USING btree (source_repository_provider_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between source_repository_project and jazzhands.source_repository
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.source_repository_provider
--	ADD CONSTRAINT fk_src_repo_project_id
--	FOREIGN KEY (source_repository_project_id, source_repository_provider_id) REFERENCES jazzhands.source_repository_project(source_repository_project_id, source_repository_provider_id);


-- FOREIGN KEYS TO
-- consider FK source_repository_project and source_repository_provider
ALTER TABLE jazzhands.source_repository_project
	ADD CONSTRAINT fk_src_repo_project_provider_id
	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_project');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_project  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_project');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_project');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_project');
-- DONE DEALING WITH TABLE source_repository_project (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_project');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_project failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_project');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_project failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE source_repository_provider_uri_template (jazzhands)
CREATE TABLE jazzhands.source_repository_provider_uri_template
(
	source_repository_provider_id	integer NOT NULL,
	source_repository_uri_purpose	varchar(50) NOT NULL,
	source_repository_protocol	varchar(255) NOT NULL,
	source_repository_uri	varchar(512)  NULL,
	service_endpoint_id	integer  NULL,
	source_repository_template_path_fragment	varchar(512) NOT NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'source_repository_provider_uri_template', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.source_repository_provider_uri_template ADD CONSTRAINT pk_source_repository_provider_uri_template PRIMARY KEY (source_repository_provider_id, source_repository_uri_purpose, source_repository_protocol);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.source_repository_provider_uri_template.source_repository_uri_purpose IS 'what the uri is used for';
COMMENT ON COLUMN jazzhands.source_repository_provider_uri_template.source_repository_uri IS 'Only one of service_repostiroy or service_endpoint_id can be set and service_repository_uri will likely go away.';
COMMENT ON COLUMN jazzhands.source_repository_provider_uri_template.service_endpoint_id IS 'Must be set if source_repository_uri is not set. This will eventually replace that column completely.';
-- INDEXES
CREATE INDEX xifsrc_repo_provider_tempate_protocol ON jazzhands.source_repository_provider_uri_template USING btree (source_repository_protocol);
CREATE INDEX xifsrc_repo_uri_src_repo_id ON jazzhands.source_repository_provider_uri_template USING btree (source_repository_provider_id);
CREATE INDEX xifsrc_repo_uri_uri_purpose ON jazzhands.source_repository_provider_uri_template USING btree (source_repository_uri_purpose);
CREATE INDEX xifsvc_endpoint_source_repo_uri ON jazzhands.source_repository_provider_uri_template USING btree (service_endpoint_id);

-- CHECK CONSTRAINTS
ALTER TABLE jazzhands.source_repository_provider_uri_template ADD CONSTRAINT ckc_valid_uri_1566262291
	CHECK (((source_repository_uri)::text ~ '^([a-z][-_a-z0-9]*)://[^\s/$.?#].[^\s]*$'::text));

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK source_repository_provider_uri_template and val_source_repository_protocol
ALTER TABLE jazzhands.source_repository_provider_uri_template
	ADD CONSTRAINT fk_src_repo_provider_tempate_protocol
	FOREIGN KEY (source_repository_protocol) REFERENCES jazzhands.val_source_repository_protocol(source_repository_protocol);
-- consider FK source_repository_provider_uri_template and source_repository_provider
ALTER TABLE jazzhands.source_repository_provider_uri_template
	ADD CONSTRAINT fk_src_repo_uri_src_repo_id
	FOREIGN KEY (source_repository_provider_id) REFERENCES jazzhands.source_repository_provider(source_repository_provider_id) DEFERRABLE;
-- consider FK source_repository_provider_uri_template and val_source_repository_uri_purpose
ALTER TABLE jazzhands.source_repository_provider_uri_template
	ADD CONSTRAINT fk_src_repo_uri_uri_purpose
	FOREIGN KEY (source_repository_uri_purpose) REFERENCES jazzhands.val_source_repository_uri_purpose(source_repository_uri_purpose) DEFERRABLE;
-- consider FK source_repository_provider_uri_template and service_endpoint
ALTER TABLE jazzhands.source_repository_provider_uri_template
	ADD CONSTRAINT fk_svc_endpoint_source_repo_uri
	FOREIGN KEY (service_endpoint_id) REFERENCES jazzhands.service_endpoint(service_endpoint_id);

-- TRIGGERS
-- considering NEW jazzhands.source_repository_provider_uri_template_endpoint_enforce
CREATE OR REPLACE FUNCTION jazzhands.source_repository_provider_uri_template_endpoint_enforce()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.source_repository_uri IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either source_repository_uri or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.source_repository_uri IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of source_repository_uri or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.source_repository_provider_uri_template_endpoint_enforce() FROM public;
CREATE CONSTRAINT TRIGGER trigger_source_repository_provider_uri_template_endpoint_enforc AFTER INSERT OR UPDATE OF source_repository_uri, service_endpoint_id ON jazzhands.source_repository_provider_uri_template NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.source_repository_provider_uri_template_endpoint_enforce();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('source_repository_provider_uri_template');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for source_repository_provider_uri_template  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'source_repository_provider_uri_template');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'source_repository_provider_uri_template');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'source_repository_provider_uri_template');
-- DONE DEALING WITH TABLE source_repository_provider_uri_template (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_provider_uri_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old source_repository_provider_uri_template failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('source_repository_provider_uri_template');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new source_repository_provider_uri_template failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to ssh_key
ALTER TABLE "jazzhands"."ssh_key" ALTER COLUMN "ssh_key_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."ssh_key_ssh_key_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".ssh_key_ssh_key_id_seq;
ALTER TABLE "jazzhands"."ssh_key" ALTER COLUMN "ssh_key_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME ssh_key_ssh_key_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to static_route
ALTER TABLE "jazzhands"."static_route" ALTER COLUMN "static_route_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."static_route_static_route_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".static_route_static_route_id_seq;
ALTER TABLE "jazzhands"."static_route" ALTER COLUMN "static_route_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME static_route_static_route_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to static_route_template
ALTER TABLE "jazzhands"."static_route_template" ALTER COLUMN "static_route_template_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."static_route_template_static_route_template_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".static_route_template_static_route_template_id_seq;
ALTER TABLE "jazzhands"."static_route_template" ALTER COLUMN "static_route_template_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME static_route_template_static_route_template_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to ticketing_system
ALTER TABLE "jazzhands"."ticketing_system" ALTER COLUMN "ticketing_system_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."ticketing_system_ticketing_system_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".ticketing_system_ticketing_system_id_seq;
ALTER TABLE "jazzhands"."ticketing_system" ALTER COLUMN "ticketing_system_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME ticketing_system_ticketing_system_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to token
ALTER TABLE "jazzhands"."token" ALTER COLUMN "token_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."token_token_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".token_token_id_seq;
ALTER TABLE "jazzhands"."token" ALTER COLUMN "token_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME token_token_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to token_collection
ALTER TABLE "jazzhands"."token_collection" ALTER COLUMN "token_collection_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."token_collection_token_collection_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".token_collection_token_collection_id_seq;
ALTER TABLE "jazzhands"."token_collection" ALTER COLUMN "token_collection_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME token_collection_token_collection_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Processing minor chagnes to volume_group
ALTER TABLE "jazzhands"."volume_group" ALTER COLUMN "volume_group_id" DROP DEFAULT;
ALTER SEQUENCE "jazzhands"."volume_group_volume_group_id_seq" OWNED BY NONE;
DROP SEQUENCE IF EXISTS "jazzhands".volume_group_volume_group_id_seq;
ALTER TABLE "jazzhands"."volume_group" ALTER COLUMN "volume_group_id" ADD GENERATED BY DEFAULT AS IDENTITY ( SEQUENCE NAME volume_group_volume_group_id_seq );
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE x509_signed_certificate
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands', 'x509_signed_certificate', 'x509_signed_certificate');

-- FOREIGN KEYS FROM
ALTER TABLE x509_key_usage_default DROP CONSTRAINT IF EXISTS fk_keyusg_deflt_x509crtid;
ALTER TABLE property DROP CONSTRAINT IF EXISTS fk_prop_x509_crt_id;
ALTER TABLE service_endpoint_provider_shared_netblock_layer3_interface DROP CONSTRAINT IF EXISTS fk_service_endpoint_prov_x509_certificate_x509id;
ALTER TABLE service_endpoint_x509_certificate DROP CONSTRAINT IF EXISTS fk_service_endpoint_x509_certificate_x509id;
ALTER TABLE x509_key_usage_attribute DROP CONSTRAINT IF EXISTS fk_x509_certificate;

-- FOREIGN KEYS TO
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_csr_pvtkeyid;
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_pvtkey_x509crt;
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_x509_cert_cert;
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_x509_cert_revoc_reason;
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS fk_x509crtid_crttype;

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands', object := 'x509_signed_certificate', newobject := 'x509_signed_certificate', newmap := '{"ak_x509_cert_cert_ca_ser":{"columns":["signing_cert_id","x509_ca_cert_serial_number"],"def":"UNIQUE (signing_cert_id, x509_ca_cert_serial_number)","deferrable":false,"deferred":false,"name":"ak_x509_cert_cert_ca_ser","type":"u"},"pk_x509_certificate":{"columns":["x509_signed_certificate_id"],"def":"PRIMARY KEY (x509_signed_certificate_id)","deferrable":false,"deferred":false,"name":"pk_x509_certificate","type":"p"}}');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS ak_x509_cert_cert_ca_ser;
ALTER TABLE jazzhands.x509_signed_certificate DROP CONSTRAINT IF EXISTS pk_x509_certificate;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands"."xif3x509_signed_certificate";
DROP INDEX IF EXISTS "jazzhands"."xif4x509_signed_certificate";
DROP INDEX IF EXISTS "jazzhands"."xif5x509_signed_certificate";
DROP INDEX IF EXISTS "jazzhands"."xif6x509_signed_certificate";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
DROP TRIGGER IF EXISTS trig_userlog_x509_signed_certificate ON jazzhands.x509_signed_certificate;
DROP TRIGGER IF EXISTS trigger_audit_x509_signed_certificate ON jazzhands.x509_signed_certificate;
DROP FUNCTION IF EXISTS perform_audit_x509_signed_certificate();
DROP TRIGGER IF EXISTS trigger_x509_signed_ski_pvtkey_validate ON jazzhands.x509_signed_certificate;
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands.x509_signed_certificate ALTER COLUMN "x509_signed_certificate_id" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands.x509_signed_certificate_x509_signed_certificate_id_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands.x509_signed_certificate_x509_signed_certificate_id_seq;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands', object := 'x509_signed_certificate', tags := ARRAY['table_x509_signed_certificate']);
---- BEGIN jazzhands_audit.x509_signed_certificate TEARDOWN
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_audit', object := 'x509_signed_certificate', tags := ARRAY['table_x509_signed_certificate']);
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_audit', 'x509_signed_certificate', 'x509_signed_certificate');

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- EXTRA-SCHEMA constraints
SELECT schema_support.save_constraint_for_replay(schema := 'jazzhands_audit',  object := 'x509_signed_certificate');

-- PRIMARY and ALTERNATE KEYS
ALTER TABLE jazzhands_audit.x509_signed_certificate DROP CONSTRAINT IF EXISTS x509_signed_certificate_pkey;
-- INDEXES
DROP INDEX IF EXISTS "jazzhands_audit"."aud_x509_signed_certificate_ak_x509_cert_cert_ca_ser";
DROP INDEX IF EXISTS "jazzhands_audit"."aud_x509_signed_certificate_pk_x509_certificate";
DROP INDEX IF EXISTS "jazzhands_audit"."x509_signed_certificate_aud#realtime_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."x509_signed_certificate_aud#timestamp_idx";
DROP INDEX IF EXISTS "jazzhands_audit"."x509_signed_certificate_aud#txid_idx";
-- CHECK CONSTRAINTS, etc
-- TRIGGERS, etc
-- default sequences associations and sequences (values rebuilt at end, if needed)
ALTER TABLE IF EXISTS jazzhands_audit.x509_signed_certificate ALTER COLUMN "aud#seq" DROP DEFAULT;
ALTER SEQUENCE IF EXISTS jazzhands_audit.x509_signed_certificate_seq OWNED BY NONE;
DROP SEQUENCE IF EXISTS jazzhands_audit.x509_signed_certificate_seq;
---- DONE jazzhands_audit.x509_signed_certificate TEARDOWN


ALTER TABLE x509_signed_certificate RENAME TO x509_signed_certificate_v92;
ALTER TABLE jazzhands_audit.x509_signed_certificate RENAME TO x509_signed_certificate_v92;

CREATE TABLE jazzhands.x509_signed_certificate
(
	x509_signed_certificate_id	integer NOT NULL,
	x509_certificate_type	varchar(50)  NULL,
	subject	varchar(255) NOT NULL,
	friendly_name	varchar(255) NOT NULL,
	subject_key_identifier	varchar(255)  NULL,
	public_key_hash_id	integer  NULL,
	description	varchar(4096)  NULL,
	is_active	boolean NOT NULL,
	is_certificate_authority	boolean NOT NULL,
	signing_cert_id	integer  NULL,
	x509_ca_cert_serial_number	numeric  NULL,
	public_key	text  NULL,
	private_key_id	integer  NULL,
	certificate_signing_request_id	integer  NULL,
	valid_from	timestamp without time zone NOT NULL,
	valid_to	timestamp without time zone NOT NULL,
	x509_revocation_date	timestamp with time zone  NULL,
	x509_revocation_reason	varchar(50)  NULL,
	ocsp_uri	varchar(255)  NULL,
	crl_uri	varchar(255)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'x509_signed_certificate', false);
ALTER TABLE x509_signed_certificate
	ALTER COLUMN x509_signed_certificate_id
	ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE x509_signed_certificate
	ALTER x509_certificate_type
	SET DEFAULT 'default'::character varying;
ALTER TABLE x509_signed_certificate
	ALTER is_active
	SET DEFAULT true;
ALTER TABLE x509_signed_certificate
	ALTER is_certificate_authority
	SET DEFAULT false;

INSERT INTO x509_signed_certificate (
	x509_signed_certificate_id,
	x509_certificate_type,
	subject,
	friendly_name,
	subject_key_identifier,
	public_key_hash_id,		-- new column (public_key_hash_id)
	description,		-- new column (description)
	is_active,
	is_certificate_authority,
	signing_cert_id,
	x509_ca_cert_serial_number,
	public_key,
	private_key_id,
	certificate_signing_request_id,
	valid_from,
	valid_to,
	x509_revocation_date,
	x509_revocation_reason,
	ocsp_uri,
	crl_uri,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT
	x509_signed_certificate_id,
	x509_certificate_type,
	subject,
	friendly_name,
	subject_key_identifier,
	NULL,		-- new column (public_key_hash_id)
	NULL,		-- new column (description)
	is_active,
	is_certificate_authority,
	signing_cert_id,
	x509_ca_cert_serial_number,
	public_key,
	private_key_id,
	certificate_signing_request_id,
	valid_from,
	valid_to,
	x509_revocation_date,
	x509_revocation_reason,
	ocsp_uri,
	crl_uri,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM x509_signed_certificate_v92;


INSERT INTO jazzhands_audit.x509_signed_certificate (
	x509_signed_certificate_id,
	x509_certificate_type,
	subject,
	friendly_name,
	subject_key_identifier,
	public_key_hash_id,		-- new column (public_key_hash_id)
	description,		-- new column (description)
	is_active,
	is_certificate_authority,
	signing_cert_id,
	x509_ca_cert_serial_number,
	public_key,
	private_key_id,
	certificate_signing_request_id,
	valid_from,
	valid_to,
	x509_revocation_date,
	x509_revocation_reason,
	ocsp_uri,
	crl_uri,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
) SELECT
	x509_signed_certificate_id,
	x509_certificate_type,
	subject,
	friendly_name,
	subject_key_identifier,
	NULL,		-- new column (public_key_hash_id)
	NULL,		-- new column (description)
	is_active,
	is_certificate_authority,
	signing_cert_id,
	x509_ca_cert_serial_number,
	public_key,
	private_key_id,
	certificate_signing_request_id,
	valid_from,
	valid_to,
	x509_revocation_date,
	x509_revocation_reason,
	ocsp_uri,
	crl_uri,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#realtime",
	"aud#txid",
	"aud#user",
	"aud#seq"
FROM jazzhands_audit.x509_signed_certificate_v92;

ALTER TABLE jazzhands.x509_signed_certificate
	ALTER x509_certificate_type
	SET DEFAULT 'default'::character varying;
ALTER TABLE jazzhands.x509_signed_certificate
	ALTER is_active
	SET DEFAULT true;
ALTER TABLE jazzhands.x509_signed_certificate
	ALTER is_certificate_authority
	SET DEFAULT false;

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.x509_signed_certificate ADD CONSTRAINT ak_x509_cert_cert_ca_ser UNIQUE (signing_cert_id, x509_ca_cert_serial_number);
ALTER TABLE jazzhands.x509_signed_certificate ADD CONSTRAINT pk_x509_certificate PRIMARY KEY (x509_signed_certificate_id);

-- Table/Column Comments
COMMENT ON TABLE jazzhands.x509_signed_certificate IS 'Signed X509 Certificate';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.x509_signed_certificate_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.x509_certificate_type IS 'business rule; default set but should be set to something else.
';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.subject IS 'Textual representation of a certificate subject. Certificate subject is a part of X509 certificate specifications.  This is the full subject from the certificate.  Friendly Name provides a human readable one.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.friendly_name IS 'human readable name for certificate.  often just the CN.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.subject_key_identifier IS 'Value of the subject key identifier x509v3 extension found in rfc3280 section 4.2.1.2.  If this is not set, it means it was not set in the x509 certificate.  This will eventually be NOT NULL.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.public_key_hash_id IS 'Used to match private keys and x509 certificates from outside of the database.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.is_active IS 'indicates certificate is in active use.  This is used by tools to decide how to show it; does not indicate revocation';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.signing_cert_id IS 'x509_cert_id for the certificate that has signed this one.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.x509_ca_cert_serial_number IS 'Serial number assigned to the certificate within Certificate Authority. It uniquely identifies certificate within the realm of the CA.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.public_key IS 'Textual representation of Certificate Public Key. Public Key is a component of X509 standard and is used for encryption.  This will become mandatory in a future release.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.private_key_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.certificate_signing_request_id IS 'Uniquely identifies Certificate';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.valid_from IS 'Timestamp indicating when the certificate becomes valid and can be used.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.valid_to IS 'Timestamp indicating when the certificate becomes invalid and can''t be used.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.x509_revocation_date IS 'if certificate was revoked, when it was revokeed.  reason must also be set.   NULL means not revoked';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.x509_revocation_reason IS 'if certificate was revoked, why iit was revokeed.  date must also be set.   NULL means not revoked';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.ocsp_uri IS 'The URI (without URI: prefix) of the OCSP server for certs signed by this CA.  This is only valid for CAs.  This URI will be included in said certificates.';
COMMENT ON COLUMN jazzhands.x509_signed_certificate.crl_uri IS 'The URI (without URI: prefix) of the CRL for certs signed by this CA.  This is only valid for CAs.  This URI will be included in said certificates.';
-- INDEXES
CREATE INDEX xif3x509_signed_certificate ON jazzhands.x509_signed_certificate USING btree (x509_revocation_reason);
CREATE INDEX xif4x509_signed_certificate ON jazzhands.x509_signed_certificate USING btree (private_key_id);
CREATE INDEX xif5x509_signed_certificate ON jazzhands.x509_signed_certificate USING btree (certificate_signing_request_id);
CREATE INDEX xif6x509_signed_certificate ON jazzhands.x509_signed_certificate USING btree (x509_certificate_type);
CREATE INDEX xifx509_signed_cert_pkhash ON jazzhands.x509_signed_certificate USING btree (public_key_hash_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
-- consider FK between x509_signed_certificate and jazzhands.x509_key_usage_default
ALTER TABLE jazzhands.x509_key_usage_default
	ADD CONSTRAINT fk_keyusg_deflt_x509crtid
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK between x509_signed_certificate and jazzhands.property
ALTER TABLE jazzhands.property
	ADD CONSTRAINT fk_prop_x509_crt_id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK between x509_signed_certificate and jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
ALTER TABLE jazzhands.service_endpoint_provider_shared_netblock_layer3_interface
	ADD CONSTRAINT fk_service_endpoint_prov_x509_certificate_x509id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id) DEFERRABLE;
-- consider FK between x509_signed_certificate and jazzhands.service_endpoint_x509_certificate
ALTER TABLE jazzhands.service_endpoint_x509_certificate
	ADD CONSTRAINT fk_service_endpoint_x509_certificate_x509id
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id) DEFERRABLE;
-- consider FK between x509_signed_certificate and jazzhands.x509_signed_certificate_fingerprint
-- Skipping this FK since column does not exist yet
--ALTER TABLE jazzhands.jazzhands.x509_signed_certificate_fingerprint
--	ADD CONSTRAINT fk_signed_cert_print_signed_cert
--	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);

-- consider FK between x509_signed_certificate and jazzhands.x509_key_usage_attribute
ALTER TABLE jazzhands.x509_key_usage_attribute
	ADD CONSTRAINT fk_x509_certificate
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);

-- FOREIGN KEYS TO
-- consider FK x509_signed_certificate and certificate_signing_request
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_csr_pvtkeyid
	FOREIGN KEY (certificate_signing_request_id) REFERENCES jazzhands.certificate_signing_request(certificate_signing_request_id);
-- consider FK x509_signed_certificate and private_key
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_pvtkey_x509crt
	FOREIGN KEY (private_key_id) REFERENCES jazzhands.private_key(private_key_id);
-- consider FK x509_signed_certificate and x509_signed_certificate
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_x509_cert_cert
	FOREIGN KEY (signing_cert_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK x509_signed_certificate and val_x509_revocation_reason
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_x509_cert_revoc_reason
	FOREIGN KEY (x509_revocation_reason) REFERENCES jazzhands.val_x509_revocation_reason(x509_revocation_reason);
-- consider FK x509_signed_certificate and public_key_hash
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_x509_signed_cert_pkhash
	FOREIGN KEY (public_key_hash_id) REFERENCES jazzhands.public_key_hash(public_key_hash_id);
-- consider FK x509_signed_certificate and val_x509_certificate_type
ALTER TABLE jazzhands.x509_signed_certificate
	ADD CONSTRAINT fk_x509crtid_crttype
	FOREIGN KEY (x509_certificate_type) REFERENCES jazzhands.val_x509_certificate_type(x509_certificate_type);

-- TRIGGERS
-- considering NEW jazzhands.x509_signed_ski_pvtkey_validate
CREATE OR REPLACE FUNCTION jazzhands.x509_signed_ski_pvtkey_validate()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ski	TEXT;
	id	INTEGER;
BEGIN
	--
	-- XXX needs to be tweaked to ensure that both are set or not set.
	--
	IF NEW.private_key_id IS NULL THEN
		RETURN NEW;
	END IF;

	SELECT	subject_key_identifier, id
	INTO	ski, id
	FROM	private_key p
	WHERE	p.private_key_id = NEW.private_key_id;

	IF FOUND AND ski != NEW.subject_key_identifier THEN
		RAISE EXCEPTION 'subject key identifier must match private key in x509_signing_certificate' USING ERRCODE = 'foreign_key_violation';
	END IF;

	IF FOUND AND id != NEW.public_key_hash_id THEN
		RAISE EXCEPTION 'public_key_hash_id must match in x509_signed_certificate_id and private_key' USING ERRCODE = 'foreign_key_violation';
	END IF;
	RETURN NEW;
END;
$function$
;
REVOKE ALL ON FUNCTION jazzhands.x509_signed_ski_pvtkey_validate() FROM public;
CREATE CONSTRAINT TRIGGER trigger_x509_signed_ski_pvtkey_validate AFTER INSERT OR UPDATE OF subject_key_identifier, public_key_hash_id, private_key_id ON jazzhands.x509_signed_certificate NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.x509_signed_ski_pvtkey_validate();

DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('x509_signed_certificate');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for x509_signed_certificate  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'x509_signed_certificate');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'x509_signed_certificate');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'x509_signed_certificate');
DROP TABLE IF EXISTS x509_signed_certificate_v92;
DROP TABLE IF EXISTS jazzhands_audit.x509_signed_certificate_v92;
-- DONE DEALING WITH TABLE x509_signed_certificate (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_signed_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old x509_signed_certificate failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_signed_certificate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new x509_signed_certificate failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE x509_signed_certificate_fingerprint (jazzhands)
CREATE TABLE jazzhands.x509_signed_certificate_fingerprint
(
	x509_signed_certificate_id	integer NOT NULL,
	x509_fingerprint_hash_algorighm	varchar(255) NOT NULL,
	fingerprint	varchar(255) NOT NULL,
	description	varchar(4096)  NULL,
	data_ins_user	varchar(255)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(255)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('jazzhands_audit', 'jazzhands', 'x509_signed_certificate_fingerprint', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE jazzhands.x509_signed_certificate_fingerprint ADD CONSTRAINT pk_x509_signed_certificate_fingerprint PRIMARY KEY (x509_signed_certificate_id, x509_fingerprint_hash_algorighm);

-- Table/Column Comments
COMMENT ON COLUMN jazzhands.x509_signed_certificate_fingerprint.x509_signed_certificate_id IS 'Uniquely identifies Certificate';
-- INDEXES
CREATE INDEX xifsigned_cert_print_signed_cert ON jazzhands.x509_signed_certificate_fingerprint USING btree (x509_signed_certificate_id);
CREATE INDEX xifx509_signed_cert_fprint_algorithm ON jazzhands.x509_signed_certificate_fingerprint USING btree (x509_fingerprint_hash_algorighm);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
-- consider FK x509_signed_certificate_fingerprint and x509_signed_certificate
ALTER TABLE jazzhands.x509_signed_certificate_fingerprint
	ADD CONSTRAINT fk_signed_cert_print_signed_cert
	FOREIGN KEY (x509_signed_certificate_id) REFERENCES jazzhands.x509_signed_certificate(x509_signed_certificate_id);
-- consider FK x509_signed_certificate_fingerprint and val_x509_fingerprint_hash_algorithm
ALTER TABLE jazzhands.x509_signed_certificate_fingerprint
	ADD CONSTRAINT fk_x509_signed_cert_fprint_algorithm
	FOREIGN KEY (x509_fingerprint_hash_algorighm) REFERENCES jazzhands.val_x509_fingerprint_hash_algorithm(x509_fingerprint_hash_algorighm);

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('x509_signed_certificate_fingerprint');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for x509_signed_certificate_fingerprint  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
SELECT schema_support.rebuild_stamp_trigger('jazzhands', 'x509_signed_certificate_fingerprint');
SELECT schema_support.build_audit_table_pkak_indexes('jazzhands_audit', 'jazzhands', 'x509_signed_certificate_fingerprint');
SELECT schema_support.rebuild_audit_trigger('jazzhands_audit', 'jazzhands', 'x509_signed_certificate_fingerprint');
-- DONE DEALING WITH TABLE x509_signed_certificate_fingerprint (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_signed_certificate_fingerprint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old x509_signed_certificate_fingerprint failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('x509_signed_certificate_fingerprint');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new x509_signed_certificate_fingerprint failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE device_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'device_note', 'device_note');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'device_note', tags := ARRAY['view_device_note']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.device_note;
CREATE VIEW audit.device_note AS
 SELECT device_note.device_note_id AS note_id,
    device_note.device_id,
    device_note.note_text,
    device_note.note_date,
    device_note.note_user,
    device_note.data_ins_user,
    device_note.data_ins_date,
    device_note.data_upd_user,
    device_note.data_upd_date,
    device_note."aud#action",
    device_note."aud#timestamp",
    device_note."aud#realtime",
    device_note."aud#txid",
    device_note."aud#user",
    device_note."aud#seq"
   FROM jazzhands_audit.device_note;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('device_note','device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of device_note failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('device_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for device_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE device_note (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new device_note failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE person_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('audit', 'person_note', 'person_note');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'person_note', tags := ARRAY['view_person_note']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS audit.person_note;
CREATE VIEW audit.person_note AS
 SELECT person_note.person_note_id AS note_id,
    person_note.person_id,
    person_note.note_text,
    person_note.note_date,
    person_note.note_user,
    person_note.data_ins_user,
    person_note.data_ins_date,
    person_note.data_upd_user,
    person_note.data_upd_date,
    person_note."aud#action",
    person_note."aud#timestamp",
    person_note."aud#realtime",
    person_note."aud#txid",
    person_note."aud#user",
    person_note."aud#seq"
   FROM jazzhands_audit.person_note;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'audit' AND type = 'view' AND object IN ('person_note','person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of person_note failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'audit' AND object IN ('person_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for person_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE person_note (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old person_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new person_note failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE val_package_relation_type
SELECT schema_support.save_dependent_objects_for_replay(schema := 'audit', object := 'val_package_relation_type', tags := ARRAY['view_val_package_relation_type']);
DROP VIEW IF EXISTS audit.val_package_relation_type;
-- DONE DEALING WITH OLD TABLE val_package_relation_type (audit)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('audit', 'jazzhands_audit') AND object IN ('val_package_relation_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_package_relation_type failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--------------------------------------------------------------------
-- DEALING WITH NEW TABLE v_service_endpoint_expanded (jazzhands)
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'v_service_endpoint_expanded');
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_audit', 'v_service_endpoint_expanded');
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_service_endpoint_expanded;
CREATE VIEW jazzhands.v_service_endpoint_expanded AS
 SELECT DISTINCT service_endpoint.service_endpoint_id,
    service_endpoint.service_id,
    service_endpoint.dns_record_id,
    service_endpoint.port_range_id,
        CASE
            WHEN service_endpoint.dns_record_id IS NULL THEN service_endpoint.service_endpoint_uri_fragment::text
            ELSE concat(pr.service_name, '://', dns.fqdn,
            CASE
                WHEN pr.port_uri_start IS NULL THEN NULL::text
                ELSE pr.port_uri
            END, '/', service_endpoint.service_endpoint_uri_fragment)
        END AS service_endpoint_uri,
    service_endpoint.description,
    service_endpoint.is_synthesized
   FROM jazzhands.service_endpoint
     LEFT JOIN ( SELECT dns_record.dns_record_id,
            concat_ws('.'::text, dns_record.dns_name, dns_domain.dns_domain_name) AS fqdn
           FROM jazzhands.dns_record
             JOIN jazzhands.dns_domain USING (dns_domain_id)) dns USING (dns_record_id)
     LEFT JOIN ( SELECT pr_1.port_range_id,
            pr_1.port_range_name,
                CASE
                    WHEN pr_1.port_start = pr_1.port_end AND pr_1.service_override_port_range_id IS NULL THEN NULL::text
                    ELSE concat(':', pr_1.port_start)
                END AS port_uri_start,
            concat(':', generate_series(pr_1.port_start, pr_1.port_end)) AS port_uri,
            COALESCE(ppr.port_range_name, pr_1.port_range_name) AS service_name
           FROM jazzhands.port_range pr_1
             LEFT JOIN jazzhands.port_range ppr ON pr_1.service_override_port_range_id = ppr.port_range_id) pr USING (port_range_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_service_endpoint_expanded','v_service_endpoint_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_service_endpoint_expanded failed but that is ok';
	NULL;
END;
$$;


-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_service_endpoint_expanded');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_service_endpoint_expanded  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_service_endpoint_expanded (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_endpoint_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_service_endpoint_expanded failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_endpoint_expanded');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_service_endpoint_expanded failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH NEW TABLE v_service_endpoint_service_instance (jazzhands)
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'v_service_endpoint_service_instance');
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_audit', 'v_service_endpoint_service_instance');
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_service_endpoint_service_instance;
CREATE VIEW jazzhands.v_service_endpoint_service_instance AS
 SELECT service_endpoint_service_endpoint_provider_collection.service_endpoint_id,
    service_endpoint_provider_service_instance.service_endpoint_provider_service_instance_id,
    service_endpoint_provider_service_instance.service_instance_id
   FROM jazzhands.service_endpoint_service_endpoint_provider_collection
     JOIN jazzhands.service_endpoint_provider_collection USING (service_endpoint_provider_collection_id)
     JOIN jazzhands.service_endpoint_provider_collection_service_endpoint_provider USING (service_endpoint_provider_collection_id)
     JOIN jazzhands.service_endpoint_provider USING (service_endpoint_provider_id)
     JOIN jazzhands.service_endpoint_provider_service_instance USING (service_endpoint_provider_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_service_endpoint_service_instance','v_service_endpoint_service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_service_endpoint_service_instance failed but that is ok';
	NULL;
END;
$$;


-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_service_endpoint_service_instance');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_service_endpoint_service_instance  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_service_endpoint_service_instance (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_endpoint_service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_service_endpoint_service_instance failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_endpoint_service_instance');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_service_endpoint_service_instance failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH NEW TABLE v_service_source_repository_uri (jazzhands)
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'v_service_source_repository_uri');
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_audit', 'v_service_source_repository_uri');
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_service_source_repository_uri;
CREATE VIEW jazzhands.v_service_source_repository_uri AS
 SELECT service_source_repository.service_id,
    source_repository.source_repository_provider_id,
    source_repository.source_repository_project_id,
    source_repository_project.source_repository_project_name,
    service_source_repository.source_repository_id,
    source_repository.source_repository_name,
    source_repository_provider_uri_template.source_repository_protocol,
    source_repository_provider_uri_template.source_repository_uri_purpose,
    service_source_repository.service_source_control_purpose,
    service_utils.build_software_repository_uri(template => concat_ws('/'::text, regexp_replace(source_repository_provider_uri_template.source_repository_uri::text, '/$'::text, ''::text), regexp_replace(concat_ws('/'::text, source_repository_provider_uri_template.source_repository_template_path_fragment, source_repository.source_repository_path_fragment, service_source_repository.service_source_repository_path_fragment), '//'::text, '/'::text, 'g'::text)), project_name => source_repository_project.source_repository_project_name::text, repository_name => source_repository.source_repository_name::text) AS source_repository_uri
   FROM jazzhands.service_source_repository
     JOIN jazzhands.source_repository USING (source_repository_id)
     JOIN jazzhands.source_repository_project USING (source_repository_provider_id, source_repository_project_id)
     JOIN jazzhands.source_repository_provider_uri_template USING (source_repository_provider_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_service_source_repository_uri','v_service_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_service_source_repository_uri failed but that is ok';
	NULL;
END;
$$;


-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_service_source_repository_uri');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_service_source_repository_uri  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_service_source_repository_uri (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_service_source_repository_uri failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_service_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_service_source_repository_uri failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- DEALING WITH NEW TABLE v_source_repository_uri (jazzhands)
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'v_source_repository_uri');
SELECT schema_support.save_dependent_objects_for_replay('jazzhands_audit', 'v_source_repository_uri');
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands.v_source_repository_uri;
CREATE VIEW jazzhands.v_source_repository_uri AS
 SELECT source_repository.source_repository_provider_id,
    source_repository.source_repository_project_id,
    source_repository_project.source_repository_project_name,
    source_repository.source_repository_id,
    source_repository.source_repository_name,
    source_repository_provider_uri_template.source_repository_protocol,
    source_repository_provider_uri_template.source_repository_uri_purpose,
    service_utils.build_software_repository_uri(template => concat_ws('/'::text, regexp_replace(source_repository_provider_uri_template.source_repository_uri::text, '/$'::text, ''::text), regexp_replace(concat_ws('/'::text, source_repository_provider_uri_template.source_repository_template_path_fragment, source_repository.source_repository_path_fragment), '//'::text, '/'::text, 'g'::text)), project_name => source_repository_project.source_repository_project_name::text, repository_name => source_repository.source_repository_name::text) AS source_repository_uri
   FROM jazzhands.source_repository
     JOIN jazzhands.source_repository_project USING (source_repository_provider_id, source_repository_project_id)
     JOIN jazzhands.source_repository_provider_uri_template USING (source_repository_provider_id);

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'view' AND object IN ('v_source_repository_uri','v_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of v_source_repository_uri failed but that is ok';
	NULL;
END;
$$;


-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands' AND object IN ('v_source_repository_uri');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for v_source_repository_uri  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE v_source_repository_uri (jazzhands)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old v_source_repository_uri failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands', 'jazzhands_audit') AND object IN ('v_source_repository_uri');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new v_source_repository_uri failed but that is ok';
	NULL;
END;
$$;

select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
select clock_timestamp(), clock_timestamp() - now() AS len;
--
-- Process all procs in jazzhands_cache
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_cache']);
--
-- Process all procs in account_collection_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_collection_manip']);
--
-- Process all procs in account_password_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_account_password_manip']);
--
-- Process all procs in approval_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_approval_utils']);
--
-- Process all procs in audit
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_audit']);
--
-- Process all procs in auto_ac_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_auto_ac_manip']);
--
-- Process all procs in backend_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_backend_utils']);
--
-- Process all procs in company_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_company_manip']);
--
-- Process all procs in component_connection_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_connection_utils']);
--
-- Process all procs in component_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_manip']);
--
-- Process all procs in component_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_component_utils']);
--
-- Process all procs in device_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_manip']);
--
-- Process all procs in device_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_device_utils']);
--
-- Process all procs in dns_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_manip']);
--
-- Process all procs in dns_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_dns_utils']);
--
-- Process all procs in jazzhands
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'account_status_per_row_after_hooks');
SELECT schema_support.save_grants_for_replay('jazzhands', 'account_status_per_row_after_hooks');
CREATE OR REPLACE FUNCTION jazzhands.account_status_per_row_after_hooks()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
BEGIN
	BEGIN
		PERFORM local_hooks.account_status_per_row_after_hooks(account_record => NEW);
	EXCEPTION WHEN invalid_schema_name OR undefined_function THEN
		PERFORM 1;
	END;
	RETURN NULL;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('account_status_per_row_after_hooks');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc account_status_per_row_after_hooks failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'pvtkey_ski_signed_validate');
SELECT schema_support.save_grants_for_replay('jazzhands', 'pvtkey_ski_signed_validate');
CREATE OR REPLACE FUNCTION jazzhands.pvtkey_ski_signed_validate()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ski	TEXT;
	id	INTEGER;
BEGIN
	SELECT	subject_key_identifier, id
	INTO	ski, id
	FROM	x509_signed_certificate x
	WHERE	x.private_key_id = NEW.private_key_id;

	IF FOUND AND ski != NEW.subject_key_identifier THEN
		RAISE EXCEPTION 'subject key identifier must match private key in x509_signing_certificate' USING ERRCODE = 'foreign_key_violation';
	END IF;

	IF FOUND AND id != NEW.public_key_hash_id THEN
		RAISE EXCEPTION 'public_key_hash_id must match in x509_signed_certificate_id and private_key' USING ERRCODE = 'foreign_key_violation';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('pvtkey_ski_signed_validate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc pvtkey_ski_signed_validate failed but that is ok';
	NULL;
END;
$$;

DROP TRIGGER IF EXISTS trigger_service_depend_feature_check ON jazzhands.service_depend_service_feature;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'service_depend_feature_check (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.service_depend_feature_check (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'service_instance_feature_check');
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_instance_feature_check');
CREATE OR REPLACE FUNCTION jazzhands.service_instance_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	PERFORM *
	FROM service_version_collection_permitted_feature svcpf
		-- may not need this join
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_collection_id)
		JOIN service_instance si USING (service_version_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND		si.service_instance_id = NEW.service_instance_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Feature not permitted for this service'
		USING ERRCODE = 'foreign_key_violation',
		HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('service_instance_feature_check');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc service_instance_feature_check failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'service_instance_service_feature_rename');
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_instance_service_feature_rename');
CREATE OR REPLACE FUNCTION jazzhands.service_instance_service_feature_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
			USING ERRCODE = 'invalid_paramater',
			HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('service_instance_service_feature_rename');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc service_instance_service_feature_rename failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'service_source_repository_sanity');
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_source_repository_sanity');
CREATE OR REPLACE FUNCTION jazzhands.service_source_repository_sanity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	--
	-- check to see if there's another primary, if so fail.
	---
	IF NEW.is_primary THEN
		SELECT count(*) INTO _tally
		FROM service_source_repository
		WHERE service_source_repository_id != NEW.service_source_repository_id
		AND service_id = NEW.service_id
		AND service_source_control_purpose = NEW.service_source_control_purpose
		AND service_source_repository_path_fragment IS NOT DISTINCT FROM NEW.service_source_repository_path_fragment
		AND is_primary;

		IF _tally > 0 THEN
			RAISE EXCEPTION 'A primary source repository already exists for this service'
				USING ERRCODE = 'unique_violation';
		END IF;

	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('service_source_repository_sanity');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc service_source_repository_sanity failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'service_version_feature_permitted_rename');
SELECT schema_support.save_grants_for_replay('jazzhands', 'service_version_feature_permitted_rename');
CREATE OR REPLACE FUNCTION jazzhands.service_version_feature_permitted_rename()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
			USING ERRCODE = 'invalid_paramater',
			HINT = 'This feature is not implemented';
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('service_version_feature_permitted_rename');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc service_version_feature_permitted_rename failed but that is ok';
	NULL;
END;
$$;

DROP TRIGGER IF EXISTS trigger_source_repository_url_endpoint_enforcement ON jazzhands.source_repository_url;
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands'::text, object := 'source_repository_url_endpoint_enforcement (  )'::text, tags := ARRAY['process_all_procs_in_schema_jazzhands'::text]);
DROP FUNCTION IF EXISTS jazzhands.source_repository_url_endpoint_enforcement (  );
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'update_per_service_environment_service_environment_collection');
SELECT schema_support.save_grants_for_replay('jazzhands', 'update_per_service_environment_service_environment_collection');
CREATE OR REPLACE FUNCTION jazzhands.update_per_service_environment_service_environment_collection()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	secid		service_environment_collection.service_environment_collection_id%TYPE;
	_newname		TEXT;
BEGIN
	_newname = concat(NEW.service_environment_name, '_', NEW.service_environment_id);
	IF TG_OP = 'INSERT' THEN
		insert into service_environment_collection
			(service_environment_collection_name, service_environment_collection_type)
		values
			(_newname, 'per-environment')
		RETURNING service_environment_collection_id INTO secid;
		insert into service_environment_collection_service_environment
			(service_environment_collection_id, service_environment_id)
		VALUES
			(secid, NEW.service_environment_id);
	ELSIF TG_OP = 'UPDATE'  AND OLD.service_environment_id != NEW.service_environment_id THEN
		UPDATE	service_environment_collection
		   SET	service_environment_collection_name = _newname
		 WHERE	service_environment_collection_name != _newname
		   AND	service_environment_collection_type = 'per-environment'
		   AND	service_environment_collection_id in (
			SELECT	service_environment_collection_id
			  FROM	service_environment_collection_service_environment
			 WHERE	service_environment_id =
				NEW.service_environment_id
			);
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('update_per_service_environment_service_environment_collection');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc update_per_service_environment_service_environment_collection failed but that is ok';
	NULL;
END;
$$;

-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('jazzhands', 'x509_signed_ski_pvtkey_validate');
SELECT schema_support.save_grants_for_replay('jazzhands', 'x509_signed_ski_pvtkey_validate');
CREATE OR REPLACE FUNCTION jazzhands.x509_signed_ski_pvtkey_validate()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	ski	TEXT;
	id	INTEGER;
BEGIN
	--
	-- XXX needs to be tweaked to ensure that both are set or not set.
	--
	IF NEW.private_key_id IS NULL THEN
		RETURN NEW;
	END IF;

	SELECT	subject_key_identifier, id
	INTO	ski, id
	FROM	private_key p
	WHERE	p.private_key_id = NEW.private_key_id;

	IF FOUND AND ski != NEW.subject_key_identifier THEN
		RAISE EXCEPTION 'subject key identifier must match private key in x509_signing_certificate' USING ERRCODE = 'foreign_key_violation';
	END IF;

	IF FOUND AND id != NEW.public_key_hash_id THEN
		RAISE EXCEPTION 'public_key_hash_id must match in x509_signed_certificate_id and private_key' USING ERRCODE = 'foreign_key_violation';
	END IF;
	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands' AND type = 'function' AND object IN ('x509_signed_ski_pvtkey_validate');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc x509_signed_ski_pvtkey_validate failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands']);
-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.check_service_namespace()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
	_myns	TEXT;
BEGIN
	SELECT service_namespace
	INTO _myns
	FROM val_service_type
	WHERE service_type = NEW.service_type;

	--
	-- uniqueness within the same type is covered by an AK
	--
	SELECT count(*) INTO _tally
	FROM service
		JOIN val_service_type USING (service_type)
	WHERE service_name = NEW.service_name
	AND service_type  != NEW.service_type
	AND service_namespace = _myns;

	IF _tally > 0 THEN
		RAISE EXCEPTION '% is not unique within % namespace (%).',
			NEW.service_name, NEW.service_type, _myns
		USING ERRCODE = 'unique_violation';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.check_service_relationship_rhs()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_t	BOOLEAN;
	_id	INTEGER;
	_re	TEXT;
BEGIN
	IF NEW.service_version_restriction IS NOT NULL THEN
		IF NEW.service_version_restriction_service_id IS NULL THEN
			RAISE EXCEPTION 'If service_version_restriction is set, service_version_restriction_service_id must also be set'
				USING ERRCODE = 'not_null_violation';
		END IF;

		--
		-- Either use the user specified regex or the default one and
		-- check the relationship against it
		--

		SELECT st.service_version_restriction_regular_expression
		INTO _re
		FROM val_service_type st
		JOIN service USING (service_type)
		JOIn service_version USING (service_id)
		WHERE service_version_id = NEW.service_version_id;

		IF _re IS NULL THEN
			_re := '^((<=? [-_\.a-z0-9]+) (>=? [-_\.a-z0-9]+)|(([<>]=?|=) [-_\.a-z0-9]+))$';
		END IF;

		IF NEW.service_version_restriction !~_re THEN
			RAISE EXCEPTION 'restriction must match rules for this service type'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = format('Using regexp %s', _re);
		END IF;
	END IF;

	IF NEW.related_service_version_id IS NOT NULL THEN
		IF NEW.related_service_version_id IS NOT NULL THEN
			SELECT v1.service_id = v2.service_id INTO _t
			FROM service_version v1, service_version v2
			WHERE v1.service_version_id = NEW.service_version_id
			AND v2.service_version_id = NEW.related_service_version_id;
			IF _t THEN
				RAISE EXCEPTION 'service_version_restriction_service_id and '
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
		END IF;
	END IF;

	IF NEW.service_version_restriction_service_id IS NOT NULL THEN
		IF NEW.related_service_version_id IS NOT NULL  THEN
			IF NEW.service_version_restriction IS NULL THEN
				RAISE EXCEPTION 'If service_version_restriction_service_id and related_service_version_id is set, service_version_restriction must also be set'
					USING ERRCODE = 'not_null_violation';
			END IF;

			--
			-- make sure service_version_restriction_service_id points to
			-- the same service as related_service_version_id
			--
			SELECT service_id
			INTO _id
			FROM service_version
			WHERE service_version_id = NEW.related_service_version_id;

			IF _id != NEW.service_version_restriction_service_id THEN
				RAISE EXCEPTION 'service_version_restriction_service_id and related_service_version_id must point to the same services.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
		END IF;

		SELECT service_id
		INTO _id
		FROM service_version
		WHERE service_version_id = NEW.service_version_id;

		IF _id = NEW.service_version_restriction_service_id THEN
			RAISE EXCEPTION 'May not relate to oneself'
					USING ERRCODE = 'invalid_parameter_value';
		END IF;
	ELSE
		IF NEW.related_service_version_id IS NULL THEN
			RAISE EXCEPTION 'One of service_version_restriction_service_id and related_service_version_id must be set.'
				USING ERRCODE = 'not_null_violation';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.check_service_type_namespace()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_tally	INTEGER;
BEGIN
	SELECT coalesce(sum(n), 0)
	INTO _tally
	FROM (
		SELECT service_name, count(*) as n
		FROM service
			JOIN val_service_type USING (service_type)
		WHERE service_namespace = NEW.service_namespace
		GROUP BY 1
		HAVING count(*) > 1
	) x;

	IF _tally > 0 THEN
		RAISE EXCEPTION 'namespace % has % conflicting services',
			NEW.service_type, _tally
		USING ERRCODE = 'unique_violation';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.check_service_type_relation_regexp_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	_r	RECORD;
BEGIN
	IF NEW.service_version_restriction_regular_expression IS NOT NULL THEN
		FOR _r IN
			SELECT sr.*
			FROM service_relationship sr
			JOIN service_version USING (service_version_id)
			WHERE service_type = NEW.service_type
			AND service_version_restriction IS NOT NULL
			AND service_version_restriction !~
				NEW.service_version_restriction_regular_expression
		LOOP
			RAISE EXCEPTION 'Existing service_relationships must match type.'
				USING ERRCODE = 'invalid_parameter_value',
				HINT = format('Check relationship %s',
					_r.service_relationship_id);
		END LOOP;
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.service_relationship_feature_check()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF TG_OP = 'UPDATE' AND OLD.serice_feature != NEW.service_feature THEN
		RAISE EXCEPTION 'Features may not be renaemd due to possible constraint issues'
			USING ERRCODE = 'invalid_paramater',
			HINT = 'This feature is not implemented';
	END IF;

	PERFORM *
	FROM (select service_relationship_id, service_id from service_version) sd
		JOIN service_version USING (service_id)
		JOIN service_instance si USING (service_version_id)
		JOIN service_version_collection_service_version svscsv
			USING (service_version_id)
		JOIN service_version_collection svc
			USING (service_version_collection_id)
		JOIN service_version_collection_permitted_feature svcpf
			USING (service_version_collection_id)
	WHERE	svcpf.service_feature = NEW.service_feature
	AND	sd.service_relationship = NEW.service_relationship_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'service_feature is not offered by any versions of service'
			USING ERRCODE = 'foreign_key_violation',
			HINT = 'An entry in service_version_collection_permitted_feature may be required';
	END IF;

	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.software_artifact_repository_uri_endpoint_enforce()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.software_artifact_repository_uri IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either software_artifact_repository_uri or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.software_artifact_repository_uri IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of software_artifact_repository_uri or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.source_repository_provider_uri_template_endpoint_enforce()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.source_repository_uri IS NULL AND NEW.service_endpoint_id IS NULL THEN
		RAISE EXCEPTION 'Must set either source_repository_uri or service_endpoint_id'
			USING ERRCODE = 'null_value_not_allowed';
	ELSIF NEW.source_repository_uri IS NOT NULL AND NEW.service_endpoint_id IS NOT NULL THEN
		RAISE EXCEPTION 'Must set only one of source_repository_uri or service_endpoint_id'
			USING ERRCODE = 'invalid_parameter_value';
	END IF;
	RETURN NEW;
END;
$function$
;

-- New function; dropping in case it returned because of type change
CREATE OR REPLACE FUNCTION jazzhands.validate_service_endpoint_fksets()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
BEGIN
	IF NEW.dns_record_id IS NOT NULL
		OR NEW.port_range_id IS NOT NULL
	THEN
		IF NEW.dns_record_id IS NULL
			OR NEW.port_range_id IS NULL
		THEN
			RAISE EXCEPTION 'both dns_record_id and port_range_id must be set'
				USING ERRCODE = 'not_null_violation';
		END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

--
-- Process all procs in layerx_network_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_layerx_network_manip']);
--
-- Process all procs in logical_port_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_logical_port_manip']);
--
-- Process all procs in lv_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_lv_manip']);
--
-- Process all procs in net_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_net_manip']);
--
-- Process all procs in netblock_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_manip']);
--
-- Process all procs in netblock_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_netblock_utils']);
--
-- Process all procs in network_strings
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_network_strings']);
--
-- Process all procs in obfuscation_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_obfuscation_utils']);
--
-- Process all procs in person_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_person_manip']);
--
-- Process all procs in pgcrypto
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_pgcrypto']);
--
-- Process all procs in physical_address_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_physical_address_utils']);
--
-- Process all procs in port_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_port_utils']);
--
-- Process all procs in rack_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_rack_utils']);
--
-- Process all procs in schema_support
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('schema_support', 'trigger_ins_upd_generic_func');
SELECT schema_support.save_grants_for_replay('schema_support', 'trigger_ins_upd_generic_func');
CREATE OR REPLACE FUNCTION schema_support.trigger_ins_upd_generic_func()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    appuser VARCHAR;
BEGIN
	appuser := concat_ws('/', session_user,
		coalesce(
			current_setting('jazzhands.appuser', true),
			current_setting('request.header.x-remote-user', true)
		)
	);
    appuser = substr(appuser, 1, 255);

    IF TG_OP = 'INSERT' THEN
	NEW.data_ins_user = appuser;
	NEW.data_ins_date = 'now';
    END IF;

    IF TG_OP = 'UPDATE' AND OLD != NEW THEN
	NEW.data_upd_user = appuser;
	NEW.data_upd_date = 'now';

	IF OLD.data_ins_user != NEW.data_ins_user THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_USER" cannot be modified.';
	END IF;

	IF OLD.data_ins_date != NEW.data_ins_date THEN
	    RAISE EXCEPTION
		'Non modifiable column "DATA_INS_DATE" cannot be modified.';
	END IF;
    END IF;

    RETURN NEW;

END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'schema_support' AND type = 'function' AND object IN ('trigger_ins_upd_generic_func');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc trigger_ins_upd_generic_func failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_schema_support']);
--
-- Process all procs in script_hooks
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_script_hooks']);
--
-- Process all procs in service_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_service_manip']);
--
-- Process all procs in service_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_service_utils']);
--
-- Process all procs in snapshot_manip
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_snapshot_manip']);
--
-- Process all procs in time_util
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_time_util']);
--
-- Process all procs in token_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_token_utils']);
--
-- Process all procs in versioning_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_versioning_utils']);
--
-- Recreate the saved views in the base schema
--
SELECT schema_support.replay_object_recreates(schema := 'jazzhands', type := 'view');


-- BEGIN Misc that does not apply to above

--
-- changed the index.
--
DROP INDEX IF EXISTS jazzhands_audit.aud_logical_volume_ak_logvol_devid_lvname;
CREATE INDEX aud_logical_volume_ak_logvol_devid_lvname ON jazzhands_audit.logical_volume USING btree (device_id, logical_volume_name, logical_volume_type, volume_group_id);

--
-- because of table rename dance
ALTER TABLE ONLY jazzhands.service_source_repository
	ADD CONSTRAINT fk_service_source_repo_srcrepoid
	FOREIGN KEY (source_repository_id)
	REFERENCES jazzhands.source_repository(source_repository_id)
	DEFERRABLE;
ALTER TABLE ONLY jazzhands.source_repository
	ADD CONSTRAINT fk_src_repo_project_id
	FOREIGN KEY (source_repository_project_id, source_repository_provider_id)
	REFERENCES jazzhands.source_repository_project(source_repository_project_id, source_repository_provider_id);
-- end rename dance
ALTER TABLE ONLY jazzhands.source_repository_commit
	ADD CONSTRAINT fk_src_repo_commit_src_repo_id
	FOREIGN KEY (source_repository_id)
	REFERENCES jazzhands.source_repository(source_repository_id);

--
-- recreating this because of some issues
--
ALTER TABLE device_collection 
	DROP CONSTRAINT IF EXISTS ak_uq_devicecoll_name_type;
ALTER TABLE device_collection
        ADD CONSTRAINT ak_uq_devicecoll_name_type 
	UNIQUE (device_collection_name,device_collection_type);

--
-- migration script didn't detect this, timing requires doing it here.
--

ALTER TABLE service DROP CONSTRAINT IF EXISTS ak_service_name_type;
ALTER TABLE service
        ADD CONSTRAINT ak_service_name_type
        UNIQUE (service_id, service_type);
SELECT schema_support.migrate_legacy_serials_to_identities('jazzhands_audit');
SELECT schema_support.rebuild_audit_indexes(
	aud_schema := 'jazzhands_audit',
	tbl_schema := 'jazzhands',
	table_name := 'service'
);

-- naming algorithm changed for long tables
SELECT schema_support.rebuild_audit_table(
	aud_schema := 'jazzhands_audit',
	tbl_schema := 'jazzhands',
	table_name :=  'service_endpoint_provider_collection_service_endpoint_provider'
);
COMMENT ON COLUMN jazzhands.service.service_type IS 'The _current_ type of the service.  This is propagated to each new service version.  Services names are _NOT_ unique within this type BUT _are_ within the type''s namespace.';

--
-- this should probably happen when the view is dropped.
--
DELETE FROM __regrants WHERE object = 'val_package_relation_type'
	AND schema IN ('jazzhands_legacy', 'audit');


SELECT schema_support.set_schema_version(
        version := '0.92',
        schema := 'jazzhands'
);


-- END Misc that does not apply to above
--
-- BEGIN: process_ancillary_schema(jazzhands_legacy)
--
--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE device_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'device_note', 'device_note');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'device_note', tags := ARRAY['view_device_note']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.device_note;
CREATE VIEW jazzhands_legacy.device_note AS
 SELECT device_note.device_note_id AS note_id,
    device_note.device_id,
    device_note.note_text,
    device_note.note_date,
    device_note.note_user,
    device_note.data_ins_user,
    device_note.data_ins_date,
    device_note.data_upd_user,
    device_note.data_upd_date
   FROM jazzhands.device_note;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('device_note','device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of device_note failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('device_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for device_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE device_note (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old device_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('device_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new device_note failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE person_note
-- Save grants for later reapplication
SELECT schema_support.save_grants_for_replay('jazzhands_legacy', 'person_note', 'person_note');
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'person_note', tags := ARRAY['view_person_note']);
-- restore any missing random views that may be cached that this one needs.
DROP VIEW IF EXISTS jazzhands_legacy.person_note;
CREATE VIEW jazzhands_legacy.person_note AS
 SELECT person_note.person_note_id AS note_id,
    person_note.person_id,
    person_note.note_text,
    person_note.note_date,
    person_note.note_user,
    person_note.data_ins_user,
    person_note.data_ins_date,
    person_note.data_upd_user,
    person_note.data_upd_date
   FROM jazzhands.person_note;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND type = 'view' AND object IN ('person_note','person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of person_note failed but that is ok';
	NULL;
END;
$$;

-- just in case
SELECT schema_support.prepare_for_object_replay();

-- PRIMARY AND ALTERNATE KEYS

-- Table/Column Comments
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
DO $$
BEGIN
		DELETE FROM __recreate WHERE schema = 'jazzhands_legacy' AND object IN ('person_note');
	EXCEPTION WHEN undefined_table THEN
		RAISE NOTICE 'Drop of triggers for person_note  failed but that is ok';
		NULL;
END;
$$;

-- this used to be at the end...
-- SELECT schema_support.replay_object_recreates();
-- DONE DEALING WITH TABLE person_note (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old person_note failed but that is ok';
	NULL;
END;
$$;

DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('person_note');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of new person_note failed but that is ok';
	NULL;
END;
$$;

--------------------------------------------------------------------
-- BEGIN: DEALING WITH TABLE val_package_relation_type
SELECT schema_support.save_dependent_objects_for_replay(schema := 'jazzhands_legacy', object := 'val_package_relation_type', tags := ARRAY['view_val_package_relation_type']);
DROP VIEW IF EXISTS jazzhands_legacy.val_package_relation_type;
-- DONE DEALING WITH OLD TABLE val_package_relation_type (jazzhands_legacy)
--------------------------------------------------------------------
DO $$
BEGIN
	DELETE FROM __recreate WHERE schema IN ('jazzhands_legacy', 'jazzhands_audit') AND object IN ('val_package_relation_type');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of old val_package_relation_type failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_jazzhands_legacy']);
-- DONE: process_ancillary_schema(jazzhands_legacy)
--
-- BEGIN: Fix cache table entries.
--
-- removing old
-- adding new cache tables that are not there
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  WHERE ('jazzhands_cache' , 'ct_device_components' , 'jazzhands_cache' , 'v_device_components' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_hier' , 'jazzhands_cache' , 'v_netblock_hier' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_account_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_account_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_device_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_device_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  WHERE ('jazzhands_cache' , 'ct_netblock_collection_hier_from_ancestor' , 'jazzhands_cache' , 'v_netblock_collection_hier_from_ancestor' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
INSERT INTO schema_support.cache_table (cache_table_schema, cache_table, defining_view_schema, defining_view, updates_enabled 
	) SELECT 'jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  WHERE ('jazzhands_cache' , 'ct_jazzhands_legacy_device_support' , 'jazzhands_cache' , 'v_jazzhands_legacy_device_support' , '1'  ) NOT IN ( SELECT * FROM schema_support.cache_table );
--
-- DONE: Fix cache table entries.
--


-- Clean Up
--
-- Process post-schema property_utils
--
select clock_timestamp(), clock_timestamp() - now() AS len;
-- Changed function
SELECT schema_support.save_dependent_objects_for_replay('property_utils', 'validate_property');
SELECT schema_support.save_grants_for_replay('property_utils', 'validate_property');
-- Dropped in case type changes.
DROP FUNCTION IF EXISTS property_utils.validate_property ( new jazzhands.property );
CREATE OR REPLACE FUNCTION property_utils.validate_property(new jazzhands.property)
 RETURNS jazzhands.property
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'jazzhands'
AS $function$
DECLARE
	tally				integer;
	v_prop				VAL_Property%ROWTYPE;
	v_proptype			VAL_Property_Type%ROWTYPE;
	v_account_collection		account_collection%ROWTYPE;
	v_company_collection		company_collection%ROWTYPE;
	v_device_collection		device_collection%ROWTYPE;
	v_dns_domain_collection		dns_domain_collection%ROWTYPE;
	v_layer2_network_collection	layer2_network_collection%ROWTYPE;
	v_layer3_network_collection	layer3_network_collection%ROWTYPE;
	v_netblock_collection		netblock_collection%ROWTYPE;
	v_network_range				network_range%ROWTYPE;
	v_property_name_collection		property_name_collection%ROWTYPE;
	v_service_environment_collection	service_environment_collection%ROWTYPE;
	v_service_version_collection	service_version_collection%ROWTYPE;
	v_num				integer;
	v_listvalue			Property.Property_Value%TYPE;
BEGIN
	-- Pull in the data from the property and property_type so we can
	-- figure out what is and is not valid

	BEGIN
		SELECT * INTO STRICT v_prop FROM VAL_Property WHERE
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type;

		SELECT * INTO STRICT v_proptype FROM VAL_Property_Type WHERE
			Property_Type = NEW.Property_Type;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION
				'Property name (%) or type (%) does not exist',
				NEW.property_name, NEW.property_type
				USING ERRCODE = 'foreign_key_violation';
			RETURN NULL;
	END;

	-- Check to see if the property itself is multivalue.  That is, if only
	-- one value can be set for this property for a specific property LHS
	IF (v_prop.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of type (%,%) already exists for given LHS and property is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	ELSE
		-- check for the same lhs+rhs existing, which is basically a dup row
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code AND
			property_value IS NOT DISTINCT FROM NEW.property_value AND
			property_value_json IS NOT DISTINCT FROM
				NEW.property_value_json AND
			property_value_boolean IS NOT DISTINCT FROM
				NEW.property_value_boolean AND
			property_value_timestamp IS NOT DISTINCT FROM
				NEW.property_value_timestamp AND
			property_value_account_collection_id IS NOT DISTINCT FROM
				NEW.property_value_account_collection_id AND
			property_value_device_collection_id IS NOT DISTINCT FROM
				NEW.property_value_device_collection_id AND
			property_value_netblock_collection_id IS NOT DISTINCT FROM
				NEW.property_value_netblock_collection_id AND
			property_value_service_version_collection_id IS NOT DISTINCT FROM
				NEW.property_value_service_version_collection_id AND
			property_value_password_type IS NOT DISTINCT FROM
				NEW.property_value_password_type AND
			property_value_token_collection_id IS NOT DISTINCT FROM
				NEW.property_value_token_collection_id AND
			property_value_encryption_key_id IS NOT DISTINCT FROM
				NEW.property_value_encryption_key_id AND
			property_value_private_key_id IS NOT DISTINCT FROM
				NEW.property_value_private_key_id AND
			start_date IS NOT DISTINCT FROM NEW.start_date AND
			finish_date IS NOT DISTINCT FROM NEW.finish_date
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property of (n,t) (%,%) already exists for given property',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;

	END IF;

	-- Check to see if the property type is multivalue.  That is, if only
	-- one property and value can be set for any properties with this type
	-- for a specific property LHS

	IF (v_proptype.is_multivalue = false) THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Type = NEW.Property_Type AND
			account_collection_id IS NOT DISTINCT FROM NEW.account_collection_id
				AND
			account_id IS NOT DISTINCT FROM NEW.account_id AND
			account_realm_id IS NOT DISTINCT FROM NEW.account_realm_id AND
			company_collection_id IS NOT DISTINCT FROM NEW.company_collection_id AND
			company_id IS NOT DISTINCT FROM NEW.company_id AND
			device_collection_id IS NOT DISTINCT FROM NEW.device_collection_id AND
			dns_domain_collection_id IS NOT DISTINCT FROM
				NEW.dns_domain_collection_id AND
			layer2_network_collection_id IS NOT DISTINCT FROM
				NEW.layer2_network_collection_id AND
			layer3_network_collection_id IS NOT DISTINCT FROM
				NEW.layer3_network_collection_id AND
			netblock_collection_id IS NOT DISTINCT FROM NEW.netblock_collection_id AND
			network_range_id IS NOT DISTINCT FROM NEW.network_range_id AND
			operating_system_id IS NOT DISTINCT FROM NEW.operating_system_id AND
			operating_system_snapshot_id IS NOT DISTINCT FROM
				NEW.operating_system_snapshot_id AND
			property_name_collection_id IS NOT DISTINCT FROM NEW.property_name_collection_id AND
			service_environment_collection_id IS NOT DISTINCT FROM
				NEW.service_environment_collection_id AND
			service_version_collection_id IS NOT DISTINCT FROM
				NEW.service_version_collection_id AND
			site_code IS NOT DISTINCT FROM NEW.site_code
		;

		IF FOUND THEN
			RAISE EXCEPTION
				'Property % of type % already exists for given LHS and property type is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	END IF;

	-- now validate the property_value columns.
	tally := 0;

	--
	-- first determine if the property_value is set properly.
	--

	-- iterate over each of fk PROPERTY_VALUE columns and if a valid
	-- value is set, increment tally, otherwise raise an exception.
	IF NEW.Property_Value_JSON IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'json' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be JSON' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Password_Type IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'password_type' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Password_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Token_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'token_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Token_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'account_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be account_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'netblock_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be netblock_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_service_version_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'service_version_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be service_version_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Timestamp IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'timestamp' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Timestamp' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'device_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Device_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_boolean IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'boolean' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be boolean' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_encryption_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'encryption_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be encryption_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF NEW.property_value_private_key_id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'private_key_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be private_key_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- at this point, tally will be set to 1 if one of the other property
	-- values is set to something valid.  Now, check the various options for
	-- PROPERTY_VALUE itself.  If a new type is added to the val table, this
	-- trigger needs to be updated or it will be considered invalid.  If a
	-- new PROPERTY_VALUE_* column is added, then it will pass through without
	-- trigger modification.  This should be considered bad.
	IF NEW.Property_Value IS NOT NULL THEN
		tally := tally + 1;
		IF v_prop.Property_Data_Type = 'number' THEN
			BEGIN
				v_num := to_number(NEW.property_value, '9');
			EXCEPTION
				WHEN OTHERS THEN
					RAISE 'Property_Value must be numeric' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'list' THEN
			BEGIN
				SELECT Valid_Property_Value INTO STRICT v_listvalue FROM
					VAL_Property_Value WHERE
						Property_Name = NEW.Property_Name AND
						Property_Type = NEW.Property_Type AND
						Valid_Property_Value = NEW.Property_Value;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					RAISE 'Property_Value must be a valid value' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'boolean' THEN
			RAISE 'Boolean values are set in Property_Value_Boolean' USING
				ERRCODE = 'invalid_parameter_value';
		ELSIF v_prop.Property_Data_Type != 'string' THEN
			RAISE 'Property_Value may not be set for this Property_Data_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF v_prop.Property_Data_Type != 'none' AND tally = 0 THEN
		RAISE 'One of the PROPERTY_VALUE fields must be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	IF tally > 1 THEN
		RAISE 'Only one of the PROPERTY_VALUE fields may be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	-- If the LHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.account_collection_id IS NOT NULL THEN
		IF v_prop.account_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.account_collection_id;
				IF v_account_collection.account_collection_Type != v_prop.account_collection_type
				THEN
					RAISE 'account_collection_id must be of type %',
					v_prop.account_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a company_collection_ID, check to see if it must be a
	-- specific type (e.g. per-company), and verify that if so
	IF NEW.company_collection_id IS NOT NULL THEN
		IF v_prop.company_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_company_collection
					FROM company_collection WHERE
					company_collection_Id = NEW.company_collection_id;
				IF v_company_collection.company_collection_Type != v_prop.company_collection_type
				THEN
					RAISE 'company_collection_id must be of type %',
					v_prop.company_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a device_collection_ID, check to see if it must be a
	-- specific type (e.g. per-device), and verify that if so
	IF NEW.device_collection_id IS NOT NULL THEN
		IF v_prop.device_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_Id = NEW.device_collection_id;
				IF v_device_collection.device_collection_Type != v_prop.device_collection_type
				THEN
					RAISE 'device_collection_id must be of type %',
					v_prop.device_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a dns_domain_collection_ID, check to see if it must be a
	-- specific type (e.g. per-dns_domain), and verify that if so
	IF NEW.dns_domain_collection_id IS NOT NULL THEN
		IF v_prop.dns_domain_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_dns_domain_collection
					FROM dns_domain_collection WHERE
					dns_domain_collection_Id = NEW.dns_domain_collection_id;
				IF v_dns_domain_collection.dns_domain_collection_Type != v_prop.dns_domain_collection_type
				THEN
					RAISE 'dns_domain_collection_id must be of type %',
					v_prop.dns_domain_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer2_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer2_network), and verify that if so
	IF NEW.layer2_network_collection_id IS NOT NULL THEN
		IF v_prop.layer2_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer2_network_collection
					FROM layer2_network_collection WHERE
					layer2_network_collection_Id = NEW.layer2_network_collection_id;
				IF v_layer2_network_collection.layer2_network_collection_Type != v_prop.layer2_network_collection_type
				THEN
					RAISE 'layer2_network_collection_id must be of type %',
					v_prop.layer2_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a layer3_network_collection_ID, check to see if it must be a
	-- specific type (e.g. per-layer3_network), and verify that if so
	IF NEW.layer3_network_collection_id IS NOT NULL THEN
		IF v_prop.layer3_network_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_layer3_network_collection
					FROM layer3_network_collection WHERE
					layer3_network_collection_Id = NEW.layer3_network_collection_id;
				IF v_layer3_network_collection.layer3_network_collection_Type != v_prop.layer3_network_collection_type
				THEN
					RAISE 'layer3_network_collection_id must be of type %',
					v_prop.layer3_network_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type (e.g. per-netblock), and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.netblock_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.netblock_collection_id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.netblock_collection_type
				THEN
					RAISE 'netblock_collection_id must be of type %',
					v_prop.netblock_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a network_range_id, check to see if it must
	-- be a specific type and verify that if so
	IF NEW.netblock_collection_id IS NOT NULL THEN
		IF v_prop.network_range_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_network_range
					FROM network_range WHERE
					network_range_id = NEW.network_range_id;
				IF v_network_range.network_range_type != v_prop.network_range_type
				THEN
					RAISE 'network_range_id must be of type %',
					v_prop.network_range_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a property_name_collection_ID, check to see if it must be a
	-- specific type (e.g. per-property), and verify that if so
	IF NEW.property_name_collection_id IS NOT NULL THEN
		IF v_prop.property_name_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_property_name_collection
					FROM property_name_collection WHERE
					property_name_collection_Id = NEW.property_name_collection_id;
				IF v_property_name_collection.property_name_collection_Type != v_prop.property_name_collection_type
				THEN
					RAISE 'property_name_collection_id must be of type %',
					v_prop.property_name_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the LHS contains a service_environment_collection_ID, check to see if it must be a
	-- specific type (e.g. per-service_env), and verify that if so
	IF NEW.service_environment_collection_id IS NOT NULL THEN
		IF v_prop.service_environment_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_environment_collection
					FROM service_environment_collection WHERE
					service_environment_collection_Id = NEW.service_environment_collection_id;
				IF v_service_environment_collection.service_environment_collection_Type != v_prop.service_environment_collection_type
				THEN
					RAISE 'service_environment_collection_id must be of type %',
					v_prop.service_environment_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;
	IF NEW.service_version_collection_id IS NOT NULL THEN
		IF v_prop.service_version_collection_type IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_version_collection
					FROM service_version_collection WHERE
					service_version_collection_Id = NEW.service_version_collection_id;
				IF v_service_version_collection.service_version_collection_Type != v_prop.service_version_collection_type
				THEN
					RAISE 'service_version_collection_id must be of type %',
					v_prop.service_version_collection_type
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-account), and verify that if so
	IF NEW.Property_Value_Account_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_account_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection
					FROM account_collection WHERE
					account_collection_Id = NEW.Property_Value_Account_collection_Id;
				IF v_account_collection.account_collection_Type != v_prop.property_value_account_collection_type_restriction
				THEN
					RAISE 'Property_Value_Account_collection_Id must be of type %',
					v_prop.property_value_account_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_netblock_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_netblock_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection
					FROM netblock_collection WHERE
					netblock_collection_Id = NEW.Property_Value_netblock_collection_Id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.property_value_netblock_collection_type_restriction
				THEN
					RAISE 'Property_Value_netblock_collection_Id must be of type %',
					v_prop.property_value_netbloc_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a service_version_collection_id, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.property_value_service_version_collection_id IS NOT NULL THEN
		IF v_prop.property_value_service_version_collection_id IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_service_version_collection
					FROM service_version_collection WHERE
					service_version_collection_Id = NEW.property_value_service_version_collection_id;
				IF v_service_version_collection.service_version_collection_Type != v_prop.property_value_service_version_collection_type_restriction
				THEN
					RAISE 'Property_Value_service_version_collection_Id must be of type %',
					v_prop.property_value_service_version_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a device_collection_id, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_Device_collection_Id IS NOT NULL THEN
		IF v_prop.property_value_device_collection_type_restriction IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_device_collection
					FROM device_collection WHERE
					device_collection_id = NEW.Property_Value_Device_collection_Id;
				IF v_device_collection.device_collection_type !=
					v_prop.property_value_device_collection_type_restriction
				THEN
					RAISE 'Property_Value_Device_collection_Id must be of type %',
					v_prop.property_value_device_collection_type_restriction
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	--
	--
	IF v_prop.property_data_type = 'json' THEN
		IF  NOT validate_json_schema(
				v_prop.property_value_json_schema,
				NEW.property_value_json) THEN
			RAISE EXCEPTION 'JSON provided must match the json schema'
				USING ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- At this point, the RHS has been checked, so now we verify data
	-- set on the LHS

	-- There needs to be a stanza here for every "lhs".  If a new column is
	-- added to the property table, a new stanza needs to be added here,
	-- otherwise it will not be validated.  This should be considered bad.

	IF v_prop.Permit_Company_Id = 'REQUIRED' THEN
			IF NEW.Company_Id IS NULL THEN
				RAISE 'Company_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Id = 'PROHIBITED' THEN
			IF NEW.Company_Id IS NOT NULL THEN
				RAISE 'Company_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Company_Collection_Id = 'REQUIRED' THEN
			IF NEW.Company_Collection_Id IS NULL THEN
				RAISE 'Company_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Company_Collection_Id IS NOT NULL THEN
				RAISE 'Company_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Device_Collection_Id = 'REQUIRED' THEN
			IF NEW.Device_Collection_Id IS NULL THEN
				RAISE 'Device_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;

	ELSIF v_prop.Permit_Device_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Device_Collection_Id IS NOT NULL THEN
				RAISE 'Device_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_service_environment_collection_id = 'REQUIRED' THEN
			IF NEW.service_environment_collection_id IS NULL THEN
				RAISE 'service_environment_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_service_environment_collection_id = 'PROHIBITED' THEN
			IF NEW.service_environment_collection_id IS NOT NULL THEN
				RAISE 'service_environment is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_service_version_collection_id = 'REQUIRED' THEN
			IF NEW.service_version_collection_id IS NULL THEN
				RAISE 'service_version_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_service_version_collection_id = 'PROHIBITED' THEN
			IF NEW.service_version_collection_id IS NOT NULL THEN
				RAISE 'service_version_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Operating_System_Id = 'REQUIRED' THEN
			IF NEW.Operating_System_Id IS NULL THEN
				RAISE 'Operating_System_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Operating_System_Id = 'PROHIBITED' THEN
			IF NEW.Operating_System_Id IS NOT NULL THEN
				RAISE 'Operating_System_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_operating_system_snapshot_id = 'REQUIRED' THEN
			IF NEW.operating_system_snapshot_id IS NULL THEN
				RAISE 'operating_system_snapshot_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_operating_system_snapshot_id = 'PROHIBITED' THEN
			IF NEW.operating_system_snapshot_id IS NOT NULL THEN
				RAISE 'operating_system_snapshot_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Site_Code = 'REQUIRED' THEN
			IF NEW.Site_Code IS NULL THEN
				RAISE 'Site_Code is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Site_Code = 'PROHIBITED' THEN
			IF NEW.Site_Code IS NOT NULL THEN
				RAISE 'Site_Code is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Id = 'REQUIRED' THEN
			IF NEW.Account_Id IS NULL THEN
				RAISE 'Account_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Id = 'PROHIBITED' THEN
			IF NEW.Account_Id IS NOT NULL THEN
				RAISE 'Account_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Realm_Id = 'REQUIRED' THEN
			IF NEW.Account_Realm_Id IS NULL THEN
				RAISE 'Account_Realm_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Realm_Id = 'PROHIBITED' THEN
			IF NEW.Account_Realm_Id IS NOT NULL THEN
				RAISE 'Account_Realm_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_account_collection_Id = 'REQUIRED' THEN
			IF NEW.account_collection_Id IS NULL THEN
				RAISE 'account_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_account_collection_Id = 'PROHIBITED' THEN
			IF NEW.account_collection_Id IS NOT NULL THEN
				RAISE 'account_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer2_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer2_network_collection_id IS NULL THEN
				RAISE 'layer2_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer2_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer2_network_collection_id IS NOT NULL THEN
				RAISE 'layer2_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.permit_layer3_network_collection_id = 'REQUIRED' THEN
			IF NEW.layer3_network_collection_id IS NULL THEN
				RAISE 'layer3_network_collection_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.permit_layer3_network_collection_id = 'PROHIBITED' THEN
			IF NEW.layer3_network_collection_id IS NOT NULL THEN
				RAISE 'layer3_network_collection_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_netblock_collection_Id = 'REQUIRED' THEN
			IF NEW.netblock_collection_Id IS NULL THEN
				RAISE 'netblock_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_netblock_collection_Id = 'PROHIBITED' THEN
			IF NEW.netblock_collection_Id IS NOT NULL THEN
				RAISE 'netblock_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_network_range_id = 'REQUIRED' THEN
			IF NEW.network_range_id IS NULL THEN
				RAISE 'network_range_id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_network_range_id = 'PROHIBITED' THEN
			IF NEW.network_range_id IS NOT NULL THEN
				RAISE 'network_range_id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_property_name_collection_Id = 'REQUIRED' THEN
			IF NEW.property_name_collection_Id IS NULL THEN
				RAISE 'property_name_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_property_name_collection_Id = 'PROHIBITED' THEN
			IF NEW.property_name_collection_Id IS NOT NULL THEN
				RAISE 'property_name_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Property_Rank = 'REQUIRED' THEN
			IF NEW.property_rank IS NULL THEN
				RAISE 'property_rank is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Property_Rank = 'PROHIBITED' THEN
			IF NEW.property_rank IS NOT NULL THEN
				RAISE 'property_rank is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	RETURN NEW;
END;
$function$
;

DO $$
-- not dropping regrants here.
BEGIN
	DELETE FROM __recreate WHERE schema = 'property_utils' AND type = 'function' AND object IN ('validate_property');
EXCEPTION WHEN undefined_table THEN
	RAISE NOTICE 'Drop of proc validate_property failed but that is ok';
	NULL;
END;
$$;

SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
SELECT schema_support.replay_object_recreates(tags := ARRAY['process_all_procs_in_schema_property_utils']);
-- Dropping obsoleted sequences....
DROP SEQUENCE IF EXISTS device_note_note_id_seq;
DROP SEQUENCE IF EXISTS layer3_acl_chain_layer3_interface_layer3_acl_chain_id_seq;
DROP SEQUENCE IF EXISTS layer3_acl_chain_layer3_interface_layer3_interface_id_seq;
DROP SEQUENCE IF EXISTS note_id_seq;
DROP SEQUENCE IF EXISTS person_note_note_id_seq;
DROP SEQUENCE IF EXISTS service_depend_service_depend_id_seq;
DROP SEQUENCE IF EXISTS service_endpoint_provider_col_service_endpoint_provider_co_seq1;
DROP SEQUENCE IF EXISTS service_endpoint_provider_coll_service_endpoint_provider_id_seq;
DROP SEQUENCE IF EXISTS service_software_repository_software_artifact_repository_id_seq;
DROP SEQUENCE IF EXISTS service_version_artifact_software_artifact_name_id_seq;
DROP SEQUENCE IF EXISTS service_version_software_arti_software_artifact_repository__seq;
DROP SEQUENCE IF EXISTS software_artifact_system_software_artifact_system_id_seq;
DROP SEQUENCE IF EXISTS source_repository_location_source_repository_location_id_seq;
DROP SEQUENCE IF EXISTS source_repository_url_source_repository_id_seq;


-- Dropping obsoleted jazzhands_audit sequences....
DROP SEQUENCE IF EXISTS jazzhands_audit.service_depend_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_depend_service_feature_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.service_endpoint_provider_collection_service_endpoint_provider_;
DROP SEQUENCE IF EXISTS jazzhands_audit.software_artifact_repository_location_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.software_artifact_system_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.source_repository_location_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.source_repository_url_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_package_relation_type_seq;
DROP SEQUENCE IF EXISTS jazzhands_audit.val_source_repository_url_purpose_seq;


-- Processing tables with no structural changes
-- Some of these may be redundant
-- fk constraints
ALTER TABLE logical_volume DROP CONSTRAINT IF EXISTS ak_logvol_devid_lvname;
ALTER TABLE logical_volume
	ADD CONSTRAINT ak_logvol_devid_lvname
	UNIQUE (device_id, logical_volume_name, logical_volume_type, volume_group_id);

ALTER TABLE service DROP CONSTRAINT IF EXISTS ak_service_name_type;
ALTER TABLE service
	ADD CONSTRAINT ak_service_name_type
	UNIQUE (service_id, service_type);

-- index
-- triggers
DROP TRIGGER IF EXISTS trig_account_change_realm_aca_realm ON account;
CREATE TRIGGER trig_account_change_realm_aca_realm BEFORE UPDATE OF account_realm_id ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_change_realm_aca_realm();
DROP TRIGGER IF EXISTS trig_add_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_add_account_automated_reporting_ac AFTER INSERT OR UPDATE OF login, account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_add_automated_ac_on_account ON account;
CREATE TRIGGER trig_add_automated_ac_on_account AFTER INSERT OR UPDATE OF account_type, account_role, account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_rm_account_automated_reporting_ac ON account;
CREATE TRIGGER trig_rm_account_automated_reporting_ac BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_automated_reporting_ac();
DROP TRIGGER IF EXISTS trig_rm_automated_ac_on_account ON account;
CREATE TRIGGER trig_rm_automated_ac_on_account BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_account();
DROP TRIGGER IF EXISTS trig_userlog_account ON account;
CREATE TRIGGER trig_userlog_account BEFORE INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_enforce_is_enabled ON account;
CREATE TRIGGER trigger_account_enforce_is_enabled BEFORE INSERT OR UPDATE OF account_status, is_enabled ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_enforce_is_enabled();
DROP TRIGGER IF EXISTS trigger_account_status_per_row_after_hooks ON account;
CREATE TRIGGER trigger_account_status_per_row_after_hooks AFTER UPDATE OF account_status ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_status_per_row_after_hooks();
DROP TRIGGER IF EXISTS trigger_account_validate_login ON account;
CREATE TRIGGER trigger_account_validate_login BEFORE INSERT OR UPDATE OF login ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_validate_login();
DROP TRIGGER IF EXISTS trigger_audit_account ON account;
CREATE TRIGGER trigger_audit_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account();
DROP TRIGGER IF EXISTS trigger_create_new_unix_account ON account;
CREATE TRIGGER trigger_create_new_unix_account AFTER INSERT ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.create_new_unix_account();
DROP TRIGGER IF EXISTS trigger_delete_peraccount_account_collection ON account;
CREATE TRIGGER trigger_delete_peraccount_account_collection BEFORE DELETE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_peraccount_account_collection();
DROP TRIGGER IF EXISTS trigger_update_peraccount_account_collection ON account;
CREATE TRIGGER trigger_update_peraccount_account_collection AFTER INSERT OR UPDATE ON jazzhands.account FOR EACH ROW EXECUTE FUNCTION jazzhands.update_peraccount_account_collection();
DROP TRIGGER IF EXISTS trig_userlog_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trig_userlog_account_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_assigned_certificate ON account_assigned_certificate;
CREATE TRIGGER trigger_audit_account_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_assigned_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_assigned_certificate();
DROP TRIGGER IF EXISTS trig_userlog_account_authentication_log ON account_authentication_log;
CREATE TRIGGER trig_userlog_account_authentication_log BEFORE INSERT OR UPDATE ON jazzhands.account_authentication_log FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_authentication_log ON account_authentication_log;
CREATE TRIGGER trigger_audit_account_authentication_log AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_authentication_log FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_authentication_log();
DROP TRIGGER IF EXISTS aaa_account_collection_base_handler ON account_collection;
CREATE TRIGGER aaa_account_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.account_collection_base_handler();
DROP TRIGGER IF EXISTS trig_account_collection_realm ON account_collection;
CREATE TRIGGER trig_account_collection_realm AFTER UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection ON account_collection;
CREATE TRIGGER trig_userlog_account_collection BEFORE INSERT OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection ON account_collection;
CREATE TRIGGER trigger_audit_account_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection();
DROP TRIGGER IF EXISTS trigger_validate_account_collection_type_change ON account_collection;
CREATE TRIGGER trigger_validate_account_collection_type_change BEFORE UPDATE OF account_collection_type ON jazzhands.account_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_account_collection_type_change();
DROP TRIGGER IF EXISTS trig_account_collection_account_realm ON account_collection_account;
CREATE TRIGGER trig_account_collection_account_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_account ON account_collection_account;
CREATE TRIGGER trig_userlog_account_collection_account BEFORE INSERT OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_coll_member_relation_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_coll_member_relation_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_coll_member_relation_enforce();
DROP TRIGGER IF EXISTS trigger_account_collection_member_enforce ON account_collection_account;
CREATE CONSTRAINT TRIGGER trigger_account_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_account DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_account ON account_collection_account;
CREATE TRIGGER trigger_audit_account_collection_account AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_account();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_collection_account_token_changes ON account_collection_account;
CREATE TRIGGER trigger_pgnotify_account_collection_account_token_changes AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_account FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_collection_account_token_changes();
DROP TRIGGER IF EXISTS aaa_account_collection_root_handler ON account_collection_hier;
CREATE TRIGGER aaa_account_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF account_collection_id, child_account_collection_id ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.account_collection_root_handler();
DROP TRIGGER IF EXISTS trig_account_collection_hier_realm ON account_collection_hier;
CREATE TRIGGER trig_account_collection_hier_realm AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_hier_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trig_userlog_account_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_account_collection_hier_enforce ON account_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_account_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_hier ON account_collection_hier;
CREATE TRIGGER trigger_audit_account_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_account_collection_hier_loop ON account_collection_hier;
CREATE TRIGGER trigger_check_account_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.account_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_account_colllection_hier_loop();
DROP TRIGGER IF EXISTS trig_userlog_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trig_userlog_account_collection_type_relation BEFORE INSERT OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_collection_type_relation ON account_collection_type_relation;
CREATE TRIGGER trigger_audit_account_collection_type_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_collection_type_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_collection_type_relation();
DROP TRIGGER IF EXISTS trig_userlog_account_password ON account_password;
CREATE TRIGGER trig_userlog_account_password BEFORE INSERT OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_password ON account_password;
CREATE TRIGGER trigger_audit_account_password AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_password();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_password_changes ON account_password;
CREATE TRIGGER trigger_pgnotify_account_password_changes AFTER INSERT OR UPDATE ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_password_changes();
DROP TRIGGER IF EXISTS trigger_pull_password_account_realm_from_account ON account_password;
CREATE TRIGGER trigger_pull_password_account_realm_from_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.pull_password_account_realm_from_account();
DROP TRIGGER IF EXISTS trigger_unrequire_password_change ON account_password;
CREATE TRIGGER trigger_unrequire_password_change BEFORE INSERT OR UPDATE OF password ON jazzhands.account_password FOR EACH ROW EXECUTE FUNCTION jazzhands.unrequire_password_change();
DROP TRIGGER IF EXISTS trig_userlog_account_realm ON account_realm;
CREATE TRIGGER trig_userlog_account_realm BEFORE INSERT OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm ON account_realm;
CREATE TRIGGER trigger_audit_account_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trig_userlog_account_realm_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_account_collection_type ON account_realm_account_collection_type;
CREATE TRIGGER trigger_audit_account_realm_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_company ON account_realm_company;
CREATE TRIGGER trig_userlog_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_company ON account_realm_company;
CREATE TRIGGER trigger_audit_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trig_userlog_account_realm_password_type BEFORE INSERT OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_realm_password_type ON account_realm_password_type;
CREATE TRIGGER trigger_audit_account_realm_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_realm_password_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_realm_password_type();
DROP TRIGGER IF EXISTS trig_userlog_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trig_userlog_account_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_ssh_key ON account_ssh_key;
CREATE TRIGGER trigger_audit_account_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_account_token ON account_token;
CREATE TRIGGER trig_userlog_account_token BEFORE INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_token ON account_token;
CREATE TRIGGER trigger_audit_account_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_account_token_change ON account_token;
CREATE TRIGGER trigger_pgnotify_account_token_change AFTER INSERT OR UPDATE ON jazzhands.account_token FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_account_token_change();
DROP TRIGGER IF EXISTS trig_userlog_account_unix_info ON account_unix_info;
CREATE TRIGGER trig_userlog_account_unix_info BEFORE INSERT OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_account_unix_info ON account_unix_info;
CREATE TRIGGER trigger_audit_account_unix_info AFTER INSERT OR DELETE OR UPDATE ON jazzhands.account_unix_info FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_account_unix_info();
DROP TRIGGER IF EXISTS trig_userlog_appaal ON appaal;
CREATE TRIGGER trig_userlog_appaal BEFORE INSERT OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal ON appaal;
CREATE TRIGGER trigger_audit_appaal AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance ON appaal_instance;
CREATE TRIGGER trig_userlog_appaal_instance BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance ON appaal_instance;
CREATE TRIGGER trigger_audit_appaal_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trig_userlog_appaal_instance_device_collection BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_device_collection ON appaal_instance_device_collection;
CREATE TRIGGER trigger_audit_appaal_instance_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trig_userlog_appaal_instance_property BEFORE INSERT OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_appaal_instance_property ON appaal_instance_property;
CREATE TRIGGER trigger_audit_appaal_instance_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.appaal_instance_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_appaal_instance_property();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance ON approval_instance;
CREATE TRIGGER trig_userlog_approval_instance BEFORE INSERT OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance ON approval_instance;
CREATE TRIGGER trigger_audit_approval_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trig_userlog_approval_instance_item BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approval_notify ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approval_notify AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.approval_instance_item_approval_notify();
DROP TRIGGER IF EXISTS trigger_approval_instance_item_approved_immutable ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_item_approved_immutable BEFORE UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_item_approved_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_auto_complete ON approval_instance_item;
CREATE TRIGGER trigger_approval_instance_step_auto_complete AFTER INSERT OR UPDATE OF is_approved ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_auto_complete();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_item ON approval_instance_item;
CREATE TRIGGER trigger_audit_approval_instance_item AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_item FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_item();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trig_userlog_approval_instance_link BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_link ON approval_instance_link;
CREATE TRIGGER trigger_audit_approval_instance_link AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_link FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_link();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trig_userlog_approval_instance_step BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_completed_immutable ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_completed_immutable BEFORE UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_completed_immutable();
DROP TRIGGER IF EXISTS trigger_approval_instance_step_resolve_instance ON approval_instance_step;
CREATE TRIGGER trigger_approval_instance_step_resolve_instance AFTER UPDATE OF is_completed ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.approval_instance_step_resolve_instance();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step ON approval_instance_step;
CREATE TRIGGER trigger_audit_approval_instance_step AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_step();
DROP TRIGGER IF EXISTS trig_userlog_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trig_userlog_approval_instance_step_notify BEFORE INSERT OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_instance_step_notify ON approval_instance_step_notify;
CREATE TRIGGER trigger_audit_approval_instance_step_notify AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_instance_step_notify();
DROP TRIGGER IF EXISTS trigger_legacy_approval_instance_step_notify_account ON approval_instance_step_notify;
CREATE TRIGGER trigger_legacy_approval_instance_step_notify_account BEFORE INSERT OR UPDATE OF account_id ON jazzhands.approval_instance_step_notify FOR EACH ROW EXECUTE FUNCTION jazzhands.legacy_approval_instance_step_notify_account();
DROP TRIGGER IF EXISTS trig_userlog_approval_process ON approval_process;
CREATE TRIGGER trig_userlog_approval_process BEFORE INSERT OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_process ON approval_process;
CREATE TRIGGER trigger_audit_approval_process AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_process FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_process();
DROP TRIGGER IF EXISTS trig_userlog_approval_process_chain ON approval_process_chain;
CREATE TRIGGER trig_userlog_approval_process_chain BEFORE INSERT OR UPDATE ON jazzhands.approval_process_chain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_approval_process_chain ON approval_process_chain;
CREATE TRIGGER trigger_audit_approval_process_chain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.approval_process_chain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_approval_process_chain();
DROP TRIGGER IF EXISTS trig_userlog_asset ON asset;
CREATE TRIGGER trig_userlog_asset BEFORE INSERT OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_asset ON asset;
CREATE TRIGGER trigger_audit_asset AFTER INSERT OR DELETE OR UPDATE ON jazzhands.asset FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_asset();
DROP TRIGGER IF EXISTS trigger_validate_asset_component_assignment ON asset;
CREATE CONSTRAINT TRIGGER trigger_validate_asset_component_assignment AFTER INSERT OR UPDATE OF component_id ON jazzhands.asset DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_asset_component_assignment();
DROP TRIGGER IF EXISTS trig_userlog_badge ON badge;
CREATE TRIGGER trig_userlog_badge BEFORE INSERT OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge ON badge;
CREATE TRIGGER trigger_audit_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_badge();
DROP TRIGGER IF EXISTS trig_userlog_badge_type ON badge_type;
CREATE TRIGGER trig_userlog_badge_type BEFORE INSERT OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_badge_type ON badge_type;
CREATE TRIGGER trigger_audit_badge_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.badge_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_badge_type();
DROP TRIGGER IF EXISTS trig_userlog_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trig_userlog_certificate_signing_request BEFORE INSERT OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_certificate_signing_request ON certificate_signing_request;
CREATE TRIGGER trigger_audit_certificate_signing_request AFTER INSERT OR DELETE OR UPDATE ON jazzhands.certificate_signing_request FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_certificate_signing_request();
DROP TRIGGER IF EXISTS trig_userlog_chassis_location ON chassis_location;
CREATE TRIGGER trig_userlog_chassis_location BEFORE INSERT OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_chassis_location ON chassis_location;
CREATE TRIGGER trigger_audit_chassis_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.chassis_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_chassis_location();
DROP TRIGGER IF EXISTS trig_userlog_circuit ON circuit;
CREATE TRIGGER trig_userlog_circuit BEFORE INSERT OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_circuit ON circuit;
CREATE TRIGGER trigger_audit_circuit AFTER INSERT OR DELETE OR UPDATE ON jazzhands.circuit FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_circuit();
DROP TRIGGER IF EXISTS trig_userlog_company ON company;
CREATE TRIGGER trig_userlog_company BEFORE INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company ON company;
CREATE TRIGGER trigger_audit_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company();
DROP TRIGGER IF EXISTS trigger_company_insert_function_nudge ON company;
CREATE TRIGGER trigger_company_insert_function_nudge BEFORE INSERT ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.company_insert_function_nudge();
DROP TRIGGER IF EXISTS trigger_delete_per_company_company_collection ON company;
CREATE TRIGGER trigger_delete_per_company_company_collection BEFORE DELETE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_company_company_collection();
DROP TRIGGER IF EXISTS trigger_update_per_company_company_collection ON company;
CREATE TRIGGER trigger_update_per_company_company_collection AFTER INSERT OR UPDATE ON jazzhands.company FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_company_company_collection();
DROP TRIGGER IF EXISTS trig_userlog_company_collection ON company_collection;
CREATE TRIGGER trig_userlog_company_collection BEFORE INSERT OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection ON company_collection;
CREATE TRIGGER trigger_audit_company_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_del ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_del BEFORE DELETE ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_bytype_insup ON company_collection;
CREATE TRIGGER trigger_manip_company_collection_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_company_collection_type_change ON company_collection;
CREATE TRIGGER trigger_validate_company_collection_type_change BEFORE UPDATE OF company_collection_type ON jazzhands.company_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_company_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_company ON company_collection_company;
CREATE TRIGGER trig_userlog_company_collection_company BEFORE INSERT OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_company ON company_collection_company;
CREATE TRIGGER trigger_audit_company_collection_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection_company();
DROP TRIGGER IF EXISTS trigger_company_collection_member_enforce ON company_collection_company;
CREATE CONSTRAINT TRIGGER trigger_company_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_company DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.company_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trig_userlog_company_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_collection_hier ON company_collection_hier;
CREATE TRIGGER trigger_audit_company_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_collection_hier();
DROP TRIGGER IF EXISTS trigger_company_collection_hier_enforce ON company_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_company_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.company_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.company_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_company_type ON company_type;
CREATE TRIGGER trig_userlog_company_type BEFORE INSERT OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_company_type ON company_type;
CREATE TRIGGER trigger_audit_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.company_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_company_type();
DROP TRIGGER IF EXISTS aaa_tg_cache_component_parent_handler ON component;
CREATE TRIGGER aaa_tg_cache_component_parent_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_component_parent_handler();
DROP TRIGGER IF EXISTS aab_tg_cache_device_component_component_handler ON component;
CREATE TRIGGER aab_tg_cache_device_component_component_handler AFTER INSERT OR DELETE OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_device_component_component_handler();
DROP TRIGGER IF EXISTS trig_userlog_component ON component;
CREATE TRIGGER trig_userlog_component BEFORE INSERT OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component ON component;
CREATE TRIGGER trigger_audit_component AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component();
DROP TRIGGER IF EXISTS trigger_create_component_template_slots ON component;
CREATE TRIGGER trigger_create_component_template_slots AFTER INSERT OR UPDATE OF component_type_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.create_component_slots_by_trigger();
DROP TRIGGER IF EXISTS trigger_validate_component_parent_slot_id ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_parent_slot_id AFTER INSERT OR UPDATE OF parent_slot_id, component_type_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_parent_slot_id();
DROP TRIGGER IF EXISTS trigger_validate_component_rack_location ON component;
CREATE CONSTRAINT TRIGGER trigger_validate_component_rack_location AFTER INSERT OR UPDATE OF rack_location_id ON jazzhands.component DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_rack_location();
DROP TRIGGER IF EXISTS trigger_zzz_generate_slot_names ON component;
CREATE TRIGGER trigger_zzz_generate_slot_names AFTER INSERT OR UPDATE OF parent_slot_id ON jazzhands.component FOR EACH ROW EXECUTE FUNCTION jazzhands.set_slot_names_by_trigger();
DROP TRIGGER IF EXISTS trig_userlog_component_property ON component_property;
CREATE TRIGGER trig_userlog_component_property BEFORE INSERT OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_property ON component_property;
CREATE TRIGGER trigger_audit_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_property();
DROP TRIGGER IF EXISTS trigger_validate_component_property ON component_property;
CREATE CONSTRAINT TRIGGER trigger_validate_component_property AFTER INSERT OR UPDATE ON jazzhands.component_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_component_property();
DROP TRIGGER IF EXISTS trig_userlog_component_type ON component_type;
CREATE TRIGGER trig_userlog_component_type BEFORE INSERT OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type ON component_type;
CREATE TRIGGER trigger_audit_component_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type();
DROP TRIGGER IF EXISTS trig_userlog_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trig_userlog_component_type_component_function BEFORE INSERT OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_component_function ON component_type_component_function;
CREATE TRIGGER trigger_audit_component_type_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_component_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type_component_function();
DROP TRIGGER IF EXISTS trig_userlog_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trig_userlog_component_type_slot_template BEFORE INSERT OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_component_type_slot_template ON component_type_slot_template;
CREATE TRIGGER trigger_audit_component_type_slot_template AFTER INSERT OR DELETE OR UPDATE ON jazzhands.component_type_slot_template FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_component_type_slot_template();
DROP TRIGGER IF EXISTS trig_userlog_contract ON contract;
CREATE TRIGGER trig_userlog_contract BEFORE INSERT OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract ON contract;
CREATE TRIGGER trigger_audit_contract AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_contract();
DROP TRIGGER IF EXISTS trig_userlog_contract_type ON contract_type;
CREATE TRIGGER trig_userlog_contract_type BEFORE INSERT OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_contract_type ON contract_type;
CREATE TRIGGER trigger_audit_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.contract_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_department ON department;
CREATE TRIGGER trig_userlog_department BEFORE INSERT OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_department ON department;
CREATE TRIGGER trigger_audit_department AFTER INSERT OR DELETE OR UPDATE ON jazzhands.department FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_department();
DROP TRIGGER IF EXISTS tg_cache_device_component_device_handler ON device;
CREATE TRIGGER tg_cache_device_component_device_handler AFTER INSERT OR DELETE OR UPDATE OF component_id ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_device_component_device_handler();
DROP TRIGGER IF EXISTS trig_userlog_device ON device;
CREATE TRIGGER trig_userlog_device BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device ON device;
CREATE TRIGGER trigger_audit_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device();
DROP TRIGGER IF EXISTS trigger_create_device_component ON device;
CREATE TRIGGER trigger_create_device_component BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.create_device_component_by_trigger();
DROP TRIGGER IF EXISTS trigger_del_jazzhands_legacy_support ON device;
CREATE TRIGGER trigger_del_jazzhands_legacy_support BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.del_jazzhands_legacy_support();
DROP TRIGGER IF EXISTS trigger_delete_per_device_device_collection ON device;
CREATE TRIGGER trigger_delete_per_device_device_collection BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_device_one_location_validate ON device;
CREATE TRIGGER trigger_device_one_location_validate BEFORE INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.device_one_location_validate();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_del ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_del BEFORE DELETE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_ins ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_ins AFTER INSERT ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_device_upd ON device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_device_upd AFTER UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_device_upd();
DROP TRIGGER IF EXISTS trigger_update_per_device_device_collection ON device;
CREATE TRIGGER trigger_update_per_device_device_collection AFTER INSERT OR UPDATE ON jazzhands.device FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_device_device_collection();
DROP TRIGGER IF EXISTS trigger_validate_device_component_assignment ON device;
CREATE CONSTRAINT TRIGGER trigger_validate_device_component_assignment AFTER INSERT OR UPDATE OF device_type_id, component_id ON jazzhands.device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_device_component_assignment();
DROP TRIGGER IF EXISTS aaa_device_collection_base_handler ON device_collection;
CREATE TRIGGER aaa_device_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.device_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection ON device_collection;
CREATE TRIGGER trig_userlog_device_collection BEFORE INSERT OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection ON device_collection;
CREATE TRIGGER trigger_audit_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_del ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_del BEFORE DELETE ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_bytype_insup ON device_collection;
CREATE TRIGGER trigger_manip_device_collection_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_device_collection_type_change ON device_collection;
CREATE TRIGGER trigger_validate_device_collection_type_change BEFORE UPDATE OF device_collection_type ON jazzhands.device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_device_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trig_userlog_device_collection_assigned_certificate BEFORE INSERT OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_assigned_certificate ON device_collection_assigned_certificate;
CREATE TRIGGER trigger_audit_device_collection_assigned_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_assigned_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_assigned_certificate();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_device ON device_collection_device;
CREATE TRIGGER trig_userlog_device_collection_device BEFORE INSERT OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_device ON device_collection_device;
CREATE TRIGGER trigger_audit_device_collection_device AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_device();
DROP TRIGGER IF EXISTS trigger_device_collection_member_enforce ON device_collection_device;
CREATE CONSTRAINT TRIGGER trigger_device_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_device DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_del ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_del BEFORE DELETE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_del();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_ins ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_ins AFTER INSERT ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_ins();
DROP TRIGGER IF EXISTS trigger_jazzhands_legacy_device_columns_dcd_upd ON device_collection_device;
CREATE TRIGGER trigger_jazzhands_legacy_device_columns_dcd_upd AFTER UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.jazzhands_legacy_device_columns_dcd_upd();
DROP TRIGGER IF EXISTS trigger_member_device_collection_after_hooks ON device_collection_device;
CREATE TRIGGER trigger_member_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_member_device_collection_after_row_hooks ON device_collection_device;
CREATE TRIGGER trigger_member_device_collection_after_row_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_device FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_device_after_row_hooks();
DROP TRIGGER IF EXISTS aaa_device_collection_root_handler ON device_collection_hier;
CREATE TRIGGER aaa_device_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF device_collection_id, child_device_collection_id ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.device_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trig_userlog_device_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_hier ON device_collection_hier;
CREATE TRIGGER trigger_audit_device_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_device_collection_hier_loop ON device_collection_hier;
CREATE TRIGGER trigger_check_device_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_device_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_device_collection_hier_enforce ON device_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_device_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.device_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_hier_enforce();
DROP TRIGGER IF EXISTS trigger_hier_device_collection_after_hooks ON device_collection_hier;
CREATE TRIGGER trigger_hier_device_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.device_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_hier_device_collection_after_row_hooks ON device_collection_hier;
CREATE TRIGGER trigger_hier_device_collection_after_row_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.device_collection_hier_after_row_hooks();
DROP TRIGGER IF EXISTS trig_userlog_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trig_userlog_device_collection_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_collection_ssh_key ON device_collection_ssh_key;
CREATE TRIGGER trigger_audit_device_collection_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_collection_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_collection_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trig_userlog_device_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_encapsulation_domain ON device_encapsulation_domain;
CREATE TRIGGER trigger_audit_device_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_encapsulation_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trig_userlog_device_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_layer2_network ON device_layer2_network;
CREATE TRIGGER trigger_audit_device_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_device_management_controller ON device_management_controller;
CREATE TRIGGER trig_userlog_device_management_controller BEFORE INSERT OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_management_controller ON device_management_controller;
CREATE TRIGGER trigger_audit_device_management_controller AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_management_controller FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_management_controller();
DROP TRIGGER IF EXISTS trig_userlog_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trig_userlog_device_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ssh_key ON device_ssh_key;
CREATE TRIGGER trigger_audit_device_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_device_ticket ON device_ticket;
CREATE TRIGGER trig_userlog_device_ticket BEFORE INSERT OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_ticket ON device_ticket;
CREATE TRIGGER trigger_audit_device_ticket AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_ticket FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_ticket();
DROP TRIGGER IF EXISTS trig_userlog_device_type ON device_type;
CREATE TRIGGER trig_userlog_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type ON device_type;
CREATE TRIGGER trigger_audit_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type();
DROP TRIGGER IF EXISTS trigger_device_type_chassis_check ON device_type;
CREATE TRIGGER trigger_device_type_chassis_check BEFORE UPDATE OF is_chassis ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_model_to_name ON device_type;
CREATE TRIGGER trigger_device_type_model_to_name BEFORE INSERT OR UPDATE OF device_type_name, model ON jazzhands.device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_model_to_name();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module ON device_type_module;
CREATE TRIGGER trig_userlog_device_type_module BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module ON device_type_module;
CREATE TRIGGER trigger_audit_device_type_module AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type_module();
DROP TRIGGER IF EXISTS trigger_device_type_module_chassis_check ON device_type_module;
CREATE TRIGGER trigger_device_type_module_chassis_check BEFORE INSERT OR UPDATE OF device_type_id ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_module_chassis_check();
DROP TRIGGER IF EXISTS trigger_device_type_module_sanity_set ON device_type_module;
CREATE TRIGGER trigger_device_type_module_sanity_set BEFORE INSERT OR UPDATE ON jazzhands.device_type_module FOR EACH ROW EXECUTE FUNCTION jazzhands.device_type_module_sanity_set();
DROP TRIGGER IF EXISTS trig_userlog_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trig_userlog_device_type_module_device_type BEFORE INSERT OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_device_type_module_device_type ON device_type_module_device_type;
CREATE TRIGGER trigger_audit_device_type_module_device_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.device_type_module_device_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_device_type_module_device_type();
DROP TRIGGER IF EXISTS trig_userlog_dns_change_record ON dns_change_record;
CREATE TRIGGER trig_userlog_dns_change_record BEFORE INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_change_record ON dns_change_record;
CREATE TRIGGER trigger_audit_dns_change_record AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_change_record FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_change_record();
DROP TRIGGER IF EXISTS trigger_dns_change_record_pgnotify ON dns_change_record;
CREATE TRIGGER trigger_dns_change_record_pgnotify AFTER INSERT OR UPDATE ON jazzhands.dns_change_record FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.dns_change_record_pgnotify();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain ON dns_domain;
CREATE TRIGGER trig_userlog_dns_domain BEFORE INSERT OR UPDATE ON jazzhands.dns_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain ON dns_domain;
CREATE TRIGGER trigger_audit_dns_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_trigger_change ON dns_domain;
CREATE TRIGGER trigger_dns_domain_trigger_change AFTER INSERT OR UPDATE OF dns_domain_name ON jazzhands.dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_trigger_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trig_userlog_dns_domain_collection BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection ON dns_domain_collection;
CREATE TRIGGER trigger_audit_dns_domain_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_del ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_del BEFORE DELETE ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_bytype_insup ON dns_domain_collection;
CREATE TRIGGER trigger_manip_dns_domain_collection_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_dns_domain_collection_type_change ON dns_domain_collection;
CREATE TRIGGER trigger_validate_dns_domain_collection_type_change BEFORE UPDATE OF dns_domain_collection_type ON jazzhands.dns_domain_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_dns_domain_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trig_userlog_dns_domain_collection_dns_domain BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_dns_domain ON dns_domain_collection_dns_domain;
CREATE TRIGGER trigger_audit_dns_domain_collection_dns_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_dns_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection_dns_domain();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_member_enforce ON dns_domain_collection_dns_domain;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_dns_domain DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trig_userlog_dns_domain_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_collection_hier ON dns_domain_collection_hier;
CREATE TRIGGER trigger_audit_dns_domain_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_collection_hier();
DROP TRIGGER IF EXISTS trigger_dns_domain_collection_hier_enforce ON dns_domain_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_dns_domain_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.dns_domain_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trig_userlog_dns_domain_ip_universe BEFORE INSERT OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_domain_ip_universe ON dns_domain_ip_universe;
CREATE TRIGGER trigger_audit_dns_domain_ip_universe AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_domain_ip_universe();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_can_generate ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_can_generate AFTER INSERT OR UPDATE OF should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_ip_universe_can_generate();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_trigger_change ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_trigger_change AFTER INSERT OR UPDATE OF soa_class, soa_ttl, soa_serial, soa_refresh, soa_retry, soa_expire, soa_minimum, soa_mname, soa_rname, should_generate ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_ip_universe_trigger_change();
DROP TRIGGER IF EXISTS trigger_dns_domain_ip_universe_trigger_del ON dns_domain_ip_universe;
CREATE TRIGGER trigger_dns_domain_ip_universe_trigger_del BEFORE DELETE ON jazzhands.dns_domain_ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_ip_universe_trigger_del();
DROP TRIGGER IF EXISTS trig_userlog_dns_record ON dns_record;
CREATE TRIGGER trig_userlog_dns_record BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_record ON dns_record;
CREATE TRIGGER trigger_audit_dns_record AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_record();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_dns_record ON dns_record;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_dns_record AFTER INSERT OR UPDATE OF dns_record_id, ip_universe_id ON jazzhands.dns_record DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_ip_universe_dns_record();
DROP TRIGGER IF EXISTS trigger_dns_a_rec_validation ON dns_record;
CREATE TRIGGER trigger_dns_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_a_rec_validation();
DROP TRIGGER IF EXISTS trigger_dns_non_a_rec_validation ON dns_record;
CREATE TRIGGER trigger_dns_non_a_rec_validation BEFORE INSERT OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_non_a_rec_validation();
DROP TRIGGER IF EXISTS trigger_dns_rec_prevent_dups ON dns_record;
CREATE CONSTRAINT TRIGGER trigger_dns_rec_prevent_dups AFTER INSERT OR UPDATE ON jazzhands.dns_record NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_rec_prevent_dups();
DROP TRIGGER IF EXISTS trigger_dns_record_check_name ON dns_record;
CREATE TRIGGER trigger_dns_record_check_name BEFORE INSERT OR UPDATE OF dns_name, should_generate_ptr ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_check_name();
DROP TRIGGER IF EXISTS trigger_dns_record_cname_checker ON dns_record;
CREATE CONSTRAINT TRIGGER trigger_dns_record_cname_checker AFTER INSERT OR UPDATE OF dns_class, dns_type, dns_name, dns_domain_id, is_enabled ON jazzhands.dns_record NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_cname_checker();
DROP TRIGGER IF EXISTS trigger_dns_record_enabled_check ON dns_record;
CREATE TRIGGER trigger_dns_record_enabled_check BEFORE INSERT OR UPDATE OF is_enabled ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_enabled_check();
DROP TRIGGER IF EXISTS trigger_dns_record_update_nontime ON dns_record;
CREATE TRIGGER trigger_dns_record_update_nontime AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_record_update_nontime();
DROP TRIGGER IF EXISTS trig_userlog_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trig_userlog_dns_record_relation BEFORE INSERT OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_dns_record_relation ON dns_record_relation;
CREATE TRIGGER trigger_audit_dns_record_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.dns_record_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_dns_record_relation();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trig_userlog_encapsulation_domain BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_domain ON encapsulation_domain;
CREATE TRIGGER trigger_audit_encapsulation_domain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_domain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_encapsulation_domain();
DROP TRIGGER IF EXISTS trig_userlog_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trig_userlog_encapsulation_range BEFORE INSERT OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encapsulation_range ON encapsulation_range;
CREATE TRIGGER trigger_audit_encapsulation_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encapsulation_range FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_encapsulation_range();
DROP TRIGGER IF EXISTS trig_userlog_encryption_key ON encryption_key;
CREATE TRIGGER trig_userlog_encryption_key BEFORE INSERT OR UPDATE ON jazzhands.encryption_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_encryption_key ON encryption_key;
CREATE TRIGGER trigger_audit_encryption_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.encryption_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_encryption_key();
DROP TRIGGER IF EXISTS trig_userlog_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trig_userlog_inter_component_connection BEFORE INSERT OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_inter_component_connection ON inter_component_connection;
CREATE TRIGGER trigger_audit_inter_component_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.inter_component_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_inter_component_connection();
DROP TRIGGER IF EXISTS trigger_validate_inter_component_connection ON inter_component_connection;
CREATE CONSTRAINT TRIGGER trigger_validate_inter_component_connection AFTER INSERT OR UPDATE ON jazzhands.inter_component_connection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_inter_component_connection();
DROP TRIGGER IF EXISTS trig_userlog_ip_universe ON ip_universe;
CREATE TRIGGER trig_userlog_ip_universe BEFORE INSERT OR UPDATE ON jazzhands.ip_universe FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ip_universe ON ip_universe;
CREATE TRIGGER trigger_audit_ip_universe AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ip_universe FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ip_universe();
DROP TRIGGER IF EXISTS trig_userlog_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trig_userlog_ip_universe_visibility BEFORE INSERT OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ip_universe_visibility ON ip_universe_visibility;
CREATE TRIGGER trigger_audit_ip_universe_visibility AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ip_universe_visibility FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ip_universe_visibility();
DROP TRIGGER IF EXISTS trig_userlog_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trig_userlog_kerberos_realm BEFORE INSERT OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_kerberos_realm ON kerberos_realm;
CREATE TRIGGER trigger_audit_kerberos_realm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.kerberos_realm FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_kerberos_realm();
DROP TRIGGER IF EXISTS trig_userlog_klogin ON klogin;
CREATE TRIGGER trig_userlog_klogin BEFORE INSERT OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin ON klogin;
CREATE TRIGGER trigger_audit_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_klogin();
DROP TRIGGER IF EXISTS trig_userlog_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trig_userlog_klogin_mclass BEFORE INSERT OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_klogin_mclass ON klogin_mclass;
CREATE TRIGGER trigger_audit_klogin_mclass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.klogin_mclass FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_klogin_mclass();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection ON layer2_connection;
CREATE TRIGGER trig_userlog_layer2_connection BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection ON layer2_connection;
CREATE TRIGGER trigger_audit_layer2_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_connection();
DROP TRIGGER IF EXISTS trig_userlog_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_connection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_connection_layer2_network ON layer2_connection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_connection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_connection_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_connection_layer2_network();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network ON layer2_network;
CREATE TRIGGER trig_userlog_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network ON layer2_network;
CREATE TRIGGER trigger_audit_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network();
DROP TRIGGER IF EXISTS layer2_net_collection_member_enforce_on_type_change ON layer2_network_collection;
CREATE CONSTRAINT TRIGGER layer2_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trig_userlog_layer2_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection ON layer2_network_collection;
CREATE TRIGGER trigger_audit_layer2_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_del ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_bytype_insup ON layer2_network_collection;
CREATE TRIGGER trigger_manip_layer2_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer2_network_collection_type_change ON layer2_network_collection;
CREATE TRIGGER trigger_validate_layer2_network_collection_type_change BEFORE UPDATE OF layer2_network_collection_type ON jazzhands.layer2_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_layer2_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trig_userlog_layer2_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_hier ON layer2_network_collection_hier;
CREATE TRIGGER trigger_audit_layer2_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer2_network_collection_after_hooks ON layer2_network_collection_hier;
CREATE TRIGGER trigger_hier_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_hier_enforce ON layer2_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trig_userlog_layer2_network_collection_layer2_network BEFORE INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer2_network_collection_layer2_network ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_audit_layer2_network_collection_layer2_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer2_network_collection_layer2_network();
DROP TRIGGER IF EXISTS trigger_layer2_network_collection_member_enforce ON layer2_network_collection_layer2_network;
CREATE CONSTRAINT TRIGGER trigger_layer2_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer2_network_collection_layer2_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer2_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer2_network_collection_after_hooks ON layer2_network_collection_layer2_network;
CREATE TRIGGER trigger_member_layer2_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer2_network_collection_layer2_network FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer2_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_layer3_acl_chain ON layer3_acl_chain;
CREATE TRIGGER trig_userlog_layer3_acl_chain BEFORE INSERT OR UPDATE ON jazzhands.layer3_acl_chain FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_acl_chain ON layer3_acl_chain;
CREATE TRIGGER trigger_audit_layer3_acl_chain AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_acl_chain FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_acl_chain();
DROP TRIGGER IF EXISTS trig_userlog_layer3_acl_chain_layer3_interface ON layer3_acl_chain_layer3_interface;
CREATE TRIGGER trig_userlog_layer3_acl_chain_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.layer3_acl_chain_layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_acl_chain_layer3_interface ON layer3_acl_chain_layer3_interface;
CREATE TRIGGER trigger_audit_layer3_acl_chain_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_acl_chain_layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_acl_chain_layer3_interface();
DROP TRIGGER IF EXISTS trig_userlog_layer3_acl_group ON layer3_acl_group;
CREATE TRIGGER trig_userlog_layer3_acl_group BEFORE INSERT OR UPDATE ON jazzhands.layer3_acl_group FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_acl_group ON layer3_acl_group;
CREATE TRIGGER trigger_audit_layer3_acl_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_acl_group FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_acl_group();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface ON layer3_interface;
CREATE TRIGGER trig_userlog_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface ON layer3_interface;
CREATE TRIGGER trigger_audit_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_interface();
DROP TRIGGER IF EXISTS trigger_net_int_device_id_upd ON layer3_interface;
CREATE TRIGGER trigger_net_int_device_id_upd AFTER UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_device_id_upd();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_before ON layer3_interface;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_before BEFORE UPDATE OF device_id ON jazzhands.layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins_before();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_netblock ON layer3_interface_netblock;
CREATE TRIGGER trig_userlog_layer3_interface_netblock BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_netblock ON layer3_interface_netblock;
CREATE TRIGGER trigger_audit_layer3_interface_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_interface_netblock();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins ON layer3_interface_netblock;
CREATE TRIGGER trigger_net_int_nb_device_id_ins BEFORE INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins();
DROP TRIGGER IF EXISTS trigger_net_int_nb_device_id_ins_after ON layer3_interface_netblock;
CREATE TRIGGER trigger_net_int_nb_device_id_ins_after AFTER INSERT OR UPDATE OF layer3_interface_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_device_id_ins_after();
DROP TRIGGER IF EXISTS trigger_net_int_nb_single_address ON layer3_interface_netblock;
CREATE TRIGGER trigger_net_int_nb_single_address BEFORE INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_interface_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.net_int_nb_single_address();
DROP TRIGGER IF EXISTS trig_userlog_layer3_interface_purpose ON layer3_interface_purpose;
CREATE TRIGGER trig_userlog_layer3_interface_purpose BEFORE INSERT OR UPDATE ON jazzhands.layer3_interface_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_interface_purpose ON layer3_interface_purpose;
CREATE TRIGGER trigger_audit_layer3_interface_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_interface_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_interface_purpose();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network ON layer3_network;
CREATE TRIGGER trig_userlog_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network ON layer3_network;
CREATE TRIGGER trigger_audit_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_validate_netblock ON layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_validate_netblock AFTER INSERT OR UPDATE OF netblock_id ON jazzhands.layer3_network NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_validate_netblock();
DROP TRIGGER IF EXISTS layer3_net_collection_member_enforce_on_type_change ON layer3_network_collection;
CREATE CONSTRAINT TRIGGER layer3_net_collection_member_enforce_on_type_change AFTER UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_net_collection_member_enforce_on_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trig_userlog_layer3_network_collection BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection ON layer3_network_collection;
CREATE TRIGGER trigger_audit_layer3_network_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_del ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_del BEFORE DELETE ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_bytype_insup ON layer3_network_collection;
CREATE TRIGGER trigger_manip_layer3_network_collection_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_layer3_network_collection_type_change ON layer3_network_collection;
CREATE TRIGGER trigger_validate_layer3_network_collection_type_change BEFORE UPDATE OF layer3_network_collection_type ON jazzhands.layer3_network_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_layer3_network_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trig_userlog_layer3_network_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_hier ON layer3_network_collection_hier;
CREATE TRIGGER trigger_audit_layer3_network_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_layer3_network_collection_after_hooks ON layer3_network_collection_hier;
CREATE TRIGGER trigger_hier_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_hier_enforce ON layer3_network_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trig_userlog_layer3_network_collection_layer3_network BEFORE INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_layer3_network_collection_layer3_network ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_audit_layer3_network_collection_layer3_network AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_layer3_network_collection_layer3_network();
DROP TRIGGER IF EXISTS trigger_layer3_network_collection_member_enforce ON layer3_network_collection_layer3_network;
CREATE CONSTRAINT TRIGGER trigger_layer3_network_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.layer3_network_collection_layer3_network DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.layer3_network_collection_member_enforce();
DROP TRIGGER IF EXISTS trigger_member_layer3_network_collection_after_hooks ON layer3_network_collection_layer3_network;
CREATE TRIGGER trigger_member_layer3_network_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.layer3_network_collection_layer3_network FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.layer3_network_collection_after_hooks();
DROP TRIGGER IF EXISTS trig_userlog_logical_port ON logical_port;
CREATE TRIGGER trig_userlog_logical_port BEFORE INSERT OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port ON logical_port;
CREATE TRIGGER trigger_audit_logical_port AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_port();
DROP TRIGGER IF EXISTS trig_userlog_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trig_userlog_logical_port_slot BEFORE INSERT OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_port_slot ON logical_port_slot;
CREATE TRIGGER trigger_audit_logical_port_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_port_slot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_port_slot();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume ON logical_volume;
CREATE TRIGGER trig_userlog_logical_volume BEFORE INSERT OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume ON logical_volume;
CREATE TRIGGER trigger_audit_logical_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trig_userlog_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_property ON logical_volume_property;
CREATE TRIGGER trigger_audit_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trig_userlog_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_logical_volume_purpose ON logical_volume_purpose;
CREATE TRIGGER trigger_audit_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_mlag_peering ON mlag_peering;
CREATE TRIGGER trig_userlog_mlag_peering BEFORE INSERT OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_mlag_peering ON mlag_peering;
CREATE TRIGGER trigger_audit_mlag_peering AFTER INSERT OR DELETE OR UPDATE ON jazzhands.mlag_peering FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_mlag_peering();
DROP TRIGGER IF EXISTS aaa_ta_manipulate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER aaa_ta_manipulate_netblock_parentage AFTER INSERT OR DELETE ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.manipulate_netblock_parentage_after();
DROP TRIGGER IF EXISTS tb_a_validate_netblock ON netblock;
CREATE TRIGGER tb_a_validate_netblock BEFORE INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock();
DROP TRIGGER IF EXISTS tb_manipulate_netblock_parentage ON netblock;
CREATE TRIGGER tb_manipulate_netblock_parentage BEFORE INSERT OR UPDATE OF ip_address, netblock_type, ip_universe_id, netblock_id, can_subnet, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.manipulate_netblock_parentage_before();
DROP TRIGGER IF EXISTS trig_userlog_netblock ON netblock;
CREATE TRIGGER trig_userlog_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock ON netblock;
CREATE TRIGGER trigger_audit_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock();
DROP TRIGGER IF EXISTS trigger_cache_netblock_hier_truncate ON netblock;
CREATE TRIGGER trigger_cache_netblock_hier_truncate AFTER TRUNCATE ON jazzhands.netblock FOR EACH STATEMENT EXECUTE FUNCTION jazzhands_cache.cache_netblock_hier_truncate_handler();
DROP TRIGGER IF EXISTS trigger_check_ip_universe_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_check_ip_universe_netblock AFTER UPDATE OF netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_ip_universe_netblock();
DROP TRIGGER IF EXISTS trigger_nb_dns_a_rec_validation ON netblock;
CREATE TRIGGER trigger_nb_dns_a_rec_validation BEFORE UPDATE OF ip_address, is_single_address ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.nb_dns_a_rec_validation();
DROP TRIGGER IF EXISTS trigger_netblock_single_address_ni ON netblock;
CREATE TRIGGER trigger_netblock_single_address_ni BEFORE UPDATE OF is_single_address, netblock_type ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_single_address_ni();
DROP TRIGGER IF EXISTS trigger_netblock_validate_layer3_network_netblock ON netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_validate_layer3_network_netblock AFTER UPDATE OF can_subnet, is_single_address ON jazzhands.netblock NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_validate_layer3_network_netblock();
DROP TRIGGER IF EXISTS trigger_validate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_parentage AFTER INSERT OR UPDATE OF netblock_id, ip_address, netblock_type, is_single_address, can_subnet, parent_netblock_id, ip_universe_id ON jazzhands.netblock DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_parentage();
DROP TRIGGER IF EXISTS trigger_validate_netblock_to_range_changes ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_to_range_changes AFTER UPDATE OF ip_address, is_single_address, can_subnet, netblock_type ON jazzhands.netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_to_range_changes();
DROP TRIGGER IF EXISTS zaa_ta_cache_netblock_hier_handler ON netblock;
CREATE TRIGGER zaa_ta_cache_netblock_hier_handler AFTER INSERT OR DELETE OR UPDATE OF ip_address, parent_netblock_id ON jazzhands.netblock FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.cache_netblock_hier_handler();
DROP TRIGGER IF EXISTS aaa_netblock_collection_base_handler ON netblock_collection;
CREATE TRIGGER aaa_netblock_collection_base_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.netblock_collection_base_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection ON netblock_collection;
CREATE TRIGGER trig_userlog_netblock_collection BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection ON netblock_collection;
CREATE TRIGGER trigger_audit_netblock_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_del ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_del BEFORE DELETE ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_bytype_insup ON netblock_collection;
CREATE TRIGGER trigger_manip_netblock_collection_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_netblock_collection_type_change ON netblock_collection;
CREATE TRIGGER trigger_validate_netblock_collection_type_change BEFORE UPDATE OF netblock_collection_type ON jazzhands.netblock_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_netblock_collection_type_change();
DROP TRIGGER IF EXISTS aaa_netblock_collection_root_handler ON netblock_collection_hier;
CREATE TRIGGER aaa_netblock_collection_root_handler AFTER INSERT OR DELETE OR UPDATE OF netblock_collection_id, child_netblock_collection_id ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands_cache.netblock_collection_root_handler();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trig_userlog_netblock_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_hier ON netblock_collection_hier;
CREATE TRIGGER trigger_audit_netblock_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_netblock_collection_hier_loop ON netblock_collection_hier;
CREATE TRIGGER trigger_check_netblock_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_netblock_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_netblock_collection_hier_enforce ON netblock_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trig_userlog_netblock_collection_netblock BEFORE INSERT OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_netblock_collection_netblock ON netblock_collection_netblock;
CREATE TRIGGER trigger_audit_netblock_collection_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.netblock_collection_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_netblock_collection_netblock();
DROP TRIGGER IF EXISTS trigger_netblock_collection_member_enforce ON netblock_collection_netblock;
CREATE CONSTRAINT TRIGGER trigger_netblock_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.netblock_collection_netblock DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.netblock_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_network_range ON network_range;
CREATE TRIGGER trig_userlog_network_range BEFORE INSERT OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_network_range ON network_range;
CREATE TRIGGER trigger_audit_network_range AFTER INSERT OR DELETE OR UPDATE ON jazzhands.network_range FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_network_range();
DROP TRIGGER IF EXISTS trigger_validate_network_range_dns ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_dns AFTER INSERT OR UPDATE OF dns_domain_id ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_network_range_dns();
DROP TRIGGER IF EXISTS trigger_validate_network_range_ips ON network_range;
CREATE CONSTRAINT TRIGGER trigger_validate_network_range_ips AFTER INSERT OR UPDATE OF start_netblock_id, stop_netblock_id, parent_netblock_id, network_range_type ON jazzhands.network_range DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_network_range_ips();
DROP TRIGGER IF EXISTS trig_userlog_network_service ON network_service;
CREATE TRIGGER trig_userlog_network_service BEFORE INSERT OR UPDATE ON jazzhands.network_service FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_network_service ON network_service;
CREATE TRIGGER trigger_audit_network_service AFTER INSERT OR DELETE OR UPDATE ON jazzhands.network_service FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_network_service();
DROP TRIGGER IF EXISTS trig_userlog_operating_system ON operating_system;
CREATE TRIGGER trig_userlog_operating_system BEFORE INSERT OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system ON operating_system;
CREATE TRIGGER trigger_audit_operating_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_operating_system();
DROP TRIGGER IF EXISTS trig_userlog_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trig_userlog_operating_system_snapshot BEFORE INSERT OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_operating_system_snapshot ON operating_system_snapshot;
CREATE TRIGGER trigger_audit_operating_system_snapshot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.operating_system_snapshot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_operating_system_snapshot();
DROP TRIGGER IF EXISTS trig_userlog_person ON person;
CREATE TRIGGER trig_userlog_person BEFORE INSERT OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person ON person;
CREATE TRIGGER trigger_audit_person AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person();
DROP TRIGGER IF EXISTS trig_userlog_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trig_userlog_person_account_realm_company BEFORE INSERT OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_account_realm_company ON person_account_realm_company;
CREATE TRIGGER trigger_audit_person_account_realm_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_account_realm_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_account_realm_company();
DROP TRIGGER IF EXISTS trig_userlog_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trig_userlog_person_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_authentication_question ON person_authentication_question;
CREATE TRIGGER trigger_audit_person_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_authentication_question FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_person_company ON person_company;
CREATE TRIGGER trig_userlog_person_company BEFORE INSERT OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company ON person_company;
CREATE TRIGGER trigger_audit_person_company AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company();
DROP TRIGGER IF EXISTS trigger_propagate_person_status_to_account ON person_company;
CREATE TRIGGER trigger_propagate_person_status_to_account AFTER UPDATE ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.propagate_person_status_to_account();
DROP TRIGGER IF EXISTS trigger_z_automated_ac_on_person_company ON person_company;
CREATE TRIGGER trigger_z_automated_ac_on_person_company AFTER UPDATE OF is_management, is_exempt, is_full_time, person_id, company_id, manager_person_id ON jazzhands.person_company FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_ac_on_person_company();
DROP TRIGGER IF EXISTS trig_userlog_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trig_userlog_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_audit_person_company_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company_attribute();
DROP TRIGGER IF EXISTS trigger_validate_person_company_attribute ON person_company_attribute;
CREATE TRIGGER trigger_validate_person_company_attribute BEFORE INSERT OR UPDATE ON jazzhands.person_company_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_person_company_attribute();
DROP TRIGGER IF EXISTS trig_userlog_person_company_badge ON person_company_badge;
CREATE TRIGGER trig_userlog_person_company_badge BEFORE INSERT OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_company_badge ON person_company_badge;
CREATE TRIGGER trigger_audit_person_company_badge AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_company_badge FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_company_badge();
DROP TRIGGER IF EXISTS trig_userlog_person_contact ON person_contact;
CREATE TRIGGER trig_userlog_person_contact BEFORE INSERT OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_contact ON person_contact;
CREATE TRIGGER trigger_audit_person_contact AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_contact FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_contact();
DROP TRIGGER IF EXISTS trig_userlog_person_image ON person_image;
CREATE TRIGGER trig_userlog_person_image BEFORE INSERT OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image ON person_image;
CREATE TRIGGER trigger_audit_person_image AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_image();
DROP TRIGGER IF EXISTS trigger_fix_person_image_oid_ownership ON person_image;
CREATE TRIGGER trigger_fix_person_image_oid_ownership BEFORE INSERT ON jazzhands.person_image FOR EACH ROW EXECUTE FUNCTION jazzhands.fix_person_image_oid_ownership();
DROP TRIGGER IF EXISTS trig_userlog_person_image_usage ON person_image_usage;
CREATE TRIGGER trig_userlog_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_image_usage ON person_image_usage;
CREATE TRIGGER trigger_audit_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_image_usage();
DROP TRIGGER IF EXISTS trigger_check_person_image_usage_mv ON person_image_usage;
CREATE TRIGGER trigger_check_person_image_usage_mv AFTER INSERT OR UPDATE ON jazzhands.person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.check_person_image_usage_mv();
DROP TRIGGER IF EXISTS trig_automated_realm_site_ac_pl ON person_location;
CREATE TRIGGER trig_automated_realm_site_ac_pl AFTER INSERT OR DELETE OR UPDATE OF site_code, person_id ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION jazzhands.automated_realm_site_ac_pl();
DROP TRIGGER IF EXISTS trig_userlog_person_location ON person_location;
CREATE TRIGGER trig_userlog_person_location BEFORE INSERT OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_location ON person_location;
CREATE TRIGGER trigger_audit_person_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_location();
DROP TRIGGER IF EXISTS trig_userlog_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trig_userlog_person_parking_pass BEFORE INSERT OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_parking_pass ON person_parking_pass;
CREATE TRIGGER trigger_audit_person_parking_pass AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_parking_pass FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_parking_pass();
DROP TRIGGER IF EXISTS trig_userlog_person_vehicle ON person_vehicle;
CREATE TRIGGER trig_userlog_person_vehicle BEFORE INSERT OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_person_vehicle ON person_vehicle;
CREATE TRIGGER trigger_audit_person_vehicle AFTER INSERT OR DELETE OR UPDATE ON jazzhands.person_vehicle FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_person_vehicle();
DROP TRIGGER IF EXISTS trig_userlog_physical_address ON physical_address;
CREATE TRIGGER trig_userlog_physical_address BEFORE INSERT OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_address ON physical_address;
CREATE TRIGGER trigger_audit_physical_address AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_address FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physical_address();
DROP TRIGGER IF EXISTS trig_userlog_physical_connection ON physical_connection;
CREATE TRIGGER trig_userlog_physical_connection BEFORE INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physical_connection ON physical_connection;
CREATE TRIGGER trigger_audit_physical_connection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physical_connection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physical_connection();
DROP TRIGGER IF EXISTS trigger_verify_physical_connection ON physical_connection;
CREATE TRIGGER trigger_verify_physical_connection AFTER INSERT OR UPDATE ON jazzhands.physical_connection FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.verify_physical_connection();
DROP TRIGGER IF EXISTS trig_userlog_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trig_userlog_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_audit_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_physicalish_volume();
DROP TRIGGER IF EXISTS trigger_verify_physicalish_volume ON physicalish_volume;
CREATE TRIGGER trigger_verify_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.verify_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_property ON property;
CREATE TRIGGER trig_userlog_property BEFORE INSERT OR UPDATE ON jazzhands.property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property ON property;
CREATE TRIGGER trigger_audit_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property();
DROP TRIGGER IF EXISTS trigger_validate_property ON property;
CREATE TRIGGER trigger_validate_property BEFORE INSERT OR UPDATE ON jazzhands.property FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_property();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection ON property_name_collection;
CREATE TRIGGER trig_userlog_property_name_collection BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection ON property_name_collection;
CREATE TRIGGER trigger_audit_property_name_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection();
DROP TRIGGER IF EXISTS trigger_validate_property_name_collection_type_change ON property_name_collection;
CREATE TRIGGER trigger_validate_property_name_collection_type_change BEFORE UPDATE OF property_name_collection_type ON jazzhands.property_name_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_property_name_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trig_userlog_property_name_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_hier ON property_name_collection_hier;
CREATE TRIGGER trigger_audit_property_name_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection_hier();
DROP TRIGGER IF EXISTS trigger_hier_property_name_collection_after_hooks ON property_name_collection_hier;
CREATE TRIGGER trigger_hier_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_hier FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_hier_enforce ON property_name_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.property_name_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trig_userlog_property_name_collection_property_name BEFORE INSERT OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_property_name_collection_property_name ON property_name_collection_property_name;
CREATE TRIGGER trigger_audit_property_name_collection_property_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_property_name_collection_property_name();
DROP TRIGGER IF EXISTS trigger_member_property_name_collection_after_hooks ON property_name_collection_property_name;
CREATE TRIGGER trigger_member_property_name_collection_after_hooks AFTER INSERT OR DELETE OR UPDATE ON jazzhands.property_name_collection_property_name FOR EACH STATEMENT EXECUTE FUNCTION jazzhands.property_name_collection_after_hooks();
DROP TRIGGER IF EXISTS trigger_property_name_collection_member_enforce ON property_name_collection_property_name;
CREATE CONSTRAINT TRIGGER trigger_property_name_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.property_name_collection_property_name DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.property_name_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_protocol ON protocol;
CREATE TRIGGER trig_userlog_protocol BEFORE INSERT OR UPDATE ON jazzhands.protocol FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_protocol ON protocol;
CREATE TRIGGER trigger_audit_protocol AFTER INSERT OR DELETE OR UPDATE ON jazzhands.protocol FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_protocol();
DROP TRIGGER IF EXISTS trig_userlog_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trig_userlog_pseudo_klogin BEFORE INSERT OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_pseudo_klogin ON pseudo_klogin;
CREATE TRIGGER trigger_audit_pseudo_klogin AFTER INSERT OR DELETE OR UPDATE ON jazzhands.pseudo_klogin FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_pseudo_klogin();
DROP TRIGGER IF EXISTS trig_userlog_rack ON rack;
CREATE TRIGGER trig_userlog_rack BEFORE INSERT OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack ON rack;
CREATE TRIGGER trigger_audit_rack AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_rack();
DROP TRIGGER IF EXISTS trig_userlog_rack_location ON rack_location;
CREATE TRIGGER trig_userlog_rack_location BEFORE INSERT OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_rack_location ON rack_location;
CREATE TRIGGER trigger_audit_rack_location AFTER INSERT OR DELETE OR UPDATE ON jazzhands.rack_location FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_rack_location();
DROP TRIGGER IF EXISTS trig_userlog_service ON service;
CREATE TRIGGER trig_userlog_service BEFORE INSERT OR UPDATE ON jazzhands.service FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service ON service;
CREATE TRIGGER trigger_audit_service AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service();
DROP TRIGGER IF EXISTS trigger_check_service_namespace ON service;
CREATE CONSTRAINT TRIGGER trigger_check_service_namespace AFTER INSERT OR UPDATE OF service_name, service_type ON jazzhands.service NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.check_service_namespace();
DROP TRIGGER IF EXISTS trigger_create_all_services_collection ON service;
CREATE TRIGGER trigger_create_all_services_collection AFTER INSERT OR UPDATE OF service_name ON jazzhands.service FOR EACH ROW EXECUTE FUNCTION jazzhands.create_all_services_collection();
DROP TRIGGER IF EXISTS trigger_create_all_services_collection_del ON service;
CREATE TRIGGER trigger_create_all_services_collection_del BEFORE DELETE ON jazzhands.service FOR EACH ROW EXECUTE FUNCTION jazzhands.create_all_services_collection();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_health_check ON service_endpoint_health_check;
CREATE TRIGGER trig_userlog_service_endpoint_health_check BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_health_check FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_health_check ON service_endpoint_health_check;
CREATE TRIGGER trigger_audit_service_endpoint_health_check AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_health_check FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_health_check();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_provider ON service_endpoint_provider;
CREATE TRIGGER trig_userlog_service_endpoint_provider BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_provider FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_provider ON service_endpoint_provider;
CREATE TRIGGER trigger_audit_service_endpoint_provider AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_provider FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_provider();
DROP TRIGGER IF EXISTS trigger_service_endpoint_provider_direct_check ON service_endpoint_provider;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_provider_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_type, dns_record_id ON jazzhands.service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_endpoint_provider_direct_check();
DROP TRIGGER IF EXISTS trigger_service_endpoint_provider_dns_netblock_check ON service_endpoint_provider;
CREATE CONSTRAINT TRIGGER trigger_service_endpoint_provider_dns_netblock_check AFTER INSERT OR UPDATE OF dns_record_id, netblock_id ON jazzhands.service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_endpoint_provider_dns_netblock_check();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_provider_collection ON service_endpoint_provider_collection;
CREATE TRIGGER trig_userlog_service_endpoint_provider_collection BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_provider_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_provider_collection ON service_endpoint_provider_collection;
CREATE TRIGGER trigger_audit_service_endpoint_provider_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_provider_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_provider_collection();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_provider_collection_service_endpo ON service_endpoint_provider_collection_service_endpoint_provider;
CREATE TRIGGER trig_userlog_service_endpoint_provider_collection_service_endpo BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_provider_collection_service_endp ON service_endpoint_provider_collection_service_endpoint_provider;
CREATE TRIGGER trigger_audit_service_endpoint_provider_collection_service_endp AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_provider_collection_service_endp();
DROP TRIGGER IF EXISTS trigger_svc_ep_coll_sep_direct_check ON service_endpoint_provider_collection_service_endpoint_provider;
CREATE CONSTRAINT TRIGGER trigger_svc_ep_coll_sep_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_collection_id, service_endpoint_provider_id ON jazzhands.service_endpoint_provider_collection_service_endpoint_provider NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.svc_ep_coll_sep_direct_check();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_provider_service_instance ON service_endpoint_provider_service_instance;
CREATE TRIGGER trig_userlog_service_endpoint_provider_service_instance BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_provider_service_instance FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_provider_service_instance ON service_endpoint_provider_service_instance;
CREATE TRIGGER trigger_audit_service_endpoint_provider_service_instance AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_provider_service_instance FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_provider_service_instance();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_provider_shared_netblock_layer3_i ON service_endpoint_provider_shared_netblock_layer3_interface;
CREATE TRIGGER trig_userlog_service_endpoint_provider_shared_netblock_layer3_i BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_provider_shared_netblock_layer3_ ON service_endpoint_provider_shared_netblock_layer3_interface;
CREATE TRIGGER trigger_audit_service_endpoint_provider_shared_netblock_layer3_ AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_provider_shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_provider_shared_netblock_layer3_();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_service_endpoint_provider_collect ON service_endpoint_service_endpoint_provider_collection;
CREATE TRIGGER trig_userlog_service_endpoint_service_endpoint_provider_collect BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_service_endpoint_provider_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_service_endpoint_provider_collec ON service_endpoint_service_endpoint_provider_collection;
CREATE TRIGGER trigger_audit_service_endpoint_service_endpoint_provider_collec AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_service_endpoint_provider_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_service_endpoint_provider_collec();
DROP TRIGGER IF EXISTS trigger_svc_end_prov_svc_end_col_direct_check ON service_endpoint_service_endpoint_provider_collection;
CREATE CONSTRAINT TRIGGER trigger_svc_end_prov_svc_end_col_direct_check AFTER INSERT OR UPDATE OF service_endpoint_provider_collection_id, service_endpoint_relation_type, service_endpoint_relation_key ON jazzhands.service_endpoint_service_endpoint_provider_collection NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.svc_end_prov_svc_end_col_direct_check();
DROP TRIGGER IF EXISTS trigger_svc_ep_svc_epp_coll_direct ON service_endpoint_service_endpoint_provider_collection;
CREATE CONSTRAINT TRIGGER trigger_svc_ep_svc_epp_coll_direct AFTER INSERT OR UPDATE OF service_endpoint_relation_type, service_endpoint_relation_key ON jazzhands.service_endpoint_service_endpoint_provider_collection NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.svc_ep_svc_epp_coll_direct();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_service_sla ON service_endpoint_service_sla;
CREATE TRIGGER trig_userlog_service_endpoint_service_sla BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_service_sla FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_service_sla ON service_endpoint_service_sla;
CREATE TRIGGER trigger_audit_service_endpoint_service_sla AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_service_sla FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_service_sla();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_service_sla_service_feature ON service_endpoint_service_sla_service_feature;
CREATE TRIGGER trig_userlog_service_endpoint_service_sla_service_feature BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_service_sla_service_feature FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_service_sla_service_feature ON service_endpoint_service_sla_service_feature;
CREATE TRIGGER trigger_audit_service_endpoint_service_sla_service_feature AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_service_sla_service_feature FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_service_sla_service_feature();
DROP TRIGGER IF EXISTS trig_userlog_service_endpoint_x509_certificate ON service_endpoint_x509_certificate;
CREATE TRIGGER trig_userlog_service_endpoint_x509_certificate BEFORE INSERT OR UPDATE ON jazzhands.service_endpoint_x509_certificate FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_endpoint_x509_certificate ON service_endpoint_x509_certificate;
CREATE TRIGGER trigger_audit_service_endpoint_x509_certificate AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_endpoint_x509_certificate FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_endpoint_x509_certificate();
DROP TRIGGER IF EXISTS trig_userlog_service_environment ON service_environment;
CREATE TRIGGER trig_userlog_service_environment BEFORE INSERT OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment ON service_environment;
CREATE TRIGGER trigger_audit_service_environment AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment();
DROP TRIGGER IF EXISTS trigger_delete_per_service_environment_service_environment_coll ON service_environment;
CREATE TRIGGER trigger_delete_per_service_environment_service_environment_coll BEFORE DELETE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.delete_per_service_environment_service_environment_collection();
DROP TRIGGER IF EXISTS trigger_update_per_service_environment_service_environment_coll ON service_environment;
CREATE TRIGGER trigger_update_per_service_environment_service_environment_coll AFTER INSERT OR UPDATE ON jazzhands.service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.update_per_service_environment_service_environment_collection();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trig_userlog_service_environment_collection BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection ON service_environment_collection;
CREATE TRIGGER trigger_audit_service_environment_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_del ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_del BEFORE DELETE ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_bytype_insup ON service_environment_collection;
CREATE TRIGGER trigger_manip_service_environment_collection_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_bytype();
DROP TRIGGER IF EXISTS trigger_validate_service_environment_collection_type_change ON service_environment_collection;
CREATE TRIGGER trigger_validate_service_environment_collection_type_change BEFORE UPDATE OF service_environment_collection_type ON jazzhands.service_environment_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_service_environment_collection_type_change();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trig_userlog_service_environment_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_hier ON service_environment_collection_hier;
CREATE TRIGGER trigger_audit_service_environment_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_svcenv_collection_hier_loop ON service_environment_collection_hier;
CREATE TRIGGER trigger_check_svcenv_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_svcenv_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_hier_enforce ON service_environment_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_service_environment_collection_service_environment ON service_environment_collection_service_environment;
CREATE TRIGGER trig_userlog_service_environment_collection_service_environment BEFORE INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_environment_collection_service_environmen ON service_environment_collection_service_environment;
CREATE TRIGGER trigger_audit_service_environment_collection_service_environmen AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_environment_collection_service_environment FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_environment_collection_service_environmen();
DROP TRIGGER IF EXISTS trigger_service_environment_collection_member_enforce ON service_environment_collection_service_environment;
CREATE CONSTRAINT TRIGGER trigger_service_environment_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.service_environment_collection_service_environment DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_environment_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_service_instance_provided_feature ON service_instance_provided_feature;
CREATE TRIGGER trig_userlog_service_instance_provided_feature BEFORE INSERT OR UPDATE ON jazzhands.service_instance_provided_feature FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_instance_provided_feature ON service_instance_provided_feature;
CREATE TRIGGER trigger_audit_service_instance_provided_feature AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_instance_provided_feature FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_instance_provided_feature();
DROP TRIGGER IF EXISTS trigger_service_instance_feature_check ON service_instance_provided_feature;
CREATE CONSTRAINT TRIGGER trigger_service_instance_feature_check AFTER INSERT ON jazzhands.service_instance_provided_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_instance_feature_check();
DROP TRIGGER IF EXISTS trigger_service_instance_service_feature_rename ON service_instance_provided_feature;
CREATE CONSTRAINT TRIGGER trigger_service_instance_service_feature_rename AFTER UPDATE OF service_feature, service_instance_id ON jazzhands.service_instance_provided_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_instance_service_feature_rename();
DROP TRIGGER IF EXISTS trig_userlog_service_sla ON service_sla;
CREATE TRIGGER trig_userlog_service_sla BEFORE INSERT OR UPDATE ON jazzhands.service_sla FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_sla ON service_sla;
CREATE TRIGGER trigger_audit_service_sla AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_sla FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_sla();
DROP TRIGGER IF EXISTS trig_userlog_service_software_repository ON service_software_repository;
CREATE TRIGGER trig_userlog_service_software_repository BEFORE INSERT OR UPDATE ON jazzhands.service_software_repository FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_software_repository ON service_software_repository;
CREATE TRIGGER trigger_audit_service_software_repository AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_software_repository FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_software_repository();
DROP TRIGGER IF EXISTS trig_userlog_service_version_collection ON service_version_collection;
CREATE TRIGGER trig_userlog_service_version_collection BEFORE INSERT OR UPDATE ON jazzhands.service_version_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_version_collection ON service_version_collection;
CREATE TRIGGER trigger_audit_service_version_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_version_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_version_collection();
DROP TRIGGER IF EXISTS trig_userlog_service_version_collection_hier ON service_version_collection_hier;
CREATE TRIGGER trig_userlog_service_version_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.service_version_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_version_collection_hier ON service_version_collection_hier;
CREATE TRIGGER trigger_audit_service_version_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_version_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_version_collection_hier();
DROP TRIGGER IF EXISTS trig_userlog_service_version_collection_permitted_feature ON service_version_collection_permitted_feature;
CREATE TRIGGER trig_userlog_service_version_collection_permitted_feature BEFORE INSERT OR UPDATE ON jazzhands.service_version_collection_permitted_feature FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_version_collection_permitted_feature ON service_version_collection_permitted_feature;
CREATE TRIGGER trigger_audit_service_version_collection_permitted_feature AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_version_collection_permitted_feature FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_version_collection_permitted_feature();
DROP TRIGGER IF EXISTS trigger_service_version_feature_permitted_rename ON service_version_collection_permitted_feature;
CREATE CONSTRAINT TRIGGER trigger_service_version_feature_permitted_rename AFTER UPDATE OF service_feature ON jazzhands.service_version_collection_permitted_feature NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.service_version_feature_permitted_rename();
DROP TRIGGER IF EXISTS trig_userlog_service_version_collection_service_version ON service_version_collection_service_version;
CREATE TRIGGER trig_userlog_service_version_collection_service_version BEFORE INSERT OR UPDATE ON jazzhands.service_version_collection_service_version FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_version_collection_service_version ON service_version_collection_service_version;
CREATE TRIGGER trigger_audit_service_version_collection_service_version AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_version_collection_service_version FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_version_collection_service_version();
DROP TRIGGER IF EXISTS trig_userlog_service_version_software_artifact_repository ON service_version_software_artifact_repository;
CREATE TRIGGER trig_userlog_service_version_software_artifact_repository BEFORE INSERT OR UPDATE ON jazzhands.service_version_software_artifact_repository FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_service_version_software_artifact_repository ON service_version_software_artifact_repository;
CREATE TRIGGER trigger_audit_service_version_software_artifact_repository AFTER INSERT OR DELETE OR UPDATE ON jazzhands.service_version_software_artifact_repository FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_service_version_software_artifact_repository();
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock ON shared_netblock;
CREATE TRIGGER trig_userlog_shared_netblock BEFORE INSERT OR UPDATE ON jazzhands.shared_netblock FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock ON shared_netblock;
CREATE TRIGGER trigger_audit_shared_netblock AFTER INSERT OR DELETE OR UPDATE ON jazzhands.shared_netblock FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_shared_netblock();
DROP TRIGGER IF EXISTS trig_userlog_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trig_userlog_shared_netblock_layer3_interface BEFORE INSERT OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_shared_netblock_layer3_interface ON shared_netblock_layer3_interface;
CREATE TRIGGER trigger_audit_shared_netblock_layer3_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.shared_netblock_layer3_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_shared_netblock_layer3_interface();
DROP TRIGGER IF EXISTS trig_userlog_site ON site;
CREATE TRIGGER trig_userlog_site BEFORE INSERT OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_site ON site;
CREATE TRIGGER trigger_audit_site AFTER INSERT OR DELETE OR UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_site();
DROP TRIGGER IF EXISTS trigger_del_site_netblock_collections ON site;
CREATE TRIGGER trigger_del_site_netblock_collections BEFORE DELETE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.del_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_ins_site_netblock_collections ON site;
CREATE TRIGGER trigger_ins_site_netblock_collections AFTER INSERT ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.ins_site_netblock_collections();
DROP TRIGGER IF EXISTS trigger_upd_site_netblock_collections ON site;
CREATE TRIGGER trigger_upd_site_netblock_collections AFTER UPDATE ON jazzhands.site FOR EACH ROW EXECUTE FUNCTION jazzhands.upd_site_netblock_collections();
DROP TRIGGER IF EXISTS trig_userlog_slot ON slot;
CREATE TRIGGER trig_userlog_slot BEFORE INSERT OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot ON slot;
CREATE TRIGGER trigger_audit_slot AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot();
DROP TRIGGER IF EXISTS trig_userlog_slot_type ON slot_type;
CREATE TRIGGER trig_userlog_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type ON slot_type;
CREATE TRIGGER trigger_audit_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_component_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_component_slot_type ON slot_type_permitted_component_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_component_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_component_slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type_permitted_component_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trig_userlog_slot_type_permitted_remote_slot_type BEFORE INSERT OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_slot_type_permitted_remote_slot_type ON slot_type_permitted_remote_slot_type;
CREATE TRIGGER trigger_audit_slot_type_permitted_remote_slot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.slot_type_permitted_remote_slot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_slot_type_permitted_remote_slot_type();
DROP TRIGGER IF EXISTS trig_userlog_software_artifact_name ON software_artifact_name;
CREATE TRIGGER trig_userlog_software_artifact_name BEFORE INSERT OR UPDATE ON jazzhands.software_artifact_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_software_artifact_name ON software_artifact_name;
CREATE TRIGGER trigger_audit_software_artifact_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.software_artifact_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_software_artifact_name();
DROP TRIGGER IF EXISTS trig_userlog_software_artifact_repository_relation ON software_artifact_repository_relation;
CREATE TRIGGER trig_userlog_software_artifact_repository_relation BEFORE INSERT OR UPDATE ON jazzhands.software_artifact_repository_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_software_artifact_repository_relation ON software_artifact_repository_relation;
CREATE TRIGGER trigger_audit_software_artifact_repository_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.software_artifact_repository_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_software_artifact_repository_relation();
DROP TRIGGER IF EXISTS trig_userlog_ssh_key ON ssh_key;
CREATE TRIGGER trig_userlog_ssh_key BEFORE INSERT OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ssh_key ON ssh_key;
CREATE TRIGGER trigger_audit_ssh_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ssh_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ssh_key();
DROP TRIGGER IF EXISTS trig_userlog_static_route ON static_route;
CREATE TRIGGER trig_userlog_static_route BEFORE INSERT OR UPDATE ON jazzhands.static_route FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_static_route ON static_route;
CREATE TRIGGER trigger_audit_static_route AFTER INSERT OR DELETE OR UPDATE ON jazzhands.static_route FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_static_route();
DROP TRIGGER IF EXISTS trig_userlog_static_route_template ON static_route_template;
CREATE TRIGGER trig_userlog_static_route_template BEFORE INSERT OR UPDATE ON jazzhands.static_route_template FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_static_route_template ON static_route_template;
CREATE TRIGGER trigger_audit_static_route_template AFTER INSERT OR DELETE OR UPDATE ON jazzhands.static_route_template FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_static_route_template();
DROP TRIGGER IF EXISTS trig_userlog_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trig_userlog_sudo_account_collection_device_collection BEFORE INSERT OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_account_collection_device_collection ON sudo_account_collection_device_collection;
CREATE TRIGGER trigger_audit_sudo_account_collection_device_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_account_collection_device_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_sudo_account_collection_device_collection();
DROP TRIGGER IF EXISTS trig_userlog_sudo_alias ON sudo_alias;
CREATE TRIGGER trig_userlog_sudo_alias BEFORE INSERT OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_sudo_alias ON sudo_alias;
CREATE TRIGGER trigger_audit_sudo_alias AFTER INSERT OR DELETE OR UPDATE ON jazzhands.sudo_alias FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_sudo_alias();
DROP TRIGGER IF EXISTS trig_userlog_ticketing_system ON ticketing_system;
CREATE TRIGGER trig_userlog_ticketing_system BEFORE INSERT OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_ticketing_system ON ticketing_system;
CREATE TRIGGER trigger_audit_ticketing_system AFTER INSERT OR DELETE OR UPDATE ON jazzhands.ticketing_system FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_ticketing_system();
DROP TRIGGER IF EXISTS trig_userlog_token ON token;
CREATE TRIGGER trig_userlog_token BEFORE INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token ON token;
CREATE TRIGGER trigger_audit_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token();
DROP TRIGGER IF EXISTS trigger_pgnotify_token_change ON token;
CREATE TRIGGER trigger_pgnotify_token_change AFTER INSERT OR UPDATE ON jazzhands.token FOR EACH ROW EXECUTE FUNCTION jazzhands.pgnotify_token_change();
DROP TRIGGER IF EXISTS trig_userlog_token_collection ON token_collection;
CREATE TRIGGER trig_userlog_token_collection BEFORE INSERT OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection ON token_collection;
CREATE TRIGGER trigger_audit_token_collection AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trig_userlog_token_collection_hier BEFORE INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_hier ON token_collection_hier;
CREATE TRIGGER trigger_audit_token_collection_hier AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection_hier();
DROP TRIGGER IF EXISTS trigger_check_token_collection_hier_loop ON token_collection_hier;
CREATE TRIGGER trigger_check_token_collection_hier_loop AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier FOR EACH ROW EXECUTE FUNCTION jazzhands.check_token_colllection_hier_loop();
DROP TRIGGER IF EXISTS trigger_token_collection_hier_enforce ON token_collection_hier;
CREATE CONSTRAINT TRIGGER trigger_token_collection_hier_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_hier DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.token_collection_hier_enforce();
DROP TRIGGER IF EXISTS trig_userlog_token_collection_token ON token_collection_token;
CREATE TRIGGER trig_userlog_token_collection_token BEFORE INSERT OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_token_collection_token ON token_collection_token;
CREATE TRIGGER trigger_audit_token_collection_token AFTER INSERT OR DELETE OR UPDATE ON jazzhands.token_collection_token FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_token_collection_token();
DROP TRIGGER IF EXISTS trigger_token_collection_member_enforce ON token_collection_token;
CREATE CONSTRAINT TRIGGER trigger_token_collection_member_enforce AFTER INSERT OR UPDATE ON jazzhands.token_collection_token DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.token_collection_member_enforce();
DROP TRIGGER IF EXISTS trig_userlog_unix_group ON unix_group;
CREATE TRIGGER trig_userlog_unix_group BEFORE INSERT OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_unix_group ON unix_group;
CREATE TRIGGER trigger_audit_unix_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.unix_group FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_unix_group();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trig_userlog_val_account_collection_relation BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_preserve_direct ON val_account_collection_relation;
CREATE CONSTRAINT TRIGGER trigger_acct_coll_preserve_direct AFTER DELETE OR UPDATE ON jazzhands.val_account_collection_relation DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_preserve_direct();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_relation ON val_account_collection_relation;
CREATE TRIGGER trigger_audit_val_account_collection_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_collection_relation();
DROP TRIGGER IF EXISTS trig_account_collection_type_realm ON val_account_collection_type;
CREATE TRIGGER trig_account_collection_type_realm AFTER UPDATE OF account_realm_id ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.account_collection_type_realm();
DROP TRIGGER IF EXISTS trig_userlog_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trig_userlog_val_account_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_acct_coll_insert_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_insert_direct AFTER INSERT ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_insert_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_remove_direct ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_remove_direct BEFORE DELETE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_remove_direct();
DROP TRIGGER IF EXISTS trigger_acct_coll_update_direct_before ON val_account_collection_type;
CREATE TRIGGER trigger_acct_coll_update_direct_before AFTER UPDATE OF account_collection_type ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.acct_coll_update_direct_before();
DROP TRIGGER IF EXISTS trigger_audit_val_account_collection_type ON val_account_collection_type;
CREATE TRIGGER trigger_audit_val_account_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_account_role ON val_account_role;
CREATE TRIGGER trig_userlog_val_account_role BEFORE INSERT OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_role ON val_account_role;
CREATE TRIGGER trigger_audit_val_account_role AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_role FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_role();
DROP TRIGGER IF EXISTS trig_userlog_val_account_type ON val_account_type;
CREATE TRIGGER trig_userlog_val_account_type BEFORE INSERT OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_account_type ON val_account_type;
CREATE TRIGGER trigger_audit_val_account_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_account_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_account_type();
DROP TRIGGER IF EXISTS trig_userlog_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trig_userlog_val_appaal_group_name BEFORE INSERT OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_appaal_group_name ON val_appaal_group_name;
CREATE TRIGGER trigger_audit_val_appaal_group_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_appaal_group_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_appaal_group_name();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key ON val_application_key;
CREATE TRIGGER trig_userlog_val_application_key BEFORE INSERT OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key ON val_application_key;
CREATE TRIGGER trigger_audit_val_application_key AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_application_key();
DROP TRIGGER IF EXISTS trig_userlog_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trig_userlog_val_application_key_values BEFORE INSERT OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_application_key_values ON val_application_key_values;
CREATE TRIGGER trigger_audit_val_application_key_values AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_application_key_values FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_application_key_values();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trig_userlog_val_approval_chain_response_period BEFORE INSERT OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_chain_response_period ON val_approval_chain_response_period;
CREATE TRIGGER trigger_audit_val_approval_chain_response_period AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_chain_response_period FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_chain_response_period();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trig_userlog_val_approval_expiration_action BEFORE INSERT OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_expiration_action ON val_approval_expiration_action;
CREATE TRIGGER trigger_audit_val_approval_expiration_action AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_expiration_action FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_expiration_action();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trig_userlog_val_approval_notifty_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_notifty_type ON val_approval_notifty_type;
CREATE TRIGGER trigger_audit_val_approval_notifty_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_notifty_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_notifty_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trig_userlog_val_approval_process_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_process_type ON val_approval_process_type;
CREATE TRIGGER trigger_audit_val_approval_process_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_process_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_process_type();
DROP TRIGGER IF EXISTS trig_userlog_val_approval_type ON val_approval_type;
CREATE TRIGGER trig_userlog_val_approval_type BEFORE INSERT OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_approval_type ON val_approval_type;
CREATE TRIGGER trigger_audit_val_approval_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_approval_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_approval_type();
DROP TRIGGER IF EXISTS trig_userlog_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trig_userlog_val_attestation_frequency BEFORE INSERT OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_attestation_frequency ON val_attestation_frequency;
CREATE TRIGGER trigger_audit_val_attestation_frequency AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_attestation_frequency FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_attestation_frequency();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trig_userlog_val_authentication_question BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_question ON val_authentication_question;
CREATE TRIGGER trigger_audit_val_authentication_question AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_question FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_authentication_question();
DROP TRIGGER IF EXISTS trig_userlog_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trig_userlog_val_authentication_resource BEFORE INSERT OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_authentication_resource ON val_authentication_resource;
CREATE TRIGGER trigger_audit_val_authentication_resource AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_authentication_resource FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_authentication_resource();
DROP TRIGGER IF EXISTS trig_userlog_val_badge_status ON val_badge_status;
CREATE TRIGGER trig_userlog_val_badge_status BEFORE INSERT OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_badge_status ON val_badge_status;
CREATE TRIGGER trigger_audit_val_badge_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_badge_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_badge_status();
DROP TRIGGER IF EXISTS trig_userlog_val_cable_type ON val_cable_type;
CREATE TRIGGER trig_userlog_val_cable_type BEFORE INSERT OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_cable_type ON val_cable_type;
CREATE TRIGGER trigger_audit_val_cable_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_cable_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_cable_type();
DROP TRIGGER IF EXISTS trig_userlog_val_checksum_algorithm ON val_checksum_algorithm;
CREATE TRIGGER trig_userlog_val_checksum_algorithm BEFORE INSERT OR UPDATE ON jazzhands.val_checksum_algorithm FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_checksum_algorithm ON val_checksum_algorithm;
CREATE TRIGGER trigger_audit_val_checksum_algorithm AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_checksum_algorithm FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_checksum_algorithm();
DROP TRIGGER IF EXISTS trig_userlog_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trig_userlog_val_company_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_collection_type ON val_company_collection_type;
CREATE TRIGGER trigger_audit_val_company_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_del ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_company_collection_type_bytype_insup ON val_company_collection_type;
CREATE TRIGGER trigger_manip_company_collection_type_bytype_insup AFTER INSERT OR UPDATE OF company_collection_type ON jazzhands.val_company_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_company_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type ON val_company_type;
CREATE TRIGGER trig_userlog_val_company_type BEFORE INSERT OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type ON val_company_type;
CREATE TRIGGER trigger_audit_val_company_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_type();
DROP TRIGGER IF EXISTS trig_userlog_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trig_userlog_val_company_type_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_company_type_purpose ON val_company_type_purpose;
CREATE TRIGGER trigger_audit_val_company_type_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_company_type_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_company_type_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_component_function ON val_component_function;
CREATE TRIGGER trig_userlog_val_component_function BEFORE INSERT OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_function ON val_component_function;
CREATE TRIGGER trigger_audit_val_component_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_function();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property ON val_component_property;
CREATE TRIGGER trig_userlog_val_component_property BEFORE INSERT OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property ON val_component_property;
CREATE TRIGGER trigger_audit_val_component_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trig_userlog_val_component_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_type ON val_component_property_type;
CREATE TRIGGER trigger_audit_val_component_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trig_userlog_val_component_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_component_property_value ON val_component_property_value;
CREATE TRIGGER trigger_audit_val_component_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_component_property_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_component_property_value();
DROP TRIGGER IF EXISTS trig_userlog_val_contract_type ON val_contract_type;
CREATE TRIGGER trig_userlog_val_contract_type BEFORE INSERT OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_contract_type ON val_contract_type;
CREATE TRIGGER trigger_audit_val_contract_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_contract_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_contract_type();
DROP TRIGGER IF EXISTS trig_userlog_val_country_code ON val_country_code;
CREATE TRIGGER trig_userlog_val_country_code BEFORE INSERT OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_country_code ON val_country_code;
CREATE TRIGGER trigger_audit_val_country_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_country_code FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_country_code();
DROP TRIGGER IF EXISTS trig_userlog_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trig_userlog_val_device_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_collection_type ON val_device_collection_type;
CREATE TRIGGER trigger_audit_val_device_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_del ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_device_collection_type_bytype_insup ON val_device_collection_type;
CREATE TRIGGER trigger_manip_device_collection_type_bytype_insup AFTER INSERT OR UPDATE OF device_collection_type ON jazzhands.val_device_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_device_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_device_management_controller_type ON val_device_management_controller_type;
CREATE TRIGGER trig_userlog_val_device_management_controller_type BEFORE INSERT OR UPDATE ON jazzhands.val_device_management_controller_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_management_controller_type ON val_device_management_controller_type;
CREATE TRIGGER trigger_audit_val_device_management_controller_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_management_controller_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_management_controller_type();
DROP TRIGGER IF EXISTS trig_userlog_val_device_status ON val_device_status;
CREATE TRIGGER trig_userlog_val_device_status BEFORE INSERT OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_device_status ON val_device_status;
CREATE TRIGGER trigger_audit_val_device_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_device_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_device_status();
DROP TRIGGER IF EXISTS trig_userlog_val_diet ON val_diet;
CREATE TRIGGER trig_userlog_val_diet BEFORE INSERT OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_diet ON val_diet;
CREATE TRIGGER trigger_audit_val_diet AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_diet FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_diet();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_class ON val_dns_class;
CREATE TRIGGER trig_userlog_val_dns_class BEFORE INSERT OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_class ON val_dns_class;
CREATE TRIGGER trigger_audit_val_dns_class AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_class FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_class();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trig_userlog_val_dns_domain_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_collection_type ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_audit_val_dns_domain_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_domain_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_del ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_dns_domain_collection_type_bytype_insup ON val_dns_domain_collection_type;
CREATE TRIGGER trigger_manip_dns_domain_collection_type_bytype_insup AFTER INSERT OR UPDATE OF dns_domain_collection_type ON jazzhands.val_dns_domain_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_dns_domain_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trig_userlog_val_dns_domain_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_domain_type ON val_dns_domain_type;
CREATE TRIGGER trigger_audit_val_dns_domain_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_domain_type();
DROP TRIGGER IF EXISTS trigger_dns_domain_type_should_generate ON val_dns_domain_type;
CREATE TRIGGER trigger_dns_domain_type_should_generate AFTER UPDATE OF can_generate ON jazzhands.val_dns_domain_type FOR EACH ROW EXECUTE FUNCTION jazzhands.dns_domain_type_should_generate();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trig_userlog_val_dns_record_relation_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_record_relation_type ON val_dns_record_relation_type;
CREATE TRIGGER trigger_audit_val_dns_record_relation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_record_relation_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_record_relation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trig_userlog_val_dns_srv_service BEFORE INSERT OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_srv_service ON val_dns_srv_service;
CREATE TRIGGER trigger_audit_val_dns_srv_service AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_srv_service FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_srv_service();
DROP TRIGGER IF EXISTS trig_userlog_val_dns_type ON val_dns_type;
CREATE TRIGGER trig_userlog_val_dns_type BEFORE INSERT OR UPDATE ON jazzhands.val_dns_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_dns_type ON val_dns_type;
CREATE TRIGGER trigger_audit_val_dns_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_dns_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_dns_type();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trig_userlog_val_encapsulation_mode BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_mode ON val_encapsulation_mode;
CREATE TRIGGER trigger_audit_val_encapsulation_mode AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_mode FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encapsulation_mode();
DROP TRIGGER IF EXISTS trig_userlog_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trig_userlog_val_encapsulation_type BEFORE INSERT OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encapsulation_type ON val_encapsulation_type;
CREATE TRIGGER trigger_audit_val_encapsulation_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encapsulation_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encapsulation_type();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trig_userlog_val_encryption_key_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_key_purpose ON val_encryption_key_purpose;
CREATE TRIGGER trigger_audit_val_encryption_key_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_key_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encryption_key_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trig_userlog_val_encryption_method BEFORE INSERT OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_encryption_method ON val_encryption_method;
CREATE TRIGGER trigger_audit_val_encryption_method AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_encryption_method FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_encryption_method();
DROP TRIGGER IF EXISTS trig_userlog_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trig_userlog_val_filesystem_type BEFORE INSERT OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_filesystem_type ON val_filesystem_type;
CREATE TRIGGER trigger_audit_val_filesystem_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_filesystem_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_filesystem_type();
DROP TRIGGER IF EXISTS trig_userlog_val_gender ON val_gender;
CREATE TRIGGER trig_userlog_val_gender BEFORE INSERT OR UPDATE ON jazzhands.val_gender FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_gender ON val_gender;
CREATE TRIGGER trigger_audit_val_gender AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_gender FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_gender();
DROP TRIGGER IF EXISTS trig_userlog_val_image_type ON val_image_type;
CREATE TRIGGER trig_userlog_val_image_type BEFORE INSERT OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_image_type ON val_image_type;
CREATE TRIGGER trigger_audit_val_image_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_image_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_image_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trig_userlog_val_ip_namespace BEFORE INSERT OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ip_namespace ON val_ip_namespace;
CREATE TRIGGER trigger_audit_val_ip_namespace AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ip_namespace FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ip_namespace();
DROP TRIGGER IF EXISTS trig_userlog_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trig_userlog_val_iso_currency_code BEFORE INSERT OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_iso_currency_code ON val_iso_currency_code;
CREATE TRIGGER trigger_audit_val_iso_currency_code AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_iso_currency_code FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_iso_currency_code();
DROP TRIGGER IF EXISTS trig_userlog_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trig_userlog_val_key_usage_reason_for_assignment BEFORE INSERT OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_key_usage_reason_for_assignment ON val_key_usage_reason_for_assignment;
CREATE TRIGGER trigger_audit_val_key_usage_reason_for_assignment AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_key_usage_reason_for_assignment FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_key_usage_reason_for_assignment();
DROP TRIGGER IF EXISTS trig_userlog_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer2_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer2_network_collection_type ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer2_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer2_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_del ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer2_network_collection_type_bytype_insup ON val_layer2_network_collection_type;
CREATE TRIGGER trigger_manip_layer2_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer2_network_collection_type ON jazzhands.val_layer2_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer2_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_acl_group_type ON val_layer3_acl_group_type;
CREATE TRIGGER trig_userlog_val_layer3_acl_group_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_acl_group_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_acl_group_type ON val_layer3_acl_group_type;
CREATE TRIGGER trigger_audit_val_layer3_acl_group_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_acl_group_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer3_acl_group_type();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_interface_purpose ON val_layer3_interface_purpose;
CREATE TRIGGER trig_userlog_val_layer3_interface_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_interface_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_interface_purpose ON val_layer3_interface_purpose;
CREATE TRIGGER trigger_audit_val_layer3_interface_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_interface_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer3_interface_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_interface_type ON val_layer3_interface_type;
CREATE TRIGGER trig_userlog_val_layer3_interface_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_interface_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_interface_type ON val_layer3_interface_type;
CREATE TRIGGER trigger_audit_val_layer3_interface_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_interface_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer3_interface_type();
DROP TRIGGER IF EXISTS trig_userlog_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trig_userlog_val_layer3_network_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_layer3_network_collection_type ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_audit_val_layer3_network_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_layer3_network_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_del ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_layer3_network_collection_type_bytype_insup ON val_layer3_network_collection_type;
CREATE TRIGGER trigger_manip_layer3_network_collection_type_bytype_insup AFTER INSERT OR UPDATE OF layer3_network_collection_type ON jazzhands.val_layer3_network_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_layer3_network_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trig_userlog_val_logical_port_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_port_type ON val_logical_port_type;
CREATE TRIGGER trigger_audit_val_logical_port_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_port_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_port_type();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trig_userlog_val_logical_volume_property BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_property ON val_logical_volume_property;
CREATE TRIGGER trigger_audit_val_logical_volume_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_property();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trig_userlog_val_logical_volume_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_purpose ON val_logical_volume_purpose;
CREATE TRIGGER trigger_audit_val_logical_volume_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trig_userlog_val_logical_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_logical_volume_type ON val_logical_volume_type;
CREATE TRIGGER trigger_audit_val_logical_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_logical_volume_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_logical_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trig_userlog_val_netblock_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_collection_type ON val_netblock_collection_type;
CREATE TRIGGER trigger_audit_val_netblock_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_del ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_netblock_collection_type_bytype_insup ON val_netblock_collection_type;
CREATE TRIGGER trigger_manip_netblock_collection_type_bytype_insup AFTER INSERT OR UPDATE OF netblock_collection_type ON jazzhands.val_netblock_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_netblock_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trig_userlog_val_netblock_status BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_status ON val_netblock_status;
CREATE TRIGGER trigger_audit_val_netblock_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_status();
DROP TRIGGER IF EXISTS trig_userlog_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trig_userlog_val_netblock_type BEFORE INSERT OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_netblock_type ON val_netblock_type;
CREATE TRIGGER trigger_audit_val_netblock_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_netblock_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_netblock_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trig_userlog_val_network_range_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_range_type ON val_network_range_type;
CREATE TRIGGER trigger_audit_val_network_range_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_range_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_network_range_type();
DROP TRIGGER IF EXISTS trigger_validate_net_range_toggle_nonoverlap ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_net_range_toggle_nonoverlap AFTER UPDATE OF can_overlap, require_cidr_boundary ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_net_range_toggle_nonoverlap();
DROP TRIGGER IF EXISTS trigger_validate_val_network_range_type ON val_network_range_type;
CREATE CONSTRAINT TRIGGER trigger_validate_val_network_range_type AFTER UPDATE OF dns_domain_required, netblock_type ON jazzhands.val_network_range_type DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_network_range_type();
DROP TRIGGER IF EXISTS trig_userlog_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trig_userlog_val_network_service_type BEFORE INSERT OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_network_service_type ON val_network_service_type;
CREATE TRIGGER trigger_audit_val_network_service_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_network_service_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_network_service_type();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trig_userlog_val_operating_system_family BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_family ON val_operating_system_family;
CREATE TRIGGER trigger_audit_val_operating_system_family AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_family FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_operating_system_family();
DROP TRIGGER IF EXISTS trig_userlog_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trig_userlog_val_operating_system_snapshot_type BEFORE INSERT OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_operating_system_snapshot_type ON val_operating_system_snapshot_type;
CREATE TRIGGER trigger_audit_val_operating_system_snapshot_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_operating_system_snapshot_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_operating_system_snapshot_type();
DROP TRIGGER IF EXISTS trig_userlog_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trig_userlog_val_ownership_status BEFORE INSERT OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ownership_status ON val_ownership_status;
CREATE TRIGGER trigger_audit_val_ownership_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ownership_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ownership_status();
DROP TRIGGER IF EXISTS trig_userlog_val_password_type ON val_password_type;
CREATE TRIGGER trig_userlog_val_password_type BEFORE INSERT OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_password_type ON val_password_type;
CREATE TRIGGER trigger_audit_val_password_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_password_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_password_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trig_userlog_val_person_company_attribute_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_data_type ON val_person_company_attribute_data_type;
CREATE TRIGGER trigger_audit_val_person_company_attribute_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_data_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trig_userlog_val_person_company_attribute_name BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_name ON val_person_company_attribute_name;
CREATE TRIGGER trigger_audit_val_person_company_attribute_name AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_name FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_name();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trig_userlog_val_person_company_attribute_value BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_attribute_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_audit_val_person_company_attribute_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_attribute_value();
DROP TRIGGER IF EXISTS trigger_person_company_attribute_change_after_row_hooks ON val_person_company_attribute_value;
CREATE TRIGGER trigger_person_company_attribute_change_after_row_hooks AFTER INSERT OR UPDATE ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.person_company_attribute_change_after_row_hooks();
DROP TRIGGER IF EXISTS trigger_validate_pers_comp_attr_value ON val_person_company_attribute_value;
CREATE TRIGGER trigger_validate_pers_comp_attr_value BEFORE DELETE OR UPDATE OF person_company_attribute_name, person_company_attribute_value ON jazzhands.val_person_company_attribute_value FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_pers_comp_attr_value();
DROP TRIGGER IF EXISTS trig_userlog_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trig_userlog_val_person_company_relation BEFORE INSERT OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_company_relation ON val_person_company_relation;
CREATE TRIGGER trigger_audit_val_person_company_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_company_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_company_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trig_userlog_val_person_contact_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_location_type ON val_person_contact_location_type;
CREATE TRIGGER trigger_audit_val_person_contact_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_location_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trig_userlog_val_person_contact_technology BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_technology ON val_person_contact_technology;
CREATE TRIGGER trigger_audit_val_person_contact_technology AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_technology FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_technology();
DROP TRIGGER IF EXISTS trig_userlog_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trig_userlog_val_person_contact_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_contact_type ON val_person_contact_type;
CREATE TRIGGER trigger_audit_val_person_contact_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_contact_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_contact_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trig_userlog_val_person_image_usage BEFORE INSERT OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_image_usage ON val_person_image_usage;
CREATE TRIGGER trigger_audit_val_person_image_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_image_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_image_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trig_userlog_val_person_location_type BEFORE INSERT OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_location_type ON val_person_location_type;
CREATE TRIGGER trigger_audit_val_person_location_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_location_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_location_type();
DROP TRIGGER IF EXISTS trig_userlog_val_person_status ON val_person_status;
CREATE TRIGGER trig_userlog_val_person_status BEFORE INSERT OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_person_status ON val_person_status;
CREATE TRIGGER trigger_audit_val_person_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_person_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_person_status();
DROP TRIGGER IF EXISTS trig_userlog_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trig_userlog_val_physical_address_type BEFORE INSERT OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physical_address_type ON val_physical_address_type;
CREATE TRIGGER trigger_audit_val_physical_address_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physical_address_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_physical_address_type();
DROP TRIGGER IF EXISTS trig_userlog_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trig_userlog_val_physicalish_volume_type BEFORE INSERT OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_physicalish_volume_type ON val_physicalish_volume_type;
CREATE TRIGGER trigger_audit_val_physicalish_volume_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_physicalish_volume_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_physicalish_volume_type();
DROP TRIGGER IF EXISTS trig_userlog_val_port_range_type ON val_port_range_type;
CREATE TRIGGER trig_userlog_val_port_range_type BEFORE INSERT OR UPDATE ON jazzhands.val_port_range_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_port_range_type ON val_port_range_type;
CREATE TRIGGER trigger_audit_val_port_range_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_port_range_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_port_range_type();
DROP TRIGGER IF EXISTS trigger_val_port_range_sanity_check ON val_port_range_type;
CREATE CONSTRAINT TRIGGER trigger_val_port_range_sanity_check AFTER UPDATE OF range_permitted ON jazzhands.val_port_range_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.val_port_range_sanity_check();
DROP TRIGGER IF EXISTS trig_userlog_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trig_userlog_val_private_key_encryption_type BEFORE INSERT OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_private_key_encryption_type ON val_private_key_encryption_type;
CREATE TRIGGER trigger_audit_val_private_key_encryption_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_private_key_encryption_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_private_key_encryption_type();
DROP TRIGGER IF EXISTS trig_userlog_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trig_userlog_val_processor_architecture BEFORE INSERT OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_processor_architecture ON val_processor_architecture;
CREATE TRIGGER trigger_audit_val_processor_architecture AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_processor_architecture FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_processor_architecture();
DROP TRIGGER IF EXISTS trig_userlog_val_production_state ON val_production_state;
CREATE TRIGGER trig_userlog_val_production_state BEFORE INSERT OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_production_state ON val_production_state;
CREATE TRIGGER trigger_audit_val_production_state AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_production_state FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_production_state();
DROP TRIGGER IF EXISTS trig_userlog_val_property ON val_property;
CREATE TRIGGER trig_userlog_val_property BEFORE INSERT OR UPDATE ON jazzhands.val_property FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property ON val_property;
CREATE TRIGGER trigger_audit_val_property AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property();
DROP TRIGGER IF EXISTS trigger_validate_val_property ON val_property;
CREATE TRIGGER trigger_validate_val_property BEFORE INSERT OR UPDATE OF property_data_type, property_value_json_schema, permit_company_id ON jazzhands.val_property FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_property();
DROP TRIGGER IF EXISTS trigger_validate_val_property_after ON val_property;
CREATE CONSTRAINT TRIGGER trigger_validate_val_property_after AFTER UPDATE ON jazzhands.val_property DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.validate_val_property_after();
DROP TRIGGER IF EXISTS trig_userlog_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trig_userlog_val_property_data_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_data_type ON val_property_data_type;
CREATE TRIGGER trigger_audit_val_property_data_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_data_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_data_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trig_userlog_val_property_name_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_name_collection_type ON val_property_name_collection_type;
CREATE TRIGGER trigger_audit_val_property_name_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_name_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_name_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_type ON val_property_type;
CREATE TRIGGER trig_userlog_val_property_type BEFORE INSERT OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_type ON val_property_type;
CREATE TRIGGER trigger_audit_val_property_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_type();
DROP TRIGGER IF EXISTS trig_userlog_val_property_value ON val_property_value;
CREATE TRIGGER trig_userlog_val_property_value BEFORE INSERT OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_property_value ON val_property_value;
CREATE TRIGGER trigger_audit_val_property_value AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_property_value FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_property_value();
DROP TRIGGER IF EXISTS trigger_val_property_value_del_check ON val_property_value;
CREATE CONSTRAINT TRIGGER trigger_val_property_value_del_check AFTER DELETE ON jazzhands.val_property_value DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION jazzhands.val_property_value_del_check();
DROP TRIGGER IF EXISTS trig_userlog_val_rack_type ON val_rack_type;
CREATE TRIGGER trig_userlog_val_rack_type BEFORE INSERT OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_rack_type ON val_rack_type;
CREATE TRIGGER trigger_audit_val_rack_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_rack_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_rack_type();
DROP TRIGGER IF EXISTS trig_userlog_val_raid_type ON val_raid_type;
CREATE TRIGGER trig_userlog_val_raid_type BEFORE INSERT OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_raid_type ON val_raid_type;
CREATE TRIGGER trigger_audit_val_raid_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_raid_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_raid_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_affinity ON val_service_affinity;
CREATE TRIGGER trig_userlog_val_service_affinity BEFORE INSERT OR UPDATE ON jazzhands.val_service_affinity FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_affinity ON val_service_affinity;
CREATE TRIGGER trigger_audit_val_service_affinity AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_affinity FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_affinity();
DROP TRIGGER IF EXISTS trig_userlog_val_service_endpoint_provider_collection_type ON val_service_endpoint_provider_collection_type;
CREATE TRIGGER trig_userlog_val_service_endpoint_provider_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_endpoint_provider_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_endpoint_provider_collection_type ON val_service_endpoint_provider_collection_type;
CREATE TRIGGER trigger_audit_val_service_endpoint_provider_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_endpoint_provider_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_endpoint_provider_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_endpoint_provider_type ON val_service_endpoint_provider_type;
CREATE TRIGGER trig_userlog_val_service_endpoint_provider_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_endpoint_provider_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_endpoint_provider_type ON val_service_endpoint_provider_type;
CREATE TRIGGER trigger_audit_val_service_endpoint_provider_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_endpoint_provider_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_endpoint_provider_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trig_userlog_val_service_environment_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_environment_collection_type ON val_service_environment_collection_type;
CREATE TRIGGER trigger_audit_val_service_environment_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_environment_collection_type();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_del ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_del BEFORE DELETE ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trigger_manip_service_environment_collection_type_bytype_insup ON val_service_environment_collection_type;
CREATE TRIGGER trigger_manip_service_environment_collection_type_bytype_insup AFTER INSERT OR UPDATE OF service_environment_collection_type ON jazzhands.val_service_environment_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.manip_service_environment_collection_type_bytype();
DROP TRIGGER IF EXISTS trig_userlog_val_service_environment_type ON val_service_environment_type;
CREATE TRIGGER trig_userlog_val_service_environment_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_environment_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_environment_type ON val_service_environment_type;
CREATE TRIGGER trigger_audit_val_service_environment_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_environment_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_environment_type();
DROP TRIGGER IF EXISTS trig_userlog_val_service_feature ON val_service_feature;
CREATE TRIGGER trig_userlog_val_service_feature BEFORE INSERT OR UPDATE ON jazzhands.val_service_feature FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_feature ON val_service_feature;
CREATE TRIGGER trigger_audit_val_service_feature AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_feature FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_feature();
DROP TRIGGER IF EXISTS trig_userlog_val_service_source_control_purpose ON val_service_source_control_purpose;
CREATE TRIGGER trig_userlog_val_service_source_control_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_service_source_control_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_source_control_purpose ON val_service_source_control_purpose;
CREATE TRIGGER trigger_audit_val_service_source_control_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_source_control_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_source_control_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_service_version_collection_type ON val_service_version_collection_type;
CREATE TRIGGER trig_userlog_val_service_version_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_service_version_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_service_version_collection_type ON val_service_version_collection_type;
CREATE TRIGGER trigger_audit_val_service_version_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_service_version_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_service_version_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trig_userlog_val_shared_netblock_protocol BEFORE INSERT OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_shared_netblock_protocol ON val_shared_netblock_protocol;
CREATE TRIGGER trigger_audit_val_shared_netblock_protocol AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_shared_netblock_protocol FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_shared_netblock_protocol();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_function ON val_slot_function;
CREATE TRIGGER trig_userlog_val_slot_function BEFORE INSERT OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_function ON val_slot_function;
CREATE TRIGGER trigger_audit_val_slot_function AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_function FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_slot_function();
DROP TRIGGER IF EXISTS trig_userlog_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trig_userlog_val_slot_physical_interface BEFORE INSERT OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_slot_physical_interface ON val_slot_physical_interface;
CREATE TRIGGER trigger_audit_val_slot_physical_interface AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_slot_physical_interface FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_slot_physical_interface();
DROP TRIGGER IF EXISTS trig_userlog_val_software_artifact_relationship ON val_software_artifact_relationship;
CREATE TRIGGER trig_userlog_val_software_artifact_relationship BEFORE INSERT OR UPDATE ON jazzhands.val_software_artifact_relationship FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_software_artifact_relationship ON val_software_artifact_relationship;
CREATE TRIGGER trigger_audit_val_software_artifact_relationship AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_software_artifact_relationship FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_software_artifact_relationship();
DROP TRIGGER IF EXISTS trig_userlog_val_software_artifact_type ON val_software_artifact_type;
CREATE TRIGGER trig_userlog_val_software_artifact_type BEFORE INSERT OR UPDATE ON jazzhands.val_software_artifact_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_software_artifact_type ON val_software_artifact_type;
CREATE TRIGGER trigger_audit_val_software_artifact_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_software_artifact_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_software_artifact_type();
DROP TRIGGER IF EXISTS trig_userlog_val_source_repository_method ON val_source_repository_method;
CREATE TRIGGER trig_userlog_val_source_repository_method BEFORE INSERT OR UPDATE ON jazzhands.val_source_repository_method FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_source_repository_method ON val_source_repository_method;
CREATE TRIGGER trigger_audit_val_source_repository_method AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_source_repository_method FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_source_repository_method();
DROP TRIGGER IF EXISTS trig_userlog_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trig_userlog_val_ssh_key_type BEFORE INSERT OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_ssh_key_type ON val_ssh_key_type;
CREATE TRIGGER trigger_audit_val_ssh_key_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_ssh_key_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_ssh_key_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trig_userlog_val_token_collection_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_collection_type ON val_token_collection_type;
CREATE TRIGGER trigger_audit_val_token_collection_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_collection_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_collection_type();
DROP TRIGGER IF EXISTS trig_userlog_val_token_status ON val_token_status;
CREATE TRIGGER trig_userlog_val_token_status BEFORE INSERT OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_status ON val_token_status;
CREATE TRIGGER trigger_audit_val_token_status AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_status FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_status();
DROP TRIGGER IF EXISTS trig_userlog_val_token_type ON val_token_type;
CREATE TRIGGER trig_userlog_val_token_type BEFORE INSERT OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_token_type ON val_token_type;
CREATE TRIGGER trigger_audit_val_token_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_token_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_token_type();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trig_userlog_val_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_purpose ON val_volume_group_purpose;
CREATE TRIGGER trigger_audit_val_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trig_userlog_val_volume_group_relation BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_relation ON val_volume_group_relation;
CREATE TRIGGER trigger_audit_val_volume_group_relation AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_relation FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_relation();
DROP TRIGGER IF EXISTS trig_userlog_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trig_userlog_val_volume_group_type BEFORE INSERT OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_volume_group_type ON val_volume_group_type;
CREATE TRIGGER trigger_audit_val_volume_group_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_volume_group_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_volume_group_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trig_userlog_val_x509_certificate_file_format BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_file_format ON val_x509_certificate_file_format;
CREATE TRIGGER trigger_audit_val_x509_certificate_file_format AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_file_format FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_certificate_file_format();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trig_userlog_val_x509_certificate_type BEFORE INSERT OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_certificate_type ON val_x509_certificate_type;
CREATE TRIGGER trigger_audit_val_x509_certificate_type AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_certificate_type FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_certificate_type();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trig_userlog_val_x509_key_usage BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage ON val_x509_key_usage;
CREATE TRIGGER trigger_audit_val_x509_key_usage AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_key_usage();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trig_userlog_val_x509_key_usage_category BEFORE INSERT OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_key_usage_category ON val_x509_key_usage_category;
CREATE TRIGGER trigger_audit_val_x509_key_usage_category AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_key_usage_category FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_key_usage_category();
DROP TRIGGER IF EXISTS trig_userlog_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trig_userlog_val_x509_revocation_reason BEFORE INSERT OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_val_x509_revocation_reason ON val_x509_revocation_reason;
CREATE TRIGGER trigger_audit_val_x509_revocation_reason AFTER INSERT OR DELETE OR UPDATE ON jazzhands.val_x509_revocation_reason FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_val_x509_revocation_reason();
DROP TRIGGER IF EXISTS trig_userlog_volume_group ON volume_group;
CREATE TRIGGER trig_userlog_volume_group BEFORE INSERT OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group ON volume_group;
CREATE TRIGGER trigger_audit_volume_group AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trig_userlog_volume_group_physicalish_volume BEFORE INSERT OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_physicalish_volume ON volume_group_physicalish_volume;
CREATE TRIGGER trigger_audit_volume_group_physicalish_volume AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_physicalish_volume FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group_physicalish_volume();
DROP TRIGGER IF EXISTS trig_userlog_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trig_userlog_volume_group_purpose BEFORE INSERT OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_volume_group_purpose ON volume_group_purpose;
CREATE TRIGGER trigger_audit_volume_group_purpose AFTER INSERT OR DELETE OR UPDATE ON jazzhands.volume_group_purpose FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_volume_group_purpose();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trig_userlog_x509_key_usage_attribute BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_attribute ON x509_key_usage_attribute;
CREATE TRIGGER trigger_audit_x509_key_usage_attribute AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_attribute FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_attribute();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trig_userlog_x509_key_usage_categorization BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_categorization ON x509_key_usage_categorization;
CREATE TRIGGER trigger_audit_x509_key_usage_categorization AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_categorization FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_categorization();
DROP TRIGGER IF EXISTS trig_userlog_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trig_userlog_x509_key_usage_default BEFORE INSERT OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE FUNCTION schema_support.trigger_ins_upd_generic_func();
DROP TRIGGER IF EXISTS trigger_audit_x509_key_usage_default ON x509_key_usage_default;
CREATE TRIGGER trigger_audit_x509_key_usage_default AFTER INSERT OR DELETE OR UPDATE ON jazzhands.x509_key_usage_default FOR EACH ROW EXECUTE FUNCTION jazzhands.perform_audit_x509_key_usage_default();

--
-- BEGIN: Procesing things saved for end
--
SAVEPOINT beforerecreate;

--
-- END: Procesing things saved for end
--

SELECT schema_support.replay_object_recreates(beverbose := true);
SELECT schema_support.replay_saved_grants(beverbose := true);

--
-- BEGIN: Running final cache table sync
SAVEPOINT beforecache;
SELECT schema_support.synchronize_cache_tables();

--
-- END: Running final cache table sync
SAVEPOINT beforereset;
SELECT schema_support.reset_all_schema_table_sequences('jazzhands');
SELECT schema_support.reset_all_schema_table_sequences('jazzhands_audit');
SAVEPOINT beforegrant;
GRANT select on all tables in schema jazzhands to ro_role;
GRANT insert,update,delete on all tables in schema jazzhands to iud_role;
GRANT insert,update,delete on all tables in schema jazzhands_legacy to iud_role;
GRANT select on all sequences in schema jazzhands to ro_role;
GRANT usage on all sequences in schema jazzhands to iud_role;
GRANT select on all tables in schema jazzhands_audit to ro_role;
GRANT select on all sequences in schema jazzhands_audit to ro_role;
GRANT select on all tables in schema jazzhands_audit to ro_role;
GRANT select on all sequences in schema jazzhands_audit to ro_role;
-- schema_support changes.  schema_owners needs to be documented somewhere
GRANT execute on all functions in schema schema_support to schema_owners;
REVOKE execute on all functions in schema schema_support from public;

SELECT schema_support.end_maintenance();
SAVEPOINT maintend;
select clock_timestamp(), now(), clock_timestamp() - now() AS len;
