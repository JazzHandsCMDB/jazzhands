-- tables of interest:
-- site
-- val_ssh_key_type
-- val_person_location_type
-- ssh_key
-- person_location
-- physical_address
-- device_ssh_key
-- account_ssh_key

-- XXX need to be autogenerated....
create sequence ssh_key_ssh_key_id_seq;
create sequence person_location_person_location_id_seq;
create sequence physical_address_physical_address_id_seq;

-- DEALING WITH TABLE site [70129]

-- FOREIGN KEYS FROM
alter table site_netblock drop constraint fk_site_netblock_ref_site;
alter table property drop constraint fk_property_site_code;
alter table vlan_range drop constraint fk_vlan_ran_ref_site;
alter table device drop constraint fk_device_site_code;
alter table rack drop constraint fk_site_rack;

-- FOREIGN KEYS TO
alter table site drop constraint fk_site_colo_company_id;
alter table site drop constraint pk_site_code;
-- INDEXES
DROP INDEX xif2site;
-- CHECK CONSTRAINTS, etc
alter table site drop constraint ckc_site_status_site;
-- TRIGGERS, etc
drop trigger trig_userlog_site on site;
drop trigger trigger_audit_site on site;


ALTER TABLE site RENAME TO site_v27;
ALTER TABLE audit.site RENAME TO site_v27;

CREATE TABLE site
(
	site_code	varchar(50) NOT NULL,
	colo_company_id	integer  NULL,
	npanxx	varchar(15)  NULL,
	physical_address_id	integer  NULL,
	site_status	varchar(50) NOT NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('site', false);
INSERT INTO site (
	site_code,
	colo_company_id,
	npanxx,
	physical_address_id,
	site_status,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
) SELECT		site_code,
	colo_company_id,
	npanxx,
	NULL,
	site_status,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date
FROM site_v27;

INSERT INTO audit.site (
	site_code,
	colo_company_id,
	npanxx,
	physical_address_id,
	site_status,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#user",
	"aud#seq"
) SELECT		site_code,
	colo_company_id,
	npanxx,
	NULL,
	site_status,
	description,
	data_ins_user,
	data_ins_date,
	data_upd_user,
	data_upd_date,
	"aud#action",
	"aud#timestamp",
	"aud#user",
	"aud#seq"
FROM audit.site_v27;


-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE site ADD CONSTRAINT pk_site_code PRIMARY KEY (site_code);
-- INDEXES
CREATE INDEX xifsite_physaddr_id ON site USING btree (physical_address_id);
CREATE INDEX fk_site_colo_company_id ON site USING btree (colo_company_id);

-- CHECK CONSTRAINTS
ALTER TABLE site ADD CONSTRAINT ckc_site_status_site
	CHECK (((site_status)::text = ANY ((ARRAY['ACTIVE'::character varying, 'INACTIVE'::character varying, 'OBSOLETE'::character varying, 'PLANNED'::character varying])::text[])) AND ((site_status)::text = upper((site_status)::text)));

-- FOREIGN KEYS FROM
ALTER TABLE site_netblock
	ADD CONSTRAINT fk_site_netblock_ref_site
	FOREIGN KEY (site_code) REFERENCES site(site_code);
ALTER TABLE property
	ADD CONSTRAINT fk_property_site_code
	FOREIGN KEY (site_code) REFERENCES site(site_code) ON DELETE SET NULL;
ALTER TABLE vlan_range
	ADD CONSTRAINT fk_vlan_ran_ref_site
	FOREIGN KEY (site_code) REFERENCES site(site_code);
ALTER TABLE device
	ADD CONSTRAINT fk_device_site_code
	FOREIGN KEY (site_code) REFERENCES site(site_code) ON DELETE SET NULL;
ALTER TABLE rack
	ADD CONSTRAINT fk_site_rack
	FOREIGN KEY (site_code) REFERENCES site(site_code);

-- FOREIGN KEYS TO
ALTER TABLE site
	ADD CONSTRAINT fk_site_colo_company_id
	FOREIGN KEY (colo_company_id) REFERENCES company(company_id) ON DELETE SET NULL;

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('site');
SELECT schema_support.rebuild_audit_trigger('site');
DROP TABLE site_v27;
DROP TABLE audit.site_v27;
CREATE TABLE val_ssh_key_type
(
	ssh_key_type	character(18) NOT NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('val_ssh_key_type', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE val_ssh_key_type ADD CONSTRAINT pk_val_ssh_key_type PRIMARY KEY (ssh_key_type);
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('val_ssh_key_type');
SELECT schema_support.rebuild_audit_trigger('val_ssh_key_type');
CREATE TABLE val_person_location_type
(
	person_location_type	varchar(50) NOT NULL,
	description	varchar(4000)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('val_person_location_type', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE val_person_location_type ADD CONSTRAINT pk_val_user_location_type PRIMARY KEY (person_location_type);
-- INDEXES

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('val_person_location_type');
SELECT schema_support.rebuild_audit_trigger('val_person_location_type');
CREATE TABLE ssh_key
(
	ssh_key_id	integer NOT NULL,
	ssh_key_type	character(18)  NULL,
	ssh_public_key	varchar(4096) NOT NULL,
	ssh_private_key	varchar(4096)  NULL,
	_	integer  NULL,
	description	varchar(255)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('ssh_key', true);
ALTER TABLE ssh_key
	ALTER ssh_key_id
	SET DEFAULT nextval('ssh_key_ssh_key_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE ssh_key ADD CONSTRAINT pk_ssh_key PRIMARY KEY (ssh_key_id);
-- INDEXES
CREATE INDEX xif2ssh_key ON ssh_key USING btree (ssh_key_type);
CREATE INDEX xif1ssh_key ON ssh_key USING btree (_);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE ssh_key
	ADD CONSTRAINT fk_ssh_key_enc_key_id
	FOREIGN KEY (_) REFERENCES encryption_key(encryption_key_id) ON DELETE SET NULL;
ALTER TABLE ssh_key
	ADD CONSTRAINT fk_ssh_key_ssh_key_type
	FOREIGN KEY (ssh_key_type) REFERENCES val_ssh_key_type(ssh_key_type) ON DELETE SET NULL;

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('ssh_key');
SELECT schema_support.rebuild_audit_trigger('ssh_key');
CREATE TABLE person_location
(
	person_location_id	integer NOT NULL,
	person_id	integer  NULL,
	person_location_type	varchar(50)  NULL,
	site_code	varchar(50)  NULL,
	physical_address_id	integer  NULL,
	building	varchar(50)  NULL,
	floor	varchar(10)  NULL,
	section	varchar(50)  NULL,
	seat_number	varchar(10)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('person_location', true);
ALTER TABLE person_location
	ALTER person_location_id
	SET DEFAULT nextval('person_location_person_location_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE person_location ADD CONSTRAINT pk_person_location PRIMARY KEY (person_location_id);
-- INDEXES
CREATE INDEX xifpersloc_sitecode ON person_location USING btree (site_code);
CREATE INDEX xifpersloc_persloctyp ON person_location USING btree (person_location_type);
CREATE INDEX xifpersloc_physaddrid ON person_location USING btree (physical_address_id);
CREATE INDEX xifpersloc_persid ON person_location USING btree (person_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE person_location
	ADD CONSTRAINT fk_persloc_persid
	FOREIGN KEY (person_id) REFERENCES person(person_id) ON DELETE SET NULL;
ALTER TABLE person_location
	ADD CONSTRAINT fk_persloc_persloctyp
	FOREIGN KEY (person_location_type) REFERENCES val_person_location_type(person_location_type) ON DELETE SET NULL;
ALTER TABLE person_location
	ADD CONSTRAINT fk_persloc_site_code
	FOREIGN KEY (site_code) REFERENCES site(site_code) ON DELETE SET NULL;

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('person_location');
SELECT schema_support.rebuild_audit_trigger('person_location');
CREATE TABLE physical_address
(
	physical_address_id	integer NOT NULL,
	company_id	integer  NULL,
	site_rank	integer  NULL,
	description	varchar(4000)  NULL,
	display_label	varchar(100)  NULL,
	address_agent	varchar(100)  NULL,
	address_housename	varchar(255)  NULL,
	address_street	varchar(255)  NULL,
	address_building	varchar(255)  NULL,
	address_pobox	varchar(255)  NULL,
	address_neighborhood	varchar(255)  NULL,
	address_city	varchar(100)  NULL,
	address_subregion	character(18)  NULL,
	address_region	varchar(100)  NULL,
	postal_code	varchar(20)  NULL,
	iso_country_code	character(2) NOT NULL,
	address_freeform	varchar(50)  NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('physical_address', true);
ALTER TABLE physical_address
	ALTER physical_address_id
	SET DEFAULT nextval('physical_address_physical_address_id_seq'::regclass);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE physical_address ADD CONSTRAINT ak_physaddr_compid_siterk UNIQUE (company_id, site_rank);
ALTER TABLE physical_address ADD CONSTRAINT pk_val_office_site PRIMARY KEY (physical_address_id);
-- INDEXES
CREATE INDEX xif2physical_address ON physical_address USING btree (company_id);
CREATE INDEX xif1physical_address ON physical_address USING btree (iso_country_code);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM
ALTER TABLE person_location
	ADD CONSTRAINT fk_persloc_physaddrid
	FOREIGN KEY (physical_address_id) REFERENCES physical_address(physical_address_id) ON DELETE SET NULL;
ALTER TABLE site
	ADD CONSTRAINT fk_site_physaddr_id
	FOREIGN KEY (physical_address_id) REFERENCES physical_address(physical_address_id) ON DELETE SET NULL;

-- FOREIGN KEYS TO
ALTER TABLE physical_address
	ADD CONSTRAINT fk_physaddr_iso_cc
	FOREIGN KEY (iso_country_code) REFERENCES val_country_code(iso_country_code) ON DELETE SET NULL;
ALTER TABLE physical_address
	ADD CONSTRAINT fk_physaddr_company_id
	FOREIGN KEY (company_id) REFERENCES company(company_id) ON DELETE SET NULL;

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('physical_address');
SELECT schema_support.rebuild_audit_trigger('physical_address');
CREATE TABLE device_ssh_key
(
	device_id	integer NOT NULL,
	ssh_key_id	integer NOT NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('device_ssh_key', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE device_ssh_key ADD CONSTRAINT pk_device_ssh_key PRIMARY KEY (device_id, ssh_key_id);
-- INDEXES
CREATE INDEX xif1device_ssh_key ON device_ssh_key USING btree (ssh_key_id);
CREATE INDEX xif2device_ssh_key ON device_ssh_key USING btree (device_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE device_ssh_key
	ADD CONSTRAINT fk_dev_ssh_key_device_id
	FOREIGN KEY (ssh_key_id) REFERENCES ssh_key(ssh_key_id);
ALTER TABLE device_ssh_key
	ADD CONSTRAINT fk_dev_ssh_key_ssh_key_id
	FOREIGN KEY (device_id) REFERENCES device(device_id);

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('device_ssh_key');
SELECT schema_support.rebuild_audit_trigger('device_ssh_key');
CREATE TABLE account_ssh_key
(
	account_id	integer NOT NULL,
	ssh_key_id	integer NOT NULL,
	data_ins_user	varchar(30)  NULL,
	data_ins_date	timestamp with time zone  NULL,
	data_upd_user	varchar(30)  NULL,
	data_upd_date	timestamp with time zone  NULL
);
SELECT schema_support.build_audit_table('account_ssh_key', true);

-- PRIMARY AND ALTERNATE KEYS
ALTER TABLE account_ssh_key ADD CONSTRAINT pk_account_ssh_key PRIMARY KEY (account_id, ssh_key_id);
-- INDEXES
CREATE INDEX xif1account_ssh_key ON account_ssh_key USING btree (account_id);
CREATE INDEX xif2account_ssh_key ON account_ssh_key USING btree (ssh_key_id);

-- CHECK CONSTRAINTS

-- FOREIGN KEYS FROM

-- FOREIGN KEYS TO
ALTER TABLE account_ssh_key
	ADD CONSTRAINT fk_account_ssh_key_account_id
	FOREIGN KEY (ssh_key_id) REFERENCES ssh_key(ssh_key_id);
ALTER TABLE account_ssh_key
	ADD CONSTRAINT fk_account_ssh_key_ssh_key_id
	FOREIGN KEY (account_id) REFERENCES account(account_id);

-- TRIGGERS
SELECT schema_support.rebuild_stamp_trigger('account_ssh_key');
SELECT schema_support.rebuild_audit_trigger('account_ssh_key');


-- Copyright (c) 2005-2010, Vonage Holdings Corp.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
-- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/*
 * $Id: netblock_utils.sql 210 2012-09-06 03:51:06Z mattragan $
 */

drop schema if exists netblock_utils cascade;
create schema netblock_utils authorization jazzhands;

-------------------------------------------------------------------
-- returns the Id tag for CM
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION netblock_utils.id_tag()
RETURNS VARCHAR AS $$
BEGIN
	RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;
-- end of procedure id_tag
-------------------------------------------------------------------

CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_id(
	in_IpAddress netblock.ip_address%type,
	in_Netmask_Bits netblock.NETMASK_BITS%type
) RETURNS netblock.netblock_id%type AS $$
DECLARE
	par_nbid	netblock.netblock_id%type;
BEGIN
	in_IpAddress := set_masklen(in_IpAddress, in_Netmask_Bits);
	select  Netblock_Id
	  into	par_nbid
	  from  ( select Netblock_Id, Ip_Address, Netmask_Bits
		    from NetBlock
		   where
		   	in_IpAddress <<= ip_address
		    and is_single_address = 'N'
		    and is_organizational = 'N'
		    and netmask_bits > 0
		order by netmask_bits desc
	) subq LIMIT 1;

	return par_nbid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE OR REPLACE FUNCTION netblock_utils.find_rvs_zone_from_netblock_id(
	in_netblock_id	netblock.netblock_id%type
) RETURNS dns_domain.dns_domain_id%type AS $$
DECLARE
	v_rv	dns_domain.dns_domain_id%type;
	v_domid	dns_domain.dns_domain_id%type;
	v_lhsip	netblock.ip_address%type;
	v_rhsip	netblock.ip_address%type;
	nb_match CURSOR ( in_nb_id netblock.netblock_id%type) FOR
		-- The query used to include this in the where clause, but
		-- oracle was uber slow 
		--	net_manip.inet_base(nb.ip_address, root.netmask_bits) =  
		--		net_manip.inet_base(root.ip_address, root.netmask_bits) 
		select  rootd.dns_domain_id,
				 net_manip.inet_base(nb.ip_address, root.netmask_bits),
				 net_manip.inet_base(root.ip_address, root.netmask_bits)
		  from  netblock nb,
			netblock root
				inner join dns_record rootd
					on rootd.netblock_id = root.netblock_id
					and rootd.dns_type = 'REVERSE_ZONE_BLOCK_PTR'
		 where
		  	nb.netblock_id = in_nb_id;
BEGIN
	v_rv := NULL;
	OPEN nb_match(in_netblock_id);
	LOOP
		FETCH  nb_match INTO v_domid, v_lhsip, v_rhsip;
		if NOT FOUND THEN
			EXIT;
		END IF;

		if v_lhsip = v_rhsip THEN
			v_rv := v_domid;
			EXIT;
		END IF;
	END LOOP;
	CLOSE nb_match;
	return v_rv;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Copyright (c) 2011, Todd M. Kover
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--       http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
/*
 * $Id: net_manip.sql 210 2012-09-06 03:51:06Z mattragan $
 */

DROP SCHEMA IF EXISTS net_manip CASCADE;
CREATE SCHEMA net_manip AUTHORIZATION jazzhands;

-------------------------------------------------------------------
-- returns the Id tag for CM
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION net_manip.id_tag()
RETURNS VARCHAR AS $$
BEGIN
	RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;
-- end of procedure id_tag
-------------------------------------------------------------------

-------------------------------------------------------------------
-- returns its first argument (noop under postgresql)
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION net_manip.inet_ptodb
(
	p_ip_address			in inet,
	p_raise_exception_on_error	in integer 	default 0
)
RETURNS inet AS $$
BEGIN
	return(p_ip_address);
END;
$$ LANGUAGE plpgsql;
-- end of net_manip.inet_ptodb
-------------------------------------------------------------------

-------------------------------------------------------------------
-- returns its first argument (noop under postgresql)
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION net_manip.inet_dbtop
(
	p_ip_address			in inet
)
RETURNS inet AS $$
BEGIN
	return( p_ip_address );	 --  may want this to be host(inet)
END;
$$ LANGUAGE plpgsql;
-- end of net_manip.inet_dbtop
-------------------------------------------------------------------

CREATE OR REPLACE FUNCTION net_manip.inet_bits_to_mask
	(
	p_bits				in integer
	)
RETURNS inet AS $$
BEGIN
	IF p_bits > 32 OR p_bits < 0 THEN
		RAISE EXCEPTION 'Value for p_bits must be between 0 and 32';
	END IF;
		
	RETURN( netmask(cast('0.0.0.0/' || p_bits AS inet)) );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION net_manip.inet_mask_to_bits
	(
	p_netmask			in inet
	)
RETURNS integer AS $$
BEGIN
	IF family(p_netmask) = 6 THEN
		RAISE EXCEPTION 'Netmask is not supported for IPv6 addresses';
	END IF;
	RETURN (32-log(2, 4294967296 - net_manip.inet_dbton(p_netmask)))::integer;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION net_manip.inet_base
	(
	p_ip_address		in		inet,
	p_bits			in		integer
	)
RETURNS inet AS $$
DECLARE
	host inet;
BEGIN
	host = set_masklen(p_ip_address, p_bits);
	return network(host);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION net_manip.inet_is_private_yn
	(
	p_ip_address		  in		  inet
	)
RETURNS char AS $$
BEGIN
	IF (net_manip.inet_is_private(p_ip_address)) THEN
		RETURN 'Y';
	ELSE
		RETURN 'N';
	END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION net_manip.inet_is_private
	(
	p_ip_address		in		inet
	)
RETURNS boolean AS $$
BEGIN
	IF( family(p_ip_address) = 4) THEN
		IF ('192.168/16' >> p_ip_address) THEN
			RETURN(true);
		END IF;
		IF ('10/8' >> p_ip_address) THEN
			RETURN(true);
		END IF;
		IF ('172.16/12' >> p_ip_address) THEN
			RETURN(true);
		END IF;
	else
		IF ('FC00::/7' >> p_ip_address) THEN
			RETURN(true);
		END IF;
	END IF;

	RETURN(false);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE function net_manip.inet_inblock
	(
	p_network		in		inet,
	p_bits			in		integer,
	p_ipaddr		in		inet
	)
RETURNS char AS $$
BEGIN
	RETURN(
		CAST(host(p_network) || '/' || p_bits AS inet) >> p_ipaddr
	);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE function net_manip.inet_dbton
	(
	p_ipaddr		in		inet
	)
RETURNS bigint AS $$
BEGIN
	IF (family(p_ipaddr) = 4) THEN
		RETURN p_ipaddr - '0.0.0.0';
	ELSE
		RETURN p_ipaddr - '::0';
	END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE function net_manip.inet_ntodb
	(
	p_ipaddr		in		bigint
	)
RETURNS inet AS $$
BEGIN
	IF p_ipaddr > 4294967296 OR p_ipaddr < 16777216 THEN
		RETURN inet('::0') + p_ipaddr;
	ELSE
		RETURN inet('0.0.0.0') + p_ipaddr;
	END IF;
END;
$$ LANGUAGE plpgsql;

-- Copyright (c) 2012, AppNexus, Inc.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
-- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/*
 * $Id: person_manip.sql 193 2012-08-20 23:46:41Z kovert $
 */

drop schema if exists person_manip cascade;
create schema person_manip authorization jazzhands;

-------------------------------------------------------------------
-- returns the Id tag for CM
-------------------------------------------------------------------
CREATE OR REPLACE FUNCTION person_manip.id_tag()
RETURNS VARCHAR AS $$
BEGIN
	RETURN('<-- $Id: person_manip.sql 193 2012-08-20 23:46:41Z kovert $ -->');
END;
$$ LANGUAGE plpgsql;
-- end of procedure id_tag
-------------------------------------------------------------------

CREATE OR REPLACE FUNCTION person_manip.get_account_collection_id( department varchar, type varchar )
	RETURNS INTEGER AS $$
DECLARE
	_account_collection_id INTEGER;
BEGIN
	SELECT account_collection_id INTO _account_collection_id FROM account_collection WHERE account_collection_type= type
		AND account_collection_name= department;
	IF NOT FOUND THEN
		_account_collection_id = nextval('account_collection_account_collection_id_seq');
		INSERT INTO account_collection (account_collection_id, account_collection_type, account_collection_name)
			VALUES (_account_collection_id, type, department);
		--RAISE NOTICE 'Created new department % with account_collection_id %', department, _account_collection_id;
	END IF;
	RETURN _account_collection_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION person_manip.update_department( department varchar, _account_id integer, old_account_collection_id integer) 
	RETURNS INTEGER AS $$
DECLARE
	_account_collection_id INTEGER;
BEGIN
	_account_collection_id = person_manip.get_account_collection_id( department, 'department' ); 
	--RAISE NOTICE 'updating account_collection_account with id % for account %', _account_collection_id, _account_id; 
	UPDATE account_collection_account SET account_collection_id = _account_collection_id WHERE account_id = _account_id AND account_collection_id=old_account_collection_id;
	RETURN _account_collection_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION person_manip.add_person(
	first_name VARCHAR, 
	middle_name VARCHAR, 
	last_name VARCHAR,
	name_suffix VARCHAR, 
	gender VARCHAR(1), 
	preferred_last_name VARCHAR,
	preferred_first_name VARCHAR,
	birth_date DATE,
	_company_id INTEGER, 
	external_hr_id VARCHAR, 
	person_company_status VARCHAR, 
	is_exempt VARCHAR(1),
	employee_id INTEGER,
	hire_date DATE,
	termination_date DATE,
	person_company_relation VARCHAR,
	job_title VARCHAR,
	department VARCHAR, login VARCHAR,
	OUT person_id INTEGER,
	OUT _account_collection_id INTEGER,
	OUT account_id INTEGER)
 AS $$
DECLARE
	_account_realm_id INTEGER;
BEGIN
	person_id = nextval('person_person_id_seq');
	INSERT INTO person (person_id, first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date)
		VALUES (person_id, first_name, middle_name, last_name, name_suffix, gender, preferred_first_name, preferred_last_name, birth_date);
	INSERT INTO person_company
		(person_id,company_id,external_hr_id,person_company_status,is_exempt,employee_id,hire_date,termination_date,person_company_relation, position_title)
		VALUES
		(person_id, _company_id, external_hr_id, person_company_status, is_exempt, employee_id, hire_date, termination_date, person_company_relation, job_title);
	SELECT account_realm_id INTO _account_realm_id FROM account_realm_company WHERE company_id = _company_id;
	INSERT INTO person_account_realm_company ( person_id, company_id, account_realm_id) VALUES ( person_id, _company_id, _account_realm_id);
	account_id = nextval('account_account_id_seq');
	INSERT INTO account ( account_id, login, person_id, company_id, account_realm_id, account_status, account_role, account_type) 
		VALUES (account_id, login, person_id, _company_id, _account_realm_id, person_company_status, 'primary', 'person');
	IF department IS NULL THEN
		RETURN;
	END IF;
	_account_collection_id = person_manip.get_account_collection_id(department, 'department');
	INSERT INTO account_collection_account (account_collection_id, account_id) VALUES ( _account_collection_id, account_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION person_manip.add_account_non_person(_company_id integer, _account_status character varying, _login character varying, _description character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	_account_realm_id INTEGER;
	_person_id INTEGER;
	_account_id INTEGER;
BEGIN
	_person_id := 0;
	SELECT account_realm_id INTO _account_realm_id FROM account_realm_company WHERE company_id = _company_id;
	IF NOT FOUND THEN
		RAISE EXCEPTION 'Cannot find account_realm_id with company id %',_company_id;
	END IF;
	_account_id = nextval('public.account_account_id_seq');
	INSERT INTO account ( account_id, login, person_id, company_id, account_realm_id, account_status, description, account_role, account_type) 
		VALUES (_account_id, _login, _person_id, _company_id, _account_realm_id, _account_status, _description, 'primary', 'pseudouser');
	RETURN _account_id;
END;
$$;

CREATE OR REPLACE FUNCTION person_manip.get_unix_uid(account_type CHARACTER VARYING) RETURNS INTEGER AS $$
DECLARE new_id INTEGER;
BEGIN
        IF account_type = 'people' THEN
                SELECT 
                        coalesce(max(unix_uid),10199) INTO new_id 
                FROM
                        account_unix_info aui
                JOIN
                        account a 
                USING
                        (account_id)
                JOIN
                        person p 
                USING
                        (person_id)
                WHERE
                        p.person_id != 0;
		new_id = new_id + 1;
        ELSE
                SELECT
                        coalesce(min(unix_uid),10000) INTO new_id
                FROM
                        account_unix_info aui
                JOIN
                        account a
                USING
                        (account_id)
                JOIN
                        person p
                USING
                        (person_id)
                WHERE
                        p.person_id = 0 AND unix_uid >0;
		new_id = new_id - 1;
        END IF;
        RETURN new_id;
END;

$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Purge account from system.  This is called rarely and does not hit
-- a number of tables where account_id may appear.  The caller needs
-- to deal with those manually because they are not properties of the
-- account
CREATE OR REPLACE FUNCTION person_manip.purge_account(
		in_account_id	account.account_id%TYPE
) RETURNS void AS $$
BEGIN
	DELETE FROM account_assignd_cert where ACCOUNT_ID = in_account_id;
	DELETE FROM account_token where ACCOUNT_ID = in_account_id;
	DELETE FROM account_unix_info where ACCOUNT_ID = in_account_id;
	DELETE FROM klogin where ACCOUNT_ID = in_account_id;
	DELETE FROM property where ACCOUNT_ID = in_account_id;
	DELETE FROM account_password where ACCOUNT_ID = in_account_id;
	DELETE FROM unix_group where account_collection_id in 
		(select account_collection_id from account_collection where account_collection_name in
			(select login from account where account_id = in_account_id)
			and account_collection_type in ('unix-group')
		);
	DELETE FROM account_collection_account where ACCOUNT_ID = in_account_id;

	DELETE FROM account_collection where account_collection_name in 
		(select login from account where account_id = in_account_id)
		and account_collection_type in ('per-user', 'unix-group');

	DELETE FROM account where ACCOUNT_ID = in_account_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION person_manip.merge_accounts(
	merge_from_account_id	account.account_Id%TYPE,
	merge_to_account_id	account.account_Id%TYPE
) RETURNS INTEGER AS $$
DECLARE
	fpc		person_company%ROWTYPE;
	tpc		person_company%ROWTYPE;
BEGIN
	select	*
	  into	fpc
	  from	person_company
	 where	(person_id, company_id) in
		(select person_id, company_id 
		   from account where account_id = merge_from_account_id);

	select	*
	  into	tpc
	  from	person_company
	 where	(person_id, company_id) in
		(select person_id, company_id 
		   from account where account_id = merge_to_account_id);

	IF (fpc.company_id != tpc.company_id) THEN
		RAISE EXCEPTION 'Accounts are in different companies';
	END IF;

	IF (fpc.person_company_relation != tpc.person_company_relation) THEN
		RAISE EXCEPTION 'People have different relationships';
	END IF;

	IF(tpc.external_hr_id is NOT NULL) THEN
		RAISE EXCEPTION 'Destination account has an external HR ID';
	END IF;

	-- Switch the HR ID
	UPDATE PERSON_COMPANY
	  SET  EXTERNAL_HR_ID = NULL
	WHERE	PERSON_ID = fpc.person_id
	  AND	COMPANY_ID = fpc.company_id;

	UPDATE PERSON_COMPANY
	  SET  EXTERNAL_HR_ID = fpc.external_hr_id
	WHERE	PERSON_ID = tpc.person_id
	  AND	COMPANY_ID = tpc.company_id;

	-- move any account collections over that are
	-- not infrastructure ones, and the new person is
	-- not in
	UPDATE	account_collection_account
	   SET	ACCOUNT_ID = merge_to_account_id
	 WHERE	ACCOUNT_ID = merge_from_account_id
	  AND	ACCOUNT_COLLECTION_ID IN (
			SELECT ACCOUNT_COLLECTION_ID
			  FROM	ACCOUNT_COLLECTION
				INNER JOIN VAL_ACCOUNT_COLLECTION_TYPE
					USING (ACCOUNT_COLLECTION_TYPE)
			 WHERE	IS_INFRASTRUCTURE_TYPE = 'N'
		)
	  AND	account_collection_id not in (
			SELECT	account_collection_id
			  FROM	account_collection_account
			 WHERE	account_id = merge_to_account_id
	);

	-- Now begin removing the old account
	PERFORM person_manip.purge_account( merge_from_account_id );

	update person_contact set person_id = tpc.person_id where person_id = fpc.person_id;
	update person_image set person_id = tpc.person_id where person_id = fpc.person_id;
	update person_vehicle set person_id = tpc.person_id where person_id = fpc.person_id;
	update property set person_id = tpc.person_id where person_id = fpc.person_id;
	delete from person_account_realm_company where person_id = fpc.person_id AND company_id = fpc.company_id;
	delete from person_company where person_id = fpc.person_id AND company_id = fpc.company_id;
	-- if there are other relations that may exist, do not delete the person.
	BEGIN
		delete from person where person_id = fpc.person_id;
	EXCEPTION WHEN foreign_key_violation THEN
		NULL;
	END;
	return merge_to_account_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;



CREATE OR REPLACE FUNCTION validate_netblock() RETURNS TRIGGER AS $$
BEGIN
	/* note, the autonomous transaction stuff may make some of the stuff  
	 * we're trying to do here weird.
	 */
	 
	/*
	 * Force netmask_bits to be authoritative
	 */

	IF NEW.netmask_bits IS NULL THEN
		RAISE EXCEPTION 'Column netmask_bits may not be null'
			USING ERRCODE = 23502;
	ELSE
		NEW.ip_address = set_masklen(NEW.ip_address, NEW.netmask_bits);
	END IF;

	IF NEW.can_subnet = 'Y' AND NEW.is_single_address = 'Y' THEN
		RAISE EXCEPTION 'Single addresses may not be subnettable'
			USING ERRCODE = 22106;
	END IF;

	IF NEW.is_single_address = 'N' AND (NEW.ip_address != cidr(NEW.ip_address))
			THEN
		RAISE EXCEPTION
			'Non-network bits must be zero if is_single_address is set'
			USING ERRCODE = 22103;
	END IF;

	/*
	 * only allow multiple addresses to exist if it is a 1918-space 
	 * address.   (This may need to be revised for sites that do really
	 *  really really stupid things.  Perhaps a marker in the netblock 
	 * that indicates that its one of these blocks or  some such?  Or a
	 * separate table that says which blocks are ok.  (make the 
	 * mutating table stuff better?) 
	 */
/*
	IF NOT net_manip.inet_is_private(NEW.ip_address) THEN
*/
			PERFORM netblock_id 
			   FROM netblock 
			  WHERE ip_address = new.ip_address;
			IF (TG_OP = 'INSERT' AND FOUND) THEN 
				RAISE EXCEPTION 'Unique Constraint Violated on IP Address: %', 
					new.ip_address
					USING ERRCODE= 23505;
			END IF;
			IF (TG_OP = 'UPDATE') THEN
				IF (NEW.ip_address != OLD.ip_address AND FOUND) THEN
					RAISE EXCEPTION 
						'Unique Constraint Violated on IP Address: %', 
						new.ip_address
						USING ERRCODE = 23505;
				END IF;
			END IF;
/*
	END IF;
*/

	/*
	 * Parent validation is performed in the deferred after trigger
	 */

	 RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_validate_netblock ON netblock;
CREATE TRIGGER trigger_validate_netblock BEFORE INSERT OR UPDATE ON netblock
	FOR EACH ROW EXECUTE PROCEDURE validate_netblock();

CREATE OR REPLACE FUNCTION validate_netblock_parentage() RETURNS TRIGGER AS $$
DECLARE
	nbrec			record;
	nbid			netblock.netblock_id%type;
	ipaddr			inet;
	single_count		integer;
	nonsingle_count	integer;
	pip	    		netblock.ip_address%type;
BEGIN
	/*
	 * validate that this netblock is attached to its correct parent
	 */
	IF NEW.parent_netblock_id IS NULL THEN
		/*
		 * Validate that if a non-organizational netblock has a parent, unless
		 * it is the root of a hierarchy
		 */
		IF NEW.is_organizational='N' THEN
			nbid := netblock_utils.find_best_parent_id(NEW.ip_address, 
				masklen(NEW.ip_address));
			IF nbid IS NOT NULL THEN
				RAISE EXCEPTION 'Non-organizational netblock must have correct parent(%)',
					nbid USING ERRCODE = 22102;
			END IF;
		END IF;
	ELSE
	 	/*
		 * Reject a block that is self-referential
		 */
	 	IF NEW.parent_netblock_id = NEW.netblock_id THEN
			RAISE EXCEPTION 'Netblock may not have itself as a parent'
				USING ERRCODE = 22101;
		END IF;
		
		SELECT * INTO nbrec FROM netblock WHERE netblock_id = 
			NEW.parent_netblock_id;

		/*
		 * This shouldn't happen, but may because of deferred constraints
		 */
		IF NOT FOUND THEN
			RAISE EXCEPTION 'Parent netblock % does not exist',
			NEW.parent_netblock_id
			USING ERRCODE = 23503;
		END IF;

		IF nbrec.is_single_address = 'Y' THEN
			RAISE EXCEPTION 'Parent netblock may not be a single address'
			USING ERRCODE = 23504;
		END IF;

		IF NEW.is_organizational='Y' THEN
			/*
			 * organizational addresses may not have the best parent as
			 * a parent, but if they have a parent, it should validate
			 */

			IF NOT (NEW.ip_address << nbrec.ip_address OR
					cidr(NEW.ip_address) != nbrec.ip_address) THEN
				RAISE EXCEPTION 'Parent netblock is a valid parent'
					USING ERRCODE = 22102;
			END IF;
		ELSE
			nbid := netblock_utils.find_best_parent_id(NEW.ip_address, 
				masklen(NEW.ip_address));
			if (nbid IS NULL OR NEW.parent_netblock_id != nbid) THEN
				RAISE EXCEPTION 'Parent netblock is not the correct parent'
					USING ERRCODE = 22102;
			END IF;
		END IF;
		IF NEW.is_single_address = 'Y' AND 
				((family(NEW.ip_address) = 4 AND 
					masklen(NEW.ip_address) < 32) OR
				(family(NEW.ip_address) = 6 AND 
					masklen(NEW.ip_address) < 128))
				THEN 
			SELECT ip_address INTO ipaddr FROM netblock
				WHERE netblock_id = nbid;
			IF (masklen(NEW.ip_address) != masklen(ipaddr)) THEN
			RAISE EXCEPTION 'Parent netblock does not have same netmask for single address'
				USING ERRCODE = 22105;
			END IF;
		END IF;
		/*
		 * Validate that all children are is_single_address='Y' or
		 * all children are is_single_address='N'
		 */
		SELECT count(*) INTO single_count FROM netblock WHERE
			is_single_address='Y' and parent_netblock_id = 
			NEW.parent_netblock_id;
		SELECT count(*) INTO nonsingle_count FROM netblock WHERE
			is_single_address='N' and parent_netblock_id =
			NEW.parent_netblock_id;

		IF (single_count > 0 and nonsingle_count > 0) THEN
			RAISE EXCEPTION 'Netblock may not have direct children for both single and multiple addresses simultaneously'
				USING ERRCODE = 22107;
		END IF;
		/*
		 * Validate that none of the children of the parent netblock are
		 * children of this netblock (e.g. if inserting into the middle
		 * of the hierarchy)
		 */
		 PERFORM netblock_id FROM netblock WHERE 
		 	parent_netblock_id = NEW.parent_netblock_id AND
			netblock_id != NEW.netblock_id AND
		 	ip_address <<= NEW.ip_address;
		IF FOUND THEN
			RAISE EXCEPTION 'Other netblocks have children that should belong to this parent'
				USING ERRCODE = 22108;
		END IF;
	END IF;

	RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_validate_netblock_parentage ON netblock;
CREATE CONSTRAINT TRIGGER trigger_validate_netblock_parentage 
	AFTER INSERT OR UPDATE ON netblock DEFERRABLE FOR EACH ROW 
	EXECUTE PROCEDURE validate_netblock_parentage();



CREATE OR REPLACE FUNCTION validate_property() RETURNS TRIGGER AS $$
DECLARE
	tally			integer;
	v_prop			VAL_Property%ROWTYPE;
	v_proptype		VAL_Property_Type%ROWTYPE;
	v_account_collection	account_collection%ROWTYPE;
	v_netblock_collection	netblock_collection%ROWTYPE;
	v_num			integer;
	v_listvalue		Property.Property_Value%TYPE;
BEGIN

	-- Pull in the data from the property and property_type so we can
	-- figure out what is and is not valid

	BEGIN
		SELECT * INTO STRICT v_prop FROM VAL_Property WHERE
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type;

		SELECT * INTO STRICT v_proptype FROM VAL_Property_Type WHERE
			Property_Type = NEW.Property_Type;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION 
				'Property name or type does not exist'
				USING ERRCODE = 'foreign_key_violation';
			RETURN NULL;
	END;

	-- Check to see if the property itself is multivalue.  That is, if only
	-- one value can be set for this property for a specific property LHS

	IF (v_prop.is_multivalue = 'N') THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Name = NEW.Property_Name AND
			Property_Type = NEW.Property_Type AND
			((Company_Id IS NULL AND NEW.Company_Id IS NULL) OR
				(Company_Id = NEW.Company_Id)) AND
			((Device_Collection_Id IS NULL AND NEW.Device_Collection_Id IS NULL) OR
				(Device_Collection_Id = NEW.Device_Collection_Id)) AND
			((DNS_Domain_Id IS NULL AND NEW.DNS_Domain_Id IS NULL) OR
				(DNS_Domain_Id = NEW.DNS_Domain_Id)) AND
			((Operating_System_Id IS NULL AND NEW.Operating_System_Id IS NULL) OR
				(Operating_System_Id = NEW.Operating_System_Id)) AND
			((service_environment IS NULL AND NEW.service_environment IS NULL) OR
				(service_environment = NEW.service_environment)) AND
			((Site_Code IS NULL AND NEW.Site_Code IS NULL) OR
				(Site_Code = NEW.Site_Code)) AND
			((Account_Id IS NULL AND NEW.Account_Id IS NULL) OR
				(Account_Id = NEW.Account_Id)) AND
			((account_collection_Id IS NULL AND NEW.account_collection_Id IS NULL) OR
				(account_collection_Id = NEW.account_collection_Id)) AND
			((netblock_collection_Id IS NULL AND NEW.netblock_collection_Id IS NULL) OR
				(netblock_collection_Id = NEW.netblock_collection_Id)) AND
			((person_id IS NULL AND NEW.Person_id IS NULL) OR
				(Account_Id = NEW.person_id))
			;
			
		IF FOUND THEN
			RAISE EXCEPTION 
				'Property of type % already exists for given LHS and property is not multivalue',
				NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	END IF;

	-- Check to see if the property type is multivalue.  That is, if only
	-- one property and value can be set for any properties with this type
	-- for a specific property LHS

	IF (v_proptype.is_multivalue = 'N') THEN
		PERFORM 1 FROM Property WHERE
			Property_Id != NEW.Property_Id AND
			Property_Type = NEW.Property_Type AND
			((Company_Id IS NULL AND NEW.Company_Id IS NULL) OR
				(Company_Id = NEW.Company_Id)) AND
			((Device_Collection_Id IS NULL AND NEW.Device_Collection_Id IS NULL) OR
				(Device_Collection_Id = NEW.Device_Collection_Id)) AND
			((DNS_Domain_Id IS NULL AND NEW.DNS_Domain_Id IS NULL) OR
				(DNS_Domain_Id = NEW.DNS_Domain_Id)) AND
			((Operating_System_Id IS NULL AND NEW.Operating_System_Id IS NULL) OR
				(Operating_System_Id = NEW.Operating_System_Id)) AND
			((service_environment IS NULL AND NEW.service_environment IS NULL) OR
				(service_environment = NEW.service_environment)) AND
			((Site_Code IS NULL AND NEW.Site_Code IS NULL) OR
				(Site_Code = NEW.Site_Code)) AND
			((Person_id IS NULL AND NEW.Person_id IS NULL) OR
				(Person_Id = NEW.Person_Id)) AND
			((Account_Id IS NULL AND NEW.Account_Id IS NULL) OR
				(Account_Id = NEW.Account_Id)) AND
			((account_collection_Id IS NULL AND NEW.account_collection_Id IS NULL) OR
				(account_collection_Id = NEW.account_collection_Id)) AND
			((netblock_collection_Id IS NULL AND NEW.netblock_collection_Id IS NULL) OR
				(netblock_collection_Id = NEW.netblock_collection_Id));

		IF FOUND THEN
			RAISE EXCEPTION 
				'Property % of type % already exists for given LHS and property type is not multivalue',
				NEW.Property_Name, NEW.Property_Type
				USING ERRCODE = 'unique_violation';
			RETURN NULL;
		END IF;
	END IF;

	-- now validate the property_value columns.
	tally := 0;

	--
	-- first determine if the property_value is set properly.
	--

	-- iterate over each of fk PROPERTY_VALUE columns and if a valid
	-- value is set, increment tally, otherwise raise an exception.
	IF NEW.Property_Value_Company_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'company_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Company_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Password_Type IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'password_type' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Password_Type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Token_Col_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'token_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Token_Collection_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_SW_Package_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'sw_package_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be SW_Package_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Account_Coll_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'account_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be account_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_nblk_Coll_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'netblock_collection_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be nblk_collection_id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Timestamp IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'timestamp' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Timestamp' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_DNS_Domain_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'dns_domain_id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be DNS_Domain_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;
	IF NEW.Property_Value_Person_Id IS NOT NULL THEN
		IF v_prop.Property_Data_Type = 'Person_Id' THEN
			tally := tally + 1;
		ELSE
			RAISE 'Property value may not be Person_Id' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	-- at this point, tally will be set to 1 if one of the other property
	-- values is set to something valid.  Now, check the various options for
	-- PROPERTY_VALUE itself.  If a new type is added to the val table, this
	-- trigger needs to be updated or it will be considered invalid.  If a
	-- new PROPERTY_VALUE_* column is added, then it will pass through without
	-- trigger modification.  This should be considered bad.

	IF NEW.Property_Value IS NOT NULL THEN
		tally := tally + 1;
		IF v_prop.Property_Data_Type = 'boolean' THEN
			IF NEW.Property_Value != 'Y' AND NEW.Property_Value != 'N' THEN
				RAISE 'Boolean Property_Value must be Y or N' USING
					ERRCODE = 'invalid_parameter_value';
			END IF;
		ELSIF v_prop.Property_Data_Type = 'number' THEN
			BEGIN
				v_num := to_number(NEW.property_value, '9');
			EXCEPTION
				WHEN OTHERS THEN
					RAISE 'Property_Value must be numeric' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type = 'list' THEN
			BEGIN
				SELECT Valid_Property_Value INTO STRICT v_listvalue FROM 
					VAL_Property_Value WHERE
						Property_Name = NEW.Property_Name AND
						Property_Type = NEW.Property_Type AND
						Valid_Property_Value = NEW.Property_Value;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					RAISE 'Property_Value must be a valid value' USING
						ERRCODE = 'invalid_parameter_value';
			END;
		ELSIF v_prop.Property_Data_Type != 'string' THEN
			RAISE 'Property_Data_Type is not a known type' USING
				ERRCODE = 'invalid_parameter_value';
		END IF;
	END IF;

	IF v_prop.Property_Data_Type != 'none' AND tally = 0 THEN
		RAISE 'One of the PROPERTY_VALUE fields must be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	IF tally > 1 THEN
		RAISE 'Only one of the PROPERTY_VALUE fields may be set.' USING
			ERRCODE = 'invalid_parameter_value';
	END IF;

	-- If the RHS contains a account_collection_ID, check to see if it must be a
	-- specific type (e.g. per-user), and verify that if so
	IF NEW.Property_Value_Account_Coll_Id IS NOT NULL THEN
		IF v_prop.prop_val_acct_coll_type_rstrct IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_account_collection FROM account_collection WHERE
					account_collection_Id = NEW.Property_Value_Account_Coll_Id;
				IF v_account_collection.account_collection_Type != v_prop.prop_val_acct_coll_type_rstrct
				THEN
					RAISE 'Property_Value_Account_Coll_Id must be of type %',
					v_prop.prop_val_acct_coll_type_rstrct
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- If the RHS contains a netblock_collection_ID, check to see if it must be a
	-- specific type and verify that if so
	IF NEW.Property_Value_nblk_Coll_Id IS NOT NULL THEN
		IF v_prop.prop_val_acct_coll_type_rstrct IS NOT NULL THEN
			BEGIN
				SELECT * INTO STRICT v_netblock_collection FROM netblock_collection WHERE
					netblock_collection_Id = NEW.Property_Value_nblk_Coll_Id;
				IF v_netblock_collection.netblock_collection_Type != v_prop.prop_val_acct_coll_type_rstrct
				THEN
					RAISE 'Property_Value_nblk_Coll_Id must be of type %',
					v_prop.prop_val_acct_coll_type_rstrct
					USING ERRCODE = 'invalid_parameter_value';
				END IF;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- let the database deal with the fk exception later
					NULL;
			END;
		END IF;
	END IF;

	-- At this point, the RHS has been checked, so now we verify data
	-- set on the LHS

	-- There needs to be a stanza here for every "lhs".  If a new column is
	-- added to the property table, a new stanza needs to be added here,
	-- otherwise it will not be validated.  This should be considered bad.

	IF v_prop.Permit_Company_Id = 'REQUIRED' THEN
			IF NEW.Company_Id IS NULL THEN
				RAISE 'Company_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Company_Id = 'PROHIBITED' THEN
			IF NEW.Company_Id IS NOT NULL THEN
				RAISE 'Company_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Device_Collection_Id = 'REQUIRED' THEN
			IF NEW.Device_Collection_Id IS NULL THEN
				RAISE 'Device_Collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;

	ELSIF v_prop.Permit_Device_Collection_Id = 'PROHIBITED' THEN
			IF NEW.Device_Collection_Id IS NOT NULL THEN
				RAISE 'Device_Collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_DNS_Domain_Id = 'REQUIRED' THEN
			IF NEW.DNS_Domain_Id IS NULL THEN
				RAISE 'DNS_Domain_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_DNS_Domain_Id = 'PROHIBITED' THEN
			IF NEW.DNS_Domain_Id IS NOT NULL THEN
				RAISE 'DNS_Domain_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_service_environment = 'REQUIRED' THEN
			IF NEW.service_environment IS NULL THEN
				RAISE 'service_environment is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_service_environment = 'PROHIBITED' THEN
			IF NEW.service_environment IS NOT NULL THEN
				RAISE 'service_environment is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Operating_System_Id = 'REQUIRED' THEN
			IF NEW.Operating_System_Id IS NULL THEN
				RAISE 'Operating_System_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Operating_System_Id = 'PROHIBITED' THEN
			IF NEW.Operating_System_Id IS NOT NULL THEN
				RAISE 'Operating_System_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Site_Code = 'REQUIRED' THEN
			IF NEW.Site_Code IS NULL THEN
				RAISE 'Site_Code is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Site_Code = 'PROHIBITED' THEN
			IF NEW.Site_Code IS NOT NULL THEN
				RAISE 'Site_Code is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Account_Id = 'REQUIRED' THEN
			IF NEW.Account_Id IS NULL THEN
				RAISE 'Account_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Account_Id = 'PROHIBITED' THEN
			IF NEW.Account_Id IS NOT NULL THEN
				RAISE 'Account_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_account_collection_Id = 'REQUIRED' THEN
			IF NEW.account_collection_Id IS NULL THEN
				RAISE 'account_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_account_collection_Id = 'PROHIBITED' THEN
			IF NEW.account_collection_Id IS NOT NULL THEN
				RAISE 'account_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_netblock_collection_Id = 'REQUIRED' THEN
			IF NEW.netblock_collection_Id IS NULL THEN
				RAISE 'netblock_collection_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_netblock_collection_Id = 'PROHIBITED' THEN
			IF NEW.netblock_collection_Id IS NOT NULL THEN
				RAISE 'netblock_collection_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;

	IF v_prop.Permit_Person_Id = 'REQUIRED' THEN
			IF NEW.Person_Id IS NULL THEN
				RAISE 'Person_Id is required.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	ELSIF v_prop.Permit_Person_Id = 'PROHIBITED' THEN
			IF NEW.Person_Id IS NOT NULL THEN
				RAISE 'Person_Id is prohibited.'
					USING ERRCODE = 'invalid_parameter_value';
			END IF;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


/*
 * enforces is_multivalue in val_person_image_usage
 *
 * no consideration for oracle, but probably not necessary
 */
CREATE OR REPLACE FUNCTION fix_person_image_oid_ownership()
RETURNS TRIGGER AS $$
DECLARE
   b	integer;
   str	varchar;
BEGIN
	b := NEW.image_blob; 
	BEGIN
		str := 'GRANT SELECT on LARGE OBJECT ' || b || ' to picture_image_ro';
		EXECUTE str;
		str :=  'GRANT UPDATE on LARGE OBJECT ' || b || ' to picture_image_rw';
		EXECUTE str;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'Unable to grant on %', b;
	END;

	BEGIN
		EXECUTE 'ALTER large object ' || b || ' owner to jazzhands';
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'Unable to adjust ownership of %', b;
	END;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;


DROP TRIGGER IF EXISTS trigger_fix_person_image_oid_ownership ON person_image;
CREATE TRIGGER trigger_fix_person_image_oid_ownership 
BEFORE INSERT OR UPDATE OR DELETE
    ON person_image
    FOR EACH ROW 
    EXECUTE PROCEDURE fix_person_image_oid_ownership();


CREATE OR REPLACE FUNCTION create_new_unix_account() 
RETURNS TRIGGER AS $$
DECLARE
	unix_id INTEGER;
	_account_collection_id integer;
BEGIN
	IF NEW.person_id != 0 THEN
		unix_id = person_manip.get_unix_uid('people');
		_account_collection_id = person_manip.get_account_collection_id(NEW.login, 'unix-group');
		INSERT INTO unix_group (account_collection_id, unix_gid) VALUES (_account_collection_id, unix_id);
		INSERT INTO account_collection_account (account_id,account_collection_id) VALUES (NEW.account_id, _account_collection_id);
		INSERT INTO account_unix_info (unix_uid,unix_group_acct_collection_id,account_id,shell) VALUES (unix_id, _account_collection_id, NEW.account_id,'/bin/bash');
	END IF;
	RETURN NEW;	
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

DROP TRIGGER IF EXISTS trigger_create_new_unix_account ON account;
CREATE TRIGGER trigger_create_new_unix_account 
BEFORE INSERT 
    ON account
    FOR EACH ROW 
    EXECUTE PROCEDURE create_new_unix_account();

-- Copyright (c) 2005-2010, Vonage Holdings Corp.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
-- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--
-- $Id: create_v_device_coll_hier_detail.sql 216 2012-10-13 15:54:29Z kovert $
--
create or replace view v_device_coll_hier_detail as 
WITH RECURSIVE var_recurse (
	root_device_collection_id,
	device_collection_id,
	parent_device_collection_id,
	device_collection_level
) as (
	SELECT	device_collection_id	as root_device_collection_id,
		device_collection_id	as device_collection_id,
		device_collection_id	as parent_device_collection_id,
		0			as device_collection_level
	FROM	device_collection
UNION  ALL
	SELECT	x.root_device_collection_id	as root_device_collection_id,
		dch.device_collection_id,
		dch.parent_device_collection_id,
		x.device_collection_level + 1 as device_collection_level
	 FROM	var_recurse x
		inner join device_collection_hier dch
			on x.parent_device_collection_id = 
				dch.device_collection_id
) SELECT
	root_device_collection_id	as device_collection_id,
	parent_device_collection_id	as parent_device_collection_id,
	device_collection_level		as device_collection_level
FROM	var_recurse;

-- Copyright (c) 2005-2010, Vonage Holdings Corp.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
-- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--
-- $Id: create_v_dev_col_user_prop_expanded.sql 216 2012-10-13 15:54:29Z kovert $
--

-- This view maps users to device collections and lists properties
-- assigned to the users in order of their priorities.

CREATE OR REPLACE VIEW v_dev_col_user_prop_expanded AS
SELECT dchd.device_collection_id,
  s.account_id, s.login, s.account_status,
  upo.property_type property_type,
  upo.property_name property_name, 
  upo.property_value,
   CASE WHEN upn.is_multivalue = 'N' THEN 0
	ELSE 1 END is_multievalue,
  CASE WHEN pdt.property_data_type = 'boolean' THEN 1 ELSE 0 END is_boolean
FROM v_acct_coll_acct_expanded_detail uued
JOIN Account_Collection u ON uued.Account_Collection_id = u.Account_Collection_id
JOIN v_property upo ON upo.Account_Collection_id = u.Account_Collection_id
 AND upo.property_type in (
  'CCAForceCreation', 'CCARight', 'ConsoleACL', 'RADIUS', 'TokenMgmt',
  'UnixPasswdFileValue', 'UserMgmt', 'cca', 'feed-attributes',
  'proteus-tm', 'wwwgroup')
JOIN val_property upn
  ON upo.property_name = upn.property_name
 AND upo.property_type = upn.property_type
JOIN val_property_data_type pdt
  ON upn.property_data_type = pdt.property_data_type
LEFT JOIN v_device_coll_hier_detail dchd
  ON (dchd.parent_device_collection_id = upo.device_collection_id)
JOIN account s ON uued.account_id = s.account_id
ORDER BY device_collection_level,
   CASE WHEN u.Account_Collection_type = 'per-user' THEN 0
   	WHEN u.Account_Collection_type = 'property' THEN 1
   	WHEN u.Account_Collection_type = 'systems' THEN 2
	ELSE 3 END,
  CASE WHEN uued.assign_method = 'Account_CollectionAssignedToPerson' THEN 0
  	WHEN uued.assign_method = 'Account_CollectionAssignedToDept' THEN 1
  	WHEN uued.assign_method = 
	'ParentAccount_CollectionOfAccount_CollectionAssignedToPerson' THEN 2
  	WHEN uued.assign_method = 
	'ParentAccount_CollectionOfAccount_CollectionAssignedToDept' THEN 2
  	WHEN uued.assign_method = 
	'Account_CollectionAssignedToParentDept' THEN 3
  	WHEN uued.assign_method = 
	'ParentAccount_CollectionOfAccount_CollectionAssignedToParentDep' 
			THEN 3
        ELSE 6 END,
  uued.dept_level, uued.acct_coll_level, dchd.device_collection_id, 
  u.Account_Collection_id;


-- Copyright (c) 2005-2010, Vonage Holdings Corp.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in the
--       documentation and/or other materials provided with the distribution.
--
-- THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
-- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--
--
--
-- $Id: create_v_netblock_hier.sql 88 2011-11-07 16:42:16Z kovert $
--

-- was originally in netblock/index.pl from stab.  It originally had
-- 	connect by prior nb.netblock_id = parent_netblock_id
-- 	start with nb.parent_netblock_id = ?
-- 	order siblings by ip_address, netmask_bits
-- and this makes the root selection by including root_netblock_id.
-- This may break down the "everything can be represented by a view" because
-- the recursive table takes too long to build.

-- the postgresql query would have the restriction in the non recursive part
-- of the with query


CREATE OR REPLACE VIEW v_netblock_hier AS
WITH RECURSIVE var_recurse (
	netblock_level,
	root_netblock_id,
	ip,
	netblock_id,
	ip_address,
	netmask_bits,
	netblock_status,
	IS_SINGLE_ADDRESS,
	IS_IPV4_ADDRESS,
	description,
	parent_netblock_id,
	site_code
) as  (
	select  0			as netblock_level,
		nb.netblock_id		as root_netblock_id,
		net_manip.inet_dbtop(nb.ip_address) as ip,
		nb.netblock_id,
		nb.ip_address,
		nb.netmask_bits,
		nb.netblock_status,
		nb.IS_SINGLE_ADDRESS,
		nb.IS_IPV4_ADDRESS,
		nb.description,
		nb.parent_netblock_id,
		snb.site_code
	  from  netblock nb
		left join site_netblock snb
			on snb.netblock_id = nb.netblock_id
	where   nb.IS_SINGLE_ADDRESS = 'N'
UNION ALL
	SELECT	x.netblock_level +1	as netblock_level,
		x.root_netblock_id	as root_netblock_id,
		net_manip.inet_dbtop(nb.ip_address) as ip,
		nb.netblock_id,
		nb.ip_address,
		nb.netmask_bits,
		nb.netblock_status,
		nb.IS_SINGLE_ADDRESS,
		nb.IS_IPV4_ADDRESS,
		nb.description,
		nb.parent_netblock_id,
		snb.site_code
	  from  var_recurse x
	  	inner join netblock nb
			on x.netblock_id = nb.parent_netblock_id
		left join site_netblock snb
			on snb.netblock_id = nb.netblock_id
	where   nb.IS_SINGLE_ADDRESS = 'N'
) SELECT * from var_recurse;
;

ALTER SEQUENCE ssh_key_ssh_key_id_seq OWNED BY ssh_key.ssh_key_id;
ALTER SEQUENCE physical_address_physical_address_id_seq 
	OWNED BY physical_address.physical_address_id;
ALTER SEQUENCE person_location_person_location_id_seq 
	OWNED BY person_location.person_location_id;
