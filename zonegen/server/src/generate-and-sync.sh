#!/bin/sh
#
# Copyright (c) 2013-2022, Todd M. Kover
# All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Copyright (c) 2005-2010, Vonage Holdings Corp.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#
# $Id$
#

#
#}The arguments passed to this are passed directly to generate-zones and not
# parsed, which can lead to some assmptions and confusions.  Yes, this is
# lame.
#

PATH=usr/local/bin:/usr/local/sbin:/usr/vendor/bin:/usr/kerberos/bin:/usr/bin:/bin
export PATH

#
# This entire script wants to be folded into generate-zones.pl, probably with
# all the meat of zone regeneration in its own module or something.
#

#
# Defaults
#

# zonegen is hardcoded to write to $ZG_ROOT/auto-gen, and the -o/outdir
# flag can be used in conjunction with overriding this but "auto-gen" needs
# to be at the end of the path.

ZG_ROOT=/var/lib/zonegen
PERSERVER_HOSTFILE=/etc/jazzhands/zonegen-perserver.conf
LISTGEN=/usr/libxec/jazzhands/zonegen/generate-list
DST_ROOT=/var/named/chroot/auto-gen
RSYNC_RSH=/usr/libexec/jazzhands/zonegen/ssh-wrap
STATS_SCRIPT=/usr/libexec/jazzhands/zonegen/process-stats

GENERATE_ZONES=/usr/libexec/jazzhands/zonegen/generate-zones

# Development overrides
#-	ZG_ROOT=/tmp/zg
#-	GENERATE_ZONES=`pwd`/generate-zones.pl
#-	STATS_SCRIPT=/tmp/stats-script
#-	PATH=/opt/pkg/bin:/opt/pkg/sbin:$PATH

LOGGER_TAG="dns-zonegen"
LOGGER_PRIORITY="daemon.info"

LOCKFILE=${ZG_ROOT}/run/zonegen.lock
STATSFILEN=${ZG_ROOT}/run/zonegen.stats.$$

export RSYNC_RSH
if [ ! -x ${RSYNC_RSH} ] ; then
	RSYNC_RSH="ssh"
fi

#
# override defaults
#
[ -r /etc/jazzhands/zonegen.conf ] && . /etc/jazzhands/zonegen.conf

if [ ! -r ${ZG_ROOT} ] ; then
	mkdir -p ${ZG_ROOT}
	mkdir -p ${ZG_ROOT}/run
	mkdir -p ${ZG_ROOT}/auto-gen
	mkdir -p ${ZG_ROOT}/auto-gen/perserver
fi

# redirect debugging to /dev/null unless this is a tty
exec 3>/dev/null
tty -s
if [ $? = 0 ] ; then
	exec 3>&2
fi

cleanup() {
	echo 1>&2 cleaning up lockfile after signal
	rm -f $LOCKFILE
	exit 1
}

dorsync() {
	host=$1
	zoneroot=$2

	{
		rsync </dev/null -l -rpt --delete-after $zoneroot/zones $zoneroot/etc ${host}:$DST_ROOT
	} & # submitting this job into background
}

doingest() {
	host=$1
	zoneroot=$2

	cat $zoneroot/etc/zones-changed | $RSYNC_RSH >/dev/null $host /usr/bin/timeout 120 /usr/libexec/jazzhands/zonegen/ingest-zonegen-changes
}

trap cleanup HUP INT TERM

tty >/dev/null 2>&1
#
# if we're not a tty, do away with output
#
if [ $? = 1 ] ; then
	exec >/dev/null
	exec 2>/dev/null
fi

list=`find 2>/dev/null $LOCKFILE -mmin +180`
if [ ! -z "$list" ] ; then
	echo 1>&3 removing lockfile $LOCKFILE as three hours has past.
	rm -f $LOCKFILE
fi

umask 022

lockingon=no
if [ -z "$*" ] ; then
	if [ -r $LOCKFILE ] ; then
		echo 1>&2 Locked, Skipping.
		exit 0
	fi
	echo Locking
	lockingon=yes
	touch $LOCKFILE
fi

# depends on what generate-zones does, so this can not be changed.
SRC_ROOT=${ZG_ROOT}/auto-gen

KRB5CCNAME=/tmp/krb5cc_zonegen_$$_do_zonegen
export KRB5CCNAME

if [ -x  "$GENERATE_ZONES" ] ; then
	echo 1>&3  "Generating Zones (This may take a while)..."
	"$GENERATE_ZONES" --stats-filename="$STATSFILEN" "$@" >&3
	ec=$?
	if [ $ec != 0 ] ; then
		rm -f $LOCKFILE
		exit $ec
	fi

	#
	# if the list of hosts to rsync to was generated by zonegen, use it
	#
	if [ -f ${ZG_ROOT}/auto-gen/rsynchostlist.txt ] ; then
		DSTFILES=${ZG_ROOT}/auto-gen/rsynchostlist.txt
	elif [ -r "$PERSERVER_HOSTFILE" ] ; then
		DSTFILES=$PERSERVER_HOSTFILE
	fi

	#
	# prune temporary files not from today, since presumably they have been
	# cleaned up already.
	#
	find $ZG_ROOT/auto-gen/zones -name '*.tmp.[0-9]*' -mmin +1440 -print0 |xargs -0 rm -f

	if [ -f /etc/krb5.keytab.zonegen ] ; then
		kinit -k -t /etc/krb5.keytab.zonegen zonegen
	fi
	beforesync=`date +%s`
	for hostfile in $DSTFILES ; do
		if [ -r "$hostfile" ] ; then
			echo 1>&3 Processing file $hostfile
			sed -e 's/#.*//' $hostfile |
			while read ns servers ; do
				if [ "$servers" = "" ] ; then
					servers="$ns"
					ns=""
				fi
				servers=`echo $servers | sed 's/,/ /'`
				for sync in "dorsync" "doingest"; do
					for host in $servers ; do
						if [ x"$host" != "x" ] ;then
							if [ "$ns" = "" ] ; then
								echo 1>&3 "($sync) Rsyncing to $host ..."
								$sync $host "$SRC_ROOT"
							else
								echo 1>&3 "($sync) Rsyncing to $host (in $ns) ..."
								$sync $host "$SRC_ROOT/perserver/$ns"
							fi
						fi
					done
					wait # wait for background jobs to finish
				done
			done
		fi
	done
	aftersync=`date +%s`
fi

#
# the rsynctime is calculated based on the above.  This is slightly fragile
# when things do not run/are not set, but that is for another day.
#

if [ -r "$STATSFILEN" ] ; then
	start=`jq -r < $STATSFILEN .start_time`
	if [ x"$start" != "x" ] ; then
		# add rsync time to the end fo the stats
		rsynctime=`expr $aftersync - $beforesync`
		fields=`jq < $STATSFILEN '.events |= . + [{"rsync": '$rsynctime'}]' | jq -j -r '.events[] | to_entries | .[] | "\(.key):\(.value); "'`
		logger -i -t "$LOGGER_TAG" -p "$LOGGER_PRIORITY" "Start: $start, Stats: $fields"
		jq -r < $STATSFILEN \
		'.generation_time  | to_entries | .[] | "\(.key): \(.value)"' \
			| while read line; do
				logger -i -t "$LOGGER_TAG" -p "$LOGGER_PRIORITY" "generation time: $line"
			done
	fi

	# XXX - need to capture stats about how long it took to rsync
	# maybe also break rsync up into parallel and rndcs become serial

fi

if [ -x "$STATS_SCRIPT" ] ; then
	jq < $STATSFILEN '.events |= . + [{"rsync": '$rsynctime'}]' |
		jq -j -r '.events[] | to_entries | .[] | "\(.key):\(.value); "' |
		$STATS_SCRIPT
fi
rm -f "$STATSFILEN"

if [ "$lockingon" = "yes" ] ; then
	echo 1>&3 Unlocking
	rm -f $LOCKFILE
fi

kdestroy >/dev/null 2>&1

exit 0
