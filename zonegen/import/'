#!/usr/bin/env perl
#
# Copyright (c) 2013, Todd M. Kover
# All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# $Id$
#


# does an axfr of a zone and the zone into jazzhands

use warnings;
use strict;
use Net::DNS;
use JazzHands::DBI;
use Data::Dumper;
use JazzHands::Common qw(:all);
use Carp;

exit do_zone_load();

sub get_inaddr {
	my $ip = shift(@_);

	if($ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {
		my @ip = reverse ($1,$2,$3,$4);
		my $inaddr = join(".", @ip). ".in-addr.arpa";
		my $res = new Net::DNS::Resolver;
		my $a = $res->query($inaddr, 'PTR');
		# return the first one.  If there is more than one,
		# we will consider that broken setup.  Perhaps
		# a warning is in order here.  XXX
		return undef if(!$a);
		foreach my $rr (grep {$_->type eq 'PTR'} $a->answer) {
			return $rr->ptrdname;
		}
	} else {
		die "Unable to deal with ipv6 ptr record";
	}

}

sub by_name {
	if($a->name =~ /^\d+$/ && $b->name =~ /^\d+$/) {
		return($a->name <=> $b->name);
	} else {
		return($a->name cmp $b->name);
	}
}

#
# takes a nameserver and a zone, gets the SOA record for that zone and
# makes sure the database matches for all the SOA vaules
#
sub freshen_zone {
	my($c, $ns, $zone) = @_;

	my $res = new Net::DNS::Resolver;
	$res->nameservers( $ns );

	my $answer = $res->query($zone, 'SOA') || return undef; # XXX

	my $domid;
	foreach my $rr (grep {$_->type eq 'SOA'} $answer->answer) {
		next if($rr->name ne $zone);
		my @errs;	
		my $rows = $c->DBFetch(
			table => 'dns_domain',
			match => [
				{
					key => 'soa_name',
					value => $zone,
				}
			],
			errors => \@errs
		);

		my $old = $rows->[0];


		$domid = ($old)?$old->{_dbx('dns_domain_id')}:undef;
		# should only be one SOA record, but just in case...
		my $new = {
			dns_domain_id	=> $domid,
			soa_name	=> $zone,
			soa_class	=> $rr->class,
			soa_ttl		=> $rr->ttl,
			soa_serial	=> $rr->serial,
			soa_refresh	=> $rr->refresh,
			soa_retry	=> $rr->retry,
			soa_expire	=> $rr->expire,
			soa_minimum	=> $rr->minimum,
			soa_mname	=> $rr->mname,
			soa_rname	=> $rr->rname,
		};
		# XXX needs to be fixed!
		if($new->{soa_serial} > 2147483647) {
			$new->{soa_serial} = 2147483646;
		};
		if($old) {
			my $diff = $c->hash_table_diff($old, $new);
			if(scalar %$diff) {
				$c->DBUpdate(
					table => 'dns_domain',
					dbkey => 'dns_domain_id',
					keyval => $domid,
					hash => $diff,
					errs => \@errs,
				) || die join(" ", @errs);
			}
		} else {
			delete($new->{dns_domain_id});
			$new->{should_generate} = 'N';
			$new->{dns_domain_type} = 'service';	# XXX
			JazzHands::GenericDB::DBInsert(undef,
				table => 'dns_domain',
				hash => $new,
				errrs => \@errs,
			) || die join(" ", @errs);
		}
	}

	$domid;
}

sub build_match_entry {
	my $in = shift @_;

	my $match;
	foreach my $k (sort keys %$in) {
		my $x = {
			'key' => $k,
			'value' => $in->{$k},
		};
		push(@{$match}, $x);
	}
	$match;
}

sub refresh_dns_record {
	my $opt = _options(@_);

	$name =~ s/

	my $c = $opt->{handle};
	my $name = $opt->{name};
	my $address = $opt->{address};
	my $value = $opt->{value};
	my $priority = $opt->{priority};
	my $srv_service = $opt->{srv_service};
	my $srv_protocol = $opt->{srv_protocol};
	my $srv_weight = $opt->{srv_weight};
	my $srv_port = $opt->{srv_port};
	my $genptr = $opt->{genptr};

	my $nb;
	my @errs;	
	if(defined($address)) {
		my $rows = $c->DBFetch(
			table => 'netblock',
			match => [
				{
					key => 'is_single_address',
					value => 'Y',
				},
				{
					key => 'netblock_type',
					value => 'default',
				},
				{
					key => 'ip_universe_id',
					value => '0',
				},
				{
					key => 'ip_address',
					value => $address,
				},
			],
			errors => \@errs
		);
		$nb = $rows->[0];
	}

	my $match = build_match_entry({
			dns_name => $name,
			dns_value => $value,
			netblock_id => ($nb)?$nb->{netblock_id}:undef,
	});
	warn Dumper($match);
	my $rows = $c->DBFetch(
		table => 'dns_record',
		match => $match,
		errors => \@errs,
	) || die join(" ", @errs);

	my $dnsrec = $rows->[0];

	if($dnsrec) {
		# Find if there is a dns record associated with this record

		warn "\tDNSREC: processing $name // $address // $genptr", Dumper($dnsrec);
		warn "\t\t++++   ++++  address: ", Dumper($nb) if($nb);
	}
}

sub process_zone {
	my($c, $ns, $xferzone) = @_;

	my $domid = freshen_zone($c, $ns, $xferzone);

	my $res = new Net::DNS::Resolver;
	$res->nameservers( $ns );

	my @zone = $res->axfr($xferzone);
	if($#zone == -1) {
		die "Unable to AXFR zone from authoritative DNS server $ns";
	}

	#
	# XXX - First go through the zone and find things that are not there that should be
	my $numrec = 0;
	foreach my $rr (sort by_name @zone) {
		my $name = $rr->name;
		$numrec++;
		warn "processing record of type ", $rr->type, "\n";
		if($rr->type eq 'PTR') {
			$rr->name =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)\./;
			my @addr = ($1,$2,$3,$4);
			if(!$addr[0]) {
				warn "Weird, unverified PTR record: ", $rr->name;
			} else {
				my $addr = join(".", reverse(@addr));
				warn "consider PTR ", $rr->ptrdname;
				# check_addr($c, $rr->ptrdname, $addr, $rr->type);
			}
		} elsif($rr->type eq 'A') {
			warn "consider ", $rr->name, " ", $rr->address, "\n";
			my $ptr = get_inaddr($rr->address);
			refresh_dns_record(
				handle => $c,
				name => $rr->name,
				address => $rr->address,
				genptr => (defined($ptr) && $ptr eq $rr->name)?'Y':'N',
				domain => $xferzone,
				domain_id => $domid,
			);
			# $msg .= check_addr($c, $rr->name, $rr->address, $rr->type);
			# $msg .= check_name($c, $rr->name, $rr->address, $rr->type, $zone);
		} elsif($rr->type eq 'MX') {
			warn "MX: consider ", join(" // ", $rr->name, $rr->preference, $rr->exchange);
			# $msg .= check_mx($c, $rr->name, $rr->preference, $rr->exchange, $zone);
		} elsif($rr->type eq 'CNAME') {
			# $msg .= check_cname($c, $rr->name, $rr->cname, $zone);
		} elsif($rr->type eq 'CNAME') {
			# $msg .= check_cname($c, $rr->name, $rr->cname, $zone);
		} elsif($rr->type eq 'SRV') {
			# $msg .= check_srv($c, $rr, $zone);
		} elsif($rr->type eq 'TXT') {
		 	#my @list = $rr->char_str_list;
			# $msg .= check_txt($c, $rr->name, \@list, $zone);
		} elsif($rr->type eq 'NS') {
			#$msg .= check_ns($stab, $rr->name, $rr->nsdname, $zone);
		} elsif($rr->type eq 'SOA') {
			next;
		} else {
			warn "Unable to process record for ", $rr->name, " -- ", $rr->type, "\n";
		}
		if($name eq $xferzone) {
			die "found a matching record";
		}
	}

	#
	# XXX - now go through the zone and find things that are there that should not be.
	#

	warn "Processed $numrec records";
}

sub check_for_zone {
	my ($stab, $zone) = @_;

	my $sth = $stab->prepare(qq{
		select	dns_domain_id
		 from	dns_domain
		 where	soa_name = ?
	}) || $stab->return_db_err;

	$sth->execute($zone) || $stab->return_db_err;

	my ($domid) = $sth->fetchrow_array;
	$sth->finish;
	$domid;
}

sub check_ns {
	my($stab, $name, $nsdname, $zone) = @_;
	my $cgi = $stab->cgi;

	my $shortname = $name;
	$shortname =~ s/\.?$zone$//;

	my $zoneclause = "dns_name = :name";
	if($zone eq $name) {
		$zoneclause = "dns_name is null"; 
	} else {
		if(! defined(check_for_zone($stab, $zone)) ) {
			return $cgi->li("$name is a dedicated zone; not checking NS record");
		}
	}

	my $sth = $stab->prepare(qq{
		select	d.dns_value
		  from	dns_record	d
				inner join dns_domain dom
					on dom.dns_domain_id = d.dns_domain_id
		  where	$zoneclause
		  AND	d.dns_type = 'NS'
		  AND	d.dns_class = 'IN'
		  AND	dom.soa_name = :zone
	}) || $stab->return_db_err;;

	if($zone ne $name) {
		$sth->bind_param(':name', $shortname) || $stab->return_db_err($sth);
	}

	$sth->bind_param(':zone', $zone) || $stab->return_db_err($sth);
	$sth->execute || $stab->return_db_err($sth);

	my $msg = "";
	my $found = 0;
	while(my $hr = $sth->fetchrow_hashref) {
		if($hr->{_dbx('DNS_VALUE')} eq $nsdname.".")  {
			$found = 1;
		} else {
			$msg .= $cgi->li("NS: $name ($nsdname) does not match JazzHands (",
				$hr->{_dbx('DNS_VALUE')}, ")");
		}
	}

	if(!$found) {
		if($msg && length($msg)) {
			return $msg;
		} else {
			return $cgi->li("NS record $nsdname not in JazzHands");
		}
	}
}

sub check_txt {
	my($stab, $name, $txtlist, $zone) = @_;
	my $cgi = $stab->cgi;

	my $sname = $name;
	$sname =~ s/.?$zone$//;

	my $nameq = "d.dns_name = :name";
	if($name eq $zone) {
		$nameq = "d.dns_name is null";
	}

	my $sth = $stab->prepare(qq{
		select	d.dns_value
		 from	dns_record d
				inner join dns_domain dom
					on dom.dns_domain_id = d.dns_domain_id
		 where	dom.soa_name = :zone
		 and	$nameq
		 and	d.dns_class = 'IN'
		 and	d.dns_type = 'TXT'
	}) || return $stab->return_db_err;

	$sth->bind_param(':zone', $zone) || $stab->return_db_err($sth);

	if($name ne $zone) {
		$sth->bind_param(':name', $sname) || $stab->return_db_err($sth);
	}

	$sth->execute || $stab->return_db_err($sth);

	my $found = 0;
	my $msg = "";
	while(my ($val) = $sth->fetchrow_array) {
		# the zone generation software DTRT with quotes.
		$val =~ s/^"//;
		$val =~ s/"$//;
		foreach my $txt (@$txtlist) {
			if($txt eq $val) {
				$found = 1;
			} else {
				$msg .= $cgi->li("TXT record for ", $cgi->b($name), " ($val) does not match JazzHands ",
					"(", $cgi->b($val), ")");
			}
		}
	}

	if(!$found) {
		if($msg && length($msg)) {
			return $msg;
		} else {
			return $cgi->li("TXT record for ", $cgi->b($name), " not found in JazzHands");
		}
	}
	return "";
}

sub check_srv {
	my($stab, $rr, $zone) = @_;
	my $cgi = $stab->cgi || die "no cgi!";

	my $full = $rr->name;
	$full =~ s/\.$zone$//;
	my ($svc, $proto, $name) = split(/\./, $full, 3);

	my $pq = "";
	if($proto) {
		$proto =~ s/^_//;
		$pq = q{ OR (
				d.dns_name = :shortname
			AND	d.dns_srv_protocol = :proto
			AND	d.dns_srv_service = :svc
			)
		};
	}

	my $sth = $stab->prepare(qq{
		select	d.dns_name,
			d.dns_priority,
			d.dns_srv_service,
			d.dns_srv_protocol,
			d.dns_srv_weight,
			d.dns_srv_port,
			d.dns_value
		  from	dns_record d
				inner join dns_domain dom USING (dns_domain_id)
		 where	dom.soa_name = :zone
		  and	(d.dns_name = :fullname 
				$pq )
	}) || return $stab->return_db_err;

	$sth->bind_param(':zone', $zone) || $stab->return_db_err($sth);
	$sth->bind_param(':fullname', $full) || $stab->return_db_err($sth);

	my $msg = "";
	if($pq && length($pq)) {
		$sth->bind_param(':shortname', $name) || $stab->return_db_err($sth);
		$sth->bind_param(':proto', $proto) || $stab->return_db_err($sth);
		$sth->bind_param(':svc', $svc) || $stab->return_db_err($sth);
	}
	$sth->execute || $stab->return_db_err($sth);

	my $found = 0;
	while(my $hr = $sth->fetchrow_hashref) {
		my $mesh = join(" ",  $rr->priority, $rr->weight, $rr->port, 
			$rr->target.".");
		$mesh =~ s/\s+/ /g;
		if(defined($hr->{_dbx('DNS_SRV_PORT')})) {
			if($hr->{_dbx('DNS_VALUE')} eq $rr->target."." &&
				$hr->{_dbx('DNS_SRV_SERVICE')} == $svc &&
				$hr->{_dbx('DNS_SRV_PROTOCOL')} == $proto &&
				$hr->{_dbx('DNS_PRIORITY')} == $rr->priority &&
				$hr->{_dbx('DNS_SRV_WEIGHT')} == $rr->weight &&
				$hr->{_dbx('DNS_SRV_PORT')} == $rr->port) {
					$found = 1;
			} else {
				my $dbmesh = join(" ",
					$hr->{_dbx('DNS_PRIORITY')},
					$hr->{_dbx('DNS_SRV_WEIGHT')},
					$hr->{_dbx('DNS_SRV_PORT')},
					$hr->{_dbx('DNS_VALUE')});
				$dbmesh =~ s/\s+/ /g;
				$msg .= $cgi->li("SRV record ", $rr->name, " is '", $cgi->b($dbmesh), 
					"' not '$mesh'");
			}
		} elsif($hr->{_dbx('DNS_VALUE')} eq $mesh) {
			$found = 1;
		} else {
			my $dbmesh = $hr->{_dbx('DNS_VALUE')};
			if($hr->{_dbx('DNS_SRV_PORT')}) {
				$dbmesh = join(" ",
					$hr->{_dbx('DNS_PRIORITY')},
					$hr->{_dbx('DNS_SRV_WEIGHT')},
					$hr->{_dbx('DNS_SRV_PORT')},
					$hr->{_dbx('DNS_VALUE')});
				$dbmesh =~ s/\s+/ /g;
				$msg .= $cgi->li("SRV record ", $rr->name, " is ", $cgi->b($dbmesh), 
					" not '$mesh'");
			}
		}
	}

	if(!$found) {
		if($msg && length($msg)) {
			return $msg;
		} else {
			return $cgi->li("SRV record for ", $rr->name, " was not found in JazzHands (", 
				join(" ", $rr->priority, $rr->weight, $rr->port, $rr->target),
				")");
		}
	}
}

sub check_mx {
	my($stab, $name, $pref, $mx, $zone) = @_;
	my $cgi = $stab->cgi || die "no cgi!";

	my $shortname = $name;
	$shortname =~ s/\.$zone$//;

	my $nameblurb;
	if($zone eq $name) {
		$nameblurb = "dns.dns_name is null";
		$name = undef;
	} else {
		$nameblurb = "lower(dns.dns_name) = lower(:name)";
	}

	my $msg;
	my $sth = $stab->prepare(qq{
		select	lower(dns.dns_value), dns_priority
		  from	dns_record dns
				inner join dns_domain dom
					on dom.dns_domain_id = dns.dns_domain_id
		 where	$nameblurb
		   and	dom.soa_name = :zone
		   and	dns.dns_type = 'MX'
	}) || $stab->return_db_err;

	if(defined($name)) {
		$sth->bind_param(":name", $shortname) || $stab->return_db_err($sth);
	}
	$sth->bind_param(":zone", $zone) || $stab->return_db_err($sth);

	$sth->execute || $stab->return_db_err($sth);

	my $found = 0;
	while(my ($val, $pri) = $sth->fetchrow_array) {
		$found = 1;
		my $combo = "$pref $mx.";
		if(defined($pri) && $pref == $pri && $val eq "$mx.") {
			$found = 1;
			$msg = "";
			last;
		} elsif($val eq $combo) {
			$found = 1;
			$msg = "";
			last;
		} else {
			my $x = ($pri)?"$pri $val":$val;
			$msg .= $cgi->li("MX record $name ($x) in JazzHands does not match ($combo)");
		}
	}
	$sth->finish;

	if(!$found) {
		if(!$msg || !length($msg)) {
			$msg .= $cgi->li("MX record $name $pref $mx not in JazzHands");
		}
	}
	$msg;

}

sub check_cname {
	my($stab, $cname, $pointsto, $zone) = @_;
	my $dbh = $stab->dbh || die "no dbh!";
	my $cgi = $stab->cgi || die "no cgi!";

	my($cnameSth);
	if(!$cnameSth) {
		my $q = qq{
			select	lower(dns.dns_value)
			  from	dns_record dns
					inner join dns_domain dom
						on dom.dns_domain_id = dns.dns_domain_id
			 where	lower(dns.dns_name) = lower(?)
			   and	dom.soa_name = ?
			   and	dns.dns_type = 'CNAME'
		};
		$cnameSth = $stab->prepare($q) || die $dbh->errstr;
	}

	$cname =~ s/\.$zone$//;

	$cnameSth->execute($cname, $zone) || die $dbh->errstr;
	my($db) = ($cnameSth->fetchrow_array)[0];
	$cnameSth->finish;

	my $devname = $pointsto;
	$pointsto .= ".";

	my $rv = "";
	if(!defined($db)) {
		$rv .= $cgi->li("CNAME ", $cgi->b("$cname.$zone"), 
		" in DNS (", device_link($stab, $devname, $pointsto), 
		") is not set in JazzHands");
    } elsif($db !~ /\.$/ && $pointsto eq "$db.$zone.") {
		return $rv;
	} elsif($db ne $pointsto) {
		$rv .= $cgi->li("CNAME mismatch",
			$cgi->b("$cname.$zone"), " is ",
			$cgi->b("$db"),
			" in JazzHands and ",
			$cgi->b("$pointsto"),
			" in DNS ");
	}
	return $rv;
}

sub check_name {
	my($stab, $in_name, $addr, $rec, $zone) = @_;
	my $dbh = $stab->dbh || die "no dbh!";
	my $cgi = $stab->cgi || die "no cgi!";

	my $stripname = $in_name;
	$stripname =~ s/\.$zone$//;

	my $q = qq{
		select	net_manip.inet_dbtop(ip_address) as ip,
				dns.dns_name,
				dom.soa_name,
				dom.dns_domain_id
		 from	netblock nb
				inner join dns_record dns on 
					nb.netblock_id = dns.netblock_id
				inner join dns_domain dom on
					dom.dns_domain_id = dns.dns_domain_id
		where	dns.dns_name = ?
		  and	dns.dns_type = 'A'
		  and	dom.soa_name = ?

	};
	my $sth = $stab->prepare($q) || die $dbh->errstr;

	$sth->execute($stripname, $zone) || die $dbh->errstr;

	my $m = "";

	my $found = 0;
	while(my($ip, $name, $dom, $id, $soa) = $sth->fetchrow_array) {
		$m .= $cgi->li("** A record for ", $cgi->b($in_name), " is $ip (not $addr) in DB");
		if($addr eq $ip) {
			return "";
		}
	}

	$m;
}

#
# This passes back its text as an reference to an input parameter, which is
# weird and different.  This is to faciliate combing PTR/A records, which
# probably needs to be rethought.
#
sub check_addr {
	my($stab, $in_name, $addr, $rec, $rv) = @_;
	my $dbh = $stab->dbh || die "no dbh!";
	my $cgi = $stab->cgi || die "no cgi!";

	my $casth;
	if(!defined($casth)) {
		my $q = qq{
			select	dns.dns_domain_id, dns.dns_name,
					dom.soa_name
			 from	netblock nb
					inner join dns_record dns on 
						nb.netblock_id = dns.netblock_id
					inner join dns_domain dom on
						dom.dns_domain_id = dns.dns_domain_id
			where	nb.ip_address =
						net_manip.inet_ptodb(?)
			  and	dns.dns_type = 'A'
		};
		$casth = $stab->prepare($q) || die $dbh->errstr;
	}

	$casth->execute($addr) || croak $casth->errstr;

	my $t = "";

	$in_name =~ tr/A-Z/a-z/;
	my $mismatch = 0;
	while(my ($id, $name, $domain) = $casth->fetchrow_array) {
		my $full = ($name?$name.".":"").$domain;
		$full =~ tr/A-Z/a-z/;
		if($full eq $in_name) {
			$t .= $cgi->li("$full matches $in_name") if($in_name =~ /ccadmin/);
			$casth->finish;
			return "";
		} else {
			if($rec eq 'PTR') {
				$t .= $cgi->li("IP ", $addr,
					"JazzHands ", $cgi->b(device_link($stab,$full) ), 
					" PTR does not match DNS",
					$cgi->b(device_link($stab, $in_name) ), 
					"! [May overlap with next error ]\n");
				$mismatch++;
			} elsif($rec eq 'A') {
				$t .= $cgi->li("A record for ",
					$cgi->b(device_link($stab,$in_name)), "(",
					$addr, ")",
					" does not match JazzHands (",
					$cgi->b(device_link($stab,$full)),")");
				$mismatch++;
			} else {
				$t .= $cgi->li($cgi->b("rec of type $rec not supported for $in_name/$addr.  This should not happen."));
			}
		}
	}

	if(!$mismatch) {
		if($rec eq 'PTR') {
			$t .= $cgi->li("IP $addr PTR in DNS ", 
				$cgi->b( $in_name ), " does not exist in JazzHands.\n");
		} elsif($rec eq 'A') {
			$t .= $cgi->li("A record for ",
				$cgi->b( $in_name ), " (",
				$addr, ") is not in JazzHands.\n");
		} else {
				$t .= $cgi->li($cgi->b("rec of type $rec not supported for $in_name/$addr.  This should not happen. (no records in db)"));
		}
	}


	return $t;
}

#############################################################################

sub do_zone_load {
	my $zone = shift(@ARGV) || die "No zone specified";
	my $ns = "auth00.omniscient.com";

	my $dbh = JazzHands::DBI->connect('stab', {AutoCommit => 0}) || die $JazzHands::DBI::errstr;
	my $c = new JazzHands::Common;
	$c->DBHandle($dbh);

	process_zone($c, $ns, $zone);
	$dbh->commit;
	$dbh->disconnect;
}
