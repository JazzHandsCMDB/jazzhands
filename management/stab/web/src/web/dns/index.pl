#!/usr/bin/env perl
# Copyright (c) 2005-2010, Vonage Holdings Corp.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY VONAGE HOLDINGS CORP. ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL VONAGE HOLDINGS CORP. BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#
# $Id$
#

use strict;
use warnings;
use POSIX;
use Data::Dumper;
use Carp;
use JazzHands::STAB;
use JazzHands::Common qw(_dbx);

do_dns_toplevel();

sub do_dns_toplevel {
	my $stab = new JazzHands::STAB || die "Could not create STAB";
	my $cgi  = $stab->cgi          || die "Could not create cgi";

	my $dnsid = $stab->cgi_parse_param('dnsdomainid');

	if ( !defined($dnsid) ) {

		dump_all_zones_dropdown($stab);
	} else {
		dump_zone( $stab, $dnsid );
	}
	undef $stab;
}

sub dump_all_zones_dropdown {
	my ($stab) = @_;
	my $cgi = $stab->cgi || die "Could not create cgi";

	print $cgi->header( { -type => 'text/html' } ), "\n";
	print $stab->start_html(
		{ -title => "DNS Zones", -javascript => 'dns' } ), "\n";

	print $cgi->h4( { -align => 'center' }, "Find a Zone" );
	print $cgi->start_form( { -action => "search.pl" } );
	print $cgi->start_table( { -align => 'center' } );
	print $stab->build_tr( undef, undef, "b_dropdown", "Zone",
		'DNS_DOMAIN_ID' );
	print $cgi->Tr(
		{ -align => 'center' },
		$cgi->td(
			{ -colspan => 2 },
			$cgi->submit(
				-name  => "Zone",
				-value => "Go to Zone"
			)
		)
	);
	print $cgi->end_table;
	print $cgi->end_form;

	print $cgi->hr;

	print $cgi->h4( { -align => 'center' },
		$cgi->a( { -href => "addazone.pl" }, "Add A Zone" ) );

	print $cgi->hr;

	print $cgi->h4( { -align => 'center' },
		"Reconcile non-autogenerated zones" );
	print $cgi->start_form(
		{ -action => "dns-reconcile.pl", -method => 'GET' } );
	print $cgi->start_table( { -align => 'center' } );
	print $stab->build_tr( { -only_nonauto => 'yes' },
		undef, "b_dropdown", "Zone", 'DNS_DOMAIN_ID' );
	print $cgi->Tr(
		{ -align => 'center' },
		$cgi->td(
			{ -colspan => 2 },
			$cgi->submit(
				-name  => "Zone",
				-value => "Go to Zone"
			)
		)
	);
	print $cgi->end_table;
	print $cgi->end_form;

	print $cgi->end_html, "\n";
}

sub dump_all_zones {
	my ( $stab, $cgi ) = @_;

	print $cgi->header( { -type => 'text/html' } ), "\n";
	print $stab->start_html(
		{ -title => "DNS Zones", -javascript => 'dns' } ), "\
n";

	my $q = qq{
		select 	dns_domain_id,
			soa_name,
			soa_class,
			soa_ttl,
			soa_serial,
			soa_refresh,
			soa_retry,
			soa_expire,
			soa_minimum,
			soa_mname,
			soa_rname,
			should_generate,
			last_generated
		  from	dns_domain
		order by soa_name
	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err;
	$sth->execute || return $stab->return_db_err($sth);

	my $maxperrow = 4;

	print $cgi->start_table( { -border => 1, -align => 'center' } ), "\n";

	my $curperrow = -1;
	my $rowtxt    = "";
	while ( my $hr = $sth->fetchrow_hashref ) {
		if ( ++$curperrow == $maxperrow ) {
			$curperrow = 0;
			print $cgi->Tr($rowtxt), "\n";
			$rowtxt = "";
		}

		if ( !defined( $hr->{ _dbx('LAST_GENERATED') } ) ) {
			$hr->{ _dbx('LAST_GENERATED') } =
			  $cgi->escapeHTML('<never>');
		}

		my $xbox =
		  $stab->build_checkbox( $hr, "ShouldGen", "SHOULD_GENERATE",
			'DNS_DOMAIN_ID' );

		$stab->textfield_sizing(0);
		my $serial =
		  $stab->b_textfield( $hr, 'SOA_SERIAL', 'DNS_DOMAIN_ID' );
		my $refresh =
		  $stab->b_textfield( $hr, 'SOA_REFRESH', 'DNS_DOMAIN_ID' );
		my $retry =
		  $stab->b_textfield( $hr, 'SOA_RETRY', 'DNS_DOMAIN_ID' );
		my $expire =
		  $stab->b_textfield( $hr, 'SOA_EXPIRE', 'DNS_DOMAIN_ID' );
		my $minimum =
		  $stab->b_textfield( $hr, 'SOA_MINIMUM', 'DNS_DOMAIN_ID' );
		$stab->textfield_sizing(1);

		my $link =
		  build_dns_link( $stab, $hr->{ _dbx('DNS_DOMAIN_ID') } );
		my $zone =
		  $cgi->a( { -href => $link }, $hr->{ _dbx('SOA_NAME') } );

		my $entry = $cgi->table(
			{ -width => '100%', -align => 'top' },
			$cgi->Tr(
				$cgi->td(
					{
						-align => 'center',
						-style => 'background: green'
					},
					$cgi->b($zone)
				)
			),

			#$cgi->Tr($cgi->td("Serial: ", $serial )),
			#$cgi->Tr($cgi->td("Refresh: ", $refresh )),
			#$cgi->Tr($cgi->td("Retry: ", $retry )),
			#$cgi->Tr($cgi->td("Expire: ", $expire )),
			#$cgi->Tr($cgi->td("Minimum: ", $minimum )),
			$cgi->Tr(
				$cgi->td(
					"LastGen:",
					$hr->{ _dbx('LAST_GENERATED') }
				)
			),
			$cgi->Tr( $cgi->td($xbox) )
		) . "\n";

		$rowtxt .= $cgi->td( { -valign => 'top' }, $entry );
	}
	print $cgi->Tr($rowtxt), "\n";
	print $cgi->end_table;
	print $cgi->end_html, "\n";

	$sth->finish;
}

sub zone_dns_records {
	my ( $stab, $dnsdomainid ) = @_;

	my $cgi = $stab->cgi || die "Could not create cgi";

	my $q = qq{
		select	dns.*,
				nb.netblock_id,
				net_manip.inet_dbtop(nb.ip_address) as IP
		 from 	dns_record dns
				inner join val_dns_type vdt on
					dns.dns_type = vdt.dns_type
				left join netblock nb
					on nb.netblock_id = dns.netblock_id
		where	vdt.id_type in ('ID', 'NON-ID')
		  and	dns.dns_name is NULL
		  and	dns.reference_dns_record_id is null
		  and	dns.dns_domain_id = ?
		order by dns.dns_type
	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err;
	$sth->execute($dnsdomainid) || return $stab->return_db_err($sth);

	while ( my $hr = $sth->fetchrow_hashref ) {
		print build_fwd_zone_Tr( $stab, $hr, 1 );
	}
	$sth->finish;
}

sub build_fwd_zone_Tr {
	my ( $stab, $hr, $iszone ) = @_;

	my $cssclass = 'dnsupdate';

	my $cgi = $stab->cgi || die "Could not create cgi";

	my $opts = {};

	if ( !defined($hr) ) {
		$opts->{-prefix} = "new_";
		$opts->{-suffix} = "_0";
	}

	my $ttl =
	  $stab->b_offalwaystextfield( $opts, $hr, 'DNS_TTL', 'DNS_RECORD_ID' );
	$stab->textfield_sizing(0);

	my $value = "";
	my $name  = "";
	my $class = "";
	my $type  = "";

	if ( defined($hr) && defined( $hr->{ _dbx('DNS_NAME') } ) ) {
		$name = $hr->{ _dbx('DNS_NAME') };
	}

	my $showexcess = 1;
	my $ttlonly    = 0;

	# XXX need to make secondary name and CNAME manipulation right in
	# device tab before this is reenabled!
	if ( 0 && defined($hr) && $hr->{ _dbx('DEVICE_ID') } ) {
		$showexcess = 0
		  if ( $hr->{ _dbx('SHOULD_GENERATE_PTR') } eq 'Y' );
		$ttlonly = 1;
		my $link =
		  "../device/device.pl?devid=" . $hr->{ _dbx('DEVICE_ID') };
		$name = $cgi->a( { -href => $link }, $name );

	   #$class = $stab->b_dropdown($opts, $hr, 'DNS_CLASS', 'DNS_CLASS', 1);
	   #$type = $stab->b_dropdown($opts, $hr, 'DNS_TYPE', 'DNS_TYPE', 1);
		$class = $hr->{_dbx('DNS_CLASS')};
		$type  = $hr->{_dbx('DNS_TYPE')};
		$value = $hr->{_dbx('DNS_VALUE')};
		if ( defined($hr) && $hr->{_dbx('DNS_TYPE')} =~ /^A(AAA)?$/ ) {
			$value = $hr->{_dbx('IP')};
		}
	} elsif ( !defined($iszone) ) {
		$name =
		  $stab->b_textfield( $opts, $hr, 'DNS_NAME', 'DNS_RECORD_ID' );
		$class =
		  $stab->b_dropdown( $opts, $hr, 'DNS_CLASS', 'DNS_RECORD_ID',
			1 );

		$opts->{-class} = 'dnstype';
		$type =
		  $stab->b_dropdown( $opts, $hr, 'DNS_TYPE', 'DNS_RECORD_ID',
			1 );
		delete( $opts->{-class} );

		$opts->{-textfield_width} = 40;
		$value =
		  $stab->b_textfield( $opts,
			$hr, 'DNS_VALUE', 'DNS_RECORD_ID' );
		delete( $opts->{-textfield_width} );

		if ( defined($hr) && $hr->{_dbx('DNS_TYPE')} =~ /^A(AAA)?$/ ) {
			# [XXX] hack hack hack, needs to be fixed right.
			$hr->{ _dbx('DNS_VALUE') } = $hr->{ _dbx('IP') };
			$value = $stab->b_textfield( $opts, $hr, 'DNS_VALUE',
				'DNS_RECORD_ID' );
		}
	} else {
		$opts->{-textfield_width} = 40;
		$value =
		  $stab->b_textfield( $opts,
			$hr, 'DNS_VALUE', 'DNS_RECORD_ID' );
		delete($opts->{-textfield_width});
		if ( defined($hr) && $hr->{_dbx('DNS_TYPE')} =~ /^A(AAA)?$/ ) {
			# [XXX] hack hack hack, needs to be fixed right.
			$hr->{ _dbx('DNS_VALUE') } = $hr->{ _dbx('IP') };
			$value = $stab->b_textfield( $opts, $hr, 'DNS_VALUE',
				'DNS_RECORD_ID' );
		}
		$class =
		  $stab->b_dropdown( $opts, $hr, 'DNS_CLASS', 'DNS_RECORD_ID',
			1 );

		$opts->{-class} = 'dnstype';
		$type =
		  $stab->b_dropdown( $opts, $hr, 'DNS_TYPE', 'DNS_RECORD_ID',
			1 );
		delete( $opts->{-class} );
	}

	my $excess = "";
	if ($showexcess) {
		if ( defined($hr) ) {
			$excess .= $cgi->checkbox(
				{
					-name => "Del_"
					  . $hr->{ _dbx('DNS_RECORD_ID') },
					-label => 'Delete',
				}
			);
		} else {
			$cssclass = "dnsadd";
			$excess .= "(Add)";
		}
	}
	if ( $ttlonly && defined($hr) ) {
		$excess .= $cgi->hidden(
			{
				-name => "ttlonly_"
				  . $hr->{ _dbx('DNS_RECORD_ID') },
				-value => 'ttlonly'
			}
		);
	}

	my $hidden = "";
	if ($hr) {
		$hidden = $cgi->hidden(
			{
				-name => "DNS_RECORD_ID_"
				  . $hr->{ _dbx('DNS_RECORD_ID') },
				-value => $hr->{ _dbx('DNS_RECORD_ID') }
			}
		);
	}

	$opts->{-default} = 'Y';
	my $enablebox =
	  $stab->build_checkbox( $opts,
		$hr, "", "IS_ENABLED", 'DNS_RECORD_ID' );
	delete( $opts->{-default} );

	my $ptrbox = "";
	if ( $hr && $hr->{ _dbx('DNS_TYPE') } =~ /^A(AAA)?$/ ) {
		$opts->{-class} = "ptrbox";
		$ptrbox =
		  $stab->build_checkbox( $opts,
			$hr, "", "SHOULD_GENERATE_PTR", 'DNS_RECORD_ID' );
		delete( $opts->{-class} );
	}

	# for SRV records, it iss necessary to prepend the
	# protocol and service name to the name
	if ( $hr && $hr->{ _dbx('DNS_TYPE') } eq 'SRV' ) {
		$name =
		  $stab->b_dropdown( $opts, $hr, 'DNS_SRV_SERVICE',
			'DNS_RECORD_ID', 1 )
		  . $stab->b_nondbdropdown( $opts, $hr, 'DNS_SRV_PROTOCOL',
			'DNS_RECORD_ID' )
		  . $name;

		$opts->{-class} = 'srvnum';
		$value =
		  $stab->b_textfield( $opts, $hr, 'DNS_PRIORITY',
			'DNS_RECORD_ID' )
		  . $stab->b_textfield( $opts, $hr, 'DNS_SRV_WEIGHT',
			'DNS_RECORD_ID' )
		  . $stab->b_textfield( $opts, $hr, 'DNS_SRV_PORT',
			'DNS_RECORD_ID' )
		  . $value;
		delete( $opts->{-class} );
	} elsif ( $hr && $hr->{ _dbx('DNS_TYPE') } eq 'MX' ) {
		$opts->{-class} = 'srvnum';
		$value =
		  $stab->b_textfield( $opts, $hr, 'DNS_PRIORITY',
			'DNS_RECORD_ID' )
		  . $value;
		delete( $opts->{-class} );
	}

	$stab->textfield_sizing(1);
	my $args = { '-class' => $cssclass };
	if ($hr) {
		$args->{'-id'} = $hr->{ _dbx('DNS_RECORD_ID') };
	} else {
		$args->{'-id'} = "0";
	}
	return $cgi->Tr(
		$args,
		$cgi->td( $hidden, $enablebox ),
		$cgi->td( { -class => 'DNS_NAME' }, $name ),
		$cgi->td($ttl),
		$cgi->td($class),
		$cgi->td($type),
		$cgi->td($value),
		$cgi->td( { -class => 'ptrtd' }, $ptrbox ),
		$cgi->td($excess)
	);
}

sub zone_fwd_records {
	my ( $stab, $dnsdomainid ) = @_;

	my $cgi = $stab->cgi || die "Could not create cgi";

	my $q = qq{
		select	dns.*,
				nb.netblock_id,
				net_manip.inet_dbtop(nb.ip_address) as IP,
				ni.device_id
		 from 	dns_record dns
				inner join val_dns_type vdt on
					dns.dns_type = vdt.dns_type
				left join netblock nb
					on nb.netblock_id = dns.netblock_id
				left join network_interface ni
					on ni.netblock_id = nb.netblock_id
		where	vdt.id_type in ('ID', 'NON-ID')
		  and	
				(	
					dns.dns_name is not NULL
				or
		  			dns.reference_dns_record_id is not null
				)
		  and	dns.dns_domain_id = ?
		order by dns.dns_name
	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err();
	$sth->execute($dnsdomainid) || return $stab->return_db_err($sth);

	while ( my $hr = $sth->fetchrow_hashref ) {
		print build_fwd_zone_Tr( $stab, $hr );
	}
	$sth->finish;
}

sub zone_rvs_records {
	my ( $stab, $dnsdomainid ) = @_;

	my $cgi = $stab->cgi || die "Could not create cgi";

	my $q = qq{
		select  distinct nb.ip_address,
			net_manip.inet_dbtop(nb.ip_address) as ip,
			dns.dns_name,
			dns.is_enabled,
			dom.soa_name,
			host(network(nb.ip_address)) as ip_base,
			ni.device_id
		  from  netblock nb
				inner join dns_record dns
					on nb.netblock_id = dns.netblock_id
				inner join dns_domain dom
					on dns.dns_domain_id =
						dom.dns_domain_id
				left join network_interface ni
					on ni.netblock_id = nb.netblock_id,
			netblock root
				inner join dns_record rootd
					on rootd.netblock_id = root.netblock_id
					and rootd.dns_type =
						'REVERSE_ZONE_BLOCK_PTR'
		 where  dns.should_generate_ptr = 'Y'
		   and  dns.dns_class = 'IN' and dns.dns_type = 'A'
		   and  net_manip.inet_base(nb.ip_address, 
				masklen(root.ip_address)) =
					net_manip.inet_base(root.ip_address,
					masklen(root.ip_address) )
		   and  rootd.dns_domain_id = ?
		order by nb.ip_address
	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err();
	$sth->execute($dnsdomainid) || return $stab->return_db_err($sth);

	$stab->textfield_sizing(0);
	while ( my $hr = $sth->fetchrow_hashref ) {
		my $lastoctet = ( split( /\./, $hr->{ _dbx('IP') } ) )[3];

		# only print the shortname if it is actually set.
		my $name = (
			defined( ( $hr->{ _dbx('DNS_NAME') } ) )
			? $hr->{ _dbx('DNS_NAME') } . "."
			: ""
		) . $hr->{ _dbx('SOA_NAME') } . ".";

		my $ttl   = "";
		my $class = 'IN';
		my $type  = 'PTR';
		my $value =
		  $stab->b_textfield( $hr, 'DNS_VALUE', 'DNS_RECORD_ID' );
		if (       $hr
			&& $hr->{ _dbx('DNS_TYPE') }
			&& $hr->{ _dbx('DNS_TYPE') } eq 'A' )
		{
			$value =
			  $stab->b_textfield( $hr, 'IP', 'DNS_RECORD_ID' );
		}

		if ( $hr->{ _dbx('DEVICE_ID') } ) {
			my $link =
			  "../device/device.pl?devid="
			  . $hr->{ _dbx('DEVICE_ID') };
			$name = $cgi->a( { -href => $link }, $name );
		}

	      #
	      # at this point, we don't want direct manipulation of PTR records.
	      #
		my $button = "";
		if (       0
			&& defined($hr)
			&& defined( $hr->{ _dbx('DNS_RECORD_ID') } ) )
		{

			# [XXX] these aren't buttons now, but rather
			# a delete check box...
			$button = $cgi->submit(
				{
					-name => "Update_"
					  . $hr->{ _dbx('DNS_RECORD_ID') },
					-value => 'Update'
				}
			);
			$button .= $cgi->submit(
				{
					-name => "Del_"
					  . $hr->{ _dbx('DNS_RECORD_ID') },
					-value => 'Delete'
				}
			);
		}

		my $hidden = "";
		if ( $hr && $hr->{ _dbx('DNS_RECORD_ID') } )
		{    # should not need the && case?
			$hidden = $cgi->hidden(
				{
					-name => "DNS_RECORD_ID_"
					  . $hr->{ _dbx('DNS_RECORD_ID') },
					-value => $hr->{ _dbx('DNS_RECORD_ID') }
				}
			);
		}

		# this is disabled at present since disabling from the forward
		# record likely makes more sense.
		#my $enablebox = $stab->build_checkbox({-default=>'Y'},
		#	$hr, "", "IS_ENABLED", 'DNS_RECORD_ID');
		my $enablebox = "";

		print $cgi->Tr(
			$cgi->td(
				[
					$enablebox, $lastoctet, $ttl,
					$class,     $type,      $name,
					$button,
				]
			),
		);
	}
	$stab->textfield_sizing(1);
	$sth->finish;
}

sub dump_zone {
	my ( $stab, $dnsdomainid ) = @_;
	my $cgi = $stab->cgi || die "Could not create cgi";

	my $q = qq{
		select 	d1.dns_domain_id,
			d1.soa_name,
			d1.soa_class,
			d1.soa_ttl,
			d1.soa_serial,
			d1.soa_refresh,
			d1.soa_retry,
			d1.soa_expire,
			d1.soa_minimum,
			d1.soa_mname,
			d1.soa_rname,
			d1.should_generate,
			d1.parent_dns_domain_id,
			d2.soa_name as parent_soa_name,
			d1.last_generated
		  from	dns_domain d1
				left join dns_domain d2 on
					d1.parent_dns_domain_id = d2.dns_domain_id
		where	d1.dns_domain_id = ?
	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err;
	$sth->execute($dnsdomainid) || return $stab->return_db_err($sth);

	my $hr = $sth->fetchrow_hashref;
	$sth->finish;

	if ( !defined($hr) ) {
		$stab->error_return("Unknown Domain");
	}

	my $title = $hr->{ _dbx('SOA_NAME') };
	$title .= " (Auto Generated) "
	  if ( $hr->{ _dbx('SHOULD_GENERATE') } eq 'Y' );

	print $cgi->header( { -type => 'text/html' } ), "\n";
	print $stab->start_html( { -title => $title, -javascript => 'dns' } ),
	  "\n";
	print $cgi->start_form( { -action => "write/update_domain.pl" } );
	print $cgi->hidden(
		-name    => 'DNS_DOMAIN_ID',
		-default => $hr->{ _dbx('DNS_DOMAIN_ID') }
	);

	my $lastgen = 'never';
	if ( defined( $hr->{ _dbx('LAST_GENERATED') } ) ) {
		$lastgen = $hr->{ _dbx('LAST_GENERATED') };
	}

	print $cgi->hr;
	print $cgi->start_table( { -align => 'center', -border => 1 } );
	print $cgi->Tr( $cgi->td("Last Generated: $lastgen") );
	my $autogen = "";
	if ( $hr->{ _dbx('SHOULD_GENERATE') } eq 'Y' ) {
		$autogen = "Turn Off Autogen";
	} else {
		$autogen = "Turn On Autogen";
	}
	print $cgi->Tr(
		{ -align => 'center' },
		$cgi->td(
			$cgi->submit(
				{
					-align => 'center',
					-name  => "AutoGen",
					-value => $autogen
				}
			)
		)
	);
	print $cgi->end_table;

	my $parlink = "--none--";
	if ( $hr->{ _dbx('PARENT_DNS_DOMAIN_ID') } ) {
		my $url =
		  build_dns_link( $stab,
			$hr->{ _dbx('PARENT_DNS_DOMAIN_ID') } );
		my $parent =
		  ( $hr->{ _dbx('PARENT_SOA_NAME') } )
		  ? $hr->{ _dbx('PARENT_SOA_NAME') }
		  : "unnamed zone";
		$parlink = $cgi->a( { -href => $url }, $parent );
	}
	$parlink = $cgi->span( $cgi->b("Parent: ") . $parlink );
	my $nblink = build_reverse_association_section( $stab, $dnsdomainid );

	if ( $nblink && length($nblink) ) {
		$nblink = $cgi->br($nblink);
	}

	print $cgi->div( { -align => 'center' }, $parlink, $nblink );

	print $cgi->hr;

	print $stab->zone_header( $hr, 'update' );
	print $cgi->submit(
		{
			-align => 'center',
			-name  => "SOA",
			-value => "Submit SOA Changes"
		}
	);
	print $cgi->end_form;

	print $cgi->hr;

	#
	# second form, second table
	#
	print $cgi->start_form( { -action => "update_dns.pl" } );
	print $cgi->start_table;
	print $cgi->hidden(
		-name    => 'DNS_DOMAIN_ID',
		-default => $hr->{ _dbx('DNS_DOMAIN_ID') }
	);

	print $cgi->Tr(
		$cgi->th(
			[
				'Enable', 'Record', 'TTL', 'Class',
				'Type',   'Value',  'PTR'
			]
		)
	);

	print build_fwd_zone_Tr($stab);
	zone_dns_records( $stab, $hr->{ _dbx('DNS_DOMAIN_ID') } );

	zone_fwd_records( $stab, $hr->{ _dbx('DNS_DOMAIN_ID') } );
	zone_rvs_records( $stab, $hr->{ _dbx('DNS_DOMAIN_ID') } );

	print $cgi->end_table;
	print $cgi->submit(
		{
			-align => 'center',
			-name  => "Records",
			-value => "Submit DNS Record Changes"
		}
	);
	print $cgi->end_form;
}

sub build_reverse_association_section {
	my ( $stab, $domid ) = @_;
	my $cgi = $stab->cgi || die "Could not create cgi";

	my $q = qq{
		select  nbr.netblock_id,
			net_manip.inet_dbtop(nb.ip_address),
			masklen(nb.ip_address)
		  from  dns_record d
			inner join netblock nb
				on nb.netblock_id = d.netblock_id
			left join netblock nbr
				on nbr.ip_address = nb.ip_address
				and masklen(nbr.ip_address) 
					= masklen(nb.ip_address)
				and nbr.netblock_type = 'default'
		 where  d.dns_type = 'REVERSE_ZONE_BLOCK_PTR'
		   and  d.dns_domain_id = ?

	};
	my $sth = $stab->prepare($q) || return $stab->return_db_err();
	$sth->execute($domid) || return $stab->return_db_err($sth);

	#
	# Print a useful /24 if it exists, otherwise, just show
	# what it is.
	#
	my $linkage = "";
	while ( my ( $nbid, $ip, $bits ) = $sth->fetchrow_array ) {
		if ($nbid) {
			$linkage =
			  $cgi->a( { -href => "../netblock/?nblkid=$nbid" },
				"$ip/$bits" );
		} else {
			$linkage = "$ip/$bits";
		}
	}
	$linkage = $cgi->b("Reverse Linked Netblock:") . $linkage if ($linkage);
	$sth->finish;
	$linkage;
}

sub build_dns_link {
	my ( $stab, $dnsdomainid ) = @_;
	my $cgi = $stab->cgi || die "Could not create cgi";

	my $n = new CGI($cgi);
	$n->param( 'dnsdomainid', $dnsdomainid );
	$n->self_url;
}
